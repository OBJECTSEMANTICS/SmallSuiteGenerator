<?xml version="1.0"?><st-source><!-- Name: SpyLite-ExtensionsBundleName: SpyLite-ExtensionsBundleStructure: a Store.BundleForParcelParcel: #('SpyLite-Extensions' )ParcelName: SpyLite-ExtensionsPrerequisiteParcels: #(#('SpyLite' '' ) )Date: 4:56:57 am June 8, 2020 --><time-stamp>From VisualWorksÂ®, 7.4 of December 5, 2005 on June 8, 2020 at 4:56:57 am</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><methods><class-id>Spy1.SLProfilerCoverageTest</class-id> <category>as yet unclassified</category><body package="SpyLite-Extensions" selector="assertMethodCoverageOf:on:equals:">assertMethodCoverageOf: t1 on: t2 equals: t3 	| t4 |	t4 := t1 methodCoverage1.	self assert: (t4 at: t2)		equals: t3.	</body></methods><methods><class-id>Core.Double</class-id> <category>converting</category><body package="SpyLite-Extensions" selector="specialValueExponent">specialValueExponent	^1024</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>creating class hierarchy</category><body package="SpyLite-Extensions" selector="numberOfLinesOfCode">numberOfLinesOfCode	^5 + (self methodDictionary inject: 0 into: [:t1 :t2 | t1 + t2 linesOfCode])</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>copying</category><body package="SpyLite-Extensions" selector="collect:thenSelect:">collect: t1 thenSelect: t2 	^(self collect: t1)		select: t2</body></methods><methods><class-id>Core.Set</class-id> <category>enumerating</category><body package="SpyLite-Extensions" selector="intersection:">intersection: t1 	| t2 |	t2 := self class new.	t1 do: [:t3 | (self includes: t3)			ifTrue: [t2 add: t3]			ifFalse: [nil]].	^t2</body></methods><methods><class-id>Core.Object</class-id> <category>controlling</category><body package="SpyLite-Extensions" selector="assert:">assert: t1 	t1 value ifFalse: [self error: 'Assertion failed'].</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="SpyLite-Extensions" selector="isCollection">isCollection	^false</body></methods><methods><class-id>Core.Array class</class-id> <category>instance creation</category><body package="SpyLite-Extensions" selector="new:withAll:">new: t1 withAll: t2 	^(self new: t1)		atAllPut: t2</body><body package="SpyLite-Extensions" selector="with:withAll:">with: t1 withAll: t2 	| t3 |	(t3 := self new: t2 size + 1) at: 1 put: t1.	t3		replaceFrom: 2		to: t3 size		with: t2.	^t3</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>initialize-release</category><body package="SpyLite-Extensions" selector="initialize">initialize	super initialize.	selector := #unamed.	originalMethod := self class compiledMethodAt: #initialize.	classSpy := SLClass new</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>installing</category><body package="SpyLite-Extensions" selector="install">install	self spyWrapper install.</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>testing</category><body package="SpyLite-Extensions" selector="isAbstract">isAbstract	^false</body><body package="SpyLite-Extensions" selector="isTest">isTest	('#test*' match: self selector printString)		ifTrue: [^self classSpy isTestClass].	^false</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>accessing-computed</category><body package="SpyLite-Extensions" selector="numberOfLinesOfCode">numberOfLinesOfCode	^4</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>accessing</category><body package="SpyLite-Extensions" selector="originalMethod">originalMethod	^originalMethod</body><body package="SpyLite-Extensions" selector="originalMethod:">originalMethod: t1	originalMethod := t1.</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>hooks</category><body package="SpyLite-Extensions" selector="run:with:in:">run: t1 with: t2 in: t3 	| t4 |	self classSpy ifNotNil: [classSpy			beforeEachExecution: t1			On: t3			with: t2].	self		beforeRun: t1		with: t2		in: t3.	t4 := self spyWrapper clientMethod valueWithReceiver: t3 arguments: t2.	self classSpy ifNotNil: [classSpy			afterEachExecution: t1			On: t3			with: t2].	self		afterRun: t1		with: t2		in: t3.	self returnValue: t4.	^t4</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>accessing-computed</category><body package="SpyLite-Extensions" selector="sourceCode">sourceCode	^originalMethod getSource</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>delegation</category><body package="SpyLite-Extensions" selector="theClass">theClass	^spywrapper mclass</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>installing</category><body package="SpyLite-Extensions" selector="uninstall">uninstall	self spyWrapper uninstall.	self flushCache.</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="SpyLite-Extensions" selector="lineIndicesDo:">lineIndicesDo: t1 	| t2 t3 t4 t5 t6 t7 |	t6 := 1.	t7 := self size.	t4 := Character cr.	(t3 := self				nextIndexOf: t4				from: 1				to: self size) ifNil: [t3 := 0].	t5 := Character lf.	(t2 := self				nextIndexOf: t5				from: 1				to: self size) ifNil: [t2 := 0].	[t6 &lt;= t7]		whileTrue: 			[(t2 = 0 and: [t3 = 0])				ifTrue: 					[t1						value: t6						value: t7						value: t7.					^self].			(t3 = 0 or: [0 &lt; t2 and: [t2 &lt; t3]])				ifTrue: 					[t1						value: t6						value: t2 - 1						value: t2.					t6 := 1 + t2.					(t2 := self								nextIndexOf: t5								from: t6								to: self size) ifNil: [t2 := 0]]				ifFalse: [1 + t3 = t2						ifTrue: 							[t1								value: t6								value: t3 - 1								value: t2.							t6 := 1 + t2.							(t3 := self										nextIndexOf: t4										from: t6										to: self size) ifNil: [t3 := 0].							(t2 := self										nextIndexOf: t5										from: t6										to: self size) ifNil: [t2 := 0]]						ifFalse: 							[t1								value: t6								value: t3 - 1								value: t3.							t6 := 1 + t3.							(t3 := self										nextIndexOf: t4										from: t6										to: self size) ifNil: [t3 := 0]]]].	^self</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>contract</category><body package="SpyLite-Extensions" selector="checkInvariant">checkInvariant	self assert: [className notNil].	self assert: [className isKindOf: Symbol].	self assert: [self profiler notNil].	self assert: [self methods notNil].	self assert: [self methods isSequenceable].	self assert: [self methods allSatisfy: [:t1 | t1 isKindOf: SLMethod]].	self assert: [self class spyClassForMethod == self profiler class spyClassForMethod].	self assert: [self class spyClassForMethod == self profiler class spyClassForMethod].	self assert: [self class == self profiler class spyClassForClass].	</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>accessing-computed</category><body package="SpyLite-Extensions" selector="coveredMethods">coveredMethods	^self methods select: #isCovered</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>initialize-release</category><body package="SpyLite-Extensions" selector="initialize">initialize	super initialize.	methods := IdentityDictionary new.	packageSpy := SLPackage new.</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>installing</category><body package="SpyLite-Extensions" selector="install">install	self allMethods do: [:t1 | t1 install].</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>testing</category><body package="SpyLite-Extensions" selector="isClassPresent">isClassPresent	^Smalltalk organization includesElement: className</body><body package="SpyLite-Extensions" selector="isPartiallyCovered">isPartiallyCovered	^self methods anySatisfy: #isCovered</body><body package="SpyLite-Extensions" selector="isPartiallyExecuted">isPartiallyExecuted	| t1 |	t1 := false.	self allMethods do: [:t2 | t2 numberOfInvocations &gt; 0			ifTrue: [t1 := true]			ifFalse: [nil]].	^t1</body><body package="SpyLite-Extensions" selector="isTestClass">isTestClass	^self superclass ifNil: [self theClass superclass = SUnit.TestCase or: [self theClass superclass = SUnit.TestCase]]		ifNotNil: [self superclass isTestClass]</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>accessing</category><body package="SpyLite-Extensions" selector="metaclassSpy">metaclassSpy	^metaclassSpy ifNil: [metaclassSpy := (self class new) className: (self nameOf: self theClass class); originalClass: self theClass class; yourself]</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>accessing-computed</category><body package="SpyLite-Extensions" selector="numberOfCoveredMethods">numberOfCoveredMethods	^self coveredMethods size</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>accessing</category><body package="SpyLite-Extensions" selector="originalClass">originalClass	^originalClass</body><body package="SpyLite-Extensions" selector="originalClass:">originalClass: t1 	originalClass := t1.</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>accessing-computed</category><body package="SpyLite-Extensions" selector="removeMethod:">removeMethod: t1 	(t1 mclass name endsWith: 'class')		ifTrue: [self metaclassSpy localMethods removeKey: t1 selector]		ifFalse: [methods removeKey: t1 selector ifAbsent: []].	^self</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>accessing</category><body package="SpyLite-Extensions" selector="superclass">superclass	self theClass superclass ifNil: [^nil].	^self profiler classAt: self theClass superclass name ifNone: [nil]</body><body package="SpyLite-Extensions" selector="theClass">theClass	^originalClass</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>RefactoringBrowser</category><body package="SpyLite-Extensions" selector="hasMethodSpyAsLiteral">hasMethodSpyAsLiteral	^self literals anySatisfy: [:t1 | t1 isKindOf: Spy1.SLMethod]</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>accessing</category><body package="SpyLite-Extensions" selector="isExtension">isExtension	^((Refactory.Browser.RefactoryChange new packageForClassDefinition: self mclass) name = (Refactory.Browser.RefactoryChange new packageForClass: self mclass selector: self selector) name) not</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>RefactoringBrowser</category><body package="SpyLite-Extensions" selector="isTemplateMethod">isTemplateMethod	^Spy1.SLProfiler templateMethods anySatisfy: [:t1 | self size = t1 size and: [(self initialPC to: self endPC)				allSatisfy: [:t2 | (self at: t2)						= (t1 at: t2)]]]</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>accessing</category><body package="SpyLite-Extensions" selector="linesOfCode">linesOfCode	| t1 |	t1 := 0.	self getSource ifNil: [^0].	self getSource asString lineIndicesDo: [:t2 :t3 :t4 | t3 &gt; t2			ifTrue: [t1 := t1 + 1]			ifFalse: [nil]].	^t1</body></methods><methods><class-id>Core.LimitedPrecisionReal class</class-id> <category>instance creation</category><body package="SpyLite-Extensions" selector="radix">radix	^2</body></methods><methods><class-id>Core.LimitedPrecisionReal</class-id> <category>converting</category><body package="SpyLite-Extensions" selector="asFraction">asFraction	self isSpecialValue ifTrue: [self error: #errSpecialValueConversion &lt;&lt; #dialogs &gt;&gt; 'Cannot convert special IEEE value'].	^(self mantissa: self class precision)		* self sign * (self class radix raisedTo: self exponent - self class precision + 1)</body><body package="SpyLite-Extensions" selector="isSpecialValue">isSpecialValue	^self exponent = self specialValueExponent</body><body package="SpyLite-Extensions" selector="specialValueExponent">specialValueExponent	self subclassResponsibility.</body></methods><methods><class-id>Refactory.Browser.RBProgramNode</class-id> <category>accessing</category><body package="SpyLite-Extensions" selector="sourceCode">sourceCode	| t1 |	(t1 := self sourceInterval) ifEmpty: [^''].	^self source copyFrom: t1 first to: t1 last</body></methods><methods><class-id>Core.Behavior</class-id> <category>creating class hierarchy</category><body package="SpyLite-Extensions" selector="classSpy">classSpy	| t1 |	(t1 := self spys) isEmpty		ifTrue: 			[self error: 'no spy installed'.			^self].	^self spys first classSpy</body><body package="SpyLite-Extensions" selector="hasSpy">hasSpy	^self methodDictionary values anySatisfy: [:t1 | t1 isTemplateMethod]</body><body package="SpyLite-Extensions" selector="linesOfCode">linesOfCode	| t1 |	t1 := self getMethodDictionary inject: 0 into: [:t2 :t3 | t2 + t3 linesOfCode].	self isMeta ifTrue: [^t1].	^t1 + self class linesOfCode</body><body package="SpyLite-Extensions" selector="numberOfLinesOfCode">numberOfLinesOfCode	^5 + (self methodDictionary values , self class methodDictionary values inject: 0 into: [:t1 :t2 | t1 + t2 numberOfLinesOfCode])</body><body package="SpyLite-Extensions" selector="profiler">profiler	^self classSpy profiler</body><body package="SpyLite-Extensions" selector="removeSpys">removeSpys	self == Spy1.SLProfiler class ifTrue: [^self].	self isMeta ifFalse: [self class removeSpys].	self methodDictionary keysAndValuesDo: [:t1 :t2 | t1 isSpy			ifTrue: [self methodDictionary at: t1 put: t2 originalMethod]			ifFalse: [nil]].	^self</body><body package="SpyLite-Extensions" selector="spys">spys	^(self methodDictionary values select: [:t1 | t1 isTemplateMethod])		collect: #methodSpy</body></methods><methods><class-id>Core.Symbol</class-id> <category>system primitives</category><body package="SpyLite-Extensions" selector="isUnary">isUnary	^self precedence = 1</body></methods><methods><class-id>Core.Symbol</class-id> <category>accessing</category><body package="SpyLite-Extensions" selector="value:">value: t1 	^t1 perform: self</body></methods><methods><class-id>Spy1.SLProfilerCoverage class</class-id> <category>public - profiling</category><body package="SpyLite-Extensions" selector="profile:inPackages:">profile: t1 inPackages: t2 	^self new profile: t1 inPackages: t2</body></methods><methods><class-id>Spy1.SLProfilerCoverage</class-id> <category>as yet unclassified</category><body package="SpyLite-Extensions" selector="calculateExecutedMethodsByClass">calculateExecutedMethodsByClass	^(self allClassesAsDictionary keys collect: [:t1 | t1 -&gt; (self calculateExecutedStatementsOf: t1)]		thenSelect: [:t2 | t2 value second &gt; 0]) asDictionary</body><body package="SpyLite-Extensions" selector="calculateExecutedStatementsByClass">calculateExecutedStatementsByClass	^(self allClassesAsDictionary keys collect: [:t1 | t1 -&gt; (self calculateExecutedStatementsOf: t1)]		thenSelect: [:t2 | t2 value second &gt; 0]) asDictionary</body><body package="SpyLite-Extensions" selector="calculateExecutedStatesByClassFor:">calculateExecutedStatesByClassFor: t1 	^(self allClassesAsDictionary keys collect: [:t2 | t2 -&gt; (self calculateExecutedStatesOf: t2 for: t1)]		thenSelect: [:t3 | t3 value second &gt; 0]) asDictionary</body><body package="SpyLite-Extensions" selector="calculateExecutedStatesOf:for:">calculateExecutedStatesOf: t1 for: t2 	| t3 t4 t5 |	[t3 := (t4 := t2 fsmStateSpecs collect: [:t6 | t6 actionBlock method at: 1]) size]		on: Error do: [^0].	t5 := (self classAt: t1) allMethods.	^Array with: t3 with: (self numberOfExecutedStatesIn: t5 for: t4)</body><body package="SpyLite-Extensions" selector="numberOfExecutedStatesIn:">numberOfExecutedStatesIn: t1 	^self numberOfExecutedStatesIn: self allMethods for: t1</body><body package="SpyLite-Extensions" selector="numberOfExecutedStatesIn:for:">numberOfExecutedStatesIn: t1 for: t2 	^(t1 select: [:t3 | t2 includesValue: t3 selector])		inject: 0 into: [:t4 :t5 | t4 + t5 isExecuted]</body></methods><methods><class-id>Spy1.SLProfilerCoverage</class-id> <category>public-profiling</category><body package="SpyLite-Extensions" selector="profile:inPackages:">profile: t1 inPackages: t2 	Transcript show: 'profiling...'; cr.		[self beforeProfiling.	self gatherForPackages: t2.	self install.	self beforeProfiling.	t1 value.	self afterProfiling]		ensure: [self uninstall].	Transcript show: 'ended...'; cr.	self setIfNecessaryTimeProfiler: t1.	self setIfNecessaryTimeAndCallGraphFrom: t1.	self setIfNecessaryStateChanges.	self checkInvariant.	^self</body></methods><methods><class-id>Spy1.SLProfilerCoverage</class-id> <category>as yet unclassified</category><body package="SpyLite-Extensions" selector="stateCoverage1For:">stateCoverage1For: t1 	| t2 t3 |	[t2 := (t3 := t1 fsmStateSpecs collect: [:t4 | t4 actionBlock method at: 1]) size]		on: Error do: [^0].	t2 == 0 ifTrue: [^0].	^(100 * (self numberOfExecutedStatesIn: t3) / t2) asFloat round: 3</body><body package="SpyLite-Extensions" selector="stateCoverageFor:">stateCoverageFor: t1 	| t2 t3 |	[t2 := (t3 := t1 fsmStateSpecs collect: [:t4 | t4 actionBlock method at: 1]) size]		on: Error do: [^0].	t2 == 0 ifTrue: [^0].	^(100 * (self numberOfExecutedStatesIn: t3) / t2) asFloat round: 3</body></methods><methods><class-id>Core.String class</class-id> <category>defaults</category><body package="SpyLite-Extensions" selector="lf">lf	^self with: Character lf</body></methods><methods><class-id>Core.String</class-id> <category>private</category><body package="SpyLite-Extensions" selector="substrings">substrings	^self substrings: (Array with: Character space)</body></methods><methods><class-id>Core.Dictionary class</class-id> <category>Signal constants</category><body package="SpyLite-Extensions" selector="newFrom:">newFrom: t1 	| t2 |	t2 := self new: t1 size.	t1 associationsDo: [:t3 | (t2 includesKey: t3 key)			ifTrue: [self error: 'Duplicate key: ' , t3 key printString]			ifFalse: [t2 add: t3]].	^t2</body></methods><methods><class-id>Spy1.SLProfiler class</class-id> <category>public - profiling</category><body package="SpyLite-Extensions" selector="profilerForPackagesMatching:">profilerForPackagesMatching: t1 	self installOnPackagesMatching: t1.	^self gatherForPackagesMatching: t1</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>accessing - read only</category><body package="SpyLite-Extensions" selector="allMethods">allMethods	| t1 |	t1 := OrderedCollection new.	self packages do: [:t2 | t1 addAll: t2 allMethods].	^t1</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>contract</category><body package="SpyLite-Extensions" selector="checkInvariant">checkInvariant	self assert: [self packages notNil].	self assert: [self packages allSatisfy: [:t1 | t1 isKindOf: self class spyClassForPackage]].	self assert: [self packages allSatisfy: [:t2 | t2 profiler notNil]].	self assert: [self packages allSatisfy: [:t3 | t3 profiler == self]].	self packages do: [:t4 | t4 checkInvariant]</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>util</category><body package="SpyLite-Extensions" selector="classesInCategory:">classesInCategory: t1 	^self class classesInCategory: t1</body><body package="SpyLite-Extensions" selector="classesInCategory:inNamespace:">classesInCategory: t1 inNamespace: t2 	^self class classesInCategory: t1 inNamespace: t2</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>gathering</category><body package="SpyLite-Extensions" selector="fillClassType:with:">fillClassType: t1 with: t2 	| t3 t4 t5 |	t1 theClass == SLProfiler class ifTrue: [^self].	t2 keys		do: 			[:t6 | 			t3 := t2 at: t6.			(t5 := SpyWrapper on: t6 inClass: t1 originalClass)				ifNotNil: 					[t4 := (self class spyClassForMethod new initialize) originalMethod: t3; selector: t6; instrumentedMethod: t5; classSpy: t1; yourself.					t5 methodSpy: t4.					t4 spyWrapper: t5.					t1 localMethodAt: t6 put: t4]].	^self</body><body package="SpyLite-Extensions" selector="gatherForClassCategories:inNamespace:">gatherForClassCategories: t1 inNamespace: t2 	t1		do: 			[:t3 | 			| t4 |			(t4 := self packageForClassesInCategory: t3 inNamespace: t2) packageName: t3.			self addPackage: t4]			</body><body package="SpyLite-Extensions" selector="gatherForPackageNamed:">gatherForPackageNamed: t1 	| t2 t3 t4 |	(t4 := self class spyClassForPackage new) packageName: t1.	self addPackage: t4.	(t3 := Store.Registry packageNamed: t1 allDefinedClasses)		do: 			[:t5 | 			(t2 := self spyForClass: t5) packageSpy: t4.			t4 profiler: self.			t4 classAt: t5 name put: t2].</body><body package="SpyLite-Extensions" selector="gatherForPackages:">gatherForPackages: t1 	t1		do: 			[:t2 | 			| t3 t4 |			(t4 := self class spyClassForPackage new) packageName: t2 name.			self addPackage: t4.			t2 allDefinedClasses				do: 					[:t5 | 					(t3 := self spyForClass: t5) packageSpy: t4.					t4 classAt: (self nameOf: t5) asSymbol put: t3]].	</body><body package="SpyLite-Extensions" selector="gatherForPackagesMatching:">gatherForPackagesMatching: t1 	| t2 |	t2 := Store.Registry allPackages select: [:t3 | t1 match: t3 name asString].	^self gatherForPackages: t2</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>util</category><body package="SpyLite-Extensions" selector="getInstrumentedClasses:">getInstrumentedClasses: t1 	| t2 t3 t4 t5 t6 |	t6 := [:t7 | t7 isNil				ifTrue: [Array new]				ifFalse: [t7 allClasses]].	(t4 := (Store.Registry bundleNamed: 'Base VisualWorks') allClasses) addAll: (Store.Registry bundleNamed: 'Spy') allClasses.	t4 addAll: (t6 value: (Store.Registry packageNamed: 'SUnit')).	t4 addAll: (t6 value: (Store.Registry packageNamed: 'SUnitToo')).	t5 := t4 collect: [:t8 | t8 isMeta					ifTrue: [t8 instanceBehavior name]					ifFalse: [t8 name]].	t3 := OrderedCollection new.	t1 do: [:t9 | (t2 := t9 method) mclass isMeta			ifTrue: [(t5 includes: t2 mclass instanceBehavior name asString)					ifTrue: [nil]					ifFalse: [t3 add: t2 mclass instanceBehavior]]			ifFalse: [(t5 includes: t2 mclass name asString)					ifTrue: [nil]					ifFalse: [t3 add: t2 mclass]]].	^t3 asSet asOrderedCollection</body><body package="SpyLite-Extensions" selector="getInstrumentedPackages:">getInstrumentedPackages: t1 	| t2 t3 t4 t5 |	(t4 := (Store.Registry bundleNamed: 'Base VisualWorks') allClasses) addAll: (Store.Registry bundleNamed: 'Spy') allClasses.	t4 add: Object.	t5 := t4 collect: [:t6 | t6 isMeta					ifTrue: [t6 instanceBehavior name]					ifFalse: [t6 name]].	t3 := OrderedCollection new.	t1 do: [:t7 | (t2 := t7 method) mclass isMeta			ifTrue: [(t5 includes: t2 mclass instanceBehavior name asString)					ifTrue: [nil]					ifFalse: [t3 addAll: (Store.Registry packagesContaining: t2 mclass instanceBehavior)]]			ifFalse: [(t5 includes: t2 mclass name asString)					ifTrue: [nil]					ifFalse: [t3 addAll: (Store.Registry packagesContaining: t2 mclass)]]].	^t3 asSet asOrderedCollection</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>accessing - read only</category><body package="SpyLite-Extensions" selector="getPackageNamed:">getPackageNamed: t1 	^self packages detect: [:t2 | t2 packageName asString = t1 asString]</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>hooks</category><body package="SpyLite-Extensions" selector="getTimeAndCallGraph">getTimeAndCallGraph	^false</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>gathering</category><body package="SpyLite-Extensions" selector="packageForClassCategories:">packageForClassCategories: t1 	| t2 t3 t4 |	t3 := self class spyClassForPackage new.	t4 := OrderedCollection new.	t1 do: [:t5 | t4 addAll: (Smalltalk organization listAtCategoryNamed: t5 asSymbol)].	t4		do: 			[:t6 | 			| t7 |			t7 := Smalltalk at: t6.			(t2 := self spyForClass: t7) packageSpy: t3.			t3 classAt: t6 put: t2].	^t3</body><body package="SpyLite-Extensions" selector="packageForClassCategory:">packageForClassCategory: t1 	| t2 t3 t4 |	t3 := self class spyClassForPackage new.	(t4 := Smalltalk organization listAtCategoryNamed: t1 asSymbol) do: 		[:t5 | 		| t6 |		(t6 := Smalltalk at: t5) class = NameSpace			ifTrue: [nil]			ifFalse: 				[(t2 := self spyForClass: t6) packageSpy: t3.				t3 classAt: t5 put: t2]].	^t3</body><body package="SpyLite-Extensions" selector="packageForClassesInCategory:inNamespace:">packageForClassesInCategory: t1 inNamespace: t2 	| t3 t4 t5 |	t4 := self class spyClassForPackage new.	(t5 := self classesInCategory: t1 inNamespace: t2)		do: 			[:t6 | 			| t7 |			t7 := t2 at: t6 name.			(t3 := self spyForClass: t7) packageSpy: t4.			t4 classAt: t6 name put: t3].	^t4</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>hooks</category><body package="SpyLite-Extensions" selector="uninstallClass:">uninstallClass: t1 	| t2 |	(t2 := (self allClassesSuchThat: [:t3 | t3 className = t1]) first)		ifNotNil: 			[t2 methods do: #uninstall.			t2 metaclassSpy methods do: #uninstall].	^t2</body></methods><methods><class-id>Spy1.SSTypeCollectorMethod</class-id> <category>hooks</category><body package="SpyLite-Extensions" selector="beforeRun:with:in:">beforeRun: t1 with: t2 in: t3 	self saveArguments: t2.	self saveReceiver: t3.	self selectLiteralsOf: self originalMethod getSource.	t2 do: [:t4 | self checkIfArgIsScalar: t4].	executed := true.	numberOfExecutions := numberOfExecutions + 1.	</body></methods><methods><class-id>Spy1.SSTypeCollectorMethod</class-id> <category>testing</category><body package="SpyLite-Extensions" selector="isQuick">isQuick	^self originalMethod isReturnField</body></methods><methods><class-id>Spy1.SSTypeCollectorMethod</class-id> <category>hooks</category><body package="SpyLite-Extensions" selector="nameOf:">nameOf: t1 	^(t1 isClass		ifTrue: [t1 fullName]		ifFalse: [t1 class fullName]) asSymbol</body></methods><methods><class-id>Core.Collection</class-id> <category>converting</category><body package="SpyLite-Extensions" selector="asDictionary">asDictionary	^Dictionary newFrom: self</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="SpyLite-Extensions" selector="difference:">difference: t1 	| t2 |	t2 := (self asSet) removeAllFoundIn: t1; yourself.	^self species withAll: t2 asArray</body><body package="SpyLite-Extensions" selector="intersection:">intersection: t1 	^self species withAll: (self asSet intersection: t1) asArray</body></methods><methods><class-id>Core.Collection</class-id> <category>testing</category><body package="SpyLite-Extensions" selector="isCollection">isCollection	^true</body></methods><methods><class-id>Core.Collection</class-id> <category>removing</category><body package="SpyLite-Extensions" selector="removeAllFoundIn:">removeAllFoundIn: t1 	t1 do: [:t2 | self remove: t2 ifAbsent: [nil]].	^t1</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="SpyLite-Extensions" selector="select:thenCollect:">select: t1 thenCollect: t2 	^(self select: t1)		collect: t2</body><body package="SpyLite-Extensions" selector="select:thenDo:">select: t1 thenDo: t2 	self do: [:t3 | (t1 value: t3)			ifTrue: [t2 value: t3]			ifFalse: [nil]].</body></methods><methods><class-id>Spy1.SpyLite</class-id> <category>assertion</category><body package="SpyLite-Extensions" selector="assert:">assert: t1 	t1 value ifFalse: [self error: 'Assertion failed'].	^self</body><body package="SpyLite-Extensions" selector="nameOf:">nameOf: t1 	^(t1 isClass		ifTrue: [t1 fullName]		ifFalse: [t1 class fullName]) asSymbol</body></methods><methods><class-id>Spy1.SLCollectorLiteral</class-id> <category>visiting</category><body package="SpyLite-Extensions" selector="acceptLiteralNode:">acceptLiteralNode: t1 	| t2 t3 |	t2 := t1 value.	(t3 := literals at: (self nameOf: t2 class)				ifAbsentPut: [Set new]) add: t2.	t2 isCollection ifTrue: [[t3 add: t2 class new]			on: Error do: [nil]].</body><body package="SpyLite-Extensions" selector="nameOf:">nameOf: t1 	^t1 fullName asSymbol</body></methods><methods><class-id>Refactory.Browser.RBMethodNode</class-id> <category>accessing</category><body package="SpyLite-Extensions" selector="sourceCode">sourceCode	^source</body></methods><methods><class-id>Core.Character</class-id> <category>converting</category><body package="SpyLite-Extensions" selector="asString">asString	^String with: self</body></methods><methods><class-id>Spy1.SLMethodCoverage</class-id> <category>public - metrics</category><body package="SpyLite-Extensions" selector="isExecuted">isExecuted	(self blocks select: #wasExecuted) size &gt; 0 ifTrue: [^1].	^0</body></methods><methods><class-id>Spy1.SLMethodCoverage</class-id> <category>installing</category><body package="SpyLite-Extensions" selector="uninstall">uninstall	probedMethod ifNotNil: [probedMethod revert].	</body></methods><methods><class-id>Spy1.SLInstrumentor</class-id> <category>visitor-double dispatching</category><body package="SpyLite-Extensions" selector="acceptBlockNode:">acceptBlockNode: t1 	self instrumentBlock: t1.	super acceptBlockNode: t1</body><body package="SpyLite-Extensions" selector="acceptMethodNode:">acceptMethodNode: t1 	self instrumentBlock: t1.	super acceptMethodNode: t1.</body></methods><methods><class-id>Spy1.SLInstrumentor</class-id> <category>visiting</category><body package="SpyLite-Extensions" selector="buildSBBlock:">buildSBBlock: t1 	^(SLBlock new) id: self nextId; numberOfStatements: t1 body statements size; start: t1 body start; stop: t1 body stop; code: t1 sourceCode; yourself</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SLCollectorLiteral</name><environment>Spy1</environment><super>Refactory.Browser.RBProgramNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>literals </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>SLInstrumentor</name><environment>Spy1</environment><super>Refactory.Browser.RBProgramNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blocks currentId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>SpyLite</name><environment>Spy1</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>currentTestCase currentTestMethod </class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>SpyLite</package></attributes></class><class><name>SLClass</name><environment>Spy1</environment><super>Spy1.SpyLite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methods className allSubclassesCache packageSpy metaclassSpy originalClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>SpyLite</package></attributes></class><class><name>SLMethod</name><environment>Spy1</environment><super>Spy1.SpyLite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instrumentedMethod originalMethod selector classSpy spywrapper </inst-vars><class-inst-vars>inMeta </class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>SpyLite</package></attributes></class><class><name>SLProfiler</name><environment>Spy1</environment><super>Spy1.SpyLite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packages allClassesAsDictionaryCache allMethodsCache afterBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>SpyLite</package></attributes></class><class><name>SLMethodCoverage</name><environment>Spy1</environment><super>Spy1.SLMethod</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blocks probedMethod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite</package></attributes></class><class><name>SSTypeCollectorMethod</name><environment>Spy1</environment><super>Spy1.SLMethod</super><private>false</private><indexed-type>none</indexed-type><inst-vars>returnType argTypes receiverType executed literals numberOfExecutions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-TypeCollector</category><attributes><package>SpyLite</package></attributes></class><class><name>ClassDescription</name><environment>Core</environment><super>Core.Behavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceVariables organization </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>LimitedPrecisionReal</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>SLProfilerCoverage</name><environment>Spy1</environment><super>Spy1.SLProfiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeInfo </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite</package></attributes></class><class><name>Symbol</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Double</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>RBProgramNode</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent comments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><class><name>RBMethodNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBProgramNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector selectorParts body source arguments tags replacements nodeReplacements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><class><name>Fraction</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numerator denominator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Float</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>SLProfilerCoverageTest</name><environment>Spy1</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Tests</category><attributes><package>SpyLite</package></attributes></class><class><name>WriteStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class></st-source>