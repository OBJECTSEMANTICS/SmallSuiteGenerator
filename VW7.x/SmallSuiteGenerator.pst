<?xml version="1.0"?><st-source><!-- Name: SmallSuiteGeneratorBundleName: SmallSuiteGeneratorBundleStructure: a Store.BundleForParcelParcel: #('SmallSuiteGenerator' )ParcelName: SmallSuiteGeneratorPrerequisiteParcels: #(#('SpyLite-Extensions' '' ) )Date: 8:59:57 am July 9, 2020 --><time-stamp>From VisualWorksÂ®, 7.4 of December 5, 2005 on July 9, 2020 at 8:59:57 am</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>SmallSuiteGenerator</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>SmallSuiteGenerator</category><attributes><package>SmallSuiteGenerator</package></attributes></name-space><class><name>SGACrossoverOperationTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mutationOperation operation utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-GA</category><attributes><package>SSG-Tests-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGACrossoverOperationTest</class-id><body>This class contains tests</body></comment><class><name>STypeInfoTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Info</category><attributes><package>SSG-Tests-Info</package></attributes></class><comment><class-id>SmallSuiteGenerator.STypeInfoTest</class-id><body>This class contains tests</body></comment><class><name>SConfigurationTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SSG-Tests-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SConfigurationTest</class-id><body>This class contains tests</body></comment><class><name>SMultiFitnessFunctionTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>function utility fitnessFunctions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-GA</category><attributes><package>SSG-Tests-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SMultiFitnessFunctionTest</class-id><body>This class contains tests</body></comment><class><name>SExpressionTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-AST</category><attributes><package>SSG-Tests-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SExpressionTest</class-id><body>This class contains tests</body></comment><class><name>SmallTypeCollectorTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-SmallType</category><attributes><package>SSG-Tests-SmallType</package></attributes></class><comment><class-id>SmallSuiteGenerator.SmallTypeCollectorTest</class-id><body>This class contains tests</body></comment><class><name>SGAEngineTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>engine profiler utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-GA</category><attributes><package>SSG-Tests-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGAEngineTest</class-id><body>This class contains tests</body></comment><class><name>SLiteralTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpressionTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-AST</category><attributes><package>SSG-Tests-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SLiteralTest</class-id><body>This class contains tests</body></comment><class><name>SAssertionTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpressionTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-AST</category><attributes><package>SSG-Tests-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SAssertionTest</class-id><body>This class contains tests</body></comment><class><name>SFactoryMessageTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpressionTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-AST</category><attributes><package>SSG-Tests-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SFactoryMessageTest</class-id><body>This class contains tests</body></comment><class><name>SFieldAccessMessageTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpressionTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-AST</category><attributes><package>SSG-Tests-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SFieldAccessMessageTest</class-id><body>This class contains tests</body></comment><class><name>SEventTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario</category><attributes><package>SSG-Scenario</package></attributes></class><comment><class-id>SmallSuiteGenerator.SEventTest</class-id><body>This class contains tests</body></comment><class><name>SRandom</name><environment>SmallSuiteGenerator</environment><super>Core.MinimumStandardRandom</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SSG-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SRandom</class-id><body>SRandom is a subclass of Random that is responsible for select an item of the collection or collect items randomly in a collection</body></comment><class><name>SCoverageTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>utility fitness profiler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-GA</category><attributes><package>SSG-Tests-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SCoverageTest</class-id><body>This class contains tests</body></comment><class><name>SStatementCoverageTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SCoverageTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-GA</category><attributes><package>SSG-Tests-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SStatementCoverageTest</class-id><body>This class contains tests</body></comment><class><name>SRandomTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SSG-Tests-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SRandomTest</class-id><body>This class contains tests</body></comment><class><name>SMutatorTestCaseTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SSG-Tests-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SMutatorTestCaseTest</class-id><body>This class contains tests</body></comment><class><name>SSTestCaseTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SSG-Tests-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSTestCaseTest</class-id><body>This class contains tests</body></comment><class><name>SRemoveTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSTestCaseTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SSG-Tests-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SRemoveTest</class-id><body>This class contains tests</body></comment><class><name>SMultiTypeInfoTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Info</category><attributes><package>SSG-Tests-Info</package></attributes></class><comment><class-id>SmallSuiteGenerator.SMultiTypeInfoTest</class-id><body>This class contains tests</body></comment><class><name>SUndefinedObject</name><environment>SmallSuiteGenerator</environment><super>Core.UndefinedObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Info</category><attributes><package>SSG-Info</package></attributes></class><comment><class-id>SmallSuiteGenerator.SUndefinedObject</class-id><body>I'm a generic class for returnType of methods unexecuted</body></comment><class><name>SClassInfoTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Info</category><attributes><package>SSG-Tests-Info</package></attributes></class><comment><class-id>SmallSuiteGenerator.SClassInfoTest</class-id><body>This class contains tests</body></comment><class><name>GASFooTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SConfigGenerationTestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Generated</category><attributes><package>SSG-Tests-Generated</package></attributes></class><class><name>SMethodCoverageTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SCoverageTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-GA</category><attributes><package>SSG-Tests-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SMethodCoverageTest</class-id><body>This class contains tests</body></comment><class><name>SSTestRunner</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testCase invariants </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SSG-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSTestRunner</class-id><body>This class contains tests</body></comment><class><name>SSTestShifterTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SSG-Tests-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSTestShifterTest</class-id><body>This class contains tests</body></comment><class><name>SMethodInfoTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Info</category><attributes><package>SSG-Tests-Info</package></attributes></class><comment><class-id>SmallSuiteGenerator.SMethodInfoTest</class-id><body>This class contains tests</body></comment><class><name>SInsertTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSTestCaseTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SSG-Tests-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SInsertTest</class-id><body>This class contains tests</body></comment><class><name>SGAMutationOperationTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>operation utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-GA</category><attributes><package>SSG-Tests-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGAMutationOperationTest</class-id><body>This class contains tests</body></comment><class><name>SExtensionsTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SSG-Tests-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SExtensionsTest</class-id><body>This class contains tests</body></comment><class><name>SStack</name><environment>SmallSuiteGenerator</environment><super>Core.LinkedList</super><private>false</private><indexed-type>none</indexed-type><inst-vars>firstLinkStack lastLinkStack </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario</category><attributes><package>SSG-Scenario</package></attributes></class><comment><class-id>SmallSuiteGenerator.SStack</class-id><body>SStack is a proof class created to test project functionality</body></comment><class><name>SChangeTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSTestCaseTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SSG-Tests-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SChangeTest</class-id><body>This class contains tests</body></comment><class><name>SMessageTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpressionTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-AST</category><attributes><package>SSG-Tests-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SMessageTest</class-id><body>This class contains tests</body></comment><class><name>SObject</name><environment>SmallSuiteGenerator</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SSG-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SObject</class-id><body>Superclass of almost all project classes, between them:	- AST classes used to create statements and assertions	- Core classes which configure the environment, manage assertions creation and so.	- GA classes that are responsible for testCase's fitness increasing. It means coverage augmentation.	- Info classes which transform the profiler result in nodes that are easier to use in the assertions and statements creation.	- Profiler classes which get classes' info types.</body></comment><class><name>STestCaseFactoryExample</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SSG-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.STestCaseFactoryExample</class-id><body>STestCaseFactoryExample contains some examples to run and validate the project functionality</body></comment><class><name>SGAEngineExample</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SSG-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGAEngineExample</class-id><body>SGAEngineExample contains some examples to validate correct project functionality </body></comment><class><name>SAbstractClass</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario2</category><attributes><package>SSG-Scenario2</package></attributes></class><comment><class-id>SmallSuiteGenerator.SAbstractClass</class-id><body>SAbstractClass is a proof abstract class created to test project functionality</body></comment><class><name>SGALog</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>generationNumber timeToProduceGeneration fittestTestCase mutationResult lowestFit averageFit population summaryTargetClass typeInfoGeneration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SSG-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGALog</class-id><body>SGALog saves some important data about genetic algorithm evolution like: genetic algotithm's generation number, testCase with the highest fitness and time in which is produced the generation.In each iteration of the genetic algorithm a new instance of the class is created.Instance Variables	fittestTestCase:				&amp;lt;STestCase&amp;gt;	generationNumber:				&amp;lt;Smallnteger&amp;gt;	timeToProduceGeneration:		&amp;lt;SmallInteger&amp;gt;</body></comment><class><name>SPlatform</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>level randomGenerator seed configurationClass logName asDict </class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SSG-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SPlatform</class-id><body>SConfiguration is responsible for defining or instantiating some classes or values used in the project.Furthermore, some configuration parameters are defined depending the environment, it means Pharo or VisualWorks</body></comment><class><name>STypeObjectInfo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Info</category><attributes><package>SSG-Info</package></attributes></class><comment><class-id>SmallSuiteGenerator.STypeObjectInfo</class-id><body>STypeObjectInfo is an abstract class of info nodes: 			- type class -&amp;gt; Which collect type info data of a class in the profiler	- type method -&amp;gt; Collect types of the receiver, arguments and returnType of a method in the profiler</body></comment><class><name>STypeClassInfo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.STypeObjectInfo</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeName methodTypes classMethodTypes scalars </inst-vars><class-inst-vars>classMethodTypes </class-inst-vars><imports></imports><category>SmallSuiteGenerator-Info</category><attributes><package>SSG-Info</package></attributes></class><comment><class-id>SmallSuiteGenerator.STypeClassInfo</class-id><body>STypeClassInfo is an info type node for a class.Instance Variables	classMethodTypes:	&amp;lt;Dictionary&amp;gt;	methodTypes:			&amp;lt;Dictionary&amp;gt;	typeName:				&amp;lt;Symbol&amp;gt;</body></comment><class><name>STypeMethodInfo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.STypeObjectInfo</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector returnType argTypes isQuick isDeprecated receiver scalars executions hasProfiler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Info</category><attributes><package>SSG-Info</package></attributes></class><comment><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id><body>STypeMethodInfo is an info type node for a method.Instance Variables	argTypes:			&amp;lt;Array&amp;gt;	isDeprecated:	&amp;lt;Boolean&amp;gt;	isQuick:			&amp;lt;Boolean&amp;gt;	receiver:			&amp;lt;SMultiTypeInfo&amp;gt;	returnType:		&amp;lt;SMultiTypeInfo&amp;gt;	selector:			&amp;lt;Symbol&amp;gt;</body></comment><class><name>SMultiTypeInfo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.STypeObjectInfo</super><private>false</private><indexed-type>none</indexed-type><inst-vars>types mustBeFixed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Info</category><attributes><package>SSG-Info</package></attributes></class><comment><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id><body>SMultiTypeInfo is a set of types.Instance Variables	types:		&amp;lt;Set&amp;gt;</body></comment><class><name>STestCaseFactory</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>reportClass engine typeInfo targetClassName targetPackageRegex outputPackageName fitness numberOfIterations profiler setUpMethod tearDownMethod lastMessage asDict fitnessSeed initialSeed initialAsDict typeInfoSeed typeInfoOrigin firstExecution </inst-vars><class-inst-vars>instance </class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SSG-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.STestCaseFactory</class-id><body>STestCaseFactory is an abstract class that represents the project facade. It contains the main methods to run the project</body></comment><class><name>STestCaseFactoryVisualWorks</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.STestCaseFactory</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SSG-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.STestCaseFactoryVisualWorks</class-id><body>STestCaseFactoryVisualWorks is a subclass that it is called when the project runs in VisualWorks</body></comment><class><name>SSExecutionContext</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>values </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SSG-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSExecutionContext</class-id><body>SSExecutionContext takes a snapshot of the SSTestRunner's instance context. It saves the tempNames of variables and values as dictionaryInstance Variables	values:		&amp;lt;Dictionary&amp;gt;</body></comment><class><name>SmallTypeCollector</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classDict </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-SmallType</category><attributes><package>SSG-SmallType</package></attributes></class><class><name>SGAObject</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SSG-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGAObject</class-id><body>Abstract class of those nodes responsible for the genetic algorithm evolution:	- engine (like its name says, it is responsible to execute the algorithm in order to get the testCases with the highest fitness value)	- operations classes -&amp;gt; Responsible for executing crossover and mutation operation	- selection algorithm class -&amp;gt; It selects the fittest individuals testCases</body></comment><class><name>SGASelection</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fitness </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SSG-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGASelection</class-id><body>Abstract class for strategy selection</body></comment><class><name>SGARouletteSelection</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGASelection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SSG-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGARouletteSelection</class-id><body>SGARoulleteSelection is responsible for select testCases, gives more probaility of be selected when a testCase has more fitness</body></comment><class><name>SGARankSelection</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGASelection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SSG-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGARankSelection</class-id><body>SGARankSelectionModified is responsible for select testCases based of their rank</body></comment><class><name>SGATruncatedSelection</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGASelection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>discarding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SSG-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGATruncatedSelection</class-id><body>SGATrouncateSelection is responsible for select testCases, this type of selection descart the worst N testCases (less fitness) and then select randomly testCases</body></comment><class><name>SGAEngine</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>populationSize mutationOperator crossoverOperator numberOfStatements population logs typeInfo fitness selectionStrategy targetClassName numberOfGenerations lastMessage packageRegex initialPopulation typeInfoProfiler targetPackageRegex elitismRate crossoverRate stopIterations totalExecutionGA selectionStrategyTestCase </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SSG-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGAEngine</class-id><body>SGAEngine is responsible for executing the genetic algorithm, it means that it follows the phases to get a testCase population with the highest fitness score.The phases followed are:	1. Create an initial population 	2. Use the fitness function established to calculate the fitness score of each testCase in the population	3. Determine the selection strategy to select the fittest testCases and let them pass their statements to the next generation	4. Apply the crossover operation to get offsprings (new testCases) by exchanging the statements of parents (testCases). 	5. Apply mutation operation with a low random probability to modify some statements. Internal Representation and Key Implementation Points.Instance Variables	crossoverOperator:			&amp;lt;SGACrossoverOperator&amp;gt;	fitness:						&amp;lt;SFitnessFunction&amp;gt;	logs:							&amp;lt;OrderedCollection&amp;gt;	mutationOperator:			&amp;lt;SGAMutationOperator&amp;gt;	numberOfIterations:		&amp;lt;SmallInteger&amp;gt;	numberOfStatements:		&amp;lt;SmallInteger&amp;gt;	population:					&amp;lt;OrderedCollection&amp;gt;	populationSize:				&amp;lt;SmallInteger&amp;gt;	selectionStrategy:			&amp;lt;SGATournamentSelection&amp;gt;	targetClassName:			&amp;lt;ByteString&amp;gt;	typeInfo:						&amp;lt;STypeInfo&amp;gt;</body></comment><class><name>STypeInfo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>types classes noneAbstractClasses scalars blackList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Info</category><attributes><package>SSG-Info</package></attributes></class><comment><class-id>SmallSuiteGenerator.STypeInfo</class-id><body>STypeInfo is responsible for collecting the STypeCollector's main data and building a new instance from the collected data.It is composed of STypeClassInfo collection and each item likewise is formed by STypeMethodInfo collection.Instance Variables	types:						&amp;lt;Dictionary&amp;gt;	All the classes (represented as an instance of STypeClassInfo) for which information is collected	classes:					&amp;lt;Dictionary&amp;gt;	noneAbstractClasses:	&amp;lt;Collection&amp;gt;	scalars: 					&amp;lt;Dictionary&amp;gt;	collection of classes that cannot be instrumented</body></comment><class><name>Example</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>a b c </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Generated</category><attributes><package>SSG-Tests-Generated</package></attributes></class><class><name>SFoo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>score </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario</category><attributes><package>SSG-Scenario</package></attributes></class><comment><class-id>SmallSuiteGenerator.SFoo</class-id><body>SFoo is a proof class created to test project functionality</body></comment><class><name>SSubclassChild</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SAbstractClass</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario2</category><attributes><package>SSG-Scenario2</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSubclassChild</class-id><body>SSubclassChild is a proof class created to test project functionality</body></comment><class><name>SPlatformVisualWorks</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SPlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SSG-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SPlatformVisualWorks</class-id><body>SConfigurationVisualWorks is a subclass called when the project environment is running in VisualWorks.</body></comment><class><name>SPlatformPharo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SPlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SSG-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SPlatformPharo</class-id><body>SConfigurationPharo is a subclass called when the project environment is running in Pharo. Furthermore, it defines parameters used in Pharo.</body></comment><class><name>SExpression</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>returnType id mutated parent identifier needsBeFixed </inst-vars><class-inst-vars>nextId </class-inst-vars><imports></imports><category>SmallSuiteGenerator-AST</category><attributes><package>SSG-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SExpression</class-id><body>Superclass of all nodes for 	- expressions (they represent nodes which are used to create messages),	- messages (concerned with: assertion messages, factory messages, access messages and mesasges that modify the behavior of a class)	Instance Variables	id:		               &amp;lt;Integer&amp;gt; 	randomGenerator:		&amp;lt;SRandom&amp;gt;	returnType:		      &amp;lt;Symbol&amp;gt;</body></comment><class><name>SVariable</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>varName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-AST</category><attributes><package>SSG-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SVariable</class-id><body>SVariable is a node which is represented by a name and id.For example: 	1.			_var2				_var -&amp;gt; Name of variable.		2 -&amp;gt; Id of variable			2. 		_int3				'_int' -&amp;gt; Name		3 -&amp;gt; Id</body></comment><class><name>SAbstractMessage</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>receiver selector args </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-AST</category><attributes><package>SSG-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SAbstractMessage</class-id><body>Abstract class of nodes for	- messages (access messages and messages that update the state of a class)	- factory methods (to represent the class creation messages),	- assertion messages (to represent assertion messages that match with an according requirement)Instance Variables	args:		    &amp;lt;Collection&amp;gt;	receiver:		 &amp;lt;Symbol&amp;gt;	selector:		 &amp;lt;Symbol&amp;gt;</body></comment><class><name>SSelf</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SVariable</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-AST</category><attributes><package>SSG-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSelf</class-id><body>SSelf is a node which is part of the assertion message.</body></comment><class><name>SFactoryMessage</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SAbstractMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-AST</category><attributes><package>SSG-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SFactoryMessage</class-id><body>SFactoryMessage is a node that represents the class' creation with methods of meta class.For example: 	1.			SStack newStack.			#SStack -&amp;gt; It's the receiver 		#newStack -&amp;gt; It's a method of meta class.			2. 		SFoo score: _var1.				#SFoo -&amp;gt; Receiver		#score: -&amp;gt; Message of receiver		_var1 -&amp;gt; Argument 			3. 		SFoo new.				#SFoo new -&amp;gt; Receiver		#new -&amp;gt; Default selector</body></comment><class><name>SAssignment</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>variable value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-AST</category><attributes><package>SSG-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SAssignment</class-id><body>SAssignment is a node which is compossed by a variable and an expression.For example: 	1.			_var0 := 1.			_var0 -&amp;gt; Variable.		1 -&amp;gt; value (in this case a literal).			2. 		_var1 := SFoo new.				_var1 -&amp;gt; Varaible		SFoo new -&amp;gt; an instance of factoryMessage</body></comment><class><name>SMessage</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SAbstractMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-AST</category><attributes><package>SSG-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SMessage</class-id><body>SMessage is a node which represents method calls that not return an instance variable of a class. They are a little more complex. It can receive arguments also.For example: 	1.			_var1 returnCollection.			_var1 -&amp;gt; Receiver which points to SFoo's factoryMessage.		#returnCollection -&amp;gt; selector of the method.			2. 		_var1 return: _var2.				_var1 -&amp;gt; Receiver		#return: -&amp;gt; selector		_var2 -&amp;gt; Argument of type ByteString</body></comment><class><name>SLiteral</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-AST</category><attributes><package>SSG-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SLiteral</class-id><body>SLiteral is a node which is compossed by a value that is included in typeInfo scalars.For example: 	1.			10				10 -&amp;gt; SmallInteger.			2. 		'hello'				'hello' -&amp;gt; ByteString.</body></comment><class><name>SGAOperation</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SSG-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGAOperation</class-id><body>SGAOperation is an abstract class for operation nodes which are necessary to create a new population  	- crossover operation 	- mutation operation </body></comment><class><name>SGAMutationOperation</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGAOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mutationRate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SSG-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGAMutationOperation</class-id><body>SGAMutationOperation is an operator which modifies some statements of the testCase. However this operation depends of a random probability to be applied.This operation can apply three different types of mutation: 		- remove -&amp;gt; It means that a statement choosen randomly can be removed of the testCase.	- change -&amp;gt; According to the statement choosen, it is modified in value or selector.	- insert -&amp;gt; A statement is added following one of these options: asRandomMessage, asMethodMessage or asParameter. The reason for these options is because statements are usually of different expressions.</body></comment><class><name>SGARandomSelection</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGASelection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SSG-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGARandomSelection</class-id><body>SGARankSelection is responsible for select testCases randomly regardless of fitness</body></comment><class><name>STestCaseFactoryPharo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.STestCaseFactory</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SSG-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.STestCaseFactoryPharo</class-id><body>STestCaseFactoryPharo is a subclass that it is called when the project runs in Pharo</body></comment><class><name>SSTestShifter</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>statements assertions typeInfo nextId fitness targetClassesNames maxNumberOfStatements validatedTargetClassName fitnessByClass parents children lastMessage selectionStrategy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SSG-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSTestShifter</class-id><body>SSTestShifter is responsible for creating, mutating and validating statements. It is responsible to for creating different kind of statements: primitive, factory messages, messages, accessor messages.Genetic algorithm's evolution depends this class' increasing fitness. For this reason it is one of the main classes and essential for the project.Instance Variables	assertions:						&amp;lt;OrderedCollection&amp;gt;	fitness:							&amp;lt;Dictionary&amp;gt;	fitnessByClass:					&amp;lt;Dictionary&amp;gt;	maxNumberOfStatements:		&amp;lt;SmallInteger&amp;gt;	nextId:							&amp;lt;SmallInteger&amp;gt;	randomGenerator:				&amp;lt;SRandomGenerator&amp;gt;	statements:						&amp;lt;OrderedCollection&amp;gt;	targetClassesNames:			&amp;lt;Set&amp;gt;	typeInfo:							&amp;lt;STypeInfo&amp;gt;	validatedTargetClassName:	&amp;lt;Boolean&amp;gt;</body></comment><class><name>SSTestCase</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSTestShifter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>idPopulation previousOpenWindows summaryExecutionMethods generationNumber hasErrors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SSG-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSTestCase</class-id><body>SSTestCase is a subclass that defines or initializes some instance variables which are util in the genetic algorithm evolution</body></comment><class><name>SReport</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Utility</category><attributes><package>SSG-Utility</package></attributes></class><class><name>SReportSTestCaseFactory</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SReport</super><private>false</private><indexed-type>none</indexed-type><inst-vars>factoryTestCase </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Utility</category><attributes><package>SSG-Utility</package></attributes></class><class><name>SReportTypeInfo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SReport</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Utility</category><attributes><package>SSG-Utility</package></attributes></class><comment><class-id>SmallSuiteGenerator.SReportTypeInfo</class-id><body>SReportTypeInfo exports data about coverage and patterns frequency of projects in Smalltalk. It exports two kinds of reports:	1. Project's coverage covered in the genetic algorithm. It presents 	- Project -&amp;gt; Project name in Smalltalk.	- Classes -&amp;gt; Number of classes executed in the project.	- Methods -&amp;gt; Number of methods executed in the project.	- Test -&amp;gt; Number of tests that are evaluated in the project.	- Coverage -&amp;gt; Project coverage percent covered.	2. Patterns frequency of type method info. Each type method info is categorized according its receiver, arguments and return type. The report contains:	- Project name	- Number of all methods	- Number of type method infos categorized in each pattern.</body></comment><class><name>SUtilityTypeInfo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Utility</category><attributes><package>SSG-Tests-Utility</package></attributes></class><comment><class-id>SmallSuiteGenerator.SUtilityTypeInfo</class-id><body>SUtilityTypeInfo is a class which declares typeInfos for tests. </body></comment><class><name>SFitnessFunction</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tagetPackagesRegex targetClass </inst-vars><class-inst-vars>operator </class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SSG-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SFitnessFunction</class-id><body>SFitnessFunction is an abstract class that represents a fitness abstract function used in genetic algorithm evolution to determine how fit a testCase is.</body></comment><class><name>SMultiFitnessFunction</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SFitnessFunction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fitness </inst-vars><class-inst-vars>multiFitnessFunction </class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SSG-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SMultiFitnessFunction</class-id><body>SMultiFitnessFunciton is the fitness function that contains simple fitness function's collection.</body></comment><class><name>SSimpleFitnessFunction</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SFitnessFunction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>profiler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SSG-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSimpleFitnessFunction</class-id><body>SSimpleFitnessFunction is an abstract class of simple fitness function like: 		- SMethodCoverage -&amp;gt; It calculates the number of class methods executed	- SStatementCoverage -&amp;gt; It calculates the number of statements executed 	Instance Variables	profiler:		&amp;lt;SSTypeCollector&amp;gt;	</body></comment><class><name>SStatementCoverage</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSimpleFitnessFunction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SSG-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SStatementCoverage</class-id><body>SStatementCoverage is responsible for calculating statement coverage of each testCase in the testSuite. It calculates how many statements were executed in each class defined of the testSuite. The number of statements refers to number of lines of code executed </body></comment><class><name>SAssertionMessage</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SAbstractMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-AST</category><attributes><package>SSG-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SAssertionMessage</class-id><body>Superclass of assertion messages nodes for 	- comparison assertion (it compares an object with other)	- inspector assertion (it compares the result of a method executed with a value)	- primitive assertion (it compares the primitive values)	- string assertion (it compares the way to represent an object as string with a string)</body></comment><class><name>SPrimitiveAssertion</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SAssertionMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-AST</category><attributes><package>SSG-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SPrimitiveAssertion</class-id><body>A SPrimitiveAssertion collects instances of the class if the execution context's values are primitives.For example: 		List with items classified as primitive: 		Array with: '_var1' -&amp;gt; 'hello'		with: '_var2' -&amp;gt; 2		with: '_var3' -&amp;gt; (3@5).	It returns items like: 		self assert: _var1 equals: 'hello'.		self assert: _var2 equals: 2.</body></comment><class><name>SComparisonAssertion</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SAssertionMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-AST</category><attributes><package>SSG-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SComparisonAssertion</class-id><body>A SComparisonAssertion selects the execution context values that are comparable.Collection's items of the same class are compared and for each one is created a new instance of this class with the selector depending the result of the comparison.For example: 	List with items that are comparable: 		Array with: '_var1'-&amp;gt; 9		with: '_var2' -&amp;gt; 5		with: '_var3' -&amp;gt; 9		with: '_var4' -&amp;gt; 'hello'.	It returns items like: 		self deny: _var1 equals: _var2.		self assert: _var1 equals: _var3.		</body></comment><class><name>SInspectorAssertion</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SAssertionMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-AST</category><attributes><package>SSG-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SInspectorAssertion</class-id><body>A SInspectorAssertion selects methods categorized as returnField and creates an instance for each one if the execution result is primitive.For example: 		List with classes' items categorized as returnField: 		Array with: '_var2' -&amp;gt; (2@10).	It returns items like: 		self assert: _var2 x equals: 2.		self assert: _var2 y equals: 10.</body></comment><class><name>SEvent</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>discount price </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario</category><attributes><package>SSG-Scenario</package></attributes></class><comment><class-id>SmallSuiteGenerator.SEvent</class-id><body>SEVent is a proof class created to test project functionalityInstance Variables	discount:		&amp;lt;Object&amp;gt;	price:			&amp;lt;Object&amp;gt;</body></comment><class><name>SConference</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SEvent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>date speaker offerPrice </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario</category><attributes><package>SSG-Scenario</package></attributes></class><comment><class-id>SmallSuiteGenerator.SConference</class-id><body>SConference is a proof class created to test project functionalityInstance Variables	date:				&amp;lt;Object&amp;gt;	offerPrice:		&amp;lt;Object&amp;gt;	speaker:			&amp;lt;Object&amp;gt;</body></comment><class><name>SParty</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SEvent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>date </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario</category><attributes><package>SSG-Scenario</package></attributes></class><comment><class-id>SmallSuiteGenerator.SParty</class-id><body>SParty is a proof class created to test project functionalityInstance Variables	date:		&amp;lt;Object&amp;gt;</body></comment><class><name>SFieldAccessMessage</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SAbstractMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-AST</category><attributes><package>SSG-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SFieldAccessMessage</class-id><body>SFieldAccessMessage is a node which represents method calls that return an instance variable of a class.For example: 	1.			_var1 x.			_var1 -&amp;gt; Receiver which points to Point's factoryMessage.		#x -&amp;gt; selector of the method</body></comment><class><name>SMethodCoverage</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSimpleFitnessFunction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SSG-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SMethodCoverage</class-id><body>SMethodCoverage is responsible for calculating the method coverage in each testCase of a testSuite. It means that for each class defined in the testCase it calculates how many methods were executed.</body></comment><class><name>SSPerson</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name id nickname </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario</category><attributes><package>SSG-Scenario</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSPerson</class-id><body>SSPerson is a proof class created to test project functionality</body></comment><class><name>SStudent</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSPerson</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scoreStudent idStudent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario2</category><attributes><package>SSG-Scenario2</package></attributes></class><comment><class-id>SmallSuiteGenerator.SStudent</class-id><body>SStudent is a proof class created to test project functionality</body></comment><class><name>SSTeacher</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSPerson</super><private>false</private><indexed-type>none</indexed-type><inst-vars>yearsWorkExperience idTeacher </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario</category><attributes><package>SSG-Scenario</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSTeacher</class-id><body>SSTeacher is a proof class created to test project functionality</body></comment><class><name>SGACrossoverOperation</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGAOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SSG-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGACrossoverOperation</class-id><body>SGACrossoverOperation is the operation node that is responsible to create offsprings combining the statements of their parents.To create a new offspring it gets a random percent of statements of a testCase and the rest of another testCase. Furthermore, it checks the statements references (dependencies) and repairs them if it is necessary.For example if the parents are:	Parent1	_var0 := 1.	_var1 := 'hello'.		Parent2	_var0 := SFoo new.	_var1 := _var0 returnString.	The new offspring with a 50% of statements of each parent:	_var0 := 1.	_var1 := _var0 returnString.	Like it has an inconsistency because '_var0' in the first parent is of type SFoo, it is repaired. Then the new offspring resultant is:	_var0 := 1.	_var2 := SFoo new.	_var1 := _var2 returnString. </body></comment><class><name>SReportSGALog</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SReport</super><private>false</private><indexed-type>none</indexed-type><inst-vars>engine </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Utility</category><attributes><package>SSG-Utility</package></attributes></class><class><name>SStringAssertion</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SAssertionMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-AST</category><attributes><package>SSG-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SStringAssertion</class-id><body>A SStringAssertion select execution context's values that their class implement some method of printing like: 'printOn:', 'asString'. From the resulting collection each item is used to create an instance of the class using #printString as selector.For example: 		List with classes' items which have implemented printing methods: 		Array with: '_var1' -&amp;gt; 'hello'		with: '_var2' -&amp;gt; 2.3		with: '_var3' -&amp;gt; (3@5).	It returns items like: 		self assert: _var1 printString equals: ''hello''.		self assert: _var2 printString equals: '2.3'.		self assert: _var3 printString equals: (2@3).</body></comment><class><name>SGATournamentSelection</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGASelection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tournamentSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SSG-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGATournamentSelection</class-id><body>SGATournamentSelection is responsible for select the fittest testCase based in their fitness.</body></comment><class><name>SInitialization</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>configurationDict </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Initialization</category><attributes><package>SSG-Initialization</package></attributes></class><comment><class-id>SmallSuiteGenerator.SInitialization</class-id><body>SInitialization is abstract class to create an instance taking some considerations</body></comment><class><name>SSeedingParameterization</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SInitialization</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numberToChangeSeed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Initialization</category><attributes><package>SSG-Initialization</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSeedingParameterization</class-id><body>SSeedingParametrization creates instances changing the seed whether adding or reducing a value to the original seed</body></comment><class><name>SSelectionParameterization</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SInitialization</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Initialization</category><attributes><package>SSG-Initialization</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSelectionParameterization</class-id><body>SSelectionParametrization creates instances changing selectionStrategy of GA and use: 		- SGATournamentSelection 	- SGARankSelectionModified 	- SGARouletteSelection </body></comment><class><name>SNumericParameterization</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SInitialization</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Initialization</category><attributes><package>SSG-Initialization</package></attributes></class><comment><class-id>SmallSuiteGenerator.SNumericParameterization</class-id><body>SNumericParametrization creates instances changing values like: 		- numberOfStatements 	- numberOfPopulation	- numberOfGenerations</body></comment><class><name>SError</name><environment>SmallSuiteGenerator</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SSG-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SError</class-id><body>SError is a subclass of Error. It is used to represent error's conditions in test generation process.Additionally, it saves in a log all the errors gotten.</body></comment><methods><class-id>SmallSuiteGenerator.SGACrossoverOperationTest</class-id> <category>tests</category><body package="SSG-Tests-GA" selector="crossOver:">crossOver: listTestCase	| offSprings offSpring1 offSpring2 |	self assert: listTestCase size &gt;= 2.	offSprings := operation		crossover: listTestCase first		with: listTestCase second.	offSpring1 := offSprings first.	offSpring2 := offSprings second.	self assert: offSpring1 validReferences.	self assert: offSpring2 validReferences</body><body package="SSG-Tests-GA" selector="crossOverWithMutation:">crossOverWithMutation: listTestCase	| offSprings offSpring1 offSpring2 |	self assert: listTestCase size &gt;= 2.	self assert: listTestCase first validReferences.	self assert: listTestCase second validReferences.	offSpring1 := mutationOperation mutate: listTestCase first.	offSpring2 := mutationOperation mutate: listTestCase second.	offSprings := operation crossover: offSpring1 with: offSpring2.	offSpring1 := offSprings first.	offSpring2 := offSprings second.	offSpring1 := mutationOperation mutate: offSpring1.	offSpring2 := mutationOperation mutate: offSpring2.	offSprings := operation crossover: offSpring1 with: offSpring2.	self assert: offSpring1 validReferences.	self assert: offSpring2 validReferences</body><body package="SSG-Tests-GA" selector="testCrossOverToSStack">testCrossOverToSStack	self crossOver: utility testSuiteSStack.	self crossOverWithMutation: utility testSuiteSStack</body><body package="SSG-Tests-GA" selector="testCrossOverToSStudent">testCrossOverToSStudent	self crossOver: utility testSuiteSStudent</body><body package="SSG-Tests-GA" selector="testCrossOverToSStudent2">testCrossOverToSStudent2	self crossOver: utility testSuiteSStudentManual.	self crossOverWithMutation: utility testSuiteSStudentManual</body></methods><methods><class-id>SmallSuiteGenerator.SGACrossoverOperationTest</class-id> <category>running</category><body package="SSG-Tests-GA" selector="setUp">setUp	super setUp.	SPlatform resetRandomGenerator.	operation := SGACrossoverOperation new.	mutationOperation := SGAMutationOperation new.	utility := SUtilityTypeInfo new</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfoTest</class-id> <category>tests</category><body package="SSG-Tests-Info" selector="testAccesssMessagesFrom">testAccesssMessagesFrom	| typeInfo |	typeInfo := STypeInfo new		type:			#SFoo				-&gt;					(Array						with:							(Array								with: #returnString -&gt; #(#SFoo #ByteString #() false)								with: #score -&gt; #(#SFoo #SmallInteger #() true))						with: #()).	self		assertCollection: ((typeInfo accessMessagesFrom: #SFoo) collect: #selector)		hasSameElements: #(#score)</body><body package="SSG-Tests-Info" selector="testClassMethodTypeFrom">testClassMethodTypeFrom	| typeInfo |	typeInfo := STypeInfo new type: #SFoo -&gt; (Array with: #() with: #()).	self		should: [ typeInfo classMethodType: #new from: #SFoo ]		raise: SError.	typeInfo := STypeInfo new		type:			#SFoo				-&gt;					(Array						with: (Array with: #initialize -&gt; #(#SFoo #SFoo #() false))						with: #()).	self		shouldnt: [ typeInfo classMethodType: #new from: #SFoo ]		raise: SError</body><body package="SSG-Tests-Info" selector="testEquals">testEquals	self		assert: (STypeInfo new type: #SFoo -&gt; #(#() #()))		equals: (STypeInfo new type: #SFoo -&gt; #(#() #())).	self		assert:			(STypeInfo new				type:					#SStudent						-&gt;							(Array								with: (Array with: #name -&gt; #(#SStudent #ByteString #() false))								with: #());				scalar: #ByteString with: #('Abi'))		equals:			(STypeInfo new				type:					#SStudent						-&gt;							(Array								with: (Array with: #name -&gt; #(#SStudent #ByteString #() false))								with: #());				scalar: #ByteString with: #('Abi')).	self		assert:			(STypeInfo new				type:					#SFoo						-&gt;							(Array								with: (Array with: #return: -&gt; #(#SFoo #SStudent #(#SStudent) false))								with: (Array with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false)));				scalar: #SmallInteger with: #(1 3 4);				scalar: #SStudent with: (Array with: (SStudent name: 'Nilson')))		equals:			(STypeInfo new				type:					#SFoo						-&gt;							(Array								with: (Array with: #return: -&gt; #(#SFoo #SStudent #(#SStudent) false))								with: (Array with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false)));				scalar: #SmallInteger with: #(1 3 4);				scalar: #SStudent with: (Array with: (SStudent name: 'Nilson')))</body><body package="SSG-Tests-Info" selector="testFactoryMessagesFrom">testFactoryMessagesFrom	"self halt"	</body><body package="SSG-Tests-Info" selector="testIsAbstracClass">testIsAbstracClass	| typeInfo |	typeInfo := STypeInfo new		type:			(self fullSymbolOf: #SSPerson)				-&gt;					(Array						with:							(Array								with:									#name										-&gt;											(Array												with: (self fullSymbolOf: #SSPerson)												with: (self fullSymbolOf: #ByteString)												with: #()												with: true)								with:									#id										-&gt;											(Array												with: (self fullSymbolOf: #SSPerson)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: false))						with:							(Array								with:									#name:with:										-&gt;											(Array												with: (self fullSymbolOf: #SSPerson)												with: (self fullSymbolOf: #SSPerson)												with:													(Array														with: (self fullSymbolOf: #ByteString)														with: (self fullSymbolOf: #SmallInteger))												with: false)));		scalar: (self fullSymbolOf: #SmallInteger) with: #(50);		scalar: (self fullSymbolOf: #ByteString) with: #('Ann').	self		assert: (typeInfo isAbstractClass: (self fullSymbolOf: #SSPerson))</body><body package="SSG-Tests-Info" selector="testJoinWith">testJoinWith	| typeInfo methodInfo otherTypeInfo |	typeInfo := STypeInfo new		type:			#SFoo				-&gt;					(Array						with:							(Array								with: #return: -&gt; #(#SFoo #OrderedCollection #(#OrderedCollection) false)								with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false)								with: #score -&gt; #(#SFoo #SmallInteger #() true))						with: (Array with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false))).	otherTypeInfo := STypeInfo new		type:			#SFoo				-&gt;					(Array						with:							(Array								with: #returnFloat -&gt; #(#SFoo #SmallFloat64 #() false)								with: #returnString -&gt; #(#SFoo #ByteString #() false)								with: #return: -&gt; #(#SFoo #Stack #(#Stack) false))						with: #()).	typeInfo joinWith: otherTypeInfo.	self assert: (typeInfo types at: #SFoo) methodTypes size equals: 5.	self		assert: (typeInfo types at: #SFoo) classMethodTypes size		equals: 1.	methodInfo := typeInfo methodType: #return: from: #SFoo.	self assert: methodInfo receiver type equals: #SFoo.	self		assertCollection: #(#OrderedCollection #Stack)		hasSameElements: methodInfo returnType types.	self		assertCollection: #(#OrderedCollection #Stack)		hasSameElements: (methodInfo argTypes flatCollect: [ :argType | argType types ]).	self		assert: (typeInfo methodType: #returnFloat from: #SFoo) returnType type		equals: #SmallFloat64.	self		assert: (typeInfo methodType: #returnString from: #SFoo) returnType type		equals: #ByteString.	self		assert: (typeInfo methodType: #score from: #SFoo) returnType type		equals: #SmallInteger.	methodInfo := typeInfo methodType: #score: from: #SFoo.	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #SFoo.	self		assertCollection: (methodInfo argTypes flatCollect: [ :argType | argType types ])		hasSameElements: #(#SmallInteger).	self		assert: (typeInfo classMethodType: #score: from: #SFoo) returnType type		equals: #SFoo</body><body package="SSG-Tests-Info" selector="testMessagesFrom">testMessagesFrom	| typeInfo |	typeInfo := STypeInfo new		type:			#SFoo				-&gt;					(Array						with:							(Array								with: #returnFloat -&gt; #(#SFoo #SmallFloat64 #() false)								with: #returnString -&gt; #(#SFoo #ByteString #() false)								with: #score -&gt; #(#SFoo #SmallInteger #() true))						with: (Array with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false))).	self		assertCollection: ((typeInfo messagesFrom: #SFoo) collect: #selector)		hasSameElements: #(#returnFloat #returnString)	"self assertCollection: ((typeInfo accessMessagesFrom: #SFoo) collect: #selector) hasSameElements: #(#score)."</body><body package="SSG-Tests-Info" selector="testNoneAbstractClasses">testNoneAbstractClasses	| typeInfo |	typeInfo := STypeInfo new		type:			(self fullSymbolOf: #SSPerson)				-&gt;					(Array						with:							(Array								with:									#name										-&gt;											(Array												with: (self fullSymbolOf: #SSPerson)												with: (self fullSymbolOf: #ByteString)												with: #()												with: true)								with:									#id										-&gt;											(Array												with: (self fullSymbolOf: #SSPerson)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: false))						with:							(Array								with:									#name:with:										-&gt;											(Array												with: (self fullSymbolOf: #SSPerson)												with: (self fullSymbolOf: #SSPerson)												with:													(Array														with: (self fullSymbolOf: #ByteString)														with: (self fullSymbolOf: #SmallInteger))												with: false)));		type:			(self fullSymbolOf: #SAbstractClass)				-&gt;					(Array						with:							(Array								with:									#id										-&gt;											(Array												with: (self fullSymbolOf: #SAbstractClass)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: true))						with: #());		type:			(self fullSymbolOf: #SStudent)				-&gt;					(Array						with:							(Array								with:									#scoreStudent										-&gt;											(Array												with: (self fullSymbolOf: #SStudent)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: true))						with: #());		scalar: (self fullSymbolOf: #SmallInteger) with: #(50 1);		scalar: (self fullSymbolOf: #ByteString) with: #('Ann').	self		assertCollection: (typeInfo noneAbstractClasses collect: #name) asArray		hasSameElements: (Array with: #SStudent)</body><body package="SSG-Tests-Info" selector="testScalar">testScalar	| typeInfo |	typeInfo := STypeInfo new		scalar: #SmallInteger with: #(1 5 6);		scalar: #ByteString with: #('hello' 'world');		scalar: #Dictionary			with:			(Array				with: Dictionary new				with:					(Dictionary new						at: 2 put: 3;						yourself)).	self		assertCollection: typeInfo scalars keys		hasSameElements: #(#Dictionary #ByteString #SmallInteger).	self		assertCollection: (typeInfo scalars at: #ByteString)		hasSameElements: #('hello' 'world').	self		assertCollection: (typeInfo scalars at: #SmallInteger)		hasSameElements: #(1 5 6).	self		assertCollection: ((typeInfo scalars at: #Dictionary) collect: #className)		hasSameElements: #('Dictionary' 'Dictionary')</body><body package="SSG-Tests-Info" selector="testType">testType	| typeInfo methodInfo |	typeInfo := STypeInfo new		type:			#SFoo				-&gt;					(Array						with:							(Array								with: #returnFloat -&gt; #(#SFoo #SmallFloat64 #() false)								with: #returnString -&gt; #(#SFoo #ByteString #() false)								with: #return: -&gt; #(#SFoo #OrderedCollection #(#OrderedCollection) false)								with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false)								with: #score -&gt; #(#SFoo #SmallInteger #() true))						with: (Array with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false))).	self assert: (typeInfo types at: #SFoo) methodTypes size equals: 5.	self		assert: (typeInfo types at: #SFoo) classMethodTypes size		equals: 1.	methodInfo := typeInfo methodType: #return: from: #SFoo.	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #OrderedCollection.	self		assertCollection: methodInfo allArgTypes		hasSameElements: #(#OrderedCollection).	self		assert: (typeInfo methodType: #returnFloat from: #SFoo) returnType type		equals: #SmallFloat64.	self		assert: (typeInfo methodType: #returnString from: #SFoo) returnType type		equals: #ByteString.	self		assert: (typeInfo methodType: #score from: #SFoo) returnType type		equals: #SmallInteger.	methodInfo := typeInfo methodType: #score: from: #SFoo.	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #SFoo.	self		assertCollection: methodInfo allArgTypes		hasSameElements: #(#SmallInteger).	self		assert: (typeInfo classMethodType: #score: from: #SFoo) returnType type		equals: #SFoo</body></methods><methods><class-id>SmallSuiteGenerator.SConfigurationTest</class-id> <category>as yet unclassified</category><body package="SSG-Tests-Core" selector="testFileLogger">testFileLogger	self shouldnt: (SPlatform fileLogger: 'STestLog.log') raise: Error</body></methods><methods><class-id>SmallSuiteGenerator.SConfigurationTest</class-id> <category>running</category><body package="SSG-Tests-Core" selector="tearDown">tearDown	SPlatform clearLog.	SPlatform cleanAllLogs</body></methods><methods><class-id>SmallSuiteGenerator.SMultiFitnessFunctionTest</class-id> <category>tests</category><body package="SSG-Tests-GA" selector="testComputeFitnessOnFactoryMessage">testComputeFitnessOnFactoryMessage	"| aTestCase res fitness |	aTestCase := SSTestCase with: utility typeInfoSFoo1.	aTestCase addFactoryMessage.	fitness := SStatementCoverage new.	res := (function computeFitness: aTestCase) values.	self assertCollection: res hasSameElements: #(33.33 28.57)"	</body><body package="SSG-Tests-GA" selector="testComputeFitnessOnFieldAccessMessage">testComputeFitnessOnFieldAccessMessage	"| aTestCase res |	aTestCase := SSTestCase with: utility typeInfoSFoo1.	aTestCase addFieldAccessMessage: #score from: #SFoo.	""fitness := SStatementCoverage new.""	res := (function computeFitness: aTestCase) values.	self assertCollection: res hasSameElements: #(44.44 35.71)"	</body><body package="SSG-Tests-GA" selector="testComputeFitnessOnLiteral">testComputeFitnessOnLiteral	"| aTestCase res |	aTestCase := SSTestCase with: utility typeInfoSFoo1.	aTestCase addLiteral.	""fitness := SStatementCoverage new.""	res := (function computeFitness: aTestCase) values.	self assertCollection: res hasSameElements: #(0 0)"	</body><body package="SSG-Tests-GA" selector="testComputeFitnessOnMessage">testComputeFitnessOnMessage	"| aTestCase res |	aTestCase := SSTestCase with: utility typeInfoSFoo1.	aTestCase addMessage: #returnFloat from: #SFoo.	""fitness := SStatementCoverage new.""	res := (function computeFitness: aTestCase) values.	self assertCollection: res hasSameElements: #(44.44 42.86)"	</body><body package="SSG-Tests-GA" selector="testIsBetterThan">testIsBetterThan	"| testCase1 testCase2 functions |	testCase1 := utility testSuiteSStudentManual second.	testCase2 := utility testSuiteSStudentManual second.	""testCase2 addFieldAccessMessage: #scoreStudent from: #SStudent.	functions := SStatementCoverage new, SMethodCoverage new.""	testCase1 computeFitness: functions first.	testCase1 computeFitness: functions second.	testCase2 computeFitness: functions first.	testCase2 computeFitness: functions second	""self deny: (function is: testCase1 betterThan: testCase2).	self assert: (function is: testCase2 betterThan: testCase1)"""	</body></methods><methods><class-id>SmallSuiteGenerator.SMultiFitnessFunctionTest</class-id> <category>running</category><body package="SSG-Tests-GA" selector="setUp">setUp	super setUp	"function := SMultiFitnessFunction.	function clean.	fitnessFunctions := Array		with: SMethodCoverage		with: SStatementCoverage.	utility := SUtilityTypeInfo new"</body><body package="SSG-Tests-GA" selector="tearDown">tearDown	"fitnessFunctions do: #clean.	function		clean;		reset."	super tearDown</body></methods><methods><class-id>SmallSuiteGenerator.SExpressionTest</class-id> <category>running</category><body package="SSG-Tests-AST" selector="setUp">setUp	super setUp.	utility := SUtilityTypeInfo new.	SPlatform resetRandomGenerator</body><body package="SSG-Tests-AST" selector="tearDown">tearDown	SPlatform resetRandomGenerator</body></methods><methods><class-id>SmallSuiteGenerator.SExpressionTest</class-id> <category>parsing</category><body package="SSG-Tests-AST" selector="parse:">parse: anExpresion	| sequence |	sequence := SPlatform rbParserClass parseExpression: anExpresion.	^ sequence statements		collect: [ :assig | 			SAssignment new				variable: (SVariable name: assig variable name asString);				value: (self parseMessage: assig value);				yourself ]</body><body package="SSG-Tests-AST" selector="parseMessage:">parseMessage: aRBMessageNode	aRBMessageNode isLiteralNode		ifTrue: [ ^ SLiteral value: aRBMessageNode value ].	^ SMessage new		receiver: (SVariable name: aRBMessageNode receiver name);		selector: aRBMessageNode selector;		args:			(aRBMessageNode arguments				collect: [ :arg | self parseVariableOrValue: arg ]) yourself</body><body package="SSG-Tests-AST" selector="parseVariableOrValue:">parseVariableOrValue: aRBVariableOrLiteral	^ aRBVariableOrLiteral isVariable		ifTrue: [ SVariable name: aRBVariableOrLiteral name ]		ifFalse: [ SLiteral value: aRBVariableOrLiteral value ]</body></methods><methods><class-id>SmallSuiteGenerator.SmallTypeCollectorTest</class-id> <category>tests</category><body package="SSG-Tests-SmallType" selector="testAnInteger">testAnInteger	self assert: #Integer equals: (self typeFor: 'anInteger')</body><body package="SSG-Tests-SmallType" selector="testInteger">testInteger	self assert: #Integer equals: (self typeFor: 'integer')</body><body package="SSG-Tests-SmallType" selector="typeFor:">typeFor: aName	^ SmallTypeCollector new typeFor: aName</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngineTest</class-id> <category>running</category><body package="SSG-Tests-GA" selector="setUp">setUp	super setUp.	engine := SGAEngine new.	profiler := self aSLProfilerCoverage new.	utility := SUtilityTypeInfo new</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngineTest</class-id> <category>tests</category><body package="SSG-Tests-GA" selector="testRunOnClassSStudentManual">testRunOnClassSStudentManual	"| testSuite block utility |	utility := SUtilityTypeInfo new.	block := [ SStudent new		scoreStudent: 34;		scoreStudent;		idStudent ].	testSuite := utility testSuiteSStudentManual.	engine		populationSize: 3;		numberOfStatements: 10;		blockToExecute: block;		endForMaxNumberOfGeneration: 10;		typeInfo: utility typeInfosSStudent first;		initializePopulationWith: testSuite;		fitness: (SStatementCoverage coverageOf: block onClass: SStudent).	engine run"	</body><body package="SSG-Tests-GA" selector="testRunOnPackagesMatchingSFoo">testRunOnPackagesMatchingSFoo	| first last functionFitness targetPackageRegex typeInfo |	targetPackageRegex := 'SmallSuiteGenerator-Scenario'.	typeInfo := utility typeInfoSFooOnPackage1.	self profilerOf: targetPackageRegex.	functionFitness := SMethodCoverage new profiler: profiler.	functionFitness		tagetPackagesRegex: targetPackageRegex;		targetClass: (self fullSymbolOf: #SFoo);		typeInfo: typeInfo.	engine		targetPackageRegex: targetPackageRegex;		typeInfo: typeInfo;		" STON fromString: utility typeInfoStringSFoo3."			targetClassName: (self fullSymbolOf: #SFoo);		fitness: functionFitness;		populationSize: 5;		numberOfGenerations: 5;		populationSize: 10;		run.	first := engine logs first fittestTestCase fitness		at: functionFitness functionName.	last := engine logs last fittestTestCase fitness		at: functionFitness functionName.	self assert: first &gt; 0.	self assert: first &lt;= last</body><body package="SSG-Tests-GA" selector="testRunOnPackagesSSTeacherUsingMethodCoverage">testRunOnPackagesSSTeacherUsingMethodCoverage	| first last functionFitness targetPackageRegex typeInfo |	targetPackageRegex := 'SmallSuiteGenerator-Scenario'.	typeInfo := utility typeInfoSSTeacherOnPackage1.	self profilerOf: targetPackageRegex.	functionFitness := SMethodCoverage new profiler: profiler.	functionFitness		tagetPackagesRegex: targetPackageRegex;		targetClass: (self fullSymbolOf: #SSTeacher);		typeInfo: typeInfo.	engine		targetPackageRegex: targetPackageRegex;		typeInfo: typeInfo;		"STON fromString: utility typeInfoStringSSTeacher1."			fitness: functionFitness;		targetClassName: (self fullSymbolOf: #SSTeacher);		populationSize: 10;		numberOfGenerations: 5;		run.	first := engine logs first fittestTestCase fitness		at: functionFitness functionName.	last := engine logs last fittestTestCase fitness		at: functionFitness functionName.	self assert: first &gt; 0.	"20 = (1/5) * 100"	self assert: first &lt;= last	"80 = (4/5) * 100"</body><body package="SSG-Tests-GA" selector="testRunOnPackagesSSTeacherUsingStatementCoverage">testRunOnPackagesSSTeacherUsingStatementCoverage	| first last functionFitness targetPackageRegex typeInfo |	targetPackageRegex := 'SmallSuiteGenerator-Scenario'.	typeInfo := utility typeInfoSSTeacherOnPackage1.	self profilerOf: targetPackageRegex.	functionFitness := SStatementCoverage new profiler: profiler.	functionFitness tagetPackagesRegex: targetPackageRegex.	functionFitness targetClass: (self fullSymbolOf: #SSTeacher).	functionFitness typeInfo: typeInfo.	engine		targetPackageRegex: targetPackageRegex;		typeInfo: typeInfo;		fitness: functionFitness;		targetClassName: (self fullSymbolOf: #SSTeacher);		populationSize: 10;		numberOfGenerations: 5;		run.	first := engine logs first fittestTestCase fitness		at: functionFitness functionName.	last := engine logs last fittestTestCase fitness		at: functionFitness functionName.	self assert: first &gt; 0.	"37.5 = (3/8) * 100"	self assert: first &lt;= last	"87.5 = (7/8) * 100"</body></methods><methods><class-id>SmallSuiteGenerator.SLiteralTest</class-id> <category>tests</category><body package="SSG-Tests-AST" selector="testCopy">testCopy	| literal copy |	literal := (SLiteral value: 'hello') returnType: #ByteString.	self assert: literal printString equals: '''hello'''.	copy := literal copy.	copy value: 'world'.	self assert: copy printString equals: '''world'''</body><body package="SSG-Tests-AST" selector="testEqual">testEqual	| literal |	literal := SLiteral value: 1.	self assert: (SLiteral value: 1) equals: literal.	literal value: 3.	self deny: (SLiteral value: -3) equals: literal.	literal value: #().	self assert: (SLiteral value: #()) equals: literal.	literal value: SStudent new.	self assert: (SLiteral value: SStudent new) equals: literal</body><body package="SSG-Tests-AST" selector="testInsertAsParameterUsing">testInsertAsParameterUsing	| testCase expression insertedExpression |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addLiteral: (self fullSymbolOf: #ByteString).	expression := testCase addLiteral: (self fullSymbolOf: #ByteString).	testCase addFactoryMessage: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := ''hello''.'				with: '_var1 := ''hello''.'				with: '_var2 := 7.3.'				with:					'_var3 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var2.').	testCase addMessage: #return: from: (self fullSymbolOf: #SFoo).	insertedExpression := expression		insertAsParameter: expression		using: testCase.	self		assert: insertedExpression printString		equals: '_var5 := _var3 return: _var1.'</body><body package="SSG-Tests-AST" selector="testInsertParameterOn">testInsertParameterOn	| testCase expression insertedExpression |	testCase := SSTestCase with: utility typeInfoSFoo4.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addLiteral: (self fullSymbolOf: #SStudent);		addMessage: #return: from: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := ' , SStudent new storeString , '.'				with: '_var1 := ' , (self fullNameOfClass: 'SFoo') asString , ' new.'				with: '_var2 := _var1 return: _var0.').	expression := testCase addLiteral: (self fullSymbolOf: #SStudent).	self		should: [ insertedExpression := expression				insertAsParameter: expression				using: testCase ]		raise: SError.	testCase addMessage: #return: from: (self fullSymbolOf: #SFoo).	self		shouldnt: [ insertedExpression := expression				insertAsParameter: expression				using: testCase ]		raise: SError.	self		assert: insertedExpression printString		equals: '_var5 := _var1 return: _var3.'</body><body package="SSG-Tests-AST" selector="testReferenceTo">testReferenceTo	| literal |	literal := SLiteral value: 1.	self assert: ((SLiteral new value: 1) referenceTo: #SmallInteger).	literal value: SStudent new.	self		assert: ((SLiteral new value: SStudent new) referenceTo: #SStudent)</body></methods><methods><class-id>SmallSuiteGenerator.SAssertionTest</class-id> <category>tests</category><body package="SSG-Tests-AST" selector="testAssertComparison">testAssertComparison	| test |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var0 := 1.			 _var1 := 1.			 _var2 := Point x: _var0 y: _var1.			 _var3 := Point x: _var1 y: _var0.').	test generateAssertions: (Array with: SComparisonAssertion).	self assert: test assertions size equals: 2.	self		assert: test assertions first printString		equals: 'self assert: _var0 equals: _var1.'.	self		assert: test assertions second printString		equals: 'self assert: _var2 equals: _var3.'</body><body package="SSG-Tests-AST" selector="testAssertComparison2">testAssertComparison2	| test |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var0 := 1.			 _var1 := 2.			 _var2 := Point x: _var0 y: _var1.			 _var3 := Point x: _var1 y: _var0.').	test generateAssertions: (Array with: SComparisonAssertion).	self assert: test assertions size equals: 2.	self		assert: test assertions first printString		equals: 'self deny: _var0 equals: _var1.'.	self		assert: test assertions second printString		equals: 'self deny: _var2 equals: _var3.'</body><body package="SSG-Tests-AST" selector="testAssertInspector">testAssertInspector	| test |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var0 := 1.			 _var1 := 2.			 _var3 := Point x: _var1 y: _var0.').	test generateAssertions: (Array with: SInspectorAssertion).	self assert: test assertions size equals: 2.	self		assertCollection: (test assertions collect: #printString)		hasSameElements: #('self assert: _var3 x equals: 2.' 'self assert: _var3 y equals: 1.')</body><body package="SSG-Tests-AST" selector="testAssertPrimitive">testAssertPrimitive	| test |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var0 := 1.			 _var1 := 2.			 _var3 := Point x: _var1 y: _var0.').	test generateAssertions: (Array with: SPrimitiveAssertion).	self assert: test assertions size equals: 2.	self		assert: test assertions first printString		equals: 'self assert: _var0 equals: 1.'.	self		assert: test assertions second printString		equals: 'self assert: _var1 equals: 2.'</body><body package="SSG-Tests-AST" selector="testExecutionContext">testExecutionContext	| test context |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var0 := 1.			 _var1 := 2.			 _var2 := Point x: _var0 y: _var1.').	context := test analyze.	self assert: (context at: '_var0') equals: 1.	self assert: (context at: '_var1') equals: 2.	self assert: (context at: '_var2') equals: 1 @ 2</body></methods><methods><class-id>SmallSuiteGenerator.SFactoryMessageTest</class-id> <category>tests</category><body package="SSG-Tests-AST" selector="testCopy">testCopy	| expression copy |	expression := SFactoryMessage new		receiver: (SVariable name: #SFoo);		selector: #score:;		args: (Array with: (SVariable new id: 0));		yourself.	self assert: expression printString equals: 'SFoo score: _var0'.	copy := expression copy.	self assert: copy printString equals: expression printString.	copy value args first id: 1.	self assert: copy printString equals: 'SFoo score: _var1'.	copy value receiver varName: #SStudent.	self assert: copy printString equals: 'SStudent score: _var1'.	copy value selector: #name:.	self assert: copy printString equals: 'SStudent name: _var1'.	self assert: expression printString equals: 'SFoo score: _var0'</body><body package="SSG-Tests-AST" selector="testInsertAsParameterUsing">testInsertAsParameterUsing	| testCase expression insertedExpression |	testCase := SSTestCase with: utility typeInfoSFoo2.	testCase addTargetClassName: (self fullSymbolOf: #SFoo).	expression := testCase addFactoryMessage: (self fullSymbolOf: #SFoo).	testCase addMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := ' , (self fullNameOfClass: 'SFoo') asString , ' new.'				with: '_var1 := ' , (self fullNameOfClass: 'SFoo') asString , ' new.'				with: '_var2 := _var0 return: _var0.').	insertedExpression := expression		insertAsParameter: expression		using: testCase.	self		assert:			(#('_var2 := _var0 return: _var0.')				includes: insertedExpression printString)</body><body package="SSG-Tests-AST" selector="testInsertMethodMessageUsing">testInsertMethodMessageUsing	| testCase expression |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo).	expression := testCase addFactoryMessage: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.').	self		should: [ expression insertMethodMessage: expression using: testCase ]		raise: SError</body><body package="SSG-Tests-AST" selector="testInsertRandomMessageUsing">testInsertRandomMessageUsing	| testCase factoryMessage |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo).	factoryMessage := testCase		addFactoryMessage: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.').	factoryMessage insertRandomMessage: factoryMessage using: testCase.	self		assertCollection: (testCase statements collect: #printString)		includesAll:			(Array				with: '_var0 := 7.3.'				with:					'_var2 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.')</body></methods><methods><class-id>SmallSuiteGenerator.SFieldAccessMessageTest</class-id> <category>tests</category><body package="SSG-Tests-AST" selector="testCopy">testCopy	| expression copy |	expression := SFieldAccessMessage new		receiver:			(SVariable new				id: 0;				returnType: #SStack);		selector: #firstLinkStack.	self assert: expression printString equals: '_var0 firstLinkStack'.	copy := expression copy.	copy value receiver varName: '_sstack'.	copy value receiver id: 4.	self assert: copy printString equals: '_sstack4 firstLinkStack'.	copy value selector: #lastLinkStack.	self assert: copy printString equals: '_sstack4 lastLinkStack'.	self assert: expression printString equals: '_var0 firstLinkStack'</body><body package="SSG-Tests-AST" selector="testInsertAsParameterUsing">testInsertAsParameterUsing	| testCase expression insertedExpression |	testCase := (SSTestCase with: utility typeInfoSStack4)		addTargetClassName: (self fullSymbolOf: #SStack).	testCase		addFactoryMessage: (self fullSymbolOf: #SStack)		ofSelector: #newStackWith:.	expression := testCase		addFieldAccessMessage: #firstLinkStack		from: (self fullSymbolOf: #SStack).	testCase addLiteral: (self fullSymbolOf: #SmallInteger).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := #(1 4 5 ).'				with:					'_var1 := ' , (self fullNameOfClass: 'SStack') asString						, ' newStackWith: _var0.'				with: '_var2 := _var1 firstLinkStack.'				with: '_var3 := 5.').	testCase addMessage: #push: from: (self fullSymbolOf: #SStack).	insertedExpression := expression		insertAsParameter: expression		using: testCase.	self		assert: insertedExpression printString		equals: '_var5 := _var1 push: _var2.'</body><body package="SSG-Tests-AST" selector="testInsertRandomMessageUsing">testInsertRandomMessageUsing	| testCase aExpression |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addFactoryMessage: (self fullSymbolOf: #SFoo).	aExpression := testCase addFieldAccessMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.'				with: '_var2 := _var1 score.').	aExpression insertRandomMessage: aExpression using: testCase.	self		assertCollection: (testCase statements collect: #printString)		includesAll:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.'				with: '_var2 := _var1 score.'				with: '_var3 := _var1 score.')</body></methods><methods><class-id>SmallSuiteGenerator.SEventTest</class-id> <category>tests</category><body package="SSG-Scenario" selector="testDiscount">testDiscount	| event |	event := SEvent new.	event price: 80.	event discount: 20.	self assert: event discount equals: 20.	self assert: event price equals: 64</body><body package="SSG-Scenario" selector="testDiscountWithZeroPrice">testDiscountWithZeroPrice	| event |	event := SEvent new.	event discount: 20.	self assert: event discount equals: 0.	self assert: event price equals: 0</body><body package="SSG-Scenario" selector="testPrice">testPrice	| event |	event := SEvent new.	event price: 80.	self assert: event price equals: 80</body></methods><methods><class-id>SmallSuiteGenerator.SRandom</class-id> <category>enumerating</category><body package="SSG-Core" selector="collectAtRandom:">collectAtRandom: collection	| indexes |	indexes := self shuffleCollection: collection size.	^ indexes		inject: OrderedCollection new		into: [ :result :index | 			result add: (collection at: index).			result ]</body><body package="SSG-Core" selector="selectAtRandom:">selectAtRandom: collection	^ collection at: (self nextInt: collection size)</body><body package="SSG-Core" selector="selectIndexAtRandom:">selectIndexAtRandom: collection	^ self nextInt: collection size</body><body package="SSG-Core" selector="shuffleCollection:">shuffleCollection: stop	| numbers |	numbers := (1 to: stop) asArray.	stop to: 2 by: -1 do: [ :i | numbers swap: i with: (self nextInt: i) ].	^ numbers</body></methods><methods><class-id>SmallSuiteGenerator.SRandom class</class-id> <category>instance creation</category><body package="SSG-Core" selector="seed:">seed: anObject	^ self new seed: anObject</body></methods><methods><class-id>SmallSuiteGenerator.SCoverageTest</class-id> <category>running</category><body package="SSG-Tests-GA" selector="fitnessClass">fitnessClass	^ self subclassResponsibility</body><body package="SSG-Tests-GA" selector="installOn:">installOn: aPackageName	fitness tagetPackagesRegex: aPackageName.	profiler := self aSLProfilerCoverage		profilerForPackagesMatching: aPackageName.	fitness profiler: profiler.	profiler uninstall.	profiler beforeProfiling</body><body package="SSG-Tests-GA" selector="setUp">setUp	utility := SUtilityTypeInfo new.	fitness := self fitnessClass new.	profiler := self aSLProfilerCoverage new</body><body package="SSG-Tests-GA" selector="tearDown">tearDown	</body><body package="SSG-Tests-GA" selector="uninstall">uninstall	profiler uninstall</body></methods><methods><class-id>SmallSuiteGenerator.SCoverageTest</class-id> <category>tests</category><body package="SSG-Tests-GA" selector="fitnessOf:">fitnessOf: aTestCase	^ aTestCase fitness at: fitness functionName</body><body package="SSG-Tests-GA" selector="testCase:withNumStatements:andTargetClassName:">testCase: typeInfo withNumStatements: aNumber andTargetClassName: symbol	^ (SSTestCase with: typeInfo)		numMaxStatements: aNumber;		addTargetClassName: symbol;		generateStatements</body></methods><methods><class-id>SmallSuiteGenerator.SStatementCoverageTest</class-id> <category>tests</category><body package="SSG-Tests-GA" selector="fitnessClass">fitnessClass	^ SStatementCoverage</body><body package="SSG-Tests-GA" selector="testCoverageClassSEvent">testCoverageClassSEvent	| testCase valueFitness |	testCase := SSTestCase with: utility typeInfoSEvent2.	testCase		addTargetClassName: (self fullSymbolOf: #SEvent);		addFactoryMessage: (self fullSymbolOf: #SEvent);		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: (self fullSymbolOf: #SEvent).	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 75.0 ])	"75.0 = (6/8) * 100 round: 2"</body><body package="SSG-Tests-GA" selector="testCoverageClassSFoo">testCoverageClassSFoo	| testCase valueFitness |	testCase := SSTestCase with: utility typeInfoSFoo4.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addFactoryMessage: (self fullSymbolOf: #SFoo);		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: (self fullSymbolOf: #SFoo).	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 71.43 ])	"71.43 = (10/14) * 100 round: 2"</body><body package="SSG-Tests-GA" selector="testCoverageOnClassSStack">testCoverageOnClassSStack	| testCase valueFitness |	testCase := self		testCase: utility typeInfoSStack3		withNumStatements: 20		andTargetClassName: (self fullSymbolOf: #SStack).	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: (self fullSymbolOf: #SStack).	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 73.68 ])	"73.68 = (14/19) * 100 round: 2"</body><body package="SSG-Tests-GA" selector="testCoverageOnClassSSTeacher">testCoverageOnClassSSTeacher	| testCase valueFitness |	testCase := self		testCase: utility typeInfoSFoo4		withNumStatements: 20		andTargetClassName: (self fullSymbolOf: #SFoo).	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: (self fullSymbolOf: #SFoo).	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 75.0 ])	"75.0 = (6/8) * 100 round: 2"</body><body package="SSG-Tests-GA" selector="testCoverageOnClassSStudent">testCoverageOnClassSStudent	| testCase valueFitness |	testCase := self		testCase: utility typeInfosSStudent first		withNumStatements: 20		andTargetClassName: (self fullSymbolOf: #SStudent).	self installOn: 'SmallSuiteGenerator-Scenario2'.	fitness targetClass: (self fullSymbolOf: #SStudent).	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 75.0 ])	"75.0 = (6/8) * 100 round: 2"</body><body package="SSG-Tests-GA" selector="testCoverageOnPackagesSEvent">testCoverageOnPackagesSEvent	| testCase valueFitness |	testCase := SSTestCase with: utility typeInfoSEventOnPackage1.	" (STON fromString: utility typeInfoStringSEvent)."	testCase		addTargetClassName: (self fullSymbolOf: #SEvent);		addFactoryMessage: (self fullSymbolOf: #SEvent);		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: (self fullSymbolOf: #SEvent).	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 75.0 ])</body><body package="SSG-Tests-GA" selector="testCoverageOnPackagesSFoo">testCoverageOnPackagesSFoo	| testCase valueFitness |	testCase := SSTestCase with: utility typeInfoSFooOnPackage2.	"(STON fromString: utility typeInfoStringSFoo2)."	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addFactoryMessage: (self fullSymbolOf: #SFoo);		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: (self fullSymbolOf: #SFoo).	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 71.43 ])	"71.43 = (10/14) * 100 round: 2"</body><body package="SSG-Tests-GA" selector="testCoverageOnPackagesSStack">testCoverageOnPackagesSStack	| testCase valueFitness |	testCase := SSTestCase with: utility typeInfoSStackOnPackage1.	"(STON fromString: utility typeInfoStringSStack2)"	testCase		addTargetClassName: (self fullSymbolOf: #SStack);		addFactoryMessage: (self fullSymbolOf: #SStack);		generateStatements: 19.	testCase inspect.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: (self fullSymbolOf: #SStack).	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 73.68 ])	"73.68 = (14/19) * 100 round: 2"</body><body package="SSG-Tests-GA" selector="testCoverageOnPackagesSSTeacher">testCoverageOnPackagesSSTeacher	| testCase |	testCase := SSTestCase with: utility typeInfoSSTeacherOnPackage2.	"(STON fromString: utility typeInfoStringSSTeacher2)."	testCase		addTargetClassName: (self fullSymbolOf: #SSTeacher);		addFactoryMessage: (self fullSymbolOf: #SSTeacher);		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: (self fullSymbolOf: #SSTeacher).	fitness compute: (Array with: testCase).	self uninstall.	self assert: (self fitnessOf: testCase) &lt;= 75.0</body><body package="SSG-Tests-GA" selector="testCoverageOnPackagesSStudent">testCoverageOnPackagesSStudent	| testCase valueFitness |	testCase := SSTestCase with: utility typeInfoSStudentOnPackage1.	"(STON fromString: utility typeInfoStringSStudent1)."	testCase		addTargetClassName: (self fullSymbolOf: #SStudent);		addFactoryMessage: (self fullSymbolOf: #SStudent);		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario2'.	fitness targetClass: (self fullSymbolOf: #SStudent).	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 75.0 ])</body></methods><methods><class-id>SmallSuiteGenerator.SRandomTest</class-id> <category>running</category><body package="SSG-Tests-Core" selector="setUp">setUp	super setUp.	utility := SUtilityTypeInfo new</body></methods><methods><class-id>SmallSuiteGenerator.SRandomTest</class-id> <category>tests</category><body package="SSG-Tests-Core" selector="testCollectAtRandom">testCollectAtRandom	| generator array |	generator := SRandom seed: 100.	array := (1 to: 10) asArray.	self		assertCollection: (generator collectAtRandom: array)		hasSameElements: array</body><body package="SSG-Tests-Core" selector="testCollectAtRandomOnStatements">testCollectAtRandomOnStatements	| generator testCase |	generator := SRandom seed: 100.	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addFactoryMessage;		addMessage: #returnNum from: (self fullSymbolOf: #SFoo);		addFieldAccessMessage: #score from: (self fullSymbolOf: #SFoo).	self		assertCollection: testCase printStatements		hasSameElements:			((generator collectAtRandom: testCase statements)				collect: #printString)</body><body package="SSG-Tests-Core" selector="testSelectAtRandom">testSelectAtRandom	| generator array |	generator := SRandom seed: 100.	array := (1 to: 10) asArray.	self assert: ((generator selectAtRandom: array) between: 1 and: 10)</body><body package="SSG-Tests-Core" selector="testSelectAtRandomOnStatements">testSelectAtRandomOnStatements	| generator testCase stringStatements statements |	generator := SRandom seed: 100.	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addFactoryMessage;		addMessage: #returnNum from: (self fullSymbolOf: #SFoo);		addFieldAccessMessage: #score from: (self fullSymbolOf: #SFoo).	stringStatements := testCase printStatements.	statements := testCase statements.	100		timesRepeat: [ self				assert:					(stringStatements						includes: (generator selectAtRandom: statements) printString) ]</body><body package="SSG-Tests-Core" selector="testShuffleCollection">testShuffleCollection	| generator array |	generator := SRandom seed: 100.	array := (1 to: 10) asArray.	self		assertCollection: (generator shuffleCollection: 10)		hasSameElements: array</body></methods><methods><class-id>SmallSuiteGenerator.SMutatorTestCaseTest</class-id> <category>tests</category><body package="SSG-Tests-Core" selector="testRemoveArgsMethod">testRemoveArgsMethod	| testCase expression numExprsBefore numExprsAfter |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addMessage: #return: from: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.'				with: '_var2 := ''hello''.'				with: '_var3 := _var1 return: _var2.').	numExprsBefore := testCase length.	expression := testCase statementOfVarName: '_var2'.	testCase removeExpression: expression.	numExprsAfter := testCase length.	self assert: numExprsAfter equals: numExprsBefore</body><body package="SSG-Tests-Core" selector="testRemoveExpression">testRemoveExpression	| testCase expression |	testCase := SSTestCase with: utility typeInfoSFoo1.	expression := testCase addLiteral.	testCase removeExpression: expression.	self assert: testCase statements isEmpty</body><body package="SSG-Tests-Core" selector="testRemoveExpressionWithoutRepairing">testRemoveExpressionWithoutRepairing	| testCase expression |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addMessage: #return: from: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.'				with: '_var2 := ''hello''.'				with: '_var3 := _var1 return: _var2.').	expression := testCase statementOfVarName: '_var2'.	testCase removeExpressionWithoutRepairing: expression.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.')</body><body package="SSG-Tests-Core" selector="testRemoveInEmptyTestCase">testRemoveInEmptyTestCase	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	self should: [ testCase removeExpression: nil ] raise: SError</body><body package="SSG-Tests-Core" selector="testRepair">testRepair	| testCase expression |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addMessage: #return: from: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.'				with: '_var2 := ''hello''.'				with: '_var3 := _var1 return: _var2.').	expression := testCase statementOfVarName: '_var2'.	self should: [ testCase repair: expression ] raise: SError.	testCase removeFromStatements: expression.	self assert: (testCase repair: expression) isEmpty.	expression := testCase statementOfVarName: '_var3'.	self		assertCollection: (expression value args collect: #printString)		hasSameElements: #('_var4').	self		assert:			(((testCase subStatementsFrom: 1 toPrevIndexOf: expression)				collect: #printString)				includesAny: #('_var4 := ''hello''.' '_var4 := _var1 returnString.'))</body></methods><methods><class-id>SmallSuiteGenerator.SMutatorTestCaseTest</class-id> <category>running</category><body package="SSG-Tests-Core" selector="setUp">setUp	utility := SUtilityTypeInfo new</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCaseTest</class-id> <category>tests</category><body package="SSG-Tests-Core" selector="setUp">setUp	utility := SUtilityTypeInfo new.	SPlatform resetRandomGenerator.	SPlatform fileLogger: 'STestCaseTestLogger.log'</body><body package="SSG-Tests-Core" selector="testCopy">testCopy	| testCase typeInfo otherTestCase |	typeInfo := self typeInfo.	testCase := SSTestCase with: typeInfo.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addMessage: #returnNum from: (self fullSymbolOf: #SFoo);		addFieldAccessMessage: #score from: (self fullSymbolOf: #SFoo);		addLiteral: (self fullSymbolOf: #SmallInteger).	otherTestCase := testCase copy.	self assert: testCase length equals: 5.	self assert: testCase equals: otherTestCase.	self		assertCollection: testCase targetClassesNames		hasSameElements: (Array with: (self fullSymbolOf: #SFoo)).	testCase addLiteral: (self fullSymbolOf: #ByteString).	otherTestCase		addMessage: #returnFloat		from: (self fullSymbolOf: #SFoo).	otherTestCase addMessage: #return: from: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.'				with: '_var2 := _var1 returnNum.'				with: '_var3 := _var1 score.'				with: '_var4 := 5.'				with: '_var5 := ''hello''.').	self		assertCollection: (otherTestCase statements collect: #printString)		hasSameElements:			(OrderedCollection new				add: '_var0 := 7.3.';				add:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.';				add: '_var2 := _var1 returnNum.';				add: '_var3 := _var1 score.';				add: '_var4 := 5.';				add: '_var5 := _var1 returnFloat.';				add: '_var6 := ''hello''.';				add: '_var7 := _var1 return: _var6.';				yourself)</body><body package="SSG-Tests-Core" selector="testFieldAccessMessage">testFieldAccessMessage	| testCase |	testCase := SSTestCase		with:			(STypeInfo new				type:					(self fullSymbolOf: #SFoo)						-&gt;							(Array								with:									(Array										with:											#score												-&gt;													(Array														with: (self fullSymbolOf: #SFoo)														with: (self fullSymbolOf: #SmallInteger)														with: #()														with: true)										with:											#score:												-&gt;													(Array														with: (self fullSymbolOf: #SFoo)														with: (self fullSymbolOf: #SmallInteger)														with: (Array with: (self fullSymbolOf: #SFoo))														with: false))								with:									(Array										with:											#score:												-&gt;													(Array														with: (self fullSymbolOf: #SFoo)														with: (self fullSymbolOf: #SFoo)														with: (Array with: (self fullSymbolOf: #SmallInteger))														with: false)));				scalar: (self fullSymbolOf: #SmallInteger) with: #(5)).	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addFieldAccessMessage.	self assert: testCase statements size equals: 3.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 5.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.'				with: '_var2 := _var1 score.')</body><body package="SSG-Tests-Core" selector="testGenerateStatements">testGenerateStatements	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		numMaxStatements: 30.	self shouldnt: [ testCase generateStatements ] raise: SError</body><body package="SSG-Tests-Core" selector="testPickAccessorsOf">testPickAccessorsOf	| testCase |	testCase := SSTestCase new.	testCase typeInfo: utility typeInfoOnPackage1.	self		assert: (testCase pickAccessorsOf: (self fullSymbolOf: #SEvent)) isEmpty.	self		assertCollection:			((testCase pickAccessorsOf: (self fullSymbolOf: #SConference))				collect: #selector)		hasSameElements: #(#discount #offerPrice)</body><body package="SSG-Tests-Core" selector="testPickMessagesOf">testPickMessagesOf	| testCase |	testCase := SSTestCase new.	testCase typeInfo: utility typeInfoOnPackage1.	self		assert: (testCase pickMessagesOf: (self fullSymbolOf: #SEvent)) isEmpty.	self		assertCollection:			((testCase pickMessagesOf: (self fullSymbolOf: #SConference))				collect: #selector)		hasSameElements: #(#initialize #offerPrice: #canRegister: #price)</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCaseTest</class-id> <category>running</category><body package="SSG-Tests-Core" selector="tearDown">tearDown	"SConfiguration clearFileLog: 'STestCaseTestLogger.log'"	SPlatform resetRandomGenerator</body></methods><methods><class-id>SmallSuiteGenerator.SRemoveTest</class-id> <category>mutation-remove</category><body package="SSG-Tests-Core" selector="testRemoveArgsFactoryMessage">testRemoveArgsFactoryMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addFactoryMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.').	testCase removeStatementOfVarName: '_var0'.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var2 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var2.').	self assert: testCase validReferences</body><body package="SSG-Tests-Core" selector="testRemoveArgsMessage">testRemoveArgsMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addMessage: #return: from: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.'				with: '_var2 := ''hello''.'				with: '_var3 := _var1 return: _var2.').	testCase removeStatementOfVarName: '_var2'.	self		assert:			(#('_var4 := ''hello''.' '_var4 := _var1 returnString.')				includes: (testCase statementOfVarName: '_var4') printString).	self		assert: (testCase statementOfVarName: '_var3') printString		equals: '_var3 := _var1 return: _var4.'.	self assert: testCase validReferences</body><body package="SSG-Tests-Core" selector="testRemoveFactoryMessage">testRemoveFactoryMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addFactoryMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.').	testCase removeStatementOfVarName: '_var1'.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 7.3.')</body><body package="SSG-Tests-Core" selector="testRemoveFieldAccessMessage">testRemoveFieldAccessMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addFieldAccessMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.'				with: '_var2 := _var1 score.').	testCase removeStatementOfVarName: '_var2'.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.')</body><body package="SSG-Tests-Core" selector="testRemoveMessage">testRemoveMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addMessage: #return: from: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.'				with: '_var2 := ''hello''.'				with: '_var3 := _var1 return: _var2.').	testCase removeStatementOfVarName: '_var3'.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.'				with: '_var2 := ''hello''.')</body><body package="SSG-Tests-Core" selector="testRemoveReceiverFieldAccessMessage">testRemoveReceiverFieldAccessMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addFieldAccessMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.'				with: '_var2 := _var1 score.').	testCase removeStatementOfVarName: '_var1'.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with: '_var2 := _var4 score.'				with: '_var3 := 7.3.'				with:					'_var4 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.')</body><body package="SSG-Tests-Core" selector="testRemoveReceiverMessage">testRemoveReceiverMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addMessage: #return: from: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.'				with: '_var2 := ''hello''.'				with: '_var3 := _var1 return: _var2.').	testCase removeStatementOfVarName: '_var1'.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var4 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.'				with: '_var2 := ''hello''.'				with: '_var3 := _var4 return: _var2.')</body><body package="SSG-Tests-Core" selector="testRemoveStatementNoRepairing">testRemoveStatementNoRepairing	| testCase statement |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo).	statement := testCase addFactoryMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.').	testCase removeStatementNoRepairing: statement.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 7.3.').	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo).	statement := testCase addFactoryMessage.	testCase addMessage: #returnFloat from: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.'				with: '_var2 := _var1 returnFloat.').	testCase removeStatementNoRepairing: statement.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 7.3.')</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfoTest</class-id> <category>tests</category><body package="SSG-Tests-Info" selector="testEqual">testEqual	self		assert: (SMultiTypeInfo new type: #ByteString)		equals: (SMultiTypeInfo new type: #ByteString)</body></methods><methods><class-id>SmallSuiteGenerator.SUndefinedObject</class-id> <category>comparing</category><body package="SSG-Info" selector="printOn:">printOn: aStream	"Refer to the comment in Object|printOn:."	aStream nextPutAll: 'nil'</body></methods><methods><class-id>SmallSuiteGenerator.SClassInfoTest</class-id> <category>tests</category><body package="SSG-Tests-Info" selector="testEquals">testEquals	self		assert: (STypeClassInfo type: #SFoo -&gt; #(#() #()))		equals: (STypeClassInfo type: #SFoo -&gt; #(#() #())).	self		assert:			(STypeClassInfo				type:					#SStudent						-&gt;							(Array								with: (Array with: #name -&gt; #(#SStudent #ByteString #() false))								with: #()))		equals:			(STypeClassInfo				type:					#SStudent						-&gt;							(Array								with: (Array with: #name -&gt; #(#SStudent #ByteString #() false))								with: #())).	self		assert:			(STypeClassInfo				type:					#SFoo						-&gt;							(Array								with: (Array with: #score -&gt; #(#SFoo #SmallInteger #() false))								with: (Array with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false))))		equals:			(STypeClassInfo				type:					#SFoo						-&gt;							(Array								with: (Array with: #score -&gt; #(#SFoo #SmallInteger #() false))								with: (Array with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false))))</body><body package="SSG-Tests-Info" selector="testType">testType	| classInfo methodInfo |	classInfo := STypeClassInfo		type:			#SFoo				-&gt;					(Array						with:							(Array								with: #returnFloat -&gt; #(#SFoo #SmallFloat64 #() false)								with: #returnString -&gt; #(#SFoo #ByteString #() false)								with: #return: -&gt; #(#SFoo #OrderedCollection #(#OrderedCollection) false)								with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false)								with: #score -&gt; #(#SFoo #SmallInteger #() true))						with: (Array with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false))).	classInfo typeMethod: #returnNum -&gt; #(#SFoo #SmallInteger #() false).	self assert: classInfo methodTypes size equals: 6.	self assert: classInfo classMethodTypes size equals: 1.	methodInfo := classInfo methodTypes at: #return:.	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #OrderedCollection.	self		assertCollection: methodInfo allArgTypes		hasSameElements: #(#OrderedCollection).	self		assert: (classInfo methodTypes at: #returnFloat) returnType type		equals: #SmallFloat64.	self		assert: (classInfo methodTypes at: #returnString) returnType type		equals: #ByteString.	self		assert: (classInfo methodTypes at: #score) returnType type		equals: #SmallInteger.	methodInfo := classInfo methodTypes at: #score:.	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #SFoo.	self		assertCollection: methodInfo allArgTypes		hasSameElements: #(#SmallInteger).	self		assert: (classInfo classMethodTypes at: #score:) returnType type		equals: #SFoo.	self		assert: (classInfo methodTypes at: #returnNum) returnType type		equals: #SmallInteger</body></methods><methods><class-id>SmallSuiteGenerator.GASFooTest</class-id> <category>As yet unclassified</category><body package="SSG-Tests-Generated" selector="nil">nil</body><body package="SSG-Tests-Generated" selector="setUp">setUp    ^ self</body><body package="SSG-Tests-Generated" selector="tearDown">tearDown    ^ self</body><body package="SSG-Tests-Generated" selector="test1">test1	"Fitness: block-coverage: 64.286"	"This test covers: block-coverageSmallSuiteGenerator.SFoo:64.286%"	| var |	var := Dictionary new.	var at: 1 put: SmallSuiteGenerator.SFoo new.	var at: 2 put: SmallSuiteGenerator.SFoo new.	var at: 3 put: (var at: 1) returnFloat.	var at: 5 put: Core.Dictionary new.	var at: 6 put: ((var at: 1) return: (var at: 5)).	var at: 7 put: (var at: 2) score.	var at: 8 put: (var at: 2) returnCollection.	var at: 9 put: (var at: 1) returnString.	String fromString: 'Example'.	self assert: (var at: 5) equals: (var at: 6).	self assert: (var at: 1) score equals: 0.	self assert: (var at: 2) score equals: 0.	self assert: (var at: 3) equals: 2.3.	self assert: (var at: 7) equals: 0.	self assert: (var at: 9) equals: 'Hello'.	self assert: (var at: 5) printString equals: 'Dictionary ()'.	self assert: (var at: 6) printString equals: 'Dictionary ()'.	self assert: (var at: 8) printString equals: 'OrderedCollection ()'</body><body package="SSG-Tests-Generated" selector="test10">test10	"Fitness: block-coverage: 57.143"	"This test covers: block-coverageSmallSuiteGenerator.SFoo:57.143%"	| var |	var := Dictionary new.	var at: 1 put: SmallSuiteGenerator.SFoo new.	var at: 2 put: (var at: 1) returnCollection.	var at: 3 put: (var at: 1) returnFloat.	var at: 4 put: (var at: 1) returnCollection.	var at: 5 put: (var at: 1) returnNum.	var at: 7 put: (var at: 1) score.	String fromString: 'Example'.	self assert: (var at: 2) equals: (var at: 4).	self deny: (var at: 5) equals: (var at: 7).	self assert: (var at: 1) score equals: 0.	self assert: (var at: 3) equals: 2.3.	self assert: (var at: 5) equals: 4.	self assert: (var at: 7) equals: 0.	self assert: (var at: 2) printString equals: 'OrderedCollection ()'.	self assert: (var at: 4) printString equals: 'OrderedCollection ()'</body><body package="SSG-Tests-Generated" selector="test11">test11	"Fitness: block-coverage: 57.143"	"This test covers: block-coverageSmallSuiteGenerator.SFoo:57.143%"	| var |	var := Dictionary new.	var at: 1 put: SmallSuiteGenerator.SFoo new.	var at: 9 put: SmallSuiteGenerator.SFoo new.	var at: 4 put: (var at: 1) returnFloat.	var at: 5 put: (var at: 9) returnCollection.	var at: 7 put: (var at: 1) returnNum.	var at: 8 put: (var at: 1) score.	String fromString: 'Example'.	self deny: (var at: 7) equals: (var at: 8).	self assert: (var at: 1) score equals: 0.	self assert: (var at: 9) score equals: 0.	self assert: (var at: 4) equals: 2.3.	self assert: (var at: 7) equals: 4.	self assert: (var at: 8) equals: 0.	self assert: (var at: 5) printString equals: 'OrderedCollection ()'</body><body package="SSG-Tests-Generated" selector="test12">test12	"Fitness: block-coverage: 57.143"	"This test covers: block-coverageSmallSuiteGenerator.SFoo:57.143%"	| var |	var := Dictionary new.	var at: 12 put: SmallSuiteGenerator.SFoo new.	var at: 1 put: SmallSuiteGenerator.SFoo new.	var at: 2 put: (var at: 12) returnFloat.	var at: 4 put: (var at: 1) returnCollection.	var at: 5 put: (var at: 1) returnNum.	var at: 6 put: (var at: 12) score.	String fromString: 'Example'.	self deny: (var at: 5) equals: (var at: 6).	self assert: (var at: 1) score equals: 0.	self assert: (var at: 12) score equals: 0.	self assert: (var at: 2) equals: 2.3.	self assert: (var at: 5) equals: 4.	self assert: (var at: 6) equals: 0.	self assert: (var at: 4) printString equals: 'OrderedCollection ()'</body><body package="SSG-Tests-Generated" selector="test13">test13	"Fitness: block-coverage: 57.143"	"This test covers: block-coverageSmallSuiteGenerator.SFoo:57.143%"	| var |	var := Dictionary new.	var at: 1 put: SmallSuiteGenerator.SFoo new.	var at: 2 put: SmallSuiteGenerator.SFoo new.	var at: 7 put: (var at: 2) returnFloat.	var at: 8 put: (var at: 1) returnCollection.	var at: 5 put: (var at: 2) score.	var at: 6 put: (var at: 2) returnCollection.	var at: 9 put: (var at: 1) returnString.	String fromString: 'Example'.	self assert: (var at: 6) equals: (var at: 8).	self assert: (var at: 1) score equals: 0.	self assert: (var at: 2) score equals: 0.	self assert: (var at: 5) equals: 0.	self assert: (var at: 7) equals: 2.3.	self assert: (var at: 9) equals: 'Hello'.	self assert: (var at: 6) printString equals: 'OrderedCollection ()'.	self assert: (var at: 8) printString equals: 'OrderedCollection ()'</body><body package="SSG-Tests-Generated" selector="test14">test14	"Fitness: block-coverage: 57.143"	"This test covers: block-coverageSmallSuiteGenerator.SFoo:57.143%"	| var |	var := Dictionary new.	var at: 1 put: SmallSuiteGenerator.SFoo new.	var at: 2 put: SmallSuiteGenerator.SFoo new.	var at: 3 put: (var at: 2) returnFloat.	var at: 4 put: 4.	var at: 7 put: (var at: 2) returnFloat.	var at: 8 put: (var at: 1) returnCollection.	var at: 9 put: (var at: 2) score.	var at: 10 put: (var at: 2) returnNum.	var at: 11 put: (var at: 2) score.	String fromString: 'Example'.	self assert: (var at: 3) equals: (var at: 7).	self deny: (var at: 4) equals: (var at: 9).	self assert: (var at: 4) equals: (var at: 10).	self deny: (var at: 4) equals: (var at: 11).	self deny: (var at: 9) equals: (var at: 10).	self assert: (var at: 9) equals: (var at: 11).	self deny: (var at: 10) equals: (var at: 11).	self assert: (var at: 1) score equals: 0.	self assert: (var at: 2) score equals: 0.	self assert: (var at: 3) equals: 2.3.	self assert: (var at: 4) equals: 4.	self assert: (var at: 7) equals: 2.3.	self assert: (var at: 9) equals: 0.	self assert: (var at: 10) equals: 4.	self assert: (var at: 11) equals: 0.	self assert: (var at: 8) printString equals: 'OrderedCollection ()'</body><body package="SSG-Tests-Generated" selector="test15">test15	"Fitness: block-coverage: 57.143"	"This test covers: block-coverageSmallSuiteGenerator.SFoo:57.143%"	| var |	var := Dictionary new.	var at: 1 put: SmallSuiteGenerator.SFoo new.	var at: 2 put: SmallSuiteGenerator.SFoo new.	var at: 3 put: (var at: 2) returnFloat.	var at: 4 put: 4.	var at: 7 put: (var at: 2) returnFloat.	var at: 8 put: (var at: 1) returnCollection.	var at: 9 put: (var at: 2) score.	var at: 10 put: (var at: 2) returnNum.	var at: 11 put: (var at: 2) score.	String fromString: 'Example'.	self assert: (var at: 3) equals: (var at: 7).	self deny: (var at: 4) equals: (var at: 9).	self assert: (var at: 4) equals: (var at: 10).	self deny: (var at: 4) equals: (var at: 11).	self deny: (var at: 9) equals: (var at: 10).	self assert: (var at: 9) equals: (var at: 11).	self deny: (var at: 10) equals: (var at: 11).	self assert: (var at: 1) score equals: 0.	self assert: (var at: 2) score equals: 0.	self assert: (var at: 3) equals: 2.3.	self assert: (var at: 4) equals: 4.	self assert: (var at: 7) equals: 2.3.	self assert: (var at: 9) equals: 0.	self assert: (var at: 10) equals: 4.	self assert: (var at: 11) equals: 0.	self assert: (var at: 8) printString equals: 'OrderedCollection ()'</body><body package="SSG-Tests-Generated" selector="test2">test2	"Fitness: block-coverage: 64.286"	"This test covers: block-coverageSmallSuiteGenerator.SFoo:64.286%"	| var |	var := Dictionary new.	var at: 3 put: 5.	var at: 11 put: SmallSuiteGenerator.SFoo new.	var at: 5 put: ((var at: 11) score: (var at: 3)).	var at: 6 put: (var at: 11) returnFloat.	var at: 7 put: (var at: 5) returnCollection.	var at: 8 put: (var at: 11) returnString.	var at: 9 put: (var at: 5) score.	var at: 10 put: (var at: 5) initialize.	String fromString: 'Example'.	self assert: (var at: 3) equals: (var at: 9).	self assert: (var at: 5) score equals: 0.	self assert: (var at: 10) score equals: 0.	self assert: (var at: 11) score equals: 0.	self assert: (var at: 3) equals: 5.	self assert: (var at: 6) equals: 2.3.	self assert: (var at: 8) equals: 'Hello'.	self assert: (var at: 9) equals: 5.	self assert: (var at: 7) printString equals: 'OrderedCollection ()'</body><body package="SSG-Tests-Generated" selector="test3">test3	"Fitness: block-coverage: 64.286"	"This test covers: block-coverageSmallSuiteGenerator.SFoo:64.286%"	| var |	var := Dictionary new.	var at: 3 put: 5.	var at: 11 put: SmallSuiteGenerator.SFoo new.	var at: 5 put: ((var at: 11) score: (var at: 3)).	var at: 6 put: (var at: 11) returnFloat.	var at: 7 put: (var at: 5) returnCollection.	var at: 8 put: (var at: 11) returnString.	var at: 9 put: (var at: 5) score.	var at: 10 put: (var at: 5) initialize.	String fromString: 'Example'.	self assert: (var at: 3) equals: (var at: 9).	self assert: (var at: 5) score equals: 0.	self assert: (var at: 10) score equals: 0.	self assert: (var at: 11) score equals: 0.	self assert: (var at: 3) equals: 5.	self assert: (var at: 6) equals: 2.3.	self assert: (var at: 8) equals: 'Hello'.	self assert: (var at: 9) equals: 5.	self assert: (var at: 7) printString equals: 'OrderedCollection ()'</body><body package="SSG-Tests-Generated" selector="test4">test4	"Fitness: block-coverage: 64.286"	"This test covers: block-coverageSmallSuiteGenerator.SFoo:64.286%"	| var |	var := Dictionary new.	var at: 3 put: 5.	var at: 11 put: SmallSuiteGenerator.SFoo new.	var at: 5 put: ((var at: 11) score: (var at: 3)).	var at: 6 put: (var at: 11) returnFloat.	var at: 7 put: (var at: 5) returnCollection.	var at: 8 put: (var at: 11) returnString.	var at: 9 put: (var at: 5) score.	var at: 10 put: (var at: 5) initialize.	String fromString: 'Example'.	self assert: (var at: 3) equals: (var at: 9).	self assert: (var at: 5) score equals: 0.	self assert: (var at: 10) score equals: 0.	self assert: (var at: 11) score equals: 0.	self assert: (var at: 3) equals: 5.	self assert: (var at: 6) equals: 2.3.	self assert: (var at: 8) equals: 'Hello'.	self assert: (var at: 9) equals: 5.	self assert: (var at: 7) printString equals: 'OrderedCollection ()'</body><body package="SSG-Tests-Generated" selector="test5">test5	"Fitness: block-coverage: 64.286"	"This test covers: block-coverageSmallSuiteGenerator.SFoo:64.286%"	| var |	var := Dictionary new.	var at: 3 put: 0.	var at: 10 put: SmallSuiteGenerator.SFoo new.	var at: 4 put: ((var at: 10) score: (var at: 3)).	var at: 5 put: (var at: 4) returnFloat.	var at: 6 put: (var at: 10) returnCollection.	var at: 7 put: (var at: 4) returnString.	var at: 8 put: (var at: 10) score.	var at: 9 put: (var at: 4) initialize.	String fromString: 'Example'.	self assert: (var at: 3) equals: (var at: 8).	self assert: (var at: 4) score equals: 0.	self assert: (var at: 9) score equals: 0.	self assert: (var at: 10) score equals: 0.	self assert: (var at: 3) equals: 0.	self assert: (var at: 5) equals: 2.3.	self assert: (var at: 7) equals: 'Hello'.	self assert: (var at: 8) equals: 0.	self assert: (var at: 6) printString equals: 'OrderedCollection ()'</body><body package="SSG-Tests-Generated" selector="test6">test6	"Fitness: block-coverage: 64.286"	"This test covers: block-coverageSmallSuiteGenerator.SFoo:64.286%"	| var |	var := Dictionary new.	var at: 1 put: SmallSuiteGenerator.SFoo new.	var at: 2 put: SmallSuiteGenerator.SFoo new.	var at: 3 put: (var at: 1) returnFloat.	var at: 4 put: Core.Dictionary new.	var at: 6 put: (var at: 1) score.	var at: 8 put: ((var at: 1) return: (var at: 4)).	var at: 9 put: (var at: 1) returnCollection.	var at: 10 put: (var at: 2) returnString.	String fromString: 'Example'.	self assert: (var at: 4) equals: (var at: 8).	self assert: (var at: 1) score equals: 0.	self assert: (var at: 2) score equals: 0.	self assert: (var at: 3) equals: 2.3.	self assert: (var at: 6) equals: 0.	self assert: (var at: 10) equals: 'Hello'.	self assert: (var at: 4) printString equals: 'Dictionary ()'.	self assert: (var at: 8) printString equals: 'Dictionary ()'.	self assert: (var at: 9) printString equals: 'OrderedCollection ()'</body><body package="SSG-Tests-Generated" selector="test7">test7	"Fitness: block-coverage: 64.286"	"This test covers: block-coverageSmallSuiteGenerator.SFoo:64.286%"	| var |	var := Dictionary new.	var at: 3 put: 5.	var at: 11 put: SmallSuiteGenerator.SFoo new.	var at: 5 put: ((var at: 11) score: (var at: 3)).	var at: 6 put: (var at: 11) returnFloat.	var at: 7 put: (var at: 5) returnCollection.	var at: 8 put: (var at: 11) returnString.	var at: 9 put: (var at: 5) score.	var at: 10 put: (var at: 5) initialize.	String fromString: 'Example'.	self assert: (var at: 3) equals: (var at: 9).	self assert: (var at: 5) score equals: 0.	self assert: (var at: 10) score equals: 0.	self assert: (var at: 11) score equals: 0.	self assert: (var at: 3) equals: 5.	self assert: (var at: 6) equals: 2.3.	self assert: (var at: 8) equals: 'Hello'.	self assert: (var at: 9) equals: 5.	self assert: (var at: 7) printString equals: 'OrderedCollection ()'</body><body package="SSG-Tests-Generated" selector="test8">test8	"Fitness: block-coverage: 64.286"	"This test covers: block-coverageSmallSuiteGenerator.SFoo:64.286%"	| var |	var := Dictionary new.	var at: 3 put: Core.OrderedCollection new.	var at: 10 put: SmallSuiteGenerator.SFoo new.	var at: 4 put: ((var at: 10) return: (var at: 3)).	var at: 1 put: (var at: 10) returnFloat.	var at: 5 put: (var at: 10) returnFloat.	var at: 6 put: (var at: 10) returnCollection.	var at: 7 put: (var at: 10) score.	var at: 8 put: (var at: 10) returnNum.	var at: 9 put: (var at: 10) score.	String fromString: 'Example'.	self assert: (var at: 1) equals: (var at: 5).	self assert: (var at: 3) equals: (var at: 4).	self assert: (var at: 3) equals: (var at: 6).	self assert: (var at: 4) equals: (var at: 6).	self deny: (var at: 7) equals: (var at: 8).	self assert: (var at: 7) equals: (var at: 9).	self deny: (var at: 8) equals: (var at: 9).	self assert: (var at: 10) score equals: 0.	self assert: (var at: 1) equals: 2.3.	self assert: (var at: 5) equals: 2.3.	self assert: (var at: 7) equals: 0.	self assert: (var at: 8) equals: 4.	self assert: (var at: 9) equals: 0.	self assert: (var at: 3) printString equals: 'OrderedCollection ()'.	self assert: (var at: 4) printString equals: 'OrderedCollection ()'.	self assert: (var at: 6) printString equals: 'OrderedCollection ()'</body><body package="SSG-Tests-Generated" selector="test9">test9	"Fitness: block-coverage: 64.286"	"This test covers: block-coverageSmallSuiteGenerator.SFoo:64.286%"	| var |	var := Dictionary new.	var at: 3 put: Core.OrderedCollection new.	var at: 10 put: SmallSuiteGenerator.SFoo new.	var at: 4 put: ((var at: 10) return: (var at: 3)).	var at: 5 put: (var at: 10) score.	var at: 1 put: (var at: 10) returnFloat.	var at: 2 put: (var at: 10) returnCollection.	var at: 6 put: (var at: 10) returnNum.	var at: 7 put: SmallSuiteGenerator.SFoo new.	var at: 8 put: (var at: 7) score.	String fromString: 'Example'.	self assert: (var at: 2) equals: (var at: 3).	self assert: (var at: 2) equals: (var at: 4).	self assert: (var at: 3) equals: (var at: 4).	self deny: (var at: 5) equals: (var at: 6).	self assert: (var at: 5) equals: (var at: 8).	self deny: (var at: 6) equals: (var at: 8).	self assert: (var at: 7) score equals: 0.	self assert: (var at: 10) score equals: 0.	self assert: (var at: 1) equals: 2.3.	self assert: (var at: 5) equals: 0.	self assert: (var at: 6) equals: 4.	self assert: (var at: 8) equals: 0.	self assert: (var at: 2) printString equals: 'OrderedCollection ()'.	self assert: (var at: 3) printString equals: 'OrderedCollection ()'.	self assert: (var at: 4) printString equals: 'OrderedCollection ()'</body></methods><methods><class-id>SmallSuiteGenerator.SMethodCoverageTest</class-id> <category>tests</category><body package="SSG-Tests-GA" selector="testCoverageClassSEvent">testCoverageClassSEvent	| testCase valueFitness |	testCase := self		testCase: utility typeInfoSEvent2		withNumStatements: 20		andTargetClassName: (self fullSymbolOf: #SEvent).	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 83.33 ])	"83.33 = (5/6) * 100 round: 2"</body><body package="SSG-Tests-GA" selector="testCoverageClassSFoo">testCoverageClassSFoo	| testCase valueFitness |	testCase := self		testCase: utility typeInfoSFoo4		withNumStatements: 20		andTargetClassName: (self fullSymbolOf: #SFoo).	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 77.78 ])	"77.78 = (7/9) * 100 round: 2"</body><body package="SSG-Tests-GA" selector="testCoverageOnClassSStack">testCoverageOnClassSStack	| testCase valueFitness |	testCase := self		testCase: utility typeInfoSStack3		withNumStatements: 20		andTargetClassName: (self fullSymbolOf: #SStack).	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 57.14 ])	"57.14 = (4/7) * 100 round: 2"</body><body package="SSG-Tests-GA" selector="testCoverageOnClassSSTeacher">testCoverageOnClassSSTeacher	| testCase valueFitness |	testCase := self		testCase: utility typeInfoSSTeacher3		withNumStatements: 20		andTargetClassName: (self fullSymbolOf: #SSTeacher).	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 60.0 ])	"60.0 = (3/5) * 100 round: 2"</body><body package="SSG-Tests-GA" selector="testCoverageOnClassSStudent">testCoverageOnClassSStudent	| testCase valueFitness |	testCase := self		testCase: utility typeInfosSStudent first		withNumStatements: 20		andTargetClassName: (self fullSymbolOf: #SStudent).	self installOn: 'SmallSuiteGenerator-Scenario2'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 80.0 ])	"80.0 = (4/5) * 100 round: 2"</body><body package="SSG-Tests-GA" selector="testCoverageOnPackagesSEvent">testCoverageOnPackagesSEvent	| testCase valueFitness |	testCase := self		testCase: utility typeInfoSEventOnPackage1		withNumStatements: 20		andTargetClassName: (self fullSymbolOf: #SEvent).	" (STON fromString: utility typeInfoStringSEvent)"	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 83.33 ])</body><body package="SSG-Tests-GA" selector="testCoverageOnPackagesSFoo">testCoverageOnPackagesSFoo	| testCase valueFitness |	testCase := SSTestCase with: utility typeInfoSFooOnPackage2.	"(STON fromString: utility typeInfoStringSFoo2)"	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addFactoryMessage: (self fullSymbolOf: #SFoo);		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 77.78 ])	"77.78 = (7/9) * 100 round: 2"</body><body package="SSG-Tests-GA" selector="testCoverageOnPackagesSStack">testCoverageOnPackagesSStack	| testCase valueFitness |	testCase := SSTestCase with: utility typeInfoSStackOnPackage1.	"(STON fromString: utility typeInfoStringSStack2)."	testCase		addTargetClassName: (self fullSymbolOf: #SStack);		addFactoryMessage: (self fullSymbolOf: #SStack);		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 57.14 ])	"57.14 = (4/7) * 100 round: 2"</body><body package="SSG-Tests-GA" selector="testCoverageOnPackagesSSTeacher">testCoverageOnPackagesSSTeacher	| testCase valueFitness |	testCase := SSTestCase with: utility typeInfoSSTeacherOnPackage2.	"(STON fromString: utility typeInfoStringSSTeacher2)."	testCase		addTargetClassName: (self fullSymbolOf: #SSTeacher);		addFactoryMessage: (self fullSymbolOf: #SSTeacher);		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 77.78 ])	"77.78 = (7/9) * 100 round: 2"</body><body package="SSG-Tests-GA" selector="testCoverageOnPackagesSStudent">testCoverageOnPackagesSStudent	| testCase valueFitness |	testCase := SSTestCase with: utility typeInfoSStudentOnPackage1.	"(STON fromString: utility typeInfoStringSStudent1)."	testCase		addTargetClassName: (self fullSymbolOf: #SStudent);		addFactoryMessage: (self fullSymbolOf: #SStudent);		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario2'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 80.0 ])</body></methods><methods><class-id>SmallSuiteGenerator.SMethodCoverageTest</class-id> <category>running</category><body package="SSG-Tests-GA" selector="fitnessClass">fitnessClass	^ SMethodCoverage</body></methods><methods><class-id>SmallSuiteGenerator.SSTestRunner</class-id> <category>test - instrumentation</category><body package="SSG-Core" selector="analyze:">analyze: aSmalltalkContext	"it takes an snapshot of the thisContext object"	| sContext |	sContext := SSExecutionContext new.	aSmalltalkContext tempNames		doWithIndex:			[ :varName :index | sContext at: varName put: (aSmalltalkContext namedTempAt: index) ].	^ sContext</body></methods><methods><class-id>SmallSuiteGenerator.SSTestRunner</class-id> <category>compiling</category><body package="SSG-Core" selector="compile:">compile: aBlock	self class		compile:			'performTest	' , aBlock body formattedCode</body><body package="SSG-Core" selector="compile:withName:on:">compile: aBlock withName: symbol on: aClass	aClass		compile:			symbol asString , (String with: Character cr)				, aBlock body formattedCode</body></methods><methods><class-id>SmallSuiteGenerator.SSTestRunner</class-id> <category>running</category><body package="SSG-Core" selector="evaluate:">evaluate: aSTestCase	| node |	node := aSTestCase parseTree.	node body		addNode:			(SPlatform rbParserClass				parseExpression: '^ self analyze: thisContext').	self compile: node.	^ self performTest</body><body package="SSG-Core" selector="run:">run: aSTestCase	testCase := aSTestCase.	self compile: aSTestCase parseTreeWithAssertions.	self setTestSelector: #performTest.	^ self run</body><body package="SSG-Core" selector="runCase">runCase	self resources do: [ :each | each availableFor: self ].	[ [ self setUp.	self performTest.	testCase hasErrors: false ]		on: Error		do: [ testCase hasErrors: true ] ]		ensure: [ self tearDown.			self cleanUpInstanceVariables ]</body><body package="SSG-Core" selector="runWithoutAssertions:">runWithoutAssertions: aSTestCase	testCase := aSTestCase.	self compile: aSTestCase parseTree.	self setTestSelector: #performTest.	^ self run</body></methods><methods><class-id>SmallSuiteGenerator.SSTestRunner</class-id> <category>initialization</category><body package="SSG-Core" selector="initialize">initialize	invariants := OrderedCollection new</body></methods><methods><class-id>SmallSuiteGenerator.SSTestRunner</class-id> <category>as yet unclassified</category><body package="SSG-Core" selector="performTest">performTest	| _var0 _var1 _var2 _var3 _var5 _var6 _var4 _var7 _var8 _var9 |_var0 := SmallSuiteGenerator.SStudent new._var1 := _var0 scoreStudent._var2 := _var0 scoreStudent._var3 := 1._var5 := _var0 nickname._var6 := _var0 scoreStudent._var4 := _var0 scoreStudent._var7 := _var0 scoreStudent: _var3._var8 := _var0 idStudent._var9 := _var7 initialize.Transcript show: 'Example'.^self analyze: thisContext</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifterTest</class-id> <category>tests</category><body package="SSG-Tests-Core" selector="testAddAssignment">testAddAssignment	| testCase expression |	testCase := SSTestCase new.	expression := testCase addAssignment: (SLiteral new value: 3).	self assert: expression printString equals: '_var0 := 3.'.	expression := testCase		addAssignment:			(SMessage new				receiver: (SVariable new id: 0);				selector: #foo;				yourself).	self assert: expression printString equals: '_var1 := _var0 foo.'</body><body package="SSG-Tests-Core" selector="testAddFactoryMessage">testAddFactoryMessage	| testCase aTypeInfo |	aTypeInfo := utility typeInfoSFoo3.	testCase := SSTestCase with: aTypeInfo.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addFactoryMessage: (self fullSymbolOf: #SFoo).	self assert: testCase statements size equals: 2.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 4.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.').	self		should: [ testCase addFactoryMessage: (self fullSymbolOf: #SStack) ]		raise: SError.	aTypeInfo		type:			(self fullSymbolOf: #SStack)				-&gt;					(Array						with:							(Array								with:									#top										-&gt;											(Array												with: (self fullSymbolOf: #SStack)												with: nil												with: #()												with: false))						with:							(Array								with:									#newStack:										-&gt;											(Array												with: (self fullSymbolOf: #SStack)												with: (self fullSymbolOf: #SStack)												with: (Array with: (self fullSymbolOf: #Array))												with: false)));		scalar: (self fullSymbolOf: #Array) with: #(#(1 3 2)).	testCase		addTargetClassName: (self fullSymbolOf: #SStack);		addFactoryMessage: (self fullSymbolOf: #SStack).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 4.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.'				with: '_var2 := #(1 3 2 ).'				with:					'_var3 := ' , (self fullNameOfClass: 'SStack') asString						, ' newStack: _var2.')</body><body package="SSG-Tests-Core" selector="testAddFactoryMessageOfInexistentSelector">testAddFactoryMessageOfInexistentSelector	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo2.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addFactoryMessage: (self fullSymbolOf: #SFoo) ofSelector: #score:.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := ' , (self fullNameOfClass: 'SFoo') asString , ' new.')</body><body package="SSG-Tests-Core" selector="testAddFactoryMessageOfSelector">testAddFactoryMessageOfSelector	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo3.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addFactoryMessage: (self fullSymbolOf: #SFoo) ofSelector: #score:.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 4.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.')</body><body package="SSG-Tests-Core" selector="testAddFactoryMessageOnPackage">testAddFactoryMessageOnPackage	| testCase expression |	testCase := SSTestCase with: utility typeInfoOnPackage3.	self		should: [ testCase addFactoryMessage: (self fullSymbolOf: #SSTeacher) ]		raise: SError.	testCase addTargetClassName: (self fullSymbolOf: #SSTeacher).	expression := testCase		addFactoryMessage: (self fullSymbolOf: #SSTeacher).	self		assert:			((Array				with:					'_var2 := ' , (self fullNameOfClass: 'SSTeacher') asString						, ' name: _var0 with: _var1.'				with:					'_var2 := ' , (self fullNameOfClass: 'SSTeacher') asString						, ' name: _var1 with: _var0.') includes: expression printString).	self		shouldnt: [ expression := testCase				addFactoryMessage: (self fullSymbolOf: #SConference) ]		raise: SError.	self		assert: expression printString		equals: '_var3 := ' , (self fullNameOfClass: 'SConference') asString , ' new.'</body><body package="SSG-Tests-Core" selector="testAddFactoryMessageWithAbstractClasses">testAddFactoryMessageWithAbstractClasses	| testCase |	testCase := SSTestCase with: utility typeInfoSSPerson1.	self should: [ testCase addFactoryMessage ] raise: SError.	self		should: [ testCase addFactoryMessage: (self fullNameOfClass: #SSPerson) ]		raise: SError.	testCase := SSTestCase with: utility typeInfoSAbstractClass.	self should: [ testCase addFactoryMessage ] raise: SError.	self		should:			[ testCase addFactoryMessage: (self fullNameOfClass: #SAbstractClass) ]		raise: SError</body><body package="SSG-Tests-Core" selector="testAddFieldAccessMessage">testAddFieldAccessMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSSTeacher2.	self should: [ testCase addFieldAccessMessage ] raise: SError.	testCase addTargetClassName: (self fullSymbolOf: #SSTeacher).	self		assert: testCase addFieldAccessMessage printString		equals: '_var1 := _var0 idTeacher.'</body><body package="SSG-Tests-Core" selector="testAddFieldAccessMessageFrom">testAddFieldAccessMessageFrom	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo3.	self		should: [ testCase				addFieldAccessMessage: #score				from: (self fullSymbolOf: #SFoo) ]		raise: SError.	testCase addTargetClassName: (self fullSymbolOf: #SFoo).	self		assert:			(testCase				addFieldAccessMessage: #score				from: (self fullSymbolOf: #SFoo)) printString		equals: '_var2 := _var1 score.'</body><body package="SSG-Tests-Core" selector="testAddFieldAccessMessageFromWithError">testAddFieldAccessMessageFromWithError	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo2.	self		should: [ testCase				addFieldAccessMessage: #score				from: (self fullSymbolOf: #SFoo) ]		raise: SError.	testCase addTargetClassName: (self fullSymbolOf: #SFoo).	self		should: [ testCase				addFieldAccessMessage: #score				from: (self fullSymbolOf: #SFoo) ]		raise: SError.	self		should: [ testCase				addFieldAccessMessage: #return:				from: (self fullSymbolOf: #SFoo) ]		raise: SError</body><body package="SSG-Tests-Core" selector="testAddFieldAccessMessageFromWithInvalidClassName">testAddFieldAccessMessageFromWithInvalidClassName	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo4.	testCase addTargetClassName: (self fullSymbolOf: #SFoo).	self		should: [ testCase				addFieldAccessMessage: #score				from: (self fullSymbolOf: #SStudent) ]		raise: SError</body><body package="SSG-Tests-Core" selector="testAddFieldAccessMessageWithLackTypeInfo">testAddFieldAccessMessageWithLackTypeInfo	| testCase |	testCase := SSTestCase with: utility typeInfoSSTeacher3.	self should: [ testCase addFieldAccessMessage ] raise: SError.	testCase addTargetClassName: (self fullSymbolOf: #SSTeacher).	self should: [ testCase addFieldAccessMessage ] raise: SError</body><body package="SSG-Tests-Core" selector="testAddFieldAccessMessageWithReceiver">testAddFieldAccessMessageWithReceiver	| testCase typeInfo receiver |	typeInfo := utility typeInfoSFoo1.	testCase := (SSTestCase with: typeInfo)		addTargetClassName: (self fullSymbolOf: #SFoo).	receiver := testCase addFactoryMessage variable.	self		assert:			(testCase				addFieldAccessMessage: (typeInfo accessMessagesFrom: (self fullSymbolOf: #SFoo)) first				withReceiver: receiver) printString		equals: '_var2 := _var1 score.'</body><body package="SSG-Tests-Core" selector="testAddInvalidAssignment">testAddInvalidAssignment	| testCase |	testCase := SSTestCase new.	self should: [ testCase addAssignment: 3 ] raise: SError.	self should: [ testCase addAssignment: 'hello' ] raise: SError.	self should: [ testCase addAssignment: #name ] raise: SError.	self should: [ testCase addAssignment: 3.4 ] raise: SError.	self should: [ testCase addAssignment: #() ] raise: SError</body><body package="SSG-Tests-Core" selector="testAddLiteral">testAddLiteral	| testCase aTypeInfo |	aTypeInfo := STypeInfo new.	aTypeInfo		scalar: #OrderedCollection			with: (Array with: (OrderedCollection newFrom: #(1 4)));		scalar: #ByteString with: #('World');		scalar: #SmallInteger with: #(2);		scalar: #SStudent with: (Array with: SStudent new).	testCase := SSTestCase with: aTypeInfo.	testCase		addLiteral: #ByteString;		addLiteral: #OrderedCollection;		addLiteral: #SmallInteger;		addLiteral: #SStudent.	self assert: testCase statements size equals: 4.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := ''World''.'				with:					'_var1 := '						,							(OrderedCollection new								add: 1;								add: 4;								yourself) storeString , '.'				with: '_var2 := 2.'				with: '_var3 := ' , SStudent new storeString , '.')</body><body package="SSG-Tests-Core" selector="testAddLiteralWithError">testAddLiteralWithError	| testCase |	testCase := SSTestCase with: STypeInfo new.	self should: [ testCase addLiteral ] raise: SError</body><body package="SSG-Tests-Core" selector="testAddLiteralWithWrongClassName">testAddLiteralWithWrongClassName	| testCase aTypeInfo |	aTypeInfo := STypeInfo new.	aTypeInfo scalar: #SmallInteger with: #(2).	testCase := SSTestCase with: aTypeInfo.	self should: [ testCase addLiteral: #ByteString ] raise: SError</body><body package="SSG-Tests-Core" selector="testAddMessage">testAddMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo5.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addMessage.	self assert: testCase statements size equals: 3.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := ' , (self fullNameOfClass: 'SFoo') asString , ' new.'				with: '_var1 := ' , (OrderedCollection newFrom: #(1 4 5)) storeString , '.'				with: '_var2 := _var0 return: _var1.')</body><body package="SSG-Tests-Core" selector="testAddMessageFrom">testAddMessageFrom	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo3.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addMessage: #returnFloat from: (self fullSymbolOf: #SFoo).	self assert: testCase statements size equals: 3.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 4.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.'				with: '_var2 := _var1 returnFloat.').	self		assert:			(testCase addMessage: #returnNum from: (self fullSymbolOf: #SFoo))				printString		equals: '_var3 := _var1 returnNum.'.	self		assert:			(#('_var4 := _var1 score: _var0.' '_var4 := _var1 score: _var3.' '_var5 := _var1 score: _var3.' '_var5 := _var1 score: _var4.')				includes:					(testCase addMessage: #score: from: (self fullSymbolOf: #SFoo))						printString)</body><body package="SSG-Tests-Core" selector="testAddMessageFromDifferentReceiver">testAddMessageFromDifferentReceiver	| testCase |	testCase := (SSTestCase with: utility typeInfoOnPackage1)		addTargetClassName: (self fullSymbolOf: #SEvent).	self		should: [ testCase				addMessage: #canRegister:				from: (self fullSymbolOf: #SEvent) ]		raise: SError.	testCase addTargetClassName: (self fullSymbolOf: #SConference).	testCase		addMessage: #canRegister:		from: (self fullSymbolOf: #SConference).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := ' , (self fullNameOfClass: 'SConference') asString , ' new.'				with: '_var1 := ' , (SStudent new name: 'Mary') storeString , '.'				with: '_var2 := _var0 canRegister: _var1.')</body><body package="SSG-Tests-Core" selector="testAddMessageWithEmptyTypeMethodInfo">testAddMessageWithEmptyTypeMethodInfo	| testCase |	testCase := SSTestCase with: utility typeInfoSFooEmpty.	testCase addTargetClassName: (self fullSymbolOf: #SFoo).	self should: [ testCase addMessage ] raise: SError</body><body package="SSG-Tests-Core" selector="testAddMessageWithReceiver">testAddMessageWithReceiver	| testCase typeInfo receiver |	typeInfo := utility typeInfoSFoo2.	testCase := (SSTestCase with: typeInfo)		addTargetClassName: (self fullSymbolOf: #SFoo).	receiver := testCase addFactoryMessage variable.	self		assert:			(testCase				addMessage: (typeInfo messagesFrom: (self fullSymbolOf: #SFoo)) first				withReceiver: receiver) printString		equals: '_var1 := _var0 return: _var0.'</body><body package="SSG-Tests-Core" selector="testAddMessageWithTwoDeepScalarSFoo">testAddMessageWithTwoDeepScalarSFoo	| testCase |	testCase := SSTestCase with: utility typeInfoSFooOnPackage3.	"(STON fromString: utility typeInfoStringSFoo6)."	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addMessage: #return: from: (self fullSymbolOf: #SFoo).	self assert: testCase statements size equals: 3.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(OrderedCollection new				add: '_var0 := ' , (self fullNameOfClass: 'SFoo') asString , ' new.';				add: '_var1 := ' , (SStudent name: 'Lian' with: 1) storeString , '.';				add: '_var2 := ' , (self fullNameOfClass: 'SStack') asString , ' new.';				add: '_var3 := _var2 push: _var1.';				add: '_var4 := ' , (SStudent name: 'Josh' with: 2) storeString , '.';				add: '_var5 := _var2 push: _var4.';				add: '_var6 := ' , (SStudent name: 'Mery' with: 5) storeString , '.';				add: '_var7 := ((OrderedCollection new) add: _var6; yourself).';				add:					'_var8 := ((Dictionary new) add: (1-&gt;_var5); add: (2-&gt;_var7); yourself).';				add: '_var9 := _var0 return: _var8.';				yourself)</body><body package="SSG-Tests-Core" selector="testAddMessageWithTwoDeepScalarSStack">testAddMessageWithTwoDeepScalarSStack	| testCase |	testCase := SSTestCase with: utility typeInfoSStackOnPackage2.	"(STON fromString: utility typeInfoStringSStack1)"	testCase		addTargetClassName: (self fullSymbolOf: #SStack);		addMessage: #push: from: (self fullSymbolOf: #SStack).	self assert: testCase statements size equals: 3.	self		assert:			((testCase statements collect: #printString)				includesAny:					(Array						with:							(OrderedCollection new								add: '_var0 := SStack new.';								add: '_var1 := ' , (SStudent name: 'Lian' with: 1) storeString , '.';								add: '_var2 := ' , (SStudent name: 'Josh' with: 2) storeString , '.';								add: '_var3 := ((OrderedCollection new) add: _var1; add: _var2; yourself).';								add: '_var4 := _var0 push: _var3.';								yourself)						with:							(OrderedCollection new								add: '_var0 := SStack new.';								add: '_var1 := ' , (SStudent name: 'Mery' with: 5) storeString , '.';								add: '_var2 := ((OrderedCollection new) add: _var1; yourself).';								add: '_var3 := _var0 push: _var2.';								yourself)))</body><body package="SSG-Tests-Core" selector="testAddStatementAfter">testAddStatementAfter	| testCase expression1 expression2 |	testCase := SSTestCase with: utility typeInfoSSTeacher1.	expression1 := SAssignment		name: (SVariable new id: 0)		value: ((SLiteral value: 2) returnType: (self fullSymbolOf: #SmallInteger)).	self		assert: (testCase addStatement: expression1 after: nil) printString		equals: '_var0 := 2.'.	expression2 := SAssignment		name: (SVariable new id: 1)		value: (SFactoryMessage default: (self fullSymbolOf: #SSTeacher)).	self		assert: (testCase addStatement: expression2 after: expression1) printString		equals: '_var1 := ' , (self fullNameOfClass: 'SSTeacher') asString , ' new.'.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 2.'				with: '_var1 := ' , (self fullNameOfClass: 'SSTeacher') asString , ' new.').	expression1 := expression2.	expression2 := SAssignment		name: (SVariable new id: 2)		value:			(SMessage new				selector: #yearsWorkExperience;				receiver: expression1 variable;				yourself).	testCase addStatement: expression2 after: expression1.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 2.'				with: '_var1 := ' , (self fullNameOfClass: 'SSTeacher') asString , ' new.'				with: '_var2 := _var1 yearsWorkExperience.').	expression2 := SAssignment		name: (SVariable new id: 3)		value: (SLiteral value: 4).	testCase addStatement: expression2 after: expression1.	self		assert:			((Array				with:					(Array						with: '_var0 := 2.'						with: '_var1 := ' , (self fullNameOfClass: 'SSTeacher') asString , ' new.'						with: '_var2 := _var1 yearsWorkExperience.'						with: '_var3 := 4.')				with:					(Array						with: '_var0 := 2.'						with: '_var1 := ' , (self fullNameOfClass: 'SSTeacher') asString , ' new.'						with: '_var3 := 4.'						with: '_var2 := _var1 yearsWorkExperience.'))				includes: (testCase statements collect: #printString) asArray)</body><body package="SSG-Tests-Core" selector="testAddStatementBefore">testAddStatementBefore	| testCase expression1 expression2 |	testCase := SSTestCase new.	expression1 := SAssignment		name: (SVariable new id: 0)		value: ((SLiteral value: 2) returnType: (self fullSymbolOf: #SmallInteger)).	testCase addStatement: expression1 before: nil.	expression2 := SAssignment		name: (SVariable new id: 1)		value: (SFactoryMessage default: (self fullSymbolOf: #SSTeacher)).	testCase addStatement: expression2 before: expression1.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var1 := ' , (self fullNameOfClass: 'SSTeacher') asString , ' new.'				with: '_var0 := 2.').	expression1 := expression2.	expression2 := SAssignment		name: (SVariable new id: 2)		value: ((SLiteral value: 100) returnType: (self fullSymbolOf: #SmallInteger)).	testCase addStatement: expression2 before: expression1.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var2 := 100.'				with: '_var1 := ' , (self fullNameOfClass: 'SSTeacher') asString , ' new.'				with: '_var0 := 2.').	expression1 := testCase statements last.	"_var0"	expression2 := SAssignment		name: (SVariable new id: 3)		value:			(SMessage new				selector: #yearsWorkExperience;				receiver: testCase statements second variable;				yourself).	testCase addStatement: expression2 before: expression1.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var2 := 100.'				with: '_var1 := ' , (self fullNameOfClass: 'SSTeacher') asString , ' new.'				with: '_var3 := _var1 yearsWorkExperience.'				with: '_var0 := 2.')</body><body package="SSG-Tests-Core" selector="testAddStatetementOfTypeBefore">testAddStatetementOfTypeBefore	| testCase expression |	testCase := SSTestCase with: utility typeInfoSEvent1.	testCase addTargetClassName: (self fullSymbolOf: #SEvent).	expression := testCase		addStatementOfType: (self fullSymbolOf: #SEvent)		before: nil.	self		assert: expression printString		equals:			'_var1 := ' , (self fullNameOfClass: 'SEvent') asString				, ' price: _var0.'.	expression := testCase		addStatementOfType: (self fullSymbolOf: #SmallInteger)		before: expression.	self assert: expression printString equals: '_var2 := 8.'.	"change the form to select randomly"	self		assert:			((Array				with:					(Array						with: '_var0 := 8.'						with: '_var2 := 8.'						with:							'_var1 := ' , (self fullNameOfClass: 'SEvent') asString								, ' price: _var0.')				with:					(Array						with: '_var2 := 8.'						with: '_var0 := 8.'						with:							'_var1 := ' , (self fullNameOfClass: 'SEvent') asString								, ' price: _var0.'))				includes: (testCase statements collect: #printString) asArray)</body><body package="SSG-Tests-Core" selector="testAddStatetementOfTypeBeforeFactoryMessage">testAddStatetementOfTypeBeforeFactoryMessage	| testCase expression |	testCase := SSTestCase with: utility typeInfoSEvent1.	testCase addTargetClassName: (self fullSymbolOf: #SEvent).	expression := testCase addFactoryMessage.	expression := testCase		addStatementOfType: (self fullSymbolOf: #SEvent)		before: expression.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 8.'				with:					'_var2 := ' , (self fullNameOfClass: 'SEvent') asString						, ' price: _var0.'				with:					'_var1 := ' , (self fullNameOfClass: 'SEvent') asString						, ' price: _var0.')</body><body package="SSG-Tests-Core" selector="testAddTargetClassName">testAddTargetClassName	| testCase expression |	testCase := SSTestCase with: utility typeInfoOnPackage3.	self		should: [ testCase addTargetClassName: (self fullSymbolOf: #SEvent) ]		raise: SError.	self		shouldnt: [ testCase addTargetClassName: (self fullSymbolOf: #SSTeacher) ]		raise: SError.	expression := testCase		addFactoryMessage: (self fullSymbolOf: #SSTeacher).	self		assert:			((Array				with:					'_var2 := ' , (self fullNameOfClass: 'SSTeacher') asString						, ' name: _var0 with: _var1.'				with:					'_var2 := ' , (self fullNameOfClass: 'SSTeacher') asString						, ' name: _var1 with: _var0.') includes: expression printString)</body><body package="SSG-Tests-Core" selector="testBuildArgsBefore">testBuildArgsBefore	| testCase typeInfo expression |	typeInfo := utility typeInfoSEvent1.	testCase := SSTestCase with: typeInfo.	testCase addTargetClassName: (self fullSymbolOf: #SEvent).	expression := testCase addLiteral.	testCase		buildArgs:			(typeInfo factoryMessagesFrom: (self fullSymbolOf: #SEvent)) first				argTypes		before: expression.	self		assertCollection: testCase printStatements		hasSameElements: #('_var1 := 8.' '_var0 := 8.')</body><body package="SSG-Tests-Core" selector="testNewFactoryMessageBefore">testNewFactoryMessageBefore	| testCase expression |	testCase := SSTestCase with: utility typeInfoSEvent1.	testCase addTargetClassName: (self fullSymbolOf: #SEvent).	expression := testCase addLiteral.	self		assert:			(testCase				newFactoryMessage: (self fullSymbolOf: #SEvent)				before: expression) printString		equals: (self fullNameOfClass: 'SEvent') asString , ' price: _var1'.	"default factoryMessage"	testCase := SSTestCase with: utility typeInfoSFoo5.	testCase addTargetClassName: (self fullSymbolOf: #SFoo).	self		assert:			(testCase newFactoryMessage: (self fullSymbolOf: #SFoo) before: nil)				printString		equals: (self fullNameOfClass: 'SFoo') asString , ' new'</body><body package="SSG-Tests-Core" selector="testNewFactoryMessageUsingAnd">testNewFactoryMessageUsingAnd	| testCase expression |	testCase := SSTestCase with: utility typeInfoSEvent1.	testCase addTargetClassName: (self fullSymbolOf: #SEvent).	expression := testCase addLiteral.	self		assert:			(testCase				newFactoryMessageUsing: (self fullSymbolOf: #SEvent)				and: expression) printString		equals: (self fullNameOfClass: 'SEvent') asString , ' price: _var1'.	self		assertCollection: testCase printStatements		hasSameElements: #('_var1 := 8.' '_var0 := 8.')</body><body package="SSG-Tests-Core" selector="testNewMessageOfTypeBefore">testNewMessageOfTypeBefore	| testCase expression |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo).	expression := testCase addLiteral: (self fullSymbolOf: #SmallInteger).	self		should: [ testCase				newMessageOfType: (self fullSymbolOf: #SmallInteger)				before: expression ]		raise: SError.	testCase		addStatement:			(testCase				newAssignment:					(testCase						newFactoryMessage: (self fullSymbolOf: #SFoo)						before: expression))		before: expression.	self		assert:			(testCase				newMessageOfType: (self fullSymbolOf: #SmallInteger)				before: expression) printString		equals: '_var2 returnNum'.	self		assertCollection: testCase printStatements		hasSameElements:			(Array				with: '_var1 := 7.3.'				with:					'_var2 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var1.'				with: '_var0 := 5.')</body><body package="SSG-Tests-Core" selector="testNewStatementOfTypeBefore">testNewStatementOfTypeBefore	| testCase expression |	testCase := SSTestCase with: utility typeInfoSEvent1.	testCase addTargetClassName: (self fullSymbolOf: #SEvent).	expression := testCase		newAssignment:			(testCase				newStatementOfType: (self fullSymbolOf: #SmallInteger)				before: nil).	testCase addStatement: expression before: nil.	self		assertCollection: testCase printStatements		hasSameElements: #('_var0 := 8.').	expression := testCase		newStatementOfType: (self fullSymbolOf: #SEvent)		before: expression.	self		assert: expression printString		equals: (self fullNameOfClass: 'SEvent') asString , ' price: _var1'.	expression := testCase newAssignment: expression.	testCase		addStatement: expression		before: (testCase statementOfVarName: '_var0').	self		assertCollection: testCase printStatements		hasSameElements:			(Array				with: '_var1 := 8.'				with:					'_var2 := ' , (self fullNameOfClass: 'SEvent') asString						, ' price: _var1.'				with: '_var0 := 8.')</body><body package="SSG-Tests-Core" selector="testObjectVariables">testObjectVariables	| testCase |	testCase := SSTestCase with: utility typeInfoSSTeacher3.	self assert: testCase objectVariables isEmpty.	testCase		addTargetClassName: (self fullSymbolOf: #SSTeacher);		addFactoryMessage.	self		assertCollection: (testCase objectVariables collect: #printString)		hasSameElements: #('_var0')</body><body package="SSG-Tests-Core" selector="testPickAccessorsOf">testPickAccessorsOf	| testCase |	testCase := (SSTestCase with: utility typeInfoSSTeacher4)		addTargetClassName: (self fullSymbolOf: #SSTeacher).	self		assertCollection:			((testCase pickAccessorsOf: (self fullSymbolOf: #SSTeacher))				collect: #selector)		hasSameElements: #(#yearsWorkExperience #idTeacher).	testCase := (SSTestCase with: utility typeInfoSSTeacher3)		addTargetClassName: (self fullSymbolOf: #SSTeacher).	self		assert: (testCase pickAccessorsOf: (self fullSymbolOf: #SSTeacher)) isEmpty</body><body package="SSG-Tests-Core" selector="testPickAccessorsOfWithInvalidClassName">testPickAccessorsOfWithInvalidClassName	| testCase |	testCase := (SSTestCase with: utility typeInfoSSTeacher4)		addTargetClassName: (self fullSymbolOf: #SSTeacher).	self		assert: (testCase pickAccessorsOf: (self fullSymbolOf: #SStudent)) isEmpty</body><body package="SSG-Tests-Core" selector="testPickAnObjectVariable">testPickAnObjectVariable	| testCase |	testCase := SSTestCase with: utility typeInfoSSTeacher3.	self should: [ testCase pickAnObjectVariable ] raise: SError.	testCase addTargetClassName: (self fullSymbolOf: #SSTeacher).	self		assert: testCase pickAnObjectVariable printString		equals: '_var0'</body><body package="SSG-Tests-Core" selector="testPickFactoryMessagesFrom">testPickFactoryMessagesFrom	| testCase |	testCase := SSTestCase new.	testCase typeInfo: utility typeInfoOnPackage2.	self		should: [ testCase addMessage: #price: from: (self fullSymbolOf: #SEvent) ]		raise: SError.	testCase addTargetClassName: (self fullSymbolOf: #SConference).	testCase		addFactoryMessage: (self fullSymbolOf: #SConference)		ofSelector: #price:.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 95.'				with:					'_var1 := ' , (self fullNameOfClass: 'SConference') asString						, ' price: _var0.')</body><body package="SSG-Tests-Core" selector="testPickMessagesOf">testPickMessagesOf	| testCase |	testCase := SSTestCase with: utility typeInfoOnPackage2.	self		assert:			((testCase pickMessagesOf: (self fullSymbolOf: #SEvent))				collect: #selector) isEmpty.	self		assertCollection:			((testCase pickMessagesOf: (self fullSymbolOf: #SConference))				collect: #selector)		hasSameElements: #(#price: #initialize).	testCase := SSTestCase with: utility typeInfoOnPackage3.	self		assertCollection:			((testCase pickMessagesOf: (self fullSymbolOf: #SSTeacher))				collect: #selector)		hasSameElements: #(#name: #id: #nickname: #initialize #nickname)</body><body package="SSG-Tests-Core" selector="testPickMessagesOfWrongClassName">testPickMessagesOfWrongClassName	| testCase |	testCase := SSTestCase with: utility typeInfoOnPackage2.	self		assert: (testCase pickMessagesOf: (self fullSymbolOf: #SSTeacher)) isEmpty.	testCase := SSTestCase with: utility typeInfoOnPackage3.	self		assert: (testCase pickMessagesOf: (self fullSymbolOf: #SSPerson)) isEmpty.	self		assert: (testCase pickMessagesOf: (self fullSymbolOf: #SStudent)) isEmpty</body><body package="SSG-Tests-Core" selector="testPickOrCreateObjectVariableOf">testPickOrCreateObjectVariableOf	| testCase |	testCase := (SSTestCase with: utility typeInfoSFoo2)		addTargetClassName: (self fullSymbolOf: #SFoo).	self assert: testCase statements isEmpty.	self		assert:			(testCase pickOrCreateObjectVariableOf: (self fullSymbolOf: #SFoo))				printString		equals: '_var0'.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := ' , (self fullNameOfClass: 'SFoo') asString , ' new.').	testCase pickOrCreateObjectVariableOf: (self fullSymbolOf: #SFoo).	self assert: testCase statements size equals: 1</body><body package="SSG-Tests-Core" selector="testPickOrCreateObjectVariableOfWrongClassName">testPickOrCreateObjectVariableOfWrongClassName	| testCase |	testCase := (SSTestCase with: utility typeInfoSFoo2)		addTargetClassName: (self fullSymbolOf: #SFoo).	self		should: [ testCase				pickOrCreateObjectVariableOf: (self fullSymbolOf: #SSTeacher) ]		raise: SError</body><body package="SSG-Tests-Core" selector="testRandomLiteralClassName">testRandomLiteralClassName	| testCase |	testCase := SSTestCase		with:			(STypeInfo new				scalar: (self fullSymbolOf: #SmallInteger)				with: #(1 3 4)).	self		assert: testCase randomLiteralClassName		equals: (self fullSymbolOf: #SmallInteger).	testCase := SSTestCase		with:			(STypeInfo new				scalar: (self fullSymbolOf: #ByteString) with: #('hello');				scalar: (self fullSymbolOf: #SmallInteger) with: #(1 5 6)).	self		assert:			((Array				with: (self fullSymbolOf: #ByteString)				with: (self fullSymbolOf: #SmallInteger))				includes: testCase randomLiteralClassName)</body><body package="SSG-Tests-Core" selector="testRandomLiteralClassNameWithEmptyScalars">testRandomLiteralClassNameWithEmptyScalars	| testCase |	testCase := SSTestCase with: STypeInfo new.	self should: [ testCase randomLiteralClassName ] raise: SError</body><body package="SSG-Tests-Core" selector="testSubStatementsFromToPrevIndexOf">testSubStatementsFromToPrevIndexOf	| testCase expression |	testCase := SSTestCase with: utility typeInfoSEvent1.	testCase addTargetClassName: (self fullSymbolOf: #SEvent).	self		assert: (testCase subStatementsFrom: 1 toPrevIndexOf: nil) isEmpty.	expression := testCase addLiteral.	self		assert: (testCase subStatementsFrom: 1 toPrevIndexOf: expression) isEmpty.	expression := testCase addFactoryMessage.	self		assertCollection:			((testCase subStatementsFrom: 1 toPrevIndexOf: expression)				collect: #printString)		hasSameElements: #('_var0 := 8.' '_var1 := 8.').	expression := testCase		addMessage: #discount:		from: (self fullSymbolOf: #SEvent).	self		assertCollection:			((testCase subStatementsFrom: 1 toPrevIndexOf: expression)				collect: #printString)		hasSameElements:			(Array				with: '_var0 := 8.'				with: '_var1 := 8.'				with:					'_var2 := ' , (self fullNameOfClass: 'SEvent') asString						, ' price: _var0.'				with: '_var3 := 8.').	expression := testCase		addFieldAccessMessage: #price		from: (self fullSymbolOf: #SEvent).	self		assertCollection:			((testCase subStatementsFrom: 1 toPrevIndexOf: expression)				collect: #printString)		hasSameElements:			(OrderedCollection new				add: '_var0 := 8.';				add: '_var1 := 8.';				add:					'_var2 := ' , (self fullNameOfClass: 'SEvent') asString						, ' price: _var0.';				add: '_var3 := 8.';				add: '_var4 := _var2 discount: _var1.';				yourself)</body><body package="SSG-Tests-Core" selector="testValidTargetClassName">testValidTargetClassName	| testCase |	testCase := SSTestCase with: utility typeInfoOnPackage1.	self		should: [ testCase validTargetClassName: (self fullSymbolOf: #SEvent) ]		raise: SError.	testCase addTargetClassName: (self fullSymbolOf: #SEvent).	self		shouldnt: [ testCase validTargetClassName: (self fullSymbolOf: #SEvent) ]		raise: SError.	self		shouldnt: [ testCase validTargetClassName: (self fullSymbolOf: #SConference) ]		raise: SError.	self		shouldnt: [ testCase validTargetClassName: (self fullSymbolOf: #SStudent) ]		raise: SError</body><body package="SSG-Tests-Core" selector="testValidTargetClassNameWithLackTypeInfo">testValidTargetClassNameWithLackTypeInfo	| testCase |	testCase := SSTestCase with: utility typeInfoOnPackage4.	self		should: [ testCase validTargetClassName: (self fullSymbolOf: #SEvent) ]		raise: SError.	testCase addTargetClassName: (self fullSymbolOf: #SEvent).	self		shouldnt: [ testCase validTargetClassName: (self fullSymbolOf: #SEvent) ]		raise: SError.	self		shouldnt: [ testCase validTargetClassName: (self fullSymbolOf: #SConference) ]		raise: SError.	self		should: [ testCase validTargetClassName: (self fullSymbolOf: #SParty) ]		raise: SError</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifterTest</class-id> <category>running</category><body package="SSG-Tests-Core" selector="setUp">setUp	SPlatform resetRandomGenerator.	utility := SUtilityTypeInfo new.	SPlatform fileLogger: 'STestShifterTestLogger.log'</body><body package="SSG-Tests-Core" selector="tearDown">tearDown	SPlatform resetRandomGenerator</body></methods><methods><class-id>SmallSuiteGenerator.SMethodInfoTest</class-id> <category>tests</category><body package="SSG-Tests-Info" selector="testEquals">testEquals	self		assert: (STypeMethodInfo type: #name -&gt; #(#SStudent #ByteString #() false))		equals: (STypeMethodInfo type: #name -&gt; #(#SStudent #ByteString #() false)).	self		assert:			(STypeMethodInfo				type: #return: -&gt; #(#SFoo #ByteString #(#ByteString) false))		equals:			(STypeMethodInfo				type: #return: -&gt; #(#SFoo #ByteString #(#ByteString) false))</body><body package="SSG-Tests-Info" selector="testType">testType	| methodInfo |	methodInfo := STypeMethodInfo		type: #returnFloat -&gt; #(#SFoo #SmallFloat64 #() false).	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #SmallFloat64.	self assert: methodInfo allArgTypes isEmpty.	self deny: methodInfo isQuick.	self deny: methodInfo isDeprecated.	methodInfo := STypeMethodInfo		type: #returnString -&gt; #(#SFoo #ByteString #() false).	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #ByteString.	self assert: methodInfo allArgTypes isEmpty.	self deny: methodInfo isQuick.	methodInfo := STypeMethodInfo		type: #return: -&gt; #(#SFoo #OrderedCollection #(#OrderedCollection) false).	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #OrderedCollection.	self		assertCollection: methodInfo allArgTypes		hasSameElements: #(#OrderedCollection).	self deny: methodInfo isQuick.	methodInfo := STypeMethodInfo		type: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false).	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #SFoo.	self		assertCollection: methodInfo allArgTypes		hasSameElements: #(#SmallInteger).	self deny: methodInfo isQuick.	methodInfo := STypeMethodInfo		type: #score -&gt; #(#SFoo #SmallInteger #() true).	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #SmallInteger.	self assert: methodInfo argTypes isEmpty.	self assert: methodInfo isQuick</body></methods><methods><class-id>SmallSuiteGenerator.SInsertTest</class-id> <category>tests</category><body package="SSG-Tests-Core" selector="setUp">setUp	super setUp.	SPlatform fileLogger: 'SInsertTestLogger.log'</body></methods><methods><class-id>SmallSuiteGenerator.SInsertTest</class-id> <category>mutation-insert</category><body package="SSG-Tests-Core" selector="testInsertStatementAsParameterInMessage">testInsertStatementAsParameterInMessage	| testCase anExpression |	testCase := SSTestCase with: utility typeInfoSFoo4.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addFactoryMessage: (self fullSymbolOf: #SFoo);		addLiteral;		addMessage: #return: from: (self fullSymbolOf: #SFoo).	anExpression := testCase addLiteral.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := ' , (self fullNameOfClass: 'SFoo') asString , ' new.'				with: '_var1 := ' , SStudent new storeString , '.'				with: '_var2 := ' , SStudent new storeString , '.'				with: '_var3 := _var0 return: _var2.'				with: '_var4 := ' , SStudent new storeString , '.').	self		should: [ testCase				perform: #insertAsParameter:using:				inStatement: anExpression copy ]		raise: SError.	testCase addMessage: #return: from: (self fullSymbolOf: #SFoo).	testCase		perform: #insertAsParameter:using:		inStatement: anExpression copy.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := ' , (self fullNameOfClass: 'SFoo') asString , ' new.'				with: '_var1 := ' , SStudent new storeString , '.'				with: '_var2 := ' , SStudent new storeString , '.'				with: '_var3 := _var0 return: _var2.'				with: '_var4 := ' , SStudent new storeString , '.'				with: '_var5 := _var0 return: _var4.')</body><body package="SSG-Tests-Core" selector="testInsertStatementOfMixingSelectors">testInsertStatementOfMixingSelectors	| testCase fieldAccess message |	testCase := (SSTestCase with: utility typeInfosSStudent first)		addTargetClassName: (self fullSymbolOf: #SStudent);		addLiteral: (self fullSymbolOf: #SmallInteger);		addFactoryMessage: (self fullSymbolOf: #SStudent) ofSelector: #new;		addMessage: #scoreStudent: from: (self fullSymbolOf: #SStudent);		addFactoryMessage: (self fullSymbolOf: #SStudent) ofSelector: #new;		addFieldAccessMessage: #idStudent			from: (self fullSymbolOf: #SStudent);		yourself.	self		assertCollection: (testCase statements collect: #printString) allButLast		hasSameElements:			(Array				with: '_var0 := 1.'				with: '_var1 := ' , (self fullNameOfClass: 'SStudent') asString , ' new.'				with: '_var2 := 1.'				with: '_var3 := _var1 scoreStudent: _var2.'				with: '_var4 := ' , (self fullNameOfClass: 'SStudent') asString , ' new.').	self		assert:			(#('_var5 := _var4 idStudent.')				includes: (testCase statementOfVarName: '_var5') printString).	fieldAccess := testCase statementOfVarName: '_var5'.	message := (testCase statementOfVarName: '_var2') value.	message := testCase insertExpression: message copy after: fieldAccess.	self assert: message printString equals: '_var6 := 1.'	"message := testCase		perform: #insertAsParameter:using:		inStatement: fieldAccess.	self		assert: message printString		equals: '_var5 := _var1 scoreStudent: _var4.'"</body><body package="SSG-Tests-Core" selector="testInsertStatementOfSelectorAsParameterInFactoryMessage">testInsertStatementOfSelectorAsParameterInFactoryMessage	| testCase auxExpr expression |	testCase := SSTestCase with: utility typeInfoSFoo2.	testCase addTargetClassName: (self fullSymbolOf: #SFoo).	expression := testCase addFactoryMessage.	testCase addFactoryMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := ' , (self fullNameOfClass: 'SFoo') asString , ' new.'				with: '_var1 := ' , (self fullNameOfClass: 'SFoo') asString , ' new.').	auxExpr := testCase addMessage.	auxExpr value		receiver: (testCase statementOfVarName: '_var1') variable.	auxExpr := testCase		perform: #insertAsParameter:using:		inStatement: expression.	self		assert: auxExpr printString		equals: '_var3 := _var1 return: _var0.'</body><body package="SSG-Tests-Core" selector="testInsertStatementOfSelectorAsParameterInFieldMessage">testInsertStatementOfSelectorAsParameterInFieldMessage	| testCase aExpression |	testCase := (SSTestCase with: utility typeInfoSStack4)		addTargetClassName: (self fullSymbolOf: #SStack).	testCase		addFactoryMessage: (self fullSymbolOf: #SStack)		ofSelector: #newStack.	aExpression := testCase		addFieldAccessMessage: #lastLinkStack		from: (self fullSymbolOf: #SStack).	testCase addLiteral: (self fullSymbolOf: #SmallInteger).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := ' , (self fullNameOfClass: 'SStack') asString , ' newStack.'				with: '_var1 := _var0 lastLinkStack.'				with: '_var2 := 5.').	testCase addMessage: #push: from: (self fullSymbolOf: #SStack).	testCase		perform: #insertAsParameter:using:		inStatement: aExpression copy.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := ' , (self fullNameOfClass: 'SStack') asString , ' newStack.'				with: '_var1 := _var0 lastLinkStack.'				with: '_var2 := 5.'				with: '_var3 := 5.'				with: '_var4 := _var0 push: _var1.')</body><body package="SSG-Tests-Core" selector="testInsertStatementOfSelectorAsParameterInMessage">testInsertStatementOfSelectorAsParameterInMessage	| testCase aExpression |	testCase := (SSTestCase with: utility typeInfoSStack4)		addTargetClassName: (self fullSymbolOf: #SStack).	testCase		addFactoryMessage: (self fullSymbolOf: #SStack)		ofSelector: #newStackWith:.	aExpression := testCase		addMessage: #pop		from: (self fullSymbolOf: #SStack).	testCase addLiteral: (self fullSymbolOf: #SmallInteger).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := #(1 4 5 ).'				with:					'_var1 := ' , (self fullNameOfClass: 'SStack') asString						, ' newStackWith: _var0.'				with: '_var2 := _var1 pop.'				with: '_var3 := 5.').	testCase addMessage: #push: from: (self fullSymbolOf: #SStack).	testCase		perform: #insertAsParameter:using:		inStatement: aExpression copy.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := #(1 4 5 ).'				with:					'_var1 := ' , (self fullNameOfClass: 'SStack') asString						, ' newStackWith: _var0.'				with: '_var2 := _var1 pop.'				with: '_var3 := 5.'				with: '_var4 := _var1 push: _var2.')</body><body package="SSG-Tests-Core" selector="testInsertStatementOfSelectorMethodMessageInFactoryMessage">testInsertStatementOfSelectorMethodMessageInFactoryMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addFactoryMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.').	self		should: [ testCase insertStatementOfSelector: #insertMethodMessage:using: ]		raise: SError</body><body package="SSG-Tests-Core" selector="testInsertStatementOfSelectorMethodMessageInFieldMessage">testInsertStatementOfSelectorMethodMessageInFieldMessage	| testCase fieldMessage |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo).	fieldMessage := testCase addFieldAccessMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.'				with: '_var2 := _var1 score.').	self		should: [ testCase				perform: #insertMethodMessage:using:				inStatement: fieldMessage copy ]		raise: SError</body><body package="SSG-Tests-Core" selector="testInsertStatementOfSelectorMethodMessageInLiteral">testInsertStatementOfSelectorMethodMessageInLiteral	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addLiteral: (self fullSymbolOf: #SmallInteger).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 5.').	self		should: [ testCase insertStatementOfSelector: #insertMethodMessage:using: ]		raise: SError</body><body package="SSG-Tests-Core" selector="testInsertStatementOfSelectorMethodMessageInMessage">testInsertStatementOfSelectorMethodMessageInMessage	| testCase message |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo).	message := testCase		addMessage: #returnNum		from: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.'				with: '_var2 := _var1 returnNum.').	testCase		perform: #insertMethodMessage:using:		inStatement: message copy.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.'				with: '_var2 := _var1 returnNum.'				with: '_var3 := _var1 returnNum.')</body><body package="SSG-Tests-Core" selector="testInsertStatementOfSelectorRandomMessageInFactoryMessage">testInsertStatementOfSelectorRandomMessageInFactoryMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addFactoryMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.').	testCase insertStatementOfSelector: #insertRandomMessage:using:.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.'				with:					'_var2 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.')</body><body package="SSG-Tests-Core" selector="testInsertStatementOfSelectorRandomMessageInFieldMessage">testInsertStatementOfSelectorRandomMessageInFieldMessage	| testCase fieldMessage |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo).	fieldMessage := testCase addFieldAccessMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.'				with: '_var2 := _var1 score.').	testCase		perform: #insertRandomMessage:using:		inStatement: fieldMessage copy.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.'				with: '_var2 := _var1 score.'				with: '_var3 := _var1 score.')</body><body package="SSG-Tests-Core" selector="testInsertStatementOfSelectorRandomMessageInMessage">testInsertStatementOfSelectorRandomMessageInMessage	| testCase message |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo).	message := testCase		addMessage: #return:		from: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.'				with: '_var2 := ''hello''.'				with: '_var3 := _var1 return: _var2.').	testCase		perform: #insertRandomMessage:using:		inStatement: message copy.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.'				with: '_var2 := ''hello''.'				with: '_var3 := _var1 return: _var2.'				with: '_var4 := _var1 return: _var2.')</body></methods><methods><class-id>SmallSuiteGenerator.SGAMutationOperationTest</class-id> <category>running</category><body package="SSG-Tests-GA" selector="setUp">setUp	super setUp.	SPlatform resetRandomGenerator.	operation := SGAMutationOperation new.	utility := SUtilityTypeInfo new</body></methods><methods><class-id>SmallSuiteGenerator.SGAMutationOperationTest</class-id> <category>tests</category><body package="SSG-Tests-GA" selector="testMutation">testMutation	| testCase mutatedTestCase |	testCase := SSTestCase with: utility typeInfoSStack3.	testCase numMaxStatements: 10.	testCase		addTargetClassName: (self fullSymbolOf: #SStack);		generateStatements.	mutatedTestCase := operation mutate: testCase.	mutatedTestCase := operation mutate: mutatedTestCase.	self assert: mutatedTestCase validReferences</body><body package="SSG-Tests-GA" selector="testMutationSSteacher">testMutationSSteacher	| typeInfo testCase mutatedTestCase |	typeInfo := utility typeInfoSSTeacher1.	testCase := SSTestCase with: typeInfo.	testCase		addTargetClassName: (self fullSymbolOf: #SSTeacher);		generateStatements.	mutatedTestCase := operation mutate: testCase.	mutatedTestCase := operation mutate: mutatedTestCase.	self assert: mutatedTestCase validReferences</body><body package="SSG-Tests-GA" selector="testMutationSStudentManual">testMutationSStudentManual	| testCase mutatedTestCase testSuite |	testSuite := utility testSuiteSStudentManual.	testCase := testSuite first.	"testCase generateStatements."	mutatedTestCase := operation mutate: testCase.	mutatedTestCase := operation mutate: mutatedTestCase.	self assert: mutatedTestCase validReferences.	testCase := testSuite second.	"testCase generateStatements."	mutatedTestCase := operation mutate: testCase.	mutatedTestCase := operation mutate: mutatedTestCase.	self assert: mutatedTestCase validReferences</body><body package="SSG-Tests-GA" selector="testMutationSStudentWithValidReferences">testMutationSStudentWithValidReferences	| testCase mutatedTestCase testSuite |	testSuite := utility testSuiteSStudentManual.	testCase := testSuite third.	"testCase generateStatements."	mutatedTestCase := operation mutate: testCase.	mutatedTestCase := operation mutate: mutatedTestCase.	self assert: mutatedTestCase validReferences.	testCase := testSuite third.	"testCase generateStatements."	mutatedTestCase := operation mutate: testCase.	mutatedTestCase := operation mutate: mutatedTestCase.	self assert: mutatedTestCase validReferences</body></methods><methods><class-id>SmallSuiteGenerator.SExtensionsTest</class-id> <category>tests</category><body package="SSG-Tests-Core" selector="createStudent">createStudent	^ SStudent new		name: 'Pedro';		id: 5</body><body package="SSG-Tests-Core" selector="testMutateToChange">testMutateToChange	self assert: true mutateToChange equals: false.	self assert: false mutateToChange equals: true.	self deny: 1234 mutateToChange equals: 1234.	self deny: 23.34 mutateToChange equals: 23.34.	self deny: $e mutateToChange equals: $e.	self deny: '$character' mutateToChange equals: '$character'.	self deny: 'hello' mutateToChange equals: 'hello'.	self assert: #(1 2 5 6) mutateToChange equals: #(1 2 5 6).	self deny: '#(1 2 5 6' mutateToChange equals: '#(1 2 5 6'.	self		assert: (SStack newStackWith: #(1 6 2 4)) mutateToChange		equals: (SStack newStackWith: #(1 6 2 4)).	self		assert: self createStudent mutateToChange storeString		equals: self createStudent storeString</body><body package="SSG-Tests-Core" selector="testStoreString">testStoreString	self assert: 1 storeString equals: '1'.	self assert: 4.6 storeString equals: '4.6'.	self assert: true storeString equals: 'true'.	self assert: false storeString equals: 'false'.	self assert: 'hello' storeString equals: '''hello'''.	self assert: $d storeString equals: '$d'.	self assert: (SSTeacher new name: 'Mary') storeString isNotEmpty.	self assert: (SStudent new name: 'Alan') storeString isNotEmpty</body></methods><methods><class-id>SmallSuiteGenerator.SStack</class-id> <category>adding</category><body package="SSG-Scenario" selector="push:">push: anObject	self addFirst: anObject.	^ anObject</body></methods><methods><class-id>SmallSuiteGenerator.SStack</class-id> <category>accessing</category><body package="SSG-Scenario" selector="firstLinkStack">firstLinkStack	^ firstLink</body><body package="SSG-Scenario" selector="lastLinkStack">lastLinkStack	^ lastLink</body><body package="SSG-Scenario" selector="top">top	self isEmpty		ifTrue: [ ^ nil ]		ifFalse: [ ^ self firstLink value ]</body></methods><methods><class-id>SmallSuiteGenerator.SStack</class-id> <category>removing</category><body package="SSG-Scenario" selector="pop">pop	self isEmpty		ifTrue: [ ^ nil ]		ifFalse: [ ^ self removeFirst ]</body></methods><methods><class-id>SmallSuiteGenerator.SStack class</class-id> <category>instance creation</category><body package="SSG-Scenario" selector="newStack">newStack	^ self new</body><body package="SSG-Scenario" selector="newStackWith:">newStackWith: aList	| inst |	inst := self newStack.	aList do: [ :element | inst push: element ].	^ inst</body></methods><methods><class-id>SmallSuiteGenerator.SChangeTest</class-id> <category>mutation-change</category><body package="SSG-Tests-Core" selector="testChangeStatementOfFactoryMessageWithAbstractClass">testChangeStatementOfFactoryMessageWithAbstractClass	| testCase changed |	testCase := SSTestCase with: utility typeInfoArrayedCollection.	testCase		addTargetClassName: (self fullSymbolOf: #ArrayedCollection);		addFactoryMessage;		addLiteral;		addFactoryMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with:					'_var0 := ' , (self fullNameOfClass: 'ArrayedCollection') asString						, ' new.'				with: '_var1 := ''hello''.'				with:					'_var2 := ' , (self fullNameOfClass: 'ArrayedCollection') asString						, ' new.').	changed := testCase		changeStatementOfClassName: (self fullSymbolOf: #ArrayedCollection).	self assert: changed equals: false.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var1 := ''hello''.')</body><body package="SSG-Tests-Core" selector="testChangeStatementOfFactoryMessageWithOneLiteral">testChangeStatementOfFactoryMessageWithOneLiteral	| testCase expressionChanged |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addFactoryMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.').	expressionChanged := testCase changeStatementOfVarName: '_var1'.	self		assert:			((Array				with: '_var0 := ' , (self fullNameOfClass: 'SFoo') asString , ' new.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var2.') includes: expressionChanged printString).	self assert: testCase validReferences</body><body package="SSG-Tests-Core" selector="testChangeStatementOfFieldAccessMessage">testChangeStatementOfFieldAccessMessage	| testCase exprField exprFieldChanged |	testCase := SSTestCase with: utility typeInfoSStack4.	testCase		addTargetClassName: (self fullSymbolOf: #SStack);		addFactoryMessage: (self fullSymbolOf: #SStack)			ofSelector: #newStack.	exprField := (testCase		addFieldAccessMessage: #firstLinkStack		from: (self fullSymbolOf: #SStack)) copy.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := ' , (self fullNameOfClass: 'SStack') asString , ' newStack.'				with: '_var1 := _var0 firstLinkStack.').	exprFieldChanged := testCase changeStatement: exprField.	self		assert:			(#('_var1 := _var0 lastLinkStack.' '_var1 := _var3 firstLinkStack.' '_var1 := _var2 firstLinkStack.')				includes: exprFieldChanged printString).	self assert: testCase validReferences</body><body package="SSG-Tests-Core" selector="testChangeStatementOfLiteral">testChangeStatementOfLiteral	| testCase exprLiteral exprLiteralChanged |	testCase := SSTestCase with: utility typeInfoSStack4.	exprLiteral := (testCase		addLiteral: (self fullSymbolOf: #SmallInteger)) copy.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 5.').	exprLiteralChanged := testCase changeStatementOfVarName: '_var0'.	self deny: exprLiteral equals: exprLiteralChanged.	self assert: testCase validReferences</body><body package="SSG-Tests-Core" selector="testChangeStatementOfMessage">testChangeStatementOfMessage	| testCase exprMessage exprLiteralChanged |	testCase := SSTestCase with: utility typeInfoSStack4.	testCase		addTargetClassName: (self fullSymbolOf: #SStack);		addFactoryMessage: (self fullSymbolOf: #SStack)			ofSelector: #newStack.	exprMessage := (testCase		addMessage: #pop		from: (self fullSymbolOf: #SStack)) copy.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := ' , (self fullNameOfClass: 'SStack') asString , ' newStack.'				with: '_var1 := _var0 pop.').	exprLiteralChanged := testCase changeStatement: exprMessage.	self		assert:			(#('_var1 := _var0 top.' '_var1 := _var0 push: _var2.' '_var1 := _var3 pop.' '_var1 := _var2 pop.')				includes: exprLiteralChanged printString).	self assert: testCase validReferences</body></methods><methods><class-id>SmallSuiteGenerator.SMessageTest</class-id> <category>tests</category><body package="SSG-Tests-AST" selector="testCopy">testCopy	| message copy |	message := SMessage new		receiver:			(SVariable new				id: 1;				returnType: #SFoo);		selector: #return:;		args:			(Array				with:					(SVariable new						id: 2;						returnType: #ByteString));		returnType: #ByteString.	self assert: message printString equals: '_var1 return: _var2'.	copy := message copy.	copy value args first id: 5.	self assert: copy printString equals: '_var1 return: _var5'.	copy value receiver varName: '_sfoo'.	copy value receiver id: 4.	self assert: copy printString equals: '_sfoo4 return: _var5'.	copy value selector: #returnValue:.	self assert: copy printString equals: '_sfoo4 returnValue: _var5'.	self assert: message printString equals: '_var1 return: _var2'</body><body package="SSG-Tests-AST" selector="testInsertAsParameterUsing">testInsertAsParameterUsing	| testCase aExpression insertedExpression |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: (self fullSymbolOf: #SFoo);		addFactoryMessage: (self fullSymbolOf: #SFoo);		addLiteral: (self fullSymbolOf: #ByteString).	aExpression := testCase		addMessage: #returnString		from: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.'				with: '_var2 := ''hello''.'				with: '_var3 := _var1 returnString.').	testCase addMessage: #return: from: (self fullSymbolOf: #SFoo).	insertedExpression := aExpression		insertAsParameter: aExpression		using: testCase.	self		assert:			(#('_var4 := _var1 return: _var3.')				includes: insertedExpression printString)</body><body package="SSG-Tests-AST" selector="testInsertMethodMessageUsing">testInsertMethodMessageUsing	| testCase message |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf: #SFoo).	message := testCase		addMessage: #return:		from: (self fullSymbolOf: #SFoo).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.'				with: '_var2 := ''hello''.'				with: '_var3 := _var1 return: _var2.').	message insertMethodMessage: message using: testCase.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3.'				with:					'_var1 := ' , (self fullNameOfClass: 'SFoo') asString						, ' score: _var0.'				with: '_var2 := ''hello''.'				with: '_var3 := _var1 return: _var2.'				with: '_var4 := _var1 return: _var2.')</body></methods><methods><class-id>SmallSuiteGenerator.SObject</class-id> <category>as yet unclassified</category><body package="SSG-Core" selector="next">next	^ self random next</body><body package="SSG-Core" selector="random">random	^ SPlatform randomGenerator</body></methods><methods><class-id>SmallSuiteGenerator.SObject class</class-id> <category>instance creation</category><body package="SSG-Core" selector="new">new	"Answer a newly created and initialized instance."	^ super new initialize</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngineExample</class-id> <category>examples - onPackages</category><body package="SSG-GA" selector="exampleSStackOnPackageWithSMethodCoverage">exampleSStackOnPackageWithSMethodCoverage	| engine classFitness |	classFitness := SMethodCoverage.	engine := self		runOnPackagesMatching: 'SmallSuiteGenerator-Examples'		withBlock: [ (SStack newStackWith: #(2 4 6 1))				push: 8;				pop;				top ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName)				&lt;=					(engine logs last fittestTestCase fitness						at: classFitness functionName).	engine clean</body><body package="SSG-GA" selector="exampleSStackOnPackageWithSStatementCoverage">exampleSStackOnPackageWithSStatementCoverage	| engine classFitness |	classFitness := SMethodCoverage.	engine := self		runOnPackagesMatching: 'SmallSuiteGenerator-Examples'		withBlock: [ (SStack newStackWith: #(2 4 6 1))				push: 8;				pop;				top ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName)				&lt;=					(engine logs last fittestTestCase fitness						at: classFitness functionName).	engine clean</body><body package="SSG-GA" selector="exampleSSTeacherOnPackageWithSMethodCoverage">exampleSSTeacherOnPackageWithSMethodCoverage	| engine classFitness |	classFitness := SMethodCoverage.	engine := self		runOnPackagesMatching: 'SmallSuiteGenerator-Examples'		withBlock: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName)				&lt;=					(engine logs last fittestTestCase fitness						at: classFitness functionName).	engine clean</body><body package="SSG-GA" selector="exampleSSTeacherOnPackageWithSStatementCoverage">exampleSSTeacherOnPackageWithSStatementCoverage	| engine classFitness |	classFitness := SStatementCoverage.	engine := self		runOnPackagesMatching: 'SmallSuiteGenerator-Examples'		withBlock: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName)				&lt;=					(engine logs last fittestTestCase fitness						at: classFitness functionName).	engine clean</body><body package="SSG-GA" selector="exampleSStudentOnPackageWithSMethodCoverage">exampleSStudentOnPackageWithSMethodCoverage	| engine classFitness |	classFitness := SMethodCoverage.	engine := self		runOnPackagesMatching: 'SmallSuiteGenerator-Scenario2'		withBlock: [ (SStudent name: 'Ann' with: 34)				nickname;				idStudent;				scoreStudent: 45;				scoreStudent ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName)				&lt;=					(engine logs last fittestTestCase fitness						at: classFitness functionName).	engine clean</body><body package="SSG-GA" selector="exampleSStudentOnPackageWithSStatementCoverage">exampleSStudentOnPackageWithSStatementCoverage	| engine classFitness |	classFitness := SStatementCoverage.	engine := self		runOnPackagesMatching: 'SmallSuiteGenerator-Scenario2'		withBlock: [ (SStudent name: 'Ann' with: 34)				nickname;				idStudent;				scoreStudent: 45;				scoreStudent ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName)				&lt;=					(engine logs last fittestTestCase fitness						at: classFitness functionName).	engine clean</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngineExample</class-id> <category>examples - onClass</category><body package="SSG-GA" selector="exampleSStackOnClassWithSMethodCoverage">exampleSStackOnClassWithSMethodCoverage	| engine classFitness |	classFitness := SMethodCoverage.	engine := self		runOnClass: SStack		withBlock: [ (SStack newStackWith: #(2 4 6 1))				push: 8;				pop;				top ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName) &gt;= 14.28.	"14.28 = (1/7) * 100 round: 2"	self		assert:			(engine logs last fittestTestCase fitness				at: classFitness functionName) &gt;= 57.14.	"57.14 = (4/7) * 100 round: 2"	engine clean</body><body package="SSG-GA" selector="exampleSStackOnClassWithSStatementCoverage">exampleSStackOnClassWithSStatementCoverage	| engine classFitness |	classFitness := SStatementCoverage.	engine := self		runOnClass: SStack		withBlock: [ (SStack newStackWith: #(2 4 6 1))				push: 8;				pop;				top ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName) &gt;= 21.05.	"21.05 = (4/19) * 100 round: 2"	self		assert:			(engine logs last fittestTestCase fitness				at: classFitness functionName) &gt;= 73.68.	"73.68 = (14/19) * 100 round: 2"	engine clean</body><body package="SSG-GA" selector="exampleSSTeacherOnClassWithSMethodCoverage">exampleSSTeacherOnClassWithSMethodCoverage	| engine classFitness |	classFitness := SMethodCoverage.	engine := self		runOnClass: SSTeacher		withBlock: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName) &gt;= 20.	"20 = (1/5) * 100"	self		assert:			(engine logs last fittestTestCase fitness				at: classFitness functionName)		equals: 80.	"80 = (4/5) * 100"	engine clean</body><body package="SSG-GA" selector="exampleSSTeacherOnClassWithSStatementCoverage">exampleSSTeacherOnClassWithSStatementCoverage	| engine classFitness |	classFitness := SStatementCoverage.	engine := self		runOnClass: SSTeacher		withBlock: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		andFitness: classFitness.	self		assert:			(engine logs last fittestTestCase fitness				at: classFitness functionName) &gt;= 37.5.	"37.5 = (3/8) * 100"	self		assert:			(engine logs last fittestTestCase fitness				at: classFitness functionName) &gt;= 87.5.	"87.5 = (7/8) * 100"	engine clean</body><body package="SSG-GA" selector="exampleSStudentOnClassWithSMethodCoverage">exampleSStudentOnClassWithSMethodCoverage	| engine classFitness |	classFitness := SMethodCoverage.	engine := self		runOnClass: SStudent		withBlock: [ (SStudent name: 'Ann' with: 34)				nickname;				idStudent;				scoreStudent: 45;				scoreStudent ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName) &gt;= 20.	self		assert:			(engine logs last fittestTestCase fitness				at: classFitness functionName)		equals: 100.	engine clean</body><body package="SSG-GA" selector="exampleSStudentOnClassWithSStatementCoverage">exampleSStudentOnClassWithSStatementCoverage	| engine classFitness |	classFitness := SStatementCoverage.	engine := self		runOnClass: SStudent		withBlock: [ (SStudent name: 'Ann' with: 34)				nickname;				idStudent;				scoreStudent: 45;				scoreStudent ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName) &gt;= 37.5.	self		assert:			(engine logs last fittestTestCase fitness				at: classFitness functionName)		equals: 100.	engine clean</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractClass</class-id> <category>As yet unclassified</category><body package="SSG-Scenario2">initialize	id := 1</body><body package="SSG-Scenario2">id: anObject	id := anObject</body><body package="SSG-Scenario2">id	^ id</body><body package="SSG-Scenario2">identifier	^ self subclassResponsibility</body></methods><methods><class-id>SmallSuiteGenerator.SSubclassChild</class-id> <category>As yet unclassified</category><body package="SSG-Scenario2">identifier	^ self className , '_' , self id asString</body></methods><methods><class-id>SmallSuiteGenerator.SStudent</class-id> <category>As yet unclassified</category><body package="SSG-Scenario2">idStudent	^ idStudent</body><body package="SSG-Scenario2">scoreStudent	^ scoreStudent</body><body package="SSG-Scenario2">initialize	id := 1.	scoreStudent := 1.	idStudent := id</body><body package="SSG-Scenario2">nickname	^ 'student_' , (nickname ifNil: [ '1' ])</body><body package="SSG-Scenario2">scoreStudent: aNumber	scoreStudent := aNumber</body></methods><methods><class-id>SmallSuiteGenerator.SGALog</class-id> <category>accessing</category><body package="SSG-GA" selector="averageFit">averageFit	^ averageFit</body><body package="SSG-GA" selector="averageFit:">averageFit: aNumber	averageFit := aNumber</body><body package="SSG-GA" selector="averageTestSize">averageTestSize	^ (self population collect: [ :x | x statements size ]) average		asFloat</body><body package="SSG-GA" selector="fitness">fitness	^ fittestTestCase fitness</body><body package="SSG-GA" selector="fittestTestCase">fittestTestCase	^ fittestTestCase</body><body package="SSG-GA" selector="fittestTestCase:">fittestTestCase: anTestCase	fittestTestCase := anTestCase</body><body package="SSG-GA" selector="generationNumber">generationNumber	^ generationNumber</body><body package="SSG-GA" selector="generationNumber:">generationNumber: anObject	generationNumber := anObject</body><body package="SSG-GA" selector="lowestFit">lowestFit	^ lowestFit</body><body package="SSG-GA" selector="lowestFit:">lowestFit: aNumber	lowestFit := aNumber</body><body package="SSG-GA" selector="mutationResult:">mutationResult: mutationTestingResult	self		assert: mutationResult isEmpty		description: 'The analysis of mutants has already been calculated'.	[ mutationResult		at: 'noEvaluatedMutants'			put: mutationTestingResult numberOfEvaluatedMutants;		at: 'noKilledOrTerminatedMutants'			put: mutationTestingResult numberOfKilledOrTerminatedMutants;		at: 'noAliveMutants'			put: mutationTestingResult numberOfAliveMutants;		at: 'mutationScore' put: mutationTestingResult mutationScore ]		on: Exception		do: [ nil ]</body><body package="SSG-GA" selector="percentageOftestCasesWithErrors">percentageOftestCasesWithErrors	^ ((population select: [ :e | e hasErrors ]) size / population size)		asFloat</body><body package="SSG-GA" selector="population">population	^ population</body><body package="SSG-GA" selector="population:">population: anObject	population := anObject</body><body package="SSG-GA" selector="summaryTargetClass">summaryTargetClass	^ summaryTargetClass</body><body package="SSG-GA" selector="summaryTargetClass:">summaryTargetClass: anObject	summaryTargetClass := anObject</body><body package="SSG-GA" selector="timeToProduceGeneration:">timeToProduceGeneration: anInteger	timeToProduceGeneration := anInteger</body><body package="SSG-GA" selector="typeInfoGeneration">typeInfoGeneration	^ typeInfoGeneration</body><body package="SSG-GA" selector="typeInfoGeneration:">typeInfoGeneration: anObject	typeInfoGeneration := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SGALog</class-id> <category>initialization</category><body package="SSG-GA" selector="exportDataCSV:withFilter:">exportDataCSV: neoCSVWriter withFilter: aSymbol	(self filteredMethodsBy: aSymbol)		doWithIndex: [ :each :i | each writeDataCSV: neoCSVWriter withIndex: i ]</body><body package="SSG-GA" selector="filteredMethodsBy:">filteredMethodsBy: aSymbol	^ ((self selectorsFilter includes: aSymbol)		ifTrue: [ self summaryTargetClass select: aSymbol ]		ifFalse: [ self summaryTargetClass ]) select: #isNotNil</body><body package="SSG-GA" selector="initialize">initialize	mutationResult := Dictionary new</body><body package="SSG-GA" selector="selectorsFilter">selectorsFilter	^ #(#executed #unexecuted #notAllBlocksExecuted #allBlocksExecuted)</body></methods><methods><class-id>SmallSuiteGenerator.SGALog</class-id> <category>printing</category><body package="SSG-GA" selector="printOn:">printOn: str	super printOn: str.	str		nextPut: $&lt;;		nextPutAll: fittestTestCase statements printString;		nextPut: $&gt;</body></methods><methods><class-id>SmallSuiteGenerator.SGALog class</class-id> <category>as yet unclassified</category><body package="SSG-GA" selector="collectFitnessByNameOf:">collectFitnessByNameOf: population	| dictFit |	dictFit := Dictionary new.	((population collect: #fitness) flatCollect: #associations)		do: [ :assoc | 			| aValue |			aValue := dictFit				at: assoc key				ifAbsentPut: [ OrderedCollection new ].			aValue add: assoc value ].	^ dictFit</body><body package="SSG-GA" selector="logOf:inGeneration:inTime:">logOf: aSGAEngine inGeneration: anInteger inTime: t	| log dictFitness |	log := self new		generationNumber: anInteger;		fittestTestCase: aSGAEngine population first;		timeToProduceGeneration: Time new asSeconds - t;		population: aSGAEngine population.	dictFitness := self collectFitnessByNameOf: aSGAEngine population.	log		lowestFit: aSGAEngine population last fitness;		averageFit: (self pickAverageFitTest: dictFitness).	log		summaryTargetClass: (aSGAEngine fitness runPopulation: aSGAEngine population).	log		typeInfoGeneration: (aSGAEngine typeInfo classAt: aSGAEngine targetClassName) deepCopy.	^ log</body><body package="SSG-GA" selector="pickAverageFitTest:">pickAverageFitTest: aDictionary	^ (aDictionary keys		collect: [ :key | key -&gt; (aDictionary at: key) average ])		asDictionary</body></methods><methods><class-id>SmallSuiteGenerator.SPlatform class</class-id> <category>tests</category><body package="SSG-Core" selector="createTestCaseClass:inPackage:">createTestCaseClass: aClassName inPackage: aPackageName	^ self configurationClass		createTestCaseClass: aClassName		inPackage: aPackageName</body><body package="SSG-Core" selector="testCaseClass">testCaseClass	^ self configurationClass testCaseClass</body></methods><methods><class-id>SmallSuiteGenerator.SPlatform class</class-id> <category>accessing</category><body package="SSG-Core" selector="asDict">asDict	asDict ifNil: [ asDict := false ].	^ asDict</body><body package="SSG-Core" selector="asDict:">asDict: aBoolean	asDict := aBoolean</body><body package="SSG-Core" selector="classConfigurationName">classConfigurationName	^ self subclassResponsibility</body><body package="SSG-Core" selector="classTestCaseFactory">classTestCaseFactory	^ self configurationClass classTestCaseFactory</body><body package="SSG-Core" selector="configurationClass">configurationClass	configurationClass		ifNil: [ configurationClass := self subclasses				detect: [ :aClass | 					[ Smalltalk at: aClass classConfigurationName.					true ]						on: Error						do: [ false ] ]				ifNone: [ nil ].			configurationClass				ifNil: [ self error: 'Error to look a configurationClass' ] ].	^ configurationClass</body><body package="SSG-Core" selector="defaultLogName">defaultLogName	^ 'SmallSuiteLogger.log'</body><body package="SSG-Core" selector="defaultSeed">defaultSeed	^ 100</body><body package="SSG-Core" selector="implementationType">implementationType	^ self subclassResponsibility</body><body package="SSG-Core" selector="initLevelToPrint">initLevelToPrint	level := 10</body><body package="SSG-Core" selector="levelToPrint">levelToPrint	^ level</body><body package="SSG-Core" selector="logName">logName	^ logName ifNil: [ self defaultLogName ]</body><body package="SSG-Core" selector="logName:">logName: string	logName := string</body><body package="SSG-Core" selector="lookUpClass:">lookUpClass: aClassName	^ Smalltalk at: aClassName ifAbsent: [ nil ]</body><body package="SSG-Core" selector="randomGenerator">randomGenerator	randomGenerator ifNil: [ randomGenerator := self newRandomGenerator ].	^ randomGenerator</body><body package="SSG-Core" selector="randomGenerator:">randomGenerator: sRandom	randomGenerator := sRandom</body><body package="SSG-Core" selector="resetRandomGenerator">resetRandomGenerator	self randomGenerator: self newRandomGenerator</body><body package="SSG-Core" selector="seed">seed	seed ifNil: [ seed := self defaultSeed ].	^ seed</body></methods><methods><class-id>SmallSuiteGenerator.SPlatform class</class-id> <category>instance creation</category><body package="SSG-Core" selector="fileLogger:">fileLogger: fileName	self configurationClass fileLogger: fileName</body><body package="SSG-Core" selector="newRandomGenerator">newRandomGenerator	^ SRandom seed: self seed</body><body package="SSG-Core" selector="seed:">seed: aNumber	seed := aNumber</body></methods><methods><class-id>SmallSuiteGenerator.SPlatform class</class-id> <category>logging</category><body package="SSG-Core" selector="cleanAllLogs">cleanAllLogs	self configurationClass cleanAllLogs</body><body package="SSG-Core" selector="clearLog">clearLog	self configurationClass clearLog</body><body package="SSG-Core" selector="saveOnLog:">saveOnLog: message	self configurationClass saveOnLog: message</body></methods><methods><class-id>SmallSuiteGenerator.SPlatform class</class-id> <category>actions</category><body package="SSG-Core" selector="reduceLevel">reduceLevel	level ifNil: [ self initLevelToPrint ].	level := level - 1</body></methods><methods><class-id>SmallSuiteGenerator.SPlatform class</class-id> <category>initialization</category><body package="SSG-Core" selector="resetConfigurationClass">resetConfigurationClass	configurationClass := nil</body></methods><methods><class-id>SmallSuiteGenerator.SPlatform class</class-id> <category>settings</category><body package="SSG-Core" selector="rbParserClass">rbParserClass	^ self configurationClass rbParserClass</body></methods><methods><class-id>SmallSuiteGenerator.STypeObjectInfo</class-id> <category>actions</category><body package="SSG-Info" selector="joinWith:">joinWith: otherObject	self subclassResponsibility</body></methods><methods><class-id>SmallSuiteGenerator.STypeObjectInfo class</class-id> <category>instance creation</category><body package="SSG-Info" selector="instance">instance	^ self new</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>adding</category><body package="SSG-Info" selector="addClassMethod:">addClassMethod: methodTypeInfo	"methodTypeInfo typeInfo: typeInfo."	classMethodTypes		at: methodTypeInfo selector		ifPresent: [ :methInfo | methInfo joinWith: methodTypeInfo ]		ifAbsentPut: methodTypeInfo.	self addScalars: methodTypeInfo scalars</body><body package="SSG-Info" selector="addClassMethods:">addClassMethods: methodTypeInfos	methodTypeInfos		do: [ :aMethodType | self addClassMethod: aMethodType ]</body><body package="SSG-Info" selector="addMethod:">addMethod: methodTypeInfo	"methodTypeInfo typeInfo: typeInfo."	methodTypes		at: methodTypeInfo selector		ifPresent: [ :methInfo | methInfo joinWith: methodTypeInfo ]		ifAbsentPut: [ methodTypeInfo ].	self addScalars: methodTypeInfo scalars</body><body package="SSG-Info" selector="addMethods:">addMethods: methodTypeInfos	methodTypeInfos do: [ :aMethodType | self addMethod: aMethodType ]</body><body package="SSG-Info" selector="addScalars:">addScalars: aDictionary	aDictionary associations		do: [ :assoc | 			scalars				at: assoc key				ifPresent:					[ :values | scalars at: assoc key put: (values union: assoc value) asArray ]				ifAbsentPut: [ assoc value asArray ] ]</body><body package="SSG-Info" selector="difference:">difference: anotherClassInfo	^ (OrderedCollection		withAll: (self differenceWith: anotherClassInfo usingSelector: #methodTypes))		addAll:			(self				differenceWith: anotherClassInfo				usingSelector: #classMethodTypes);		yourself</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>accessing - read only</category><body package="SSG-Info" selector="allMethods">allMethods	^ methodTypes values , classMethodTypes values</body><body package="SSG-Info" selector="classMethodOf:">classMethodOf: aSelector	^ classMethodTypes at: aSelector</body><body package="SSG-Info" selector="methodOf:">methodOf: aSelector	^ methodTypes at: aSelector</body><body package="SSG-Info" selector="reportFrequencyByFilter:">reportFrequencyByFilter: aSelector	^ (self filteredMethodsBy: aSelector) size</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>accessing</category><body package="SSG-Info" selector="classMethodTypes">classMethodTypes	^ classMethodTypes</body><body package="SSG-Info" selector="filteredMethodsBy:">filteredMethodsBy: aSymbol	^ (STypeMethodInfo selectorsFilter includes: aSymbol)		ifTrue: [ self allMethods select: aSymbol ]		ifFalse: [ self remainingOrAllMethods: aSymbol ]</body><body package="SSG-Info" selector="methodTypes">methodTypes	^ methodTypes</body><body package="SSG-Info" selector="remainingOrAllMethods:">remainingOrAllMethods: aSymbol	^ aSymbol = #others		ifTrue: [ | methods |			methods := self allMethods.			STypeMethodInfo selectorsFilter				do: [ :key | methods := methods reject: key ].			methods ]		ifFalse: [ self allMethods ]</body><body package="SSG-Info" selector="scalars">scalars	^ scalars</body><body package="SSG-Info" selector="typeName">typeName	^ typeName</body><body package="SSG-Info" selector="typeName:">typeName: anObject	typeName := anObject</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>initialization</category><body package="SSG-Info" selector="initialize">initialize	methodTypes := Dictionary new.	classMethodTypes := Dictionary new.	scalars := Dictionary new</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>copying</category><body package="SSG-Info" selector="copy">copy	| copy |	copy := self class instance.	methodTypes do: [ :methodType | copy addMethod: methodType copy ].	classMethodTypes		do: [ :classMethodType | copy addClassMethod: classMethodType copy ].	copy typeName: typeName.	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>private</category><body package="SSG-Info" selector="accessMessages">accessMessages	^ self messagesAndAccessMessages select: #isQuick</body><body package="SSG-Info" selector="factoryMessages">factoryMessages	^ classMethodTypes values		reject: [ :method | method selector = #basicNew ]</body><body package="SSG-Info" selector="factoryMessagesFrom:">factoryMessagesFrom: aClassName	^ self factoryMessages		select: [ :factMessage | 			(factMessage isFromReceiver: aClassName)				and: [ factMessage isWithReturnType: aClassName ] ]</body><body package="SSG-Info" selector="messages">messages	^ self messagesAndAccessMessages reject: #isQuick</body><body package="SSG-Info" selector="messagesAndAccessMessages">messagesAndAccessMessages	^ methodTypes values		select:			[ :methType | methType isDeprecated not and: [ methType returnType isNil not ] ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>actions</category><body package="SSG-Info" selector="exportDataCSV:withFilter:">exportDataCSV: neoCSVWriter withFilter: aSymbol	self		writeDataCSV: neoCSVWriter		using: (self filteredMethodsBy: aSymbol)</body><body package="SSG-Info" selector="joinWith:">joinWith: otherTypeClass	otherTypeClass methodTypes do: [ :aMethod | self addMethod: aMethod ].	otherTypeClass classMethodTypes		do: [ :aMethod | self addClassMethod: aMethod ]</body><body package="SSG-Info" selector="typeClassMethod:">typeClassMethod: aAssoc	self addClassMethod: (STypeMethodInfo type: aAssoc)</body><body package="SSG-Info" selector="typeMethod:">typeMethod: aAssoc	self addMethod: (STypeMethodInfo type: aAssoc)</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>converting</category><body package="SSG-Info" selector="asClassInfo:">asClassInfo: aSpyClass	| aTypeClass instanceMethods classMethods |	aTypeClass := self class newFrom: aSpyClass typeName.	instanceMethods := self instanceMethodsFor: aSpyClass.	classMethods := self classMethodsFor: aSpyClass.	aTypeClass		addMethods:			(instanceMethods				collect: [ :instMeth | STypeMethodInfo asMethodInfo: instMeth ]);		addClassMethods:			(classMethods				collect: [ :instMeth | STypeMethodInfo asMethodInfo: instMeth ]).	^ aTypeClass</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>accesing</category><body package="SSG-Info" selector="instanceMethodsFor:">instanceMethodsFor: aSpyClass	| instanceMethods |	instanceMethods := OrderedCollection new.	(aSpyClass typeName endsWith: ' class')		ifFalse: [ instanceMethods := (aSpyClass methods reject: #isTest)				select: [ :instMeth | instMeth wasExecuted or: [ instMeth isUnary ] ].			instanceMethods				do: [ :instMeth | 					instMeth wasExecuted						ifFalse: [ instMeth numberOfExecutions: 0.5.							instMeth returnValue: SUndefinedObject basicNew.							instMeth saveReceiver: instMeth originalMethod origin ] ] ].	^ instanceMethods</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>writing</category><body package="SSG-Info" selector="writeDataCSV:using:">writeDataCSV: neoCSVWriter using: methods	methods		do: [ :aMethod | 			neoCSVWriter				nextPut: (Array with: typeName printString) , aMethod dataCSV ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>acccessing</category><body package="SSG-Info" selector="classMethodsFor:">classMethodsFor: aSpyClass	| classMethods |	classMethods := OrderedCollection new.	(aSpyClass metaclassSpy typeName endsWith: ' class')		ifTrue: [ classMethods := (aSpyClass metaclassSpy methods reject: #isTest)				select:					[ :clsMethod | clsMethod wasExecuted and: [ clsMethod isValidReturnTypeWithReceiver ] ] ].	^ classMethods</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>comparing</category><body package="SSG-Info" selector="=">= other	^ self class = other class		and: [ typeName = other typeName				and: [ methodTypes = other methodTypes						and: [ classMethodTypes = other classMethodTypes ] ] ]</body><body package="SSG-Info" selector="hash">hash	^ typeName hash		bitXor: (methodTypes hash bitXor: classMethodTypes hash)</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo class</class-id> <category>accessing structure variables</category><body package="SSG-Info" selector="type:">type: aAssoc	| dataOfAllMethods inst dataMethods dataClassMethods |	inst := self new typeName: aAssoc key.	dataOfAllMethods := aAssoc value.	dataMethods := dataOfAllMethods first.	dataClassMethods := dataOfAllMethods second.	dataMethods do: [ :data | inst typeMethod: data ].	dataClassMethods do: [ :data | inst typeClassMethod: data ].	inst methodTypes do: [ :meth | meth executions: 1 ].	^ inst</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo class</class-id> <category>converting</category><body package="SSG-Info" selector="asClassInfo:">asClassInfo: aSpyClass	^ self new asClassInfo: aSpyClass</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo class</class-id> <category>instance creation</category><body package="SSG-Info" selector="newFrom:">newFrom: aClassName	^ self new typeName: aClassName</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id> <category>metrics</category><body package="SSG-Info" selector="isSimpleTyped">isSimpleTyped	"	- one type of receiver only one type for each argument	"	^ (Array		with: receiver hasOnlyOneType		with: returnType hasOnlyOneType		with: (argTypes isNil or: [ argTypes allSatisfy: #hasOnlyOneType ]))		allSatisfy: #yourself</body><body package="SSG-Info" selector="isSimpleTyped10">isSimpleTyped10	"		"	^ (Array		with: receiver hasOnlyOneType		with:			(returnType hasOnlyOneType not				and: [ returnType commonSuperclass = 'Object' ])		with:			(argTypes notNil				and: [ argTypes anySatisfy: [ :t | t hasOnlyOneType not ] ])		with:			(argTypes notNil				and: [ argTypes						allSatisfy: [ :t | 							t hasOnlyOneType								or: [ t isBlockSymbol not and: [ t commonSuperclass = 'Object' ] ] ] ]))		allSatisfy: #yourself</body><body package="SSG-Info" selector="isSimpleTyped11">isSimpleTyped11	"		"	^ (Array		with: receiver hasOnlyOneType not		with: returnType hasOnlyOneType not		with: (argTypes isNil or: [ argTypes allSatisfy: #hasOnlyOneType ])		with: (receiver equals: returnType) not) allSatisfy: #yourself</body><body package="SSG-Info" selector="isSimpleTyped12">isSimpleTyped12	"		"	^ (Array		with:			(receiver hasOnlyOneType not				and: [ receiver commonSuperclass ~= 'Object' ])		with: returnType hasOnlyOneType not		with:			(argTypes notNil				and: [ argTypes anySatisfy: [ :t | t hasOnlyOneType not ] ])		with:			(argTypes notNil				and: [ argTypes						allSatisfy: [ :t | 							t hasOnlyOneType								or: [ t isBlockSymbol not and: [ t commonSuperclass = 'Object' ] ] ] ]))		allSatisfy: #yourself</body><body package="SSG-Info" selector="isSimpleTyped2">isSimpleTyped2	"	- this guy return the type that he receive 	"	^ (Array		with: receiver hasOnlyOneType not		with: returnType hasOnlyOneType not		with: (receiver equals: returnType)		with: (argTypes isNil or: [ argTypes allSatisfy: #hasOnlyOneType ]))		allSatisfy: #yourself</body><body package="SSG-Info" selector="isSimpleTyped3">isSimpleTyped3	"	- this guy return the type that he receive 	"	^ (Array		with: receiver hasOnlyOneType not		with: receiver commonSuperclass ~= 'Object'		with: returnType hasOnlyOneType		with: (argTypes isNil or: [ argTypes allSatisfy: #hasOnlyOneType ]))		allSatisfy: #yourself</body><body package="SSG-Info" selector="isSimpleTyped4">isSimpleTyped4	"		"	^ (Array		with: receiver hasOnlyOneType		with: returnType hasOnlyOneType		with:			(argTypes notNil				and: [ argTypes anySatisfy: [ :t | t hasOnlyOneType not ] ])		with:			(argTypes notNil				and: [ argTypes						allSatisfy: [ :t | t hasOnlyOneType or: [ t isBlockSymbol ] ] ]))		allSatisfy: #yourself</body><body package="SSG-Info" selector="isSimpleTyped5">isSimpleTyped5	"		"	^ (Array		with: receiver hasOnlyOneType		with: returnType hasOnlyOneType		with:			(argTypes notNil				and: [ argTypes anySatisfy: [ :t | t hasOnlyOneType not ] ])		with:			(argTypes notNil				and: [ argTypes						allSatisfy: [ :t | 							t hasOnlyOneType								or: [ t isBlockSymbol not and: [ t commonSuperclass = 'Object' ] ] ] ]))		allSatisfy: #yourself</body><body package="SSG-Info" selector="isSimpleTyped6">isSimpleTyped6	"		"	^ (Array		with: receiver hasOnlyOneType		with: returnType hasOnlyOneType		with:			(argTypes notNil				and: [ argTypes anySatisfy: [ :t | t hasOnlyOneType not ] ])		with:			(argTypes notNil				and: [ argTypes						allSatisfy: [ :t | t hasOnlyOneType or: [ t commonSuperclass ~= 'Object' ] ] ]))		allSatisfy: #yourself</body><body package="SSG-Info" selector="isSimpleTyped7">isSimpleTyped7	"		"	^ (Array		with: receiver hasOnlyOneType		with:			(returnType hasOnlyOneType not				and: [ returnType commonSuperclass = 'Object' ])		with: (argTypes isNil or: [ argTypes allSatisfy: #hasOnlyOneType ]))		allSatisfy: #yourself</body><body package="SSG-Info" selector="isSimpleTyped8">isSimpleTyped8	"		"	^ (Array		with: receiver hasOnlyOneType		with:			(returnType hasOnlyOneType not				and: [ returnType commonSuperclass ~= 'Object' ])		with: (argTypes isNil or: [ argTypes allSatisfy: #hasOnlyOneType ]))		allSatisfy: #yourself</body><body package="SSG-Info" selector="isSimpleTyped9">isSimpleTyped9	"		"	^ (Array		with:			(receiver hasOnlyOneType not				and: [ receiver commonSuperclass ~= 'Object' ])		with:			(returnType hasOnlyOneType not				and: [ returnType commonSuperclass ~= 'Object' ])		with:			(argTypes notNil				and: [ argTypes anySatisfy: [ :t | t hasOnlyOneType not ] ])		with:			(argTypes notNil				and: [ argTypes						allSatisfy: [ :t | t hasOnlyOneType or: [ t commonSuperclass ~= 'Object' ] ] ]))		allSatisfy: #yourself</body><body package="SSG-Info" selector="returnTypeFor:">returnTypeFor: aReceiver	^ self isSimpleTyped2		ifTrue: [ "it is the same than his father" aReceiver returnType ]		ifFalse: [ "it return one random" self returnType type ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id> <category>adding</category><body package="SSG-Info" selector="addType:">addType: aType	argTypes do: [ :arg | arg type: aType ].	returnType type: aType</body><body package="SSG-Info" selector="scalars:">scalars: aDictionary	scalars := aDictionary</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id> <category>accessing</category><body package="SSG-Info" selector="allArgTypes">allArgTypes	argTypes ifNil: [ ^ #() ].	^ argTypes flatCollect: [ :arg | arg types ]</body><body package="SSG-Info" selector="allReceivers">allReceivers	^ receiver types</body><body package="SSG-Info" selector="argTypes">argTypes	^ argTypes</body><body package="SSG-Info" selector="argTypes:">argTypes: anObject	argTypes := anObject</body><body package="SSG-Info" selector="dataCSV">dataCSV	^ Array		with: selector		withAll:			(OrderedCollection new				add: receiver types asArray;				add: receiver commonSuperclass;				add:					(argTypes						ifNil: [ #() ]						ifNotNil: [ (argTypes collect: [ :argType | argType types asArray ]) asArray ]);				add:					(argTypes						ifNil: [ '' ]						ifNotNil: [ argTypes collect: [ :argType | argType commonSuperclass ] ]);				add: returnType types asArray;				add: returnType commonSuperclass;				yourself)</body><body package="SSG-Info" selector="hasProfiler">hasProfiler	^ hasProfiler</body><body package="SSG-Info" selector="hasProfiler:">hasProfiler: aBoolean	hasProfiler := aBoolean</body><body package="SSG-Info" selector="isDeprecated">isDeprecated	^ isDeprecated</body><body package="SSG-Info" selector="isDeprecated:">isDeprecated: anObject	isDeprecated := anObject</body><body package="SSG-Info" selector="isQuick">isQuick	^ isQuick</body><body package="SSG-Info" selector="isQuick:">isQuick: aBoolean	isQuick := aBoolean</body><body package="SSG-Info" selector="isUnary">isUnary	^ selector isUnary</body><body package="SSG-Info" selector="receiver">receiver	^ receiver</body><body package="SSG-Info" selector="receiver:">receiver: anObject	receiver := anObject</body><body package="SSG-Info" selector="returnType">returnType	^ returnType</body><body package="SSG-Info" selector="returnType:">returnType: anObject	returnType := anObject</body><body package="SSG-Info" selector="scalars">scalars	^ scalars</body><body package="SSG-Info" selector="selector">selector	^ selector</body><body package="SSG-Info" selector="selector:">selector: anObject	selector := anObject</body><body package="SSG-Info" selector="transform:">transform: aSet	| multiType |	multiType := SMultiTypeInfo new.	aSet do: [ :anObject | multiType type: anObject ].	^ multiType</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id> <category>acccessing</category><body package="SSG-Info" selector="executions">executions	^ executions</body><body package="SSG-Info" selector="executions:">executions: anObject	executions := anObject</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id> <category>initialization</category><body package="SSG-Info" selector="initialize">initialize	argTypes := #().	isQuick := false.	returnType := SMultiTypeInfo new.	receiver := SMultiTypeInfo new.	isDeprecated := false.	scalars := Dictionary new.	hasProfiler := true</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id> <category>copying</category><body package="SSG-Info" selector="copy">copy	| copy |	copy := self class instance.	copy		selector: selector;		isQuick: isQuick;		isDeprecated: isDeprecated;		returnType: returnType copy;		argTypes: argTypes copy;		scalars: scalars copy;		executions: executions;		receiver: receiver copy.	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id> <category>actions</category><body package="SSG-Info" selector="copyValuesOf:">copyValuesOf: otherTypeMethod	(otherTypeMethod hasProfiler		and: [ otherTypeMethod returnType types isNotEmpty ])		ifFalse: [ ^ self ].	returnType := otherTypeMethod returnType.	argTypes := otherTypeMethod argTypes.	receiver := otherTypeMethod receiver.	hasProfiler := otherTypeMethod hasProfiler</body><body package="SSG-Info" selector="joinWith:">joinWith: otherTypeMethod	hasProfiler		ifFalse: [ self copyValuesOf: otherTypeMethod ]		ifTrue: [ argTypes				ifNotNil: [ argTypes						with: otherTypeMethod argTypes						do: [ :argType :otherArgType | argType joinWith: otherArgType ] ].			returnType joinWith: otherTypeMethod returnType ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id> <category>testing</category><body package="SSG-Info" selector="isFromReceiver:">isFromReceiver: aClassName	^ receiver types includes: aClassName</body><body package="SSG-Info" selector="isWithReturnType:">isWithReturnType: aClassName	^ returnType types includes: aClassName</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id> <category>converting</category><body package="SSG-Info" selector="asMethodInfo:">asMethodInfo: typeCollMethod	^ self class new		selector: typeCollMethod selector;		receiver: (self transform: typeCollMethod receiverType);		returnType: (self transform: typeCollMethod returnType);		argTypes: (self transformArgs: typeCollMethod argTypes);		isQuick: typeCollMethod isQuick;		scalars: typeCollMethod dictLiterals;		isDeprecated: typeCollMethod isDeprecated;		executions: typeCollMethod numberOfExecutions;		hasProfiler: typeCollMethod wasExecuted</body><body package="SSG-Info" selector="transformArgs:">transformArgs: allArgs	^ allArgs collect: [ :args | self transform: args ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id> <category>comparing</category><body package="SSG-Info" selector="=">= other	^ self class = other class		and: [ selector = other selector				and: [ receiver = other receiver						and: [ returnType = other returnType								and: [ argTypes = other argTypes										and:											[ isQuick = other isQuick and: [ hasProfiler = other hasProfiler ] ] ] ] ] ]</body><body package="SSG-Info" selector="hash">hash	^ selector hash		bitXor:			(receiver hash				bitXor: (returnType hash bitXor: (argTypes hash bitXor: isQuick hash)))</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo class</class-id> <category>accessing structure variables</category><body package="SSG-Info" selector="type:">type: aAssoc	| aValue |	aValue := aAssoc value.	^ self new		selector: aAssoc key;		receiver: (SMultiTypeInfo new: aValue first);		returnType: (SMultiTypeInfo new: aValue second);		argTypes: (aValue third collect: [ :aType | SMultiTypeInfo new: aType ]);		isQuick: aValue fourth	";		isDeprecated: aValue fifth"</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo class</class-id> <category>accessing</category><body package="SSG-Info" selector="selectorsFilter">selectorsFilter	^ self selectors		select: [ :aSelector | aSelector beginsWith: 'isSimpleTyped' ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo class</class-id> <category>converting</category><body package="SSG-Info" selector="asMethodInfo:">asMethodInfo: aSpyMethod	^ self new asMethodInfo: aSpyMethod</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>initialization</category><body package="SSG-Info" selector="initialize">initialize	types := Set new.	mustBeFixed := false</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>metrics</category><body package="SSG-Info" selector="hasOnlyOneType">hasOnlyOneType	^ types size &lt;= 1</body><body package="SSG-Info" selector="isBlockSymbol">isBlockSymbol	^ types size = 2		and: [ (types anySatisfy: [ :aType | aType = #BlockClosure ])				and: [ types anySatisfy: [ :aType | aType = #ByteSymbol ] ] ]</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>accessing structure variables</category><body package="SSG-Info" selector="type:">type: aClassName	aClassName ~= #nil		ifTrue: [ types add: aClassName ]</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>copying</category><body package="SSG-Info" selector="copy">copy	| copy |	copy := self class instance.	types do: [ :aType | copy type: aType ].	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>accessing</category><body package="SSG-Info" selector="commonSuperclass">commonSuperclass	| commonSuperclass |	types ifEmpty: [ ^ '' ].	commonSuperclass := SPlatform lookUpClass: types anyOne.	commonSuperclass ifNil: [ ^ '' ].	types		do: [ :aType | 			| otherClass |			otherClass := SPlatform lookUpClass: aType.			otherClass ifNil: [ ^ '' ].			(commonSuperclass isClass and: [ commonSuperclass name = #Object ])				ifTrue: [ ^ #Object ].			commonSuperclass := commonSuperclass				commonSuperclassWith: otherClass ].	^ commonSuperclass name</body><body package="SSG-Info" selector="mustBeFixed">mustBeFixed	^ mustBeFixed</body><body package="SSG-Info" selector="type">type	^ types		ifEmpty: [ nil ]		ifNotEmpty: [ self random selectAtRandom: self types ]</body><body package="SSG-Info" selector="types">types	^ types asArray</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>actions</category><body package="SSG-Info" selector="joinWith:">joinWith: otherTypeReturn	| hasOneType |	hasOneType := self hasOnlyOneType.	otherTypeReturn types do: [ :aType | self type: aType ].	types size &gt; 1		ifTrue: [ types remove: #SUndefinedObject ifAbsent: [  ] ].	mustBeFixed := hasOneType and: [ types size &gt; 1 ]</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>ston persistence</category><body package="SSG-Info" selector="stonOn:">stonOn: stonWriter	stonWriter		writeObject: self		streamShortList: [ :array | self types do: [ :type | array add: type ] ]</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>testing</category><body package="SSG-Info" selector="includes:">includes: aType	^ self types includes: aType</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>instance creation</category><body package="SSG-Info" selector="fromSton:">fromSton: stonReader	stonReader parseListDo: [ :each :index | self type: each ]</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>comparing</category><body package="SSG-Info" selector="=">= other	^ self class = other class and: [ self types = other types ]</body><body package="SSG-Info" selector="equals:">equals: other	self types size = other types size		ifFalse: [ ^ false ].	self types asOrderedCollection		with: other types asOrderedCollection		do: [ :a :b | 			a = b				ifFalse: [ ^ false ] ].	^ true</body><body package="SSG-Info" selector="hash">hash	^ self types hash</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo class</class-id> <category>instance creation</category><body package="SSG-Info" selector="new:">new: aType	^ self new type: aType</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>accessing</category><body package="SSG-Core" selector="classesForRegex:">classesForRegex: regexExpressions	^ (regexExpressions		flatCollect: [ :regex | 			RPackage organizer packages				select: [ :p | regex match: p name printString ] ]) asSet		flatCollect: #definedClasses</body><body package="SSG-Core" selector="crossoverRate:">crossoverRate: aNumber	engine crossoverRate: aNumber</body><body package="SSG-Core" selector="elitismRate:">elitismRate: aNumber	engine elitismRate: aNumber</body><body package="SSG-Core" selector="engine">engine	^ engine</body><body package="SSG-Core" selector="engineDefault">engineDefault	^ SGAEngine new		fitness: fitness;		numberOfStatements: 30;		numberOfGenerations: numberOfIterations;		yourself</body><body package="SSG-Core" selector="firstExecution">firstExecution	^ firstExecution		ifNil: [ firstExecution := true ]		ifNotNil: [ false ]</body><body package="SSG-Core" selector="fitnessSeed">fitnessSeed	^ fitnessSeed</body><body package="SSG-Core" selector="fitnessSeedCalculated:">fitnessSeedCalculated: number	fitnessSeed := number</body><body package="SSG-Core" selector="initialAsDict">initialAsDict	^ initialAsDict</body><body package="SSG-Core" selector="initialSeed">initialSeed	^ initialSeed</body><body package="SSG-Core" selector="numberOfGenerations">numberOfGenerations	^ numberOfIterations</body><body package="SSG-Core" selector="outputPackageName">outputPackageName	^ outputPackageName</body><body package="SSG-Core" selector="outputPackageName:">outputPackageName: anObject	outputPackageName := anObject</body><body package="SSG-Core" selector="reportClass">reportClass	reportClass		ifNil: [ reportClass := SReportSTestCaseFactory on: self ].	^ reportClass</body><body package="SSG-Core" selector="stopIterations:">stopIterations: anInteger	engine stopIterations: anInteger</body><body package="SSG-Core" selector="targetClassName">targetClassName	^ targetClassName</body><body package="SSG-Core" selector="targetClassName:">targetClassName: aSymbol	targetClassName := aSymbol</body><body package="SSG-Core" selector="targetPackageRegex">targetPackageRegex	^ targetPackageRegex</body><body package="SSG-Core" selector="targetPackageRegex:">targetPackageRegex: anObject	targetPackageRegex := anObject.	engine packageRegex: anObject</body><body package="SSG-Core" selector="typeInfo">typeInfo	^ typeInfo</body><body package="SSG-Core" selector="typeInfo:">typeInfo: aTypeInfo	typeInfoOrigin := aTypeInfo copy.	typeInfo := aTypeInfo</body><body package="SSG-Core" selector="typeInfoOrigin">typeInfoOrigin	^ typeInfoOrigin</body><body package="SSG-Core" selector="typeInfoSeed">typeInfoSeed	^ typeInfoSeed</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>actions</category><body package="SSG-Core" selector="asDict:">asDict: aBoolean	initialAsDict := aBoolean.	SPlatform asDict: aBoolean</body><body package="SSG-Core" selector="checkInvariants">checkInvariants	self		assert: typeInfo isNil not		description: 'Please provide type information of the target project'.	self		assert: targetPackageRegex isNil not		description: 'Please provide a regex that match the packages under analysis'</body><body package="SSG-Core" selector="createTestCases">createTestCases	self checkInvariants.	self setUp.	self run.	self tearDown</body><body package="SSG-Core" selector="getClassOf:">getClassOf: aString	| aClassName class |	aClassName := aString asSymbol.	class := SPlatform lookUpClass: aClassName.	class		ifNil: [ class := SPlatform				createTestCaseClass: aClassName				inPackage: self outputPackageName ].	^ class</body><body package="SSG-Core" selector="initializeProfiler">initializeProfiler	self subclassResponsibility</body><body package="SSG-Core" selector="lastMessage:">lastMessage: aMessage	(aMessage isNotNil and: [ aMessage isNotEmpty ])		ifFalse: [ ^ self ].	lastMessage := aMessage.	engine lastMessage: aMessage</body><body package="SSG-Core" selector="run">run	engine run</body><body package="SSG-Core" selector="selectionStrategy:">selectionStrategy: aSelectionStrategy	engine selectionStrategy: aSelectionStrategy</body><body package="SSG-Core" selector="selectionStrategyTestCase:">selectionStrategyTestCase: aSelectionStrategy	engine selectionStrategyTestCase: aSelectionStrategy</body><body package="SSG-Core" selector="setUp">setUp	self initializeProfiler.	self firstExecution		ifTrue: [ SPlatform resetRandomGenerator.			fitness				profiler: profiler;				typeInfo: typeInfo;				targetClass: self targetClassName.			engine				fitness: fitness;				numberOfGenerations: numberOfIterations;				typeInfo: self typeInfo;				targetClassName: self targetClassName;				targetPackageRegex: targetPackageRegex.			typeInfoSeed := (typeInfo classAt: targetClassName) deepCopy ]		ifFalse: [ engine fitness profiler: profiler.			engine numberOfGenerations: numberOfIterations ]</body><body package="SSG-Core" selector="setUpMethod:">setUpMethod: anObject	(anObject isNotNil and: [ anObject isNotEmpty ])		ifFalse: [ ^ self ].	setUpMethod := anObject</body><body package="SSG-Core" selector="tearDownMethod:">tearDownMethod: anObject	(anObject isNotNil and: [ anObject isNotEmpty ])		ifFalse: [ ^ self ].	tearDownMethod := anObject</body><body package="SSG-Core" selector="uninstall">uninstall	</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>running</category><body package="SSG-Core" selector="run:">run: aNumber	numberOfIterations := aNumber.	self createTestCases</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>configuration</category><body package="SSG-Core" selector="fitness">fitness	^ fitness</body><body package="SSG-Core" selector="fitness:">fitness: aFitness	fitness := aFitness</body><body package="SSG-Core" selector="numberOfStatements:">numberOfStatements: aInt	engine numberOfStatements: aInt</body><body package="SSG-Core" selector="populationSize:">populationSize: int	engine populationSize: int</body><body package="SSG-Core" selector="seedBlock:">seedBlock: aBlock	fitnessSeed := (self aSLProfilerCoverage		profile: aBlock		inPackagesMatching: targetPackageRegex)		statementCoverageFor: targetClassName</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>initialization</category><body package="SSG-Core" selector="initialize">initialize	SPlatform resetRandomGenerator.	super initialize.	fitness := SMethodCoverage new.	numberOfIterations := 20.	engine := self engineDefault.	fitnessSeed := 0.	outputPackageName := 'SmallSuiteGenerator-Tests-Generated'.	initialSeed := 100.	initialAsDict := false</body><body package="SSG-Core" selector="numberOfGenerations:">numberOfGenerations: aNumber	engine numberOfGenerations: aNumber.	numberOfIterations := aNumber</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>instance creation</category><body package="SSG-Core" selector="seed:">seed: aNumber	initialSeed := aNumber.	SPlatform seed: aNumber</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory class</class-id> <category>settings-colors</category><body package="SSG-Core" selector="darkColors">darkColors	^ Dictionary new		at: 'background'			put:			(Color				r: 0.12549019607843137				g: 0.1803921568627451				b: 0.23529411764705882);		at: 'backgroundTestCase'			put:			(Color				r: 0.1607843137254902				g: 0.3686274509803922				b: 0.4470588235294118);		at: 'backgroundHigherFitnessTestCase'			put: (Color fromHexString: '1B8D8D');		at: 'scaleLighter'			put:			(Color				r: 0.5098039215686274				g: 0.9607843137254902				b: 0.7725490196078432);		at: 'scaleDarker'			put:			(Color				r: 0.30980392156862746				g: 0.6235294117647059				b: 0.49019607843137253);		at: 'baseBar'			put:			(Color r: 0.7647058823529411 g: 0.803921568627451 b: 0.788235294117647);		at: 'forwardBar'			put:			(Color				r: 0.5098039215686274				g: 0.9607843137254902				b: 0.7725490196078432);		at: 'backwardBar' put: (Color r: 1 g: 0 b: 0.25098039215686274);		at: 'edge'			put:			(Color r: 0.7647058823529411 g: 0.803921568627451 b: 0.788235294117647);		at: 'classCoverage'			put:			(Color				r: 0.5098039215686274				g: 0.7803921568627451				b: 0.9607843137254902);		at: 'methodCoverage'			put:			(Color				r: 0.9607843137254902				g: 0.5098039215686274				b: 0.7215686274509804);		at: 'statementCoverage'			put:			(Color				r: 0.5098039215686274				g: 0.9607843137254902				b: 0.7725490196078432);		at: 'highlightTestCase'			put:			(Color				r: 0.13725490196078433				g: 0.7215686274509804				b: 0.7725490196078432				alpha: 0.8);		at: 'highlightMethod' put: Color cyan;		at: 'fontMethodBox' put: Color white;		at: 'border' put: Color white;		at: 'axis' put: Color white;		at: 'fittestCoverage' put: (Color r: 0 g: 1 b: 0.67);		at: 'averageCoverage'			put:			(Color				r: 0.5063538611925709				g: 0.5259042033235581				b: 0.8357771260997068);		at: 'lowestCoverage' put: Color pink;		at: 'seedCoverage'			put:			(Color				r: 0.9530791788856305				g: 0.5102639296187683				b: 0.43499511241446726);		at: 'font' put: Color white;		at: 'rangeMethodColor'			put:			(#('83142C' 'AF0404' 'BB1542' 'ED3833' 'EB5F5D' 'F3826F' 'FFBA92' 'F0DAB1' 'FFF8CD' 'F7FF56' 'DCFFCC' 'DDF796' 'C3F584' 'A3F7BF' '6bffb8' '42E6A4' '4DD599' '71A95A' '007944' '00818A' '216583' '366ED8' '64C4ED' '5EDFFF' 'B2FCFF' 'FFEDFF' 'C6CBEF' '8186D5' '494CA2' '560764' '930077' 'D527B7' 'FF78AE' 'FFA0D2')				collect: [ :c | Color fromHexString: c ]);		yourself	"'0B6969'""'1E7676'"</body><body package="SSG-Core" selector="lightColors">lightColors	^ Dictionary new		at: 'background' put: Color white;		"at: 'backgroundTestCase' put: (Color r: 0.1607843137254902 g: 0.3686274509803922 b: 0.4470588235294118);"			at: 'backgroundTestCase' put: (Color fromHexString: 'ebecf0');		"at: 'backgroundHigherFitnessTestCase' put: (Color fromHexString: '1B8D8D' '0B6969' '1E7676');"			at: 'borderTestCase'			put:			(Color				r: 0.1607843137254902				g: 0.3686274509803922				b: 0.4470588235294118);		at: 'scaleLighter' put: (Color r: 0 g: 1 b: 0.67);		at: 'scaleDarker'			put:			(Color				r: 0				g: 0				b: 0				alpha: 0.1);		at: 'baseBar' put: Color white;		at: 'forwardBar'			put:			(Color				r: 0.611764705882353				g: 0.6431372549019608				b: 0.6274509803921569);		at: 'backwardBar' put: (Color r: 1 g: 0 b: 0.25098039215686274);		at: 'edge'			put:			(Color				r: 0.611764705882353				g: 0.6431372549019608				b: 0.6274509803921569);		at: 'classCoverage' put: (Color r: 0.05 g: 0.75 b: 0.91);		at: 'methodCoverage' put: (Color r: 0.88 g: 0.26 b: 0.5);		at: 'statementCoverage' put: (Color r: 0 g: 1 b: 0.67);		at: 'highlightTestCase'			put:			(Color				r: 0.13725490196078433				g: 0.7215686274509804				b: 0.7725490196078432				alpha: 0.8);		at: 'highlightMethod' put: Color cyan;		"at: 'fontMethodBox' put: Color white;"			at: 'fontMethodBox' put: Color black;		at: 'border'			put:			(Color				r: 0.12549019607843137				g: 0.1803921568627451				b: 0.23529411764705882);		at: 'axis'			put:			(Color				r: 0.12549019607843137				g: 0.1803921568627451				b: 0.23529411764705882);		at: 'fittestCoverage' put: (Color r: 0 g: 1 b: 0.67);		at: 'averageCoverage'			put:			(Color				r: 0.5063538611925709				g: 0.5259042033235581				b: 0.8357771260997068);		at: 'lowestCoverage' put: Color pink;		at: 'seedCoverage'			put:			(Color				r: 0.9530791788856305				g: 0.5102639296187683				b: 0.43499511241446726);		at: 'font'			put:			(Color				r: 0.12549019607843137				g: 0.1803921568627451				b: 0.23529411764705882);		at: 'rangeMethodColor'			put:			(#('83142C' 'AF0404' 'BB1542' 'ED3833' 'EB5F5D' 'F3826F' 'FFBA92' 'F0DAB1' 'FFF8CD' 'F7FF56' 'DCFFCC' 'DDF796' 'C3F584' 'A3F7BF' '6bffb8' '42E6A4' '4DD599' '71A95A' '007944' '00818A' '216583' '366ED8' '64C4ED' '5EDFFF' 'B2FCFF' 'FFEDFF' 'C6CBEF' '8186D5' '494CA2' '560764' '930077' 'D527B7' 'FF78AE' 'FFA0D2')				collect: [ :c | Color fromHexString: c ]);		yourself	"(Color r: 0.30980392156862746 g: 0.6235294117647059 b: 0.49019607843137253)"	"(Color r: 111/255 g: 1 b: 233/255)"</body></methods><methods><class-id>SmallSuiteGenerator.SSExecutionContext</class-id> <category>initialization</category><body package="SSG-Core" selector="at:">at: aSymbol	^ values at: aSymbol</body><body package="SSG-Core" selector="at:put:">at: aSymbol put: aValue	values at: aSymbol put: aValue</body><body package="SSG-Core" selector="initialize">initialize	super initialize.	values := OrderedDictionary new</body><body package="SSG-Core" selector="keys">keys	^ values keys asOrderedCollection</body></methods><methods><class-id>SmallSuiteGenerator.SSExecutionContext</class-id> <category>accessing</category><body package="SSG-Core" selector="associations">associations	^ values associations</body></methods><methods><class-id>SmallSuiteGenerator.SmallTypeCollector</class-id> <category>initalize</category><body package="SSG-SmallType" selector="initialize">initialize	super initialize.	classDict := Dictionary new.	Object withAllSubclasses		do: [ :class | classDict at: class name asLowercase put: class ]</body></methods><methods><class-id>SmallSuiteGenerator.SGASelection</class-id> <category>initialization</category><body package="SSG-GA" selector="initialize">initialize	</body></methods><methods><class-id>SmallSuiteGenerator.SGASelection</class-id> <category>actions</category><body package="SSG-GA" selector="fitnessFor:">fitnessFor: aTestCase	^ aTestCase fitness at: fitness functionName</body></methods><methods><class-id>SmallSuiteGenerator.SGASelection</class-id> <category>selection</category><body package="SSG-GA" selector="selectJustOneOf:with:">selectJustOneOf: aCollection with: probabilities	^ self subclassResponsibility</body><body package="SSG-GA" selector="selectOf:">selectOf: collection	^ self subclassResponsibility</body></methods><methods><class-id>SmallSuiteGenerator.SGASelection</class-id> <category>accessing</category><body package="SSG-GA" selector="fitness:">fitness: anObject	fitness := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SGARouletteSelection</class-id> <category>creating</category><body package="SSG-GA" selector="createRouletteWith:">createRouletteWith: probability	| sum roulette |	sum := probability sum.	roulette := probability collect: [ :e | e / sum ].	2 to: probability size do:		[ :i | roulette at: i put: (roulette at: i - 1) + (roulette at: i) ].	^ roulette</body></methods><methods><class-id>SmallSuiteGenerator.SGARouletteSelection</class-id> <category>selection</category><body package="SSG-GA" selector="selectJustOneOf:with:">selectJustOneOf: aCollection with: probabilities	| roulette random |	roulette := self createRouletteWith: probabilities.	random := self next.	roulette		doWithIndex: [ :probability :index | 			random &lt; probability				ifTrue: [ ^ aCollection at: index ] ].	^ nil</body><body package="SSG-GA" selector="selectOf:">selectOf: aCollection	^ self		selectOf: aCollection		with: (aCollection collect: [ :testCase | self fitnessFor: testCase ])</body><body package="SSG-GA" selector="selectOf:with:">selectOf: collection with: probability	| roulette random newCollection collectionSize indexes index |	roulette := self createRouletteWith: probability.	newCollection := OrderedCollection new.	collectionSize := collection size.	indexes := OrderedCollection new.	[ newCollection size &lt; collectionSize ]		whileTrue: [ random := self next.			index := 0.			roulette				detect: [ :rv | 					index := index + 1.					random &lt; rv and: [ (indexes includes: index) not ] ]				ifFound: [ newCollection add: (collection at: index).					indexes add: index ] ].	^ newCollection</body></methods><methods><class-id>SmallSuiteGenerator.SGARankSelection</class-id> <category>as yet unclassified</category><body package="SSG-GA" selector="ranksOf:">ranksOf: values	| indexValue |	indexValue := 0.	^ (self		ranksWithIndexOf:			(values				collect: [ :val | 					indexValue := indexValue + 1.					val -&gt; indexValue ])) collect: #value</body></methods><methods><class-id>SmallSuiteGenerator.SGARankSelection</class-id> <category>actions</category><body package="SSG-GA" selector="ranksWithIndexOf:">ranksWithIndexOf: associations	| rank sortBlock |	sortBlock := [ :a :b | a key &lt; b key ].	associations sort: sortBlock.	rank := 0.	^ (associations		collect: [ :each | 			rank := rank + 1.			each value -&gt; rank ]) sort: sortBlock</body></methods><methods><class-id>SmallSuiteGenerator.SGARankSelection</class-id> <category>selection</category><body package="SSG-GA" selector="selectJustOneOf:with:">selectJustOneOf: aCollection with: probabilities	^ SGARouletteSelection new		selectJustOneOf: aCollection		with: (self ranksOf: probabilities)</body><body package="SSG-GA" selector="selectOf:">selectOf: aCollection	^ self		selectOf: aCollection		with: (aCollection collect: [ :testCase | self fitnessFor: testCase ])</body><body package="SSG-GA" selector="selectOf:with:">selectOf: aCollection with: values	^ SGARouletteSelection new		selectOf: aCollection		with: (self ranksOf: values)</body></methods><methods><class-id>SmallSuiteGenerator.SGATruncatedSelection</class-id> <category>actions</category><body package="SSG-GA" selector="discarding:">discarding: aNumber	discarding := aNumber</body></methods><methods><class-id>SmallSuiteGenerator.SGATruncatedSelection</class-id> <category>initialization</category><body package="SSG-GA" selector="initialize">initialize	super initialize.	discarding := 5</body></methods><methods><class-id>SmallSuiteGenerator.SGATruncatedSelection</class-id> <category>selection</category><body package="SSG-GA" selector="selectJustOneOf:with:">selectJustOneOf: aCollection with: probabilities	^ (self selectOf: aCollection) first</body><body package="SSG-GA" selector="selectOf:">selectOf: aCollection	| newColl |	newColl := aCollection		sort: [ :a :b | (self fitnessFor: a) &gt; (self fitnessFor: b) ].	discarding &lt; aCollection size		ifTrue: [ newColl := newColl copyFrom: 1 to: aCollection size - discarding ].	^ newColl</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine</class-id> <category>testing</category><body package="SSG-GA" selector="checkFitness">checkFitness	self		assert: [ fitness notNil ]		description: 'Need to set a fitnessBlock'</body><body package="SSG-GA" selector="checkIfReadyToRun">checkIfReadyToRun	self checkTypeInfo.	self checkFitness.	self checkLogs</body><body package="SSG-GA" selector="checkLogs">checkLogs	self assert: [ logs isEmpty ] description: 'Already been run'</body><body package="SSG-GA" selector="checkTypeInfo">checkTypeInfo	self assert: [ typeInfo notNil ] description: 'Set a typeInfo'</body><body package="SSG-GA" selector="shouldCrossOver">shouldCrossOver	^ self next &lt; self crossoverRate</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine</class-id> <category>initialization</category><body package="SSG-GA" selector="initialize">initialize	super initialize.	logs := OrderedCollection new.	populationSize := 30.	numberOfGenerations := 100.	selectionStrategy := SGARandomSelection new.	crossoverRate := 0.8.	elitismRate := 0.1.	numberOfStatements := 10.	stopIterations := 30.	totalExecutionGA := 0.	self initializeMutationOperator.	self initializeCrossoverOperator</body><body package="SSG-GA" selector="initializeCrossoverOperator">initializeCrossoverOperator	crossoverOperator := SGACrossoverOperation new</body><body package="SSG-GA" selector="initializeMutationOperator">initializeMutationOperator	mutationOperator := SGAMutationOperation new.	mutationOperator mutationRate: (1 / 3) asFloat</body><body package="SSG-GA" selector="initializePopulation">initializePopulation	| t |	t := Time now asSeconds.	population := self createRandomPopulation.	SExpression resetId.	self computeFitness.	population := self order: population.	initialPopulation := population.	self updateTypeInfoWith: population.	logs add: (SGALog logOf: self inGeneration: 0 inTime: t)</body><body package="SSG-GA" selector="initializeProfiler">initializeProfiler	| aProfiler |	aProfiler := self aSLProfilerCoverage		profilerForClass: targetClassName.	(aProfiler allMethods select: #isNotMethodExtension)		do: #installGhosts		displayingProgress: 'Instrumenting ' , targetClassName.	^ aProfiler</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine</class-id> <category>rating</category><body package="SSG-GA" selector="crossoverRate">crossoverRate	^ crossoverRate</body><body package="SSG-GA" selector="crossoverRate:">crossoverRate: aNumber	selectionStrategy crossoverRate: aNumber</body><body package="SSG-GA" selector="elitismRate:">elitismRate: aNumber	elitismRate := aNumber</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine</class-id> <category>accessing</category><body package="SSG-GA" selector="crossoverOperator:">crossoverOperator: aCrossoverOperator	crossoverOperator := aCrossoverOperator</body><body package="SSG-GA" selector="fitness">fitness	^ fitness</body><body package="SSG-GA" selector="fitness:">fitness: aFitness	fitness := aFitness.	selectionStrategy fitness: aFitness</body><body package="SSG-GA" selector="lastMessage:">lastMessage: anObject	lastMessage := anObject</body><body package="SSG-GA" selector="logs">logs	^ logs</body><body package="SSG-GA" selector="numberOfGenerations:">numberOfGenerations: anInteger	"Set the number of generation the genetic algorithm has to run"	numberOfGenerations := anInteger</body><body package="SSG-GA" selector="numberOfStatements:">numberOfStatements: anInteger	"Set the number of statements the initial population should have.	Ideally, a small number, such as 3, is convenient. The evolution makes the individuals grow over time"	numberOfStatements := anInteger</body><body package="SSG-GA" selector="packageRegex:">packageRegex: aString	packageRegex := aString</body><body package="SSG-GA" selector="population">population	^ population</body><body package="SSG-GA" selector="populationSize:">populationSize: aInteger	populationSize := aInteger</body><body package="SSG-GA" selector="selectionStrategy:">selectionStrategy: aSelectionStrategy	selectionStrategy := aSelectionStrategy</body><body package="SSG-GA" selector="selectionStrategyTestCase:">selectionStrategyTestCase: aSelectionStrategy	selectionStrategyTestCase := aSelectionStrategy</body><body package="SSG-GA" selector="targetClassName:">targetClassName: anObject	targetClassName := anObject</body><body package="SSG-GA" selector="targetPackageRegex">targetPackageRegex	^ targetPackageRegex</body><body package="SSG-GA" selector="targetPackageRegex:">targetPackageRegex: aString	targetPackageRegex := aString</body><body package="SSG-GA" selector="totalExecutionGA">totalExecutionGA	^ totalExecutionGA</body><body package="SSG-GA" selector="tournamentSize:">tournamentSize: aNumber	selectionStrategy tournamentSize: aNumber</body><body package="SSG-GA" selector="typeInfo">typeInfo	^ typeInfo</body><body package="SSG-GA" selector="typeInfo:">typeInfo: aTypeInfo	typeInfo := aTypeInfo.	typeInfo completeTypeInfo</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine</class-id> <category>creating</category><body package="SSG-GA" selector="createNewPopulation">createNewPopulation	| newPopulation currentPopulationSize lastLowestFitness options newNumber |	lastLowestFitness := logs last lowestFit at: fitness functionName.	currentPopulationSize := initialPopulation size.	newPopulation := self eliteOfCurrentPopulation.	newNumber := newPopulation size.	[ newPopulation size &lt; currentPopulationSize ]		whileTrue:			[ | selectedList P1copy P2copy P1 P2 O1 O2 OM1 OM2 selectedOptions children |			selectedList := selectionStrategy selectOf: initialPopulation.			P1 := selectedList first.			P2 := selectedList second.			P1copy := self similarChild: P1 with: newNumber + 1.			P2copy := self similarChild: P2 with: newNumber + 2.			self shouldCrossOver				ifTrue: [ children := crossoverOperator crossover: P1 with: P2.					O1 := self						updateHierarchyData: (Array with: P1 with: P2)						of: (children first idPopulation: newNumber + 3).					O2 := self						updateHierarchyData: (Array with: P1 with: P2)						of: (children second idPopulation: newNumber + 4) ]				ifFalse: [ O1 := P1copy deepCopy						idPopulation: newNumber + 3;						addParent: P1.					O2 := P2copy deepCopy						idPopulation: newNumber + 4;						addParent: P2 ].			OM1 := self mutateAndUpdate: O1.			OM2 := self mutateAndUpdate: O2.			fitness compute: (Array with: OM1 with: OM2).			options := Array				with: OM1				with: OM2				with: P1copy				with: P2copy.			selectedOptions := (self				selectTwoBestOf: options				excludingAll: newPopulation)				select:					[ :option | (option fitness at: fitness functionName) &gt;= lastLowestFitness ].			selectedOptions := selectedOptions				first: (selectedOptions size min: currentPopulationSize - newPopulation size).			options				reject: [ :opt | selectedOptions includes: opt ]				thenDo: [ :opt | 					P1 removeChild: opt.					P2 removeChild: opt ].			newPopulation				addAll:					(selectedOptions						collect: [ :option | 							newNumber := newNumber + 1.							option idPopulation: newNumber ]) ].	self updateTypeInfoWith: newPopulation.	self fixPopulation: newPopulation.	population := newPopulation.	population := self order: population</body><body package="SSG-GA" selector="createRandomPopulation">createRandomPopulation	^ (1 to: populationSize)		collect: [ :idPop | 			| value test |			value := self next * numberOfStatements + 1.			test := SSTestCase with: typeInfo.			test				addTargetClassName: targetClassName;				addFactoryMessage: targetClassName;				generateStatements: value;				lastMessage: lastMessage;				idPopulation: idPop;				clean.			selectionStrategyTestCase				ifNotNil: [ test selectionStrategy: selectionStrategyTestCase ].			test ]</body><body package="SSG-GA" selector="stopIterations">stopIterations	^ stopIterations</body><body package="SSG-GA" selector="stopIterations:">stopIterations: aNumber	stopIterations := aNumber</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine</class-id> <category>actions</category><body package="SSG-GA" selector="computeFitness">computeFitness	fitness compute: population</body><body package="SSG-GA" selector="doSelection">doSelection	self createNewPopulation.	initialPopulation := population</body><body package="SSG-GA" selector="eliteOfCurrentPopulation">eliteOfCurrentPopulation	| endIndex index popSize |	popSize := population size.	endIndex := (popSize * elitismRate * 0.01 round: 0) asInteger.	(popSize &gt; 0 and: [ endIndex == 0 ])		ifTrue: [ endIndex := 1 ].	index := 0.	endIndex &gt;= 1		ifTrue: [ ^ ((population copyFrom: 1 to: endIndex)				collect: [ :testCase | 					index := index + 1.					self similarChild: testCase with: index ]) asOrderedCollection ].	^ OrderedCollection new</body><body package="SSG-GA" selector="lastBestFitness">lastBestFitness	^ logs last fittestTestCase fitnessFor: fitness functionName</body><body package="SSG-GA" selector="lastGenerationNumber">lastGenerationNumber	^ logs last generationNumber</body><body package="SSG-GA" selector="mutateAndUpdate:">mutateAndUpdate: aTestCase	| newTestCase |	newTestCase := mutationOperator mutate: aTestCase.	newTestCase updateWith: aTestCase.	^ newTestCase</body><body package="SSG-GA" selector="mutationRate:">mutationRate: aFloat	mutationOperator mutationRate: aFloat</body><body package="SSG-GA" selector="run">run	| counter bestFitness stopFlag |	totalExecutionGA := Time millisecondClockValue.	counter := 0.	stopFlag := false.	self initializePopulation.	totalExecutionGA := Time millisecondClockValue - totalExecutionGA.	bestFitness := self lastBestFitness.	(1 to: numberOfGenerations)		do: [ :iteration | 			| t lastBestFitness |			stopFlag				ifFalse: [ t := Time millisecondClockValue.					self doSelection.					logs add: (SGALog logOf: self inGeneration: iteration inTime: t).					lastBestFitness := self lastBestFitness.					lastBestFitness &lt;= bestFitness						ifTrue: [ counter := counter + 1.							counter &gt; stopIterations								ifTrue: [ stopFlag := true ] ]						ifFalse: [ counter := 0.							bestFitness := lastBestFitness ].					totalExecutionGA := totalExecutionGA + Time millisecondClockValue						- t ] ]		displayingProgress: [ :iteration | 'Evolving - Iteration' , iteration printString ]</body><body package="SSG-GA" selector="selectTwoBestOf:excludingAll:">selectTwoBestOf: aCollection excludingAll: excludingColl	| options |	options := (aCollection asOrderedCollection select: #notEmpty)		removeAllSuchThat: [ :e | excludingColl includes: e ];		yourself.	options := self order: options.	^ options first: (2 min: options size)</body><body package="SSG-GA" selector="similarChild:with:">similarChild: testCase with: idPopulation	^ testCase deepCopy		generationNumber: testCase generationNumber + 1;		idPopulation: idPopulation;		addParent: testCase;		yourself</body><body package="SSG-GA" selector="targetClassName">targetClassName	^ targetClassName</body><body package="SSG-GA" selector="updateHierarchyData:of:">updateHierarchyData: parents of: testCase	parents do: [ :parent | testCase addParent: parent ].	^ testCase</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine</class-id> <category>updating</category><body package="SSG-GA" selector="fixPopulation:">fixPopulation: aCollection	| targetClassMessages |	targetClassMessages := (typeInfo types at: targetClassName)		methodTypes values asOrderedCollection		removeAllSuchThat: [ :method | method returnType mustBeFixed not ].	aCollection		do: [ :testCase | 			testCase statements				select: [ :stm | 					[ (targetClassMessages collect: #selector)						includes: stm value selector ]						on: Error						do: [ false ] ]				thenDo: [ :stm | testCase fixTypeReturnOf: (stm needsBeFixed: true) ] ]</body><body package="SSG-GA" selector="mergeTypeInfo:">mergeTypeInfo: otherTypeInfo	typeInfo joinWith: otherTypeInfo</body><body package="SSG-GA" selector="profilerForPackagesMatching">profilerForPackagesMatching	Transcript		show: 'profiling...';		cr.	typeInfoProfiler := self aSTypeCollectorClass		profilerForPackagesMatching: targetPackageRegex.	typeInfoProfiler beforeProfiling</body><body package="SSG-GA" selector="profilerForTargetClass">profilerForTargetClass	| packageSpy cls classSpy |	cls := Smalltalk at: targetClassName.	Transcript		show: 'profiling...';		cr.	typeInfoProfiler := self aSTypeCollectorClass new.	self aSTypeCollectorClass installOnClass: cls.	typeInfoProfiler beforeProfiling.	classSpy := typeInfoProfiler spyForClass: cls.	packageSpy := typeInfoProfiler class spyClassForPackage new.	packageSpy classAt: targetClassName put: classSpy.	typeInfoProfiler addPackage: packageSpy.	classSpy packageSpy: packageSpy</body><body package="SSG-GA" selector="uninstall">uninstall	typeInfoProfiler		afterProfiling;		uninstall.	Transcript		show: 'ended...';		cr</body><body package="SSG-GA" selector="updateArgsOf:">updateArgsOf: aMethod	aMethod argTypes		do: [ :argType | 			| res |			res := argType types				anySatisfy: [ :type | typeInfo scalars keys includes: type ].			res				ifFalse: [ argType types						do: [ :type | 							typeInfo scalars keys								select:									[ :scalar | (type asClass allSubclasses collect: #name) includes: scalar ]								thenDo: [ :scalar | argType type: scalar ] ] ] ]</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine</class-id> <category>sorting</category><body package="SSG-GA" selector="order:">order: aCollection	^ aCollection		sort: [ :stm1 :stm2 | stm1 isBetterThan: stm2 using: fitness functionName ]</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine</class-id> <category>*SmallSuiteGenerator-Visualization</category><body package="SSG-GA" selector="fitnessOf:">fitnessOf: summaryExecMethod	^ summaryExecMethod summaryStatements		ifEmpty: [ 100 ]		ifNotEmpty: [ ((summaryExecMethod summaryStatements select: #executed) size				/ summaryExecMethod summaryStatements size) asFloat * 100 ]</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine</class-id> <category>cleaning</category><body package="SSG-GA" selector="clean">clean	fitness ifNotNil: [ fitness tearDown ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>accessing</category><body package="SSG-Info" selector="accessMessagesFrom:">accessMessagesFrom: aClassName	^ types		flatCollect: [ :aClassType | 			aClassType accessMessages				select: [ :aMessage | aMessage receiver types includes: aClassName ] ]</body><body package="SSG-Info" selector="blackList:">blackList: aList	blackList := aList.	self deleteBlackListMethods</body><body package="SSG-Info" selector="classAt:">classAt: aClassName	^ types at: aClassName</body><body package="SSG-Info" selector="classAt:ifNone:">classAt: aClassName ifNone: aBlock	^ types at: aClassName ifAbsent: aBlock</body><body package="SSG-Info" selector="classes">classes	classes ifNil: [ classes := Dictionary new ].	types		keysDo: [ :aClassName | 			classes				at: aClassName				ifAbsentPut: (SPlatform lookUpClass: aClassName) ].	^ classes</body><body package="SSG-Info" selector="isInBlackListClass:with:">isInBlackListClass: aClass with: selector	^ blackList		anySatisfy: [ :each | each origin name = aClass and: [each selector = selector] ]</body><body package="SSG-Info" selector="messagesFrom:">messagesFrom: aClassName	^ types		flatCollect: [ :aClassType | 			aClassType messages				select: [ :aMessage | aMessage receiver types includes: aClassName ] ]</body><body package="SSG-Info" selector="noneAbstractClasses">noneAbstractClasses	noneAbstractClasses		ifNil: [ noneAbstractClasses := self classes associations				select: [ :assoc | (self isAbstractClass: assoc key) not ]				thenCollect: [ :assoc | assoc value ] ].	^ noneAbstractClasses</body><body package="SSG-Info" selector="reportFrequencyByFilter">reportFrequencyByFilter	| report |	report := Dictionary new.	STypeMethodInfo selectorsFilter , #(#others #all)		do: [ :aSelector | 			report				at: aSelector				put:					(types						inject: 0						into: [ :sum :type | sum + (type reportFrequencyByFilter: aSelector) ]) ].	^ report</body><body package="SSG-Info" selector="scalars">scalars	^ scalars</body><body package="SSG-Info" selector="scalars:">scalars: aDictionary	aDictionary		associationsDo: [ :assoc | self scalar: assoc key with: assoc value ]</body><body package="SSG-Info" selector="types">types	^ types</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>initialization</category><body package="SSG-Info" selector="initialize">initialize	super initialize.	types := Dictionary new.	scalars := Dictionary new.	self initializeBlackList</body><body package="SSG-Info" selector="initializeBlackList">initializeBlackList	blackList ifNil: [ blackList := OrderedCollection new ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>actions</category><body package="SSG-Info" selector="exportDataCSV:withFilter:">exportDataCSV: neoCSVWriter withFilter: aSymbol	types		do: [ :type | type exportDataCSV: neoCSVWriter withFilter: aSymbol ]</body><body package="SSG-Info" selector="joinScalars:">joinScalars: aDict	aDict associations		do: [ :assoc | 			scalars				at: assoc key				ifPresent:					[ :values | scalars at: assoc key put: (values union: assoc value) asArray ]				ifAbsentPut: [ assoc value asArray ] ]</body><body package="SSG-Info" selector="joinWith:">joinWith: otherTypeInfo	otherTypeInfo types		do: [ :aTypeClass | self addClassInfo: aTypeClass ].	self joinScalars: otherTypeInfo scalars</body><body package="SSG-Info" selector="scalar:with:">scalar: aClassName with: aValue	scalars at: aClassName put: aValue asSet asArray</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>accessing structure variables</category><body package="SSG-Info" selector="defaultFactoryMessageFrom:">defaultFactoryMessageFrom: aClassName	(self messagesFrom: aClassName)		detect: [ :message | message selector = #initialize ]		ifFound: [ ^ STypeMethodInfo				type:					#new						-&gt;							(Array								with: aClassName								with: aClassName								with: #()								with: false) ].	self		error:			'ClassMethodType of selector new cannot be applied at class: '				, aClassName</body><body package="SSG-Info" selector="type:">type: aAssoc	self addClassInfo: (STypeClassInfo type: aAssoc)</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>copying</category><body package="SSG-Info" selector="copy">copy	| copy |	copy := self class new.	types		do: [ :aClassTypeInfo | copy addClassInfo: aClassTypeInfo copy ].	copy scalars: scalars copy.	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>error handling</category><body package="SSG-Info" selector="error:">error: aString	^ SError signal: aString</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>adding</category><body package="SSG-Info" selector="addClassInfo:">addClassInfo: aTypeClassInfo	types		at: aTypeClassInfo typeName		ifPresent: [ :aTypeClass | aTypeClass joinWith: aTypeClassInfo ]		ifAbsentPut: [ aTypeClassInfo ].	self joinScalars: aTypeClassInfo scalars</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>converting</category><body package="SSG-Info" selector="asTypeInfo:">asTypeInfo: aTypeCollector	self cleanBlockClosuresOf: aTypeCollector.	aTypeCollector allClasses		do: [ :aSpyClass | 			blackList				select: [ :aMethod | aMethod origin name == aSpyClass className ]				thenDo: [ :aMethod | aSpyClass removeMethod: aMethod ].			(aSpyClass className endsWith: 'BlockClosure')				ifFalse: [ self addClassInfo: (STypeClassInfo asClassInfo: aSpyClass) ] ].	self joinScalars: aTypeCollector scalars copy.	^ self</body><body package="SSG-Info" selector="cleanBlockClosuresOf:">cleanBlockClosuresOf: aTypeCollector	[ | cleanBlocks |	cleanBlocks := (aTypeCollector scalars at: #BlockClosure)		select: [ :aBlock | aBlock isClean ].	aTypeCollector scalars at: #BlockClosure put: cleanBlocks ]		on: Error		do: [  ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>lookup</category><body package="SSG-Info" selector="classMethodType:from:">classMethodType: aSelector from: aClassName	aSelector = #new		ifTrue: [ ^ self defaultFactoryMessageFrom: aClassName ].	(self factoryMessagesFrom: aClassName)		detect: [ :aMessage | aMessage selector = aSelector ]		ifFound: [ :aMessage | ^ aMessage ].	self		error:			'ClassMethodType of selector: ' , aSelector				, ' is not found in class: ' , aClassName</body><body package="SSG-Info" selector="factoryMessagesFrom:">factoryMessagesFrom: aClassName	^ types		flatCollect: [ :aClassType | 			aClassType factoryMessages				select: [ :aMessage | aMessage receiver types includes: aClassName ] ]</body><body package="SSG-Info" selector="methodType:from:">methodType: aSelector from: aClassName	types		do: [ :aTypeClassInfo | 			aTypeClassInfo messagesAndAccessMessages				detect: [ :aMessage | 					(aMessage isFromReceiver: aClassName)						and: [ aMessage selector = aSelector ] ]				ifFound: [ :aMessage | ^ aMessage ]				ifNone: [ false ] ].	^ self		error:			'MethodType of selector: ' , aSelector , ' is not found in class: '				, aClassName</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>comparing</category><body package="SSG-Info" selector="=">= other	^ self class = other class		and: [ types = other types				and: [ | otherScalars |					otherScalars := other scalars.					scalars keys = otherScalars keys						and: [ (scalars values collect: #size)								= (otherScalars values collect: #size) ] ] ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo class</class-id> <category>converting</category><body package="SSG-Info" selector="asTypeInfo:">asTypeInfo: aTypeCollector	^ self new asTypeInfo: aTypeCollector</body><body package="SSG-Info" selector="asTypeInfo:methodsBlacklist:">asTypeInfo: aTypeCollector methodsBlacklist: aList	^ self new		blackList: aList;		asTypeInfo: aTypeCollector	" methodsBlacklist: aList"</body></methods><methods><class-id>SmallSuiteGenerator.Example</class-id> <category>accessing</category><body package="SSG-Tests-Generated" selector="=">= anObject	a = anObject a  ifTrue: [		b = anObject b  ifTrue: [			c = anObject c  ifTrue: [ ^ true ]		]	].	^ false</body><body package="SSG-Tests-Generated" selector="a">a	^a</body><body package="SSG-Tests-Generated" selector="a:">a: anObject	a := anObject</body><body package="SSG-Tests-Generated" selector="b">b	^b</body><body package="SSG-Tests-Generated" selector="b:">b: anObject	b := anObject</body><body package="SSG-Tests-Generated" selector="c">c	^c</body><body package="SSG-Tests-Generated" selector="c:">c: anObject	c := anObject</body><body package="SSG-Tests-Generated" selector="returnColl">returnColl	^ #(3 4 5 6)</body><body package="SSG-Tests-Generated" selector="returnNumber">returnNumber	^5</body><body package="SSG-Tests-Generated" selector="sum">sum	^ a + b</body></methods><methods><class-id>SmallSuiteGenerator.SFoo</class-id> <category>handling</category><body package="SSG-Scenario" selector="returnCollection">returnCollection	| a |	a := OrderedCollection new.	^ a</body><body package="SSG-Scenario" selector="returnFloat">returnFloat	| a |	a := 2.3.	^ a</body><body package="SSG-Scenario" selector="returnNum">returnNum	| a |	a := 4.	^ a</body><body package="SSG-Scenario" selector="returnString">returnString	| a |	a := 'Hello'.	^ a</body></methods><methods><class-id>SmallSuiteGenerator.SFoo</class-id> <category>initailize-release</category><body package="SSG-Scenario" selector="initialize">initialize	score := 0</body></methods><methods><class-id>SmallSuiteGenerator.SFoo</class-id> <category>accessing</category><body package="SSG-Scenario" selector="return:">return: aType	^ aType</body><body package="SSG-Scenario" selector="score">score	^ score</body><body package="SSG-Scenario" selector="score:">score: aNumber	score := aNumber</body></methods><methods><class-id>SmallSuiteGenerator.SFoo class</class-id> <category>accessing</category><body package="SSG-Scenario" selector="score:">score: aNumber	| ins |	ins := self new score: aNumber.	^ ins</body></methods><methods><class-id>SmallSuiteGenerator.SPlatformVisualWorks class</class-id> <category>logging</category><body package="SSG-Core" selector="cleanAllLogs">cleanAllLogs	</body><body package="SSG-Core" selector="clearLog">clearLog	</body><body package="SSG-Core" selector="saveOnLog:">saveOnLog: string	</body></methods><methods><class-id>SmallSuiteGenerator.SPlatformVisualWorks class</class-id> <category>instance creation</category><body package="SSG-Core" selector="fileLogger:">fileLogger: fileName	</body></methods><methods><class-id>SmallSuiteGenerator.SPlatformVisualWorks class</class-id> <category>accessing</category><body package="SSG-Core" selector="classTestCaseFactory">classTestCaseFactory	^ STestCaseFactoryVisualWorks</body></methods><methods><class-id>SmallSuiteGenerator.SPlatformPharo class</class-id> <category>tests</category><body package="SSG-Core" selector="createTestCaseClass:inPackage:">createTestCaseClass: aClassName inPackage: aPackageName	^ self testCaseClass		subclass: aClassName		instanceVariableNames: ''		classVariableNames: ''		package: aPackageName</body></methods><methods><class-id>SmallSuiteGenerator.SPlatformPharo class</class-id> <category>logging</category><body package="SSG-Core" selector="cleanAllLogs">cleanAllLogs	self instanceLogger removeAllLoggers</body><body package="SSG-Core" selector="clearLog">clearLog	self instanceLogger clearLog</body><body package="SSG-Core" selector="saveOnLog:">saveOnLog: string	self defaultFileLogger record: string</body></methods><methods><class-id>SmallSuiteGenerator.SPlatformPharo class</class-id> <category>instance creation</category><body package="SSG-Core" selector="fileLogger:">fileLogger: fileName	self logName: fileName.	^ self classLogger		ifNotNil: [ self instanceLogger fileLoggers ifEmpty: [ self createFileLogger ].			self instanceLogger fileLoggers				detect: [ :fileLogger | fileLogger fileName = fileName ]				ifNone: [ self createFileLogger.					self fileLogger: fileName ] ]		ifNil: [ nil ]</body></methods><methods><class-id>SmallSuiteGenerator.SPlatformPharo class</class-id> <category>actions</category><body package="SSG-Core" selector="clearFileLog:">clearFileLog: string	self instanceLogger fileLoggers		detect: [ :fileLogger | fileLogger fileName = string ]		ifFound: [ :fileLogger | fileLogger clearLog ]</body><body package="SSG-Core" selector="createFileLogger">createFileLogger	self instanceLogger ensureFileLoggerNamed: self logName</body><body package="SSG-Core" selector="defaultFileLogger">defaultFileLogger	self classLogger		ifNotNil: [ self instanceLogger fileLoggers ifEmpty: [ self createFileLogger ].			^ self instanceLogger fileLoggers				detect: [ :fileLogger | fileLogger fileName = self logName ] ]</body></methods><methods><class-id>SmallSuiteGenerator.SPlatformPharo class</class-id> <category>accessing</category><body package="SSG-Core" selector="classConfigurationName">classConfigurationName	^ superclass name , self implementationType</body><body package="SSG-Core" selector="classTestCaseFactory">classTestCaseFactory	^ STestCaseFactoryPharo</body><body package="SSG-Core" selector="instanceLogger">instanceLogger	^ self classLogger default</body></methods><methods><class-id>SmallSuiteGenerator.SExpression</class-id> <category>mutation</category><body package="SSG-AST" selector="insertAsParameter:using:">insertAsParameter: aExpression using: aTestCase	^ aTestCase insertAsParameter: self copy after: aExpression</body><body package="SSG-AST" selector="insertMethodMessage:using:">insertMethodMessage: expression using: aTestCase	self		error: 'cannot be inserted the methodMessage: ' , expression printString</body><body package="SSG-AST" selector="insertOn:">insertOn: aTestCase	</body><body package="SSG-AST" selector="insertRandomMessage:using:">insertRandomMessage: expression using: aTestCase	self		error: 'cannot be inserted the randomMessage: ' , expression printString</body><body package="SSG-AST" selector="pickUpReferences:">pickUpReferences: aExpression	^ #()</body><body package="SSG-AST" selector="repairOn:changing:">repairOn: aTestCase changing: aExpression	</body><body package="SSG-AST" selector="replaceArgBy:">replaceArgBy: expression	self		error: 'cannot be inserted: ' , expression printString , ' as parameter'</body><body package="SSG-AST" selector="variablesWithId">variablesWithId	^ #()</body></methods><methods><class-id>SmallSuiteGenerator.SExpression</class-id> <category>initialization</category><body package="SSG-AST" selector="initialize">initialize	super initialize.	mutated := false.	identifier := self class nextIdentifier.	needsBeFixed := false</body></methods><methods><class-id>SmallSuiteGenerator.SExpression</class-id> <category>copying</category><body package="SSG-AST" selector="copy">copy	^ self class new		id: self id;		returnType: self returnType;		mutated: self mutated;		needsBeFixed: self needsBeFixed;		parent: self</body></methods><methods><class-id>SmallSuiteGenerator.SExpression</class-id> <category>accessing</category><body package="SSG-AST" selector="id">id	^ id</body><body package="SSG-AST" selector="id:">id: anObject	id := anObject</body><body package="SSG-AST" selector="mutated">mutated	^ mutated</body><body package="SSG-AST" selector="mutated:">mutated: aBoolean	mutated := aBoolean</body><body package="SSG-AST" selector="needsBeFixed">needsBeFixed	^ needsBeFixed</body><body package="SSG-AST" selector="needsBeFixed:">needsBeFixed: aBoolean	needsBeFixed := aBoolean</body><body package="SSG-AST" selector="parent">parent	^ parent</body><body package="SSG-AST" selector="parent:">parent: anObject	parent := anObject</body><body package="SSG-AST" selector="referenceTo:">referenceTo: aClassName	^ false</body><body package="SSG-AST" selector="returnType">returnType	^ returnType</body><body package="SSG-AST" selector="returnType:">returnType: anObject	returnType := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SExpression</class-id> <category>accesing</category><body package="SSG-AST" selector="allParents">allParents	"I return my self with all my parents"	^ parent		ifNil: #()		ifNotNil: [ Set new				add: parent;				addAll: parent allParents;				yourself ]</body></methods><methods><class-id>SmallSuiteGenerator.SExpression</class-id> <category>error handling</category><body package="SSG-AST" selector="error:">error: aString	"It throws an error signal with the string passed as argument, it is important to distinguish parsing error with others"	^ SError signal: aString</body></methods><methods><class-id>SmallSuiteGenerator.SExpression</class-id> <category>actions</category><body package="SSG-AST" selector="replaceBy:">replaceBy: otherExpression	self subclassResponsibility</body><body package="SSG-AST" selector="replaceExpression:by:">replaceExpression: expression by: newExpression	"It replace the references to this expresion to the newExpresion"	</body></methods><methods><class-id>SmallSuiteGenerator.SExpression</class-id> <category>comparing</category><body package="SSG-AST" selector="=">= another	"I return true if all my attributes are equals than the another"	^ self class = another class		and:			[ self id = another id and: [ returnType = another returnType ] ]</body><body package="SSG-AST" selector="hash">hash	^ self id hash bitXor: self returnType hash</body><body package="SSG-AST" selector="isPrimitive:">isPrimitive: anObject	^ (anObject isKindOf: Number)		or: [ (anObject isKindOf: Boolean) or: [ anObject isKindOf: String ] ]</body></methods><methods><class-id>SmallSuiteGenerator.SExpression</class-id> <category>fixing</category><body package="SSG-AST" selector="fixWith:in:">fixWith: anObject in: aTestCase	</body></methods><methods><class-id>SmallSuiteGenerator.SExpression</class-id> <category>testing</category><body package="SSG-AST" selector="isFactoryMessage">isFactoryMessage	^ false</body></methods><methods><class-id>SmallSuiteGenerator.SExpression class</class-id> <category>as yet unclassified</category><body package="SSG-AST" selector="nextIdentifier">nextIdentifier	nextId ifNil: [ nextId := 0 ].	^ nextId := nextId + 1</body></methods><methods><class-id>SmallSuiteGenerator.SExpression class</class-id> <category>initialization</category><body package="SSG-AST" selector="resetId">resetId	nextId := nil</body></methods><methods><class-id>SmallSuiteGenerator.SExpression class</class-id> <category>error handling</category><body package="SSG-AST" selector="error:">error: string	^ SError signal: string</body></methods><methods><class-id>SmallSuiteGenerator.SExpression class</class-id> <category>instance creation</category><body package="SSG-AST" selector="isPrimitive:">isPrimitive: anObject	^ self new isPrimitive: anObject</body></methods><methods><class-id>SmallSuiteGenerator.SVariable</class-id> <category>mutation</category><body package="SSG-AST" selector="pickUpReferences:">pickUpReferences: anExpression	^ self = anExpression reference		ifFalse: [ #() ]		ifTrue: [ Array with: self ]</body><body package="SSG-AST" selector="repairOn:changing:">repairOn: aTestCase changing: anExpression	| otherVariable |	otherVariable := aTestCase		alternativeOfVariable: self		before: anExpression.	mutated := otherVariable ~= self.	self varName: otherVariable varName.	self id: otherVariable id</body><body package="SSG-AST" selector="replaceArgBy:">replaceArgBy: expression	returnType = expression returnType		ifFalse: [ ^ self				error:					'Cannot replace argument of type: ' , returnType , ' by: '						, expression returnType ].	self replaceBy: expression</body><body package="SSG-AST" selector="variablesWithId">variablesWithId	^ id ifNotNil: [ Array with: self ] ifNil: [ super variablesWithId ]</body></methods><methods><class-id>SmallSuiteGenerator.SVariable</class-id> <category>initialization</category><body package="SSG-AST" selector="initialize">initialize	super initialize.	varName := '_var'</body></methods><methods><class-id>SmallSuiteGenerator.SVariable</class-id> <category>accessing</category><body package="SSG-AST" selector="key">key	SPlatform asDict		ifTrue: [ ^ id + 1 ]		ifFalse: [ ^ self printString asSymbol ]</body><body package="SSG-AST" selector="referenceTo:">referenceTo: aClassName	^ self returnType = aClassName</body><body package="SSG-AST" selector="replaceBy:">replaceBy: otherVariable	" I replace my attributes values with the ones in the otherExpression.	  the argument is an object from my same class"	self varName: otherVariable varName.	self id: otherVariable id.	self returnType: otherVariable returnType</body><body package="SSG-AST" selector="varName">varName	^ varName</body><body package="SSG-AST" selector="varName:">varName: anObject	varName := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SVariable</class-id> <category>copying</category><body package="SSG-AST" selector="copy">copy	| copy |	copy := super copy.	copy varName: varName copy.	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.SVariable</class-id> <category>actions</category><body package="SSG-AST" selector="replaceExpression:by:">replaceExpression: anExpression by: newExpression	"If I am referencing to anExprension. I will now reference to the newExpresion"	| reference |	self = anExpression		ifFalse: [ ^ self ].	reference := newExpression reference.	self		id: reference id;		varName: reference varName;		returnType: reference returnType;		mutated: true</body></methods><methods><class-id>SmallSuiteGenerator.SVariable</class-id> <category>printing</category><body package="SSG-AST" selector="printOn:">printOn: aStream	SPlatform asDict		ifFalse: [ aStream nextPutAll: varName.			id ifNotNil: [ aStream nextPutAll: id printString ] ]		ifTrue: [ id				ifNil: [ aStream nextPutAll: varName ]				ifNotNil: [ aStream nextPutAll: '( var at: '.					aStream nextPutAll: (id + 1) printString.					aStream nextPutAll: ' )' ] ]</body></methods><methods><class-id>SmallSuiteGenerator.SVariable</class-id> <category>comparing</category><body package="SSG-AST" selector="=">= other	^ super = other and: [ varName = other varName ]</body><body package="SSG-AST" selector="hash">hash	^ super hash bitXor: varName hash</body></methods><methods><class-id>SmallSuiteGenerator.SVariable class</class-id> <category>accessing</category><body package="SSG-AST" selector="name:">name: aString	| variable |	variable := self new.	variable varName: aString.	^ variable</body><body package="SSG-AST" selector="nameOrId:">nameOrId: anObject	| variable |	variable := self new.	anObject isString		ifTrue: [ variable varName: anObject ]		ifFalse: [ variable id: anObject - 1 ].	^ variable</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage</class-id> <category>accessing</category><body package="SSG-AST" selector="args">args	^ args</body><body package="SSG-AST" selector="args:">args: anObject	args := anObject</body><body package="SSG-AST" selector="id">id	^ receiver id</body><body package="SSG-AST" selector="mutated">mutated	^ mutated		or: [ receiver mutated				or: [ args detect: #mutated ifFound: [ true ] ifNone: [ false ] ] ]</body><body package="SSG-AST" selector="receiver">receiver	^ receiver</body><body package="SSG-AST" selector="receiver:">receiver: anObject	receiver := anObject</body><body package="SSG-AST" selector="replaceBy:">replaceBy: anAbstractMessage	" I replace my attributes values with the ones in the otherExpression."	mutated := receiver ~= anAbstractMessage receiver		or: [ selector ~= anAbstractMessage selector				or: [ args ~= anAbstractMessage args ] ].	receiver replaceBy: anAbstractMessage receiver.	self selector: anAbstractMessage selector.	self args size = anAbstractMessage args size		ifTrue: [ self args				with: anAbstractMessage args				do: [ :arg :newArg | arg replaceBy: newArg ] ]		ifFalse: [ self args: anAbstractMessage args deepCopy ]</body><body package="SSG-AST" selector="selector">selector	^ selector</body><body package="SSG-AST" selector="selector:">selector: anObject	selector := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage</class-id> <category>mutation</category><body package="SSG-AST" selector="changeArgsFrom:in:">changeArgsFrom: expression in: aTestCase	args isEmpty		ifTrue: [ ^ self error: 'Cannot change args from: ' , self selector ].	args do: [ :arg | arg repairOn: aTestCase changing: expression ]</body><body package="SSG-AST" selector="changeReceiverFrom:in:">changeReceiverFrom: expression in: aTestCase	receiver repairOn: aTestCase changing: expression</body><body package="SSG-AST" selector="insertRandomMessage:using:">insertRandomMessage: expression using: aTestCase	| anotherExpression |	anotherExpression := self copy.	anotherExpression mutated: true.	anotherExpression needsBeFixed: true.	^ aTestCase insertExpression: anotherExpression after: expression</body><body package="SSG-AST" selector="pickUpReferences:">pickUpReferences: aExpression	^ (receiver pickUpReferences: aExpression)		, (args flatCollect: [ :arg | arg pickUpReferences: aExpression ])</body><body package="SSG-AST" selector="repairOn:changing:">repairOn: aTestCase changing: expression	(self random		collectAtRandom: #(#changeReceiverFrom:in: #changeSelectorFrom:in: #changeArgsFrom:in:))		do: [ :aSelector | 			[ ^ self				perform: aSelector				withArguments: (Array with: expression with: aTestCase) ]				on: SError				do: [  ] ].	self error: 'Cannot change the statement: ' , expression printString</body><body package="SSG-AST" selector="replaceArgBy:">replaceArgBy: expression	args		ifEmpty: [ self error: self printString , ' does not have args to replace.' ].	args		do: [ :arg | 			[ ^ arg replaceArgBy: expression ]				on: SError				do: [  ] ].	self		error: 'Cannot replace any argument by: ' , expression printString</body><body package="SSG-AST" selector="variablesWithId">variablesWithId	^ receiver variablesWithId		, (args flatCollect: [ :arg | arg variablesWithId ])</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage</class-id> <category>initialization</category><body package="SSG-AST" selector="initialize">initialize	super initialize.	args := OrderedCollection new: 2</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage</class-id> <category>override</category><body package="SSG-AST" selector="changeSelectorFrom:in:">changeSelectorFrom: aExpression in: aTestCase	^ self subclassResponsibility</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage</class-id> <category>copying</category><body package="SSG-AST" selector="copy">copy	| copy |	copy := super copy.	copy		args: args deepCopy;		receiver: receiver copy;		selector: selector copy.	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage</class-id> <category>actions</category><body package="SSG-AST" selector="replaceExpression:by:">replaceExpression: anExpression by: newExpression	"It replace the references to this expresion to the newExpresion"	receiver replaceExpression: anExpression by: newExpression.	args		do: [ :arg | arg replaceExpression: anExpression by: newExpression ]</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage</class-id> <category>printing</category><body package="SSG-AST" selector="printOn:">printOn: aStream	receiver printOn: aStream.	aStream nextPut: Character space.	self printSelectors: aStream</body><body package="SSG-AST" selector="printSelectors:">printSelectors: aStream	args		ifEmpty: [ aStream nextPutAll: self selector ]		ifNotEmpty: [ | withColon index stop |			withColon := self selector includes: $:.			index := 0.			stop := self args size.			(self selector substrings: ':')				with: self args				do: [ :selectorPart :arg | 					index := index + 1.					aStream nextPutAll: selectorPart.					withColon						ifTrue: [ aStream nextPutAll: ': ' ].					aStream nextPutAll: arg printString.					(index &lt; stop and: [ withColon ])						ifTrue: [ aStream nextPut: Character space ] ] ]</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage</class-id> <category>comparing</category><body package="SSG-AST" selector="=">= other	^ super = other		and: [ args = other args				and:					[ receiver = other receiver and: [ selector = other selector ] ] ]</body><body package="SSG-AST" selector="hash">hash	^ super hash		bitXor: (receiver hash bitXor: (selector hash bitXor: args hash))</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage class</class-id> <category>creation</category><body package="SSG-AST" selector="args:with:">args: aMethodTypeInfo with: statements	| dict |	(statements isEmpty or: [ aMethodTypeInfo argTypes isNil ])		ifTrue: [ ^ #() ].	dict := Dictionary new.	(SPlatform randomGenerator collectAtRandom: statements)		do: [ :stm | dict at: stm returnType put: stm variable copy ].	^ aMethodTypeInfo argTypes		collect: [ :aTypeReturn | 			| ft |			ft := (SPlatform randomGenerator collectAtRandom: aTypeReturn types)				detect: [ :type | dict at: type ifPresent: [ true ] ifAbsent: [ false ] ]				ifNone: [ nil ].	"lack to update types of MultiTypeInfo"			ft				ifNil: [ self						error:							'Cannot build the method call: ' , aMethodTypeInfo selector								, ', even it was tried to build the argument first' ].			dict at: ft ]</body></methods><methods><class-id>SmallSuiteGenerator.SSelf</class-id> <category>initialization</category><body package="SSG-AST" selector="initialize">initialize	super initialize.	varName := 'self'</body></methods><methods><class-id>SmallSuiteGenerator.SFactoryMessage</class-id> <category>override</category><body package="SSG-AST" selector="changeSelectorFrom:in:">changeSelectorFrom: aExpression in: aTestCase	| otherFactoryMessage |	otherFactoryMessage := aTestCase		alternativeFactoryMessage: self		before: aExpression.	mutated := otherFactoryMessage selector ~= self selector.	self selector: otherFactoryMessage selector.	self args: otherFactoryMessage args</body></methods><methods><class-id>SmallSuiteGenerator.SFactoryMessage</class-id> <category>mutation</category><body package="SSG-AST" selector="insertOn:">insertOn: aTestCase	[ ^ aTestCase		addFactoryMessage: self returnType		ofSelector: self selector ]		on: SError		do: [  ]</body></methods><methods><class-id>SmallSuiteGenerator.SFactoryMessage</class-id> <category>accessing</category><body package="SSG-AST" selector="referenceTo:">referenceTo: aClassName	^ receiver referenceTo: aClassName</body></methods><methods><class-id>SmallSuiteGenerator.SFactoryMessage</class-id> <category>testing</category><body package="SSG-AST" selector="isFactoryMessage">isFactoryMessage	^ true</body></methods><methods><class-id>SmallSuiteGenerator.SFactoryMessage class</class-id> <category>creation</category><body package="SSG-AST" selector="method:class:previousStatements:">method: aMethodTypeInfo class: aClassName previousStatements: statements	^ self new		receiver:			(SVariable new				varName: aClassName;				returnType: aClassName;				yourself);		returnType: aClassName;		selector: aMethodTypeInfo selector;		args: (self args: aMethodTypeInfo with: statements);		yourself</body><body package="SSG-AST" selector="method:previousStatements:">method: aMethodTypeInfo previousStatements: statements	| returnType |	returnType := aMethodTypeInfo returnType type.	^ self new		receiver:			(SVariable new				varName: returnType;				returnType: returnType;				yourself);		returnType: returnType;		selector: aMethodTypeInfo selector;		args: (self args: aMethodTypeInfo with: statements);		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SFactoryMessage class</class-id> <category>accessing</category><body package="SSG-AST" selector="default:">default: aClassName	^ self new		receiver:			(SVariable new				varName: aClassName;				returnType: aClassName;				yourself);		selector: #new;		returnType: aClassName;		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SAssignment</class-id> <category>mutation</category><body package="SSG-AST" selector="insertAsParameter:using:">insertAsParameter: aExpression using: aTestCase	^ variable insertAsParameter: aExpression using: aTestCase</body><body package="SSG-AST" selector="insertMethodMessage:using:">insertMethodMessage: aExpression using: aTestCase	^ value insertMethodMessage: aExpression using: aTestCase</body><body package="SSG-AST" selector="insertOn:">insertOn: aTestCase	^ value insertOn: aTestCase</body><body package="SSG-AST" selector="insertRandomMessage:using:">insertRandomMessage: aExpression using: aTestCase	^ value insertRandomMessage: aExpression using: aTestCase</body><body package="SSG-AST" selector="pickUpReferences:">pickUpReferences: aExpression	^ value pickUpReferences: aExpression</body><body package="SSG-AST" selector="repairOn:changing:">repairOn: aTestCase changing: expression	self reference = expression reference		ifTrue: [ value repairOn: aTestCase changing: expression ]</body><body package="SSG-AST" selector="replaceArgBy:">replaceArgBy: expression	value replaceArgBy: expression</body><body package="SSG-AST" selector="variablesWithId">variablesWithId	^ variable variablesWithId , value variablesWithId</body></methods><methods><class-id>SmallSuiteGenerator.SAssignment</class-id> <category>initialization</category><body package="SSG-AST" selector="initialize">initialize	super initialize</body></methods><methods><class-id>SmallSuiteGenerator.SAssignment</class-id> <category>copying</category><body package="SSG-AST" selector="copy">copy	| copy |	copy := super copy.	copy		variable: variable copy;		value: value copy.	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.SAssignment</class-id> <category>accessing</category><body package="SSG-AST" selector="id">id	^ variable id</body><body package="SSG-AST" selector="mutated">mutated	^ value mutated</body><body package="SSG-AST" selector="needsBeFixed:">needsBeFixed: aBoolean	super needsBeFixed: aBoolean.	value ifNotNil: [ value needsBeFixed: aBoolean ]</body><body package="SSG-AST" selector="reference">reference	^ variable</body><body package="SSG-AST" selector="referenceTo:">referenceTo: aClassName	^ value referenceTo: aClassName</body><body package="SSG-AST" selector="replaceBy:">replaceBy: aExpression	" If I am the expresion to be replace it.	I replace my attributes values with the ones in the otherExpression."	self reference = aExpression reference		ifTrue: [ value replaceBy: aExpression value ]</body><body package="SSG-AST" selector="value:">value: anObject	value := anObject</body><body package="SSG-AST" selector="variable">variable	^ variable</body><body package="SSG-AST" selector="variable:">variable: anObject	variable := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SAssignment</class-id> <category>printing</category><body package="SSG-AST" selector="printOn:">printOn: aStream	SPlatform asDict		ifFalse: [ variable printOn: aStream.			aStream nextPutAll: ' := '.			value printOn: aStream.			aStream nextPut: $. ]		ifTrue: [ aStream nextPutAll: 'var at: '.			aStream nextPutAll: (variable id + 1) printString.			aStream nextPutAll: ' put: ('.			value printOn: aStream.			aStream nextPutAll: ' ).' ]</body></methods><methods><class-id>SmallSuiteGenerator.SAssignment</class-id> <category>fixing</category><body package="SSG-AST" selector="fixWith:in:">fixWith: anObject in: aTestCase	value fixWith: anObject in: aTestCase.	returnType := value returnType.	variable returnType: value returnType.	needsBeFixed := value needsBeFixed</body></methods><methods><class-id>SmallSuiteGenerator.SAssignment</class-id> <category>evaluating</category><body package="SSG-AST" selector="value">value	^ value</body></methods><methods><class-id>SmallSuiteGenerator.SAssignment</class-id> <category>actions</category><body package="SSG-AST" selector="replaceExpression:by:">replaceExpression: expression by: newExpression	"It replace the references to this expresion to the newExpresion"	value replaceExpression: expression by: newExpression</body></methods><methods><class-id>SmallSuiteGenerator.SAssignment</class-id> <category>comparing</category><body package="SSG-AST" selector="=">= other	^ super = other		and: [ variable = other variable and: [ value = other value ] ]</body><body package="SSG-AST" selector="hash">hash	^ super hash bitXor: (variable hash bitXor: value hash)</body></methods><methods><class-id>SmallSuiteGenerator.SAssignment class</class-id> <category>instance creation</category><body package="SSG-AST" selector="name:value:">name: aVariable value: anExpression	^ self new		variable: aVariable;		value: anExpression;		returnType: anExpression returnType;		needsBeFixed: anExpression needsBeFixed;		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SMessage</class-id> <category>mutation</category><body package="SSG-AST" selector="insertMethodMessage:using:">insertMethodMessage: aExpression using: aTestCase	^ self insertRandomMessage: aExpression using: aTestCase</body><body package="SSG-AST" selector="insertOn:">insertOn: aTestCase	[ ^ aTestCase		addMessage: self selector		from: self receiver returnType ]		on: SError		do: [  ]</body></methods><methods><class-id>SmallSuiteGenerator.SMessage</class-id> <category>override</category><body package="SSG-AST" selector="changeSelectorFrom:in:">changeSelectorFrom: aExpression in: aTestCase	| otherMessage |	otherMessage := aTestCase		alternativeMessage: self		before: aExpression.	mutated := otherMessage selector ~= self selector.	self selector: otherMessage selector.	self args: otherMessage args</body></methods><methods><class-id>SmallSuiteGenerator.SMessage</class-id> <category>fixing</category><body package="SSG-AST" selector="fixWith:in:">fixWith: anObject in: aTestCase	(anObject receiver types includes: receiver returnType)		ifFalse: [ self halt ].	returnType := self random selectAtRandom: anObject returnType types.	anObject argTypes		with: args		do: [ :arg1 :arg2 | 			(arg1 types includes: arg2 returnType)				ifFalse: [ self halt ] ].	needsBeFixed := false</body></methods><methods><class-id>SmallSuiteGenerator.SMessage class</class-id> <category>instance creation</category><body package="SSG-AST" selector="newFromReceiver:method:andPreviousStatements:">newFromReceiver: aReceiver method: aMethod andPreviousStatements: statements	^ SMessage new		returnType: (aMethod returnTypeFor: aReceiver);		selector: aMethod selector;		receiver: aReceiver;		args: (self args: aMethod with: statements);		needsBeFixed: (aMethod returnType types size &gt; 1 or: [ aMethod hasProfiler not ]);		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SLiteral</class-id> <category>evaluating</category><body package="SSG-AST" selector="value">value	^ value</body></methods><methods><class-id>SmallSuiteGenerator.SLiteral</class-id> <category>mutation</category><body package="SSG-AST" selector="insertOn:">insertOn: aTestCase	[ ^ aTestCase addLiteral: self returnType ]		on: SError		do: [  ]</body><body package="SSG-AST" selector="repairOn:changing:">repairOn: aTestCase changing: aExpression	self value: value mutateToChange</body></methods><methods><class-id>SmallSuiteGenerator.SLiteral</class-id> <category>copying</category><body package="SSG-AST" selector="copy">copy	| copy |	copy := super copy.	copy value: value copy.	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.SLiteral</class-id> <category>printing</category><body package="SSG-AST" selector="printOn:">printOn: aStream	aStream		nextPutAll:			((value isNumber or: [ value isBlock ])				ifTrue: [ value printString ]				ifFalse: [ value storeString ])</body></methods><methods><class-id>SmallSuiteGenerator.SLiteral</class-id> <category>accessing</category><body package="SSG-AST" selector="value:">value: anObject	value := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SLiteral</class-id> <category>actions</category><body package="SSG-AST" selector="referenceTo:">referenceTo: aClassName	^ (value isClass		ifTrue: [ value name ]		ifFalse: [ value className ]) = aClassName asString</body><body package="SSG-AST" selector="replaceBy:">replaceBy: otherExpression	" I replace my attributes values with the ones in the otherExpression.	  the argument is an object from my same class"	self value: otherExpression value</body></methods><methods><class-id>SmallSuiteGenerator.SLiteral</class-id> <category>comparing</category><body package="SSG-AST" selector="=">= other	^ super = other		and: [ value isLiteral				ifTrue: [ value = other value ]				ifFalse: [ value isClass						ifTrue: [ value name = other value name ]						ifFalse: [ value className = other value className ] ] ]</body><body package="SSG-AST" selector="hash">hash	^ super hash bitXor: value hash</body></methods><methods><class-id>SmallSuiteGenerator.SLiteral class</class-id> <category>parsing</category><body package="SSG-AST" selector="value:">value: aValue	^ self new		value: aValue;		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SGAMutationOperation</class-id> <category>actions</category><body package="SSG-GA" selector="doMutate:">doMutate: aTestCase	self next &lt;= mutationRate		ifTrue: [ aTestCase removeStatement ].	self next &lt;= mutationRate		ifTrue: [ aTestCase changeStatement ].	self next &lt;= mutationRate		ifTrue: [ aTestCase insertStatement ]</body><body package="SSG-GA" selector="mutate:">mutate: aTestCase	| newTestCase |	newTestCase := aTestCase copy.	"copyForMutation"	self doMutate: newTestCase.	^ newTestCase</body></methods><methods><class-id>SmallSuiteGenerator.SGAMutationOperation</class-id> <category>initialization</category><body package="SSG-GA" selector="initialize">initialize	super initialize.	self mutationRate: (1 / 3) asFloat</body></methods><methods><class-id>SmallSuiteGenerator.SGAMutationOperation</class-id> <category>accessing</category><body package="SSG-GA" selector="mutationRate:">mutationRate: aFloat	mutationRate := aFloat</body></methods><methods><class-id>SmallSuiteGenerator.SGARandomSelection</class-id> <category>selection</category><body package="SSG-GA" selector="selectJustOneOf:with:">selectJustOneOf: aCollection with: probabilities	^ self random selectAtRandom: aCollection</body><body package="SSG-GA" selector="selectOf:">selectOf: aCollection	^ self random collectAtRandom: aCollection</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactoryPharo</class-id> <category>actions</category><body package="SSG-Core" selector="initializeProfiler">initializeProfiler	profiler := self aSLProfilerCoverage		profilerForPackagesMatching: self targetPackageRegex.	(profiler allMethods select: #isNotMethodExtension)		do: #installGhosts		displayingProgress: 'Instrumenting ' , self targetPackageRegex</body><body package="SSG-Core" selector="uninstall">uninstall	profiler uninstall</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>actions</category><body package="SSG-Core" selector="fixTypeReturnOf:">fixTypeReturnOf: aStatement	[ | executionContext aReturnType |	executionContext := self analyze.	aReturnType := (executionContext at: aStatement variable key) class		name.	aStatement returnType = aReturnType		ifTrue: [ aStatement needsBeFixed: false.			^ self ].	(self subStatementsAfterIndexOf: aStatement)		do: [ :stm | self repairReferenceTo: aStatement of: stm ].	aStatement variable returnType: aReturnType.	aStatement value returnType: aReturnType.	aStatement needsBeFixed: false.	aStatement returnType: aReturnType ]		on: Exception		do: [  ]</body><body package="SSG-Core" selector="generateAssertions">generateAssertions	^ self		generateAssertions:			(Array				with: SComparisonAssertion				with: SInspectorAssertion				with: SPrimitiveAssertion				with: SStringAssertion)</body><body package="SSG-Core" selector="generateAssertions:">generateAssertions: classAssertions	"	it analyze each kind of assertion an generate a set of assertion based on the test case -- double dispatch	"	| executionContext |	executionContext := self analyze.	assertions := classAssertions		flatCollect: [ :assertion | assertion for: executionContext ]</body><body package="SSG-Core" selector="generateStatements">generateStatements	| flag counter |	flag := true.	counter := 0.	self		assert: typeInfo types isNotEmpty		description: 'TypeInfo does not contain info at all.'.	[ flag and: [ self length &lt; self maxNumberOfStatements ] ]		whileTrue: [ | array |			array := self random				collectAtRandom: (Array with: #addMessage with: #addFieldAccessMessage).			array				detect: [ :aMethod | 					[ (self perform: aMethod) isNotNil ]						on: SError						do: [ false ] ]				ifFound: [ :aMethod | 					| lastStm |					lastStm := statements last.					lastStm needsBeFixed						ifTrue: [ self fixTypeReturnOf: lastStm ] ]				ifNone: [ "	[ self addMessage ]				on: SError				do: [  ]"					counter := counter + 1.					counter &gt; self maxNumberOfStatements						ifTrue: [ flag := false.							self error: 'Not able to generate statements' ] ] ]</body><body package="SSG-Core" selector="generateStatements:">generateStatements: anInteger	self maxNumberOfStatements: anInteger.	self generateStatements</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>inserting</category><body package="SSG-Core" selector="addAssignment:">addAssignment: anExpression	| assignment |	assignment := self newAssignment: anExpression.	(assignment returnType isNil		or: [ assignment returnType = #SUndefinedObject ])		ifFalse: [ self validTargetClassName: assignment returnType ].	self addStatement: assignment.	^ assignment</body><body package="SSG-Core" selector="addFactoryMessage">addFactoryMessage	| variables |	variables := self objectVariables.	variables		ifEmpty: [ (self random collectAtRandom: typeInfo noneAbstractClasses)				do: [ :aClass | 					[ ^ self addFactoryMessage: (self fullSymbolOf: aClass name) ]						on: SError						do: [  ] ].			self error: 'Cannot create a factoryMessage.' ]		ifNotEmpty: [ ^ self				addFactoryMessage: (self random selectAtRandom: variables) returnType ]</body><body package="SSG-Core" selector="addFactoryMessage:">addFactoryMessage: symbol	^ self addAssignment: (self newFactoryMessage: symbol before: nil)</body><body package="SSG-Core" selector="addFactoryMessage:ofSelector:">addFactoryMessage: aClassName ofSelector: aSelector	^ [ self		addAssignment:			(self				factoryMessageUsing: (typeInfo classMethodType: aSelector from: aClassName)				before: nil) ]		on: SError		do: [ self addFactoryMessage: aClassName ]</body><body package="SSG-Core" selector="addFieldAccessMessage">addFieldAccessMessage	| receiver methods |	receiver := self pickAnObjectVariable.	methods := self pickAccessorsOf: receiver returnType.	methods		ifNotEmpty: [ ^ self				addFieldAccessMessage: (self selectMethod: methods)				withReceiver: receiver ].	self error: 'Cannot create a field access message.'</body><body package="SSG-Core" selector="addFieldAccessMessage:from:">addFieldAccessMessage: aSelector from: aClassName	| receiver anAccessor |	anAccessor := (self pickAccessorsOf: aClassName)		detect: [ :accessor | accessor selector = aSelector ]		ifNone: [ nil ].	anAccessor		ifNil: [ self				error:					'None field access message of selector: ' , aSelector						, ' matches with: ' , aClassName ].	receiver := self pickOrCreateObjectVariableOf: aClassName.	^ self addFieldAccessMessage: anAccessor withReceiver: receiver</body><body package="SSG-Core" selector="addFieldAccessMessage:withReceiver:">addFieldAccessMessage: method withReceiver: receiver	^ self		addAssignment: (SFieldAccessMessage newFromReceiver: receiver copy andMethod: method)</body><body package="SSG-Core" selector="addLiteral">addLiteral	^ self addLiteral: self randomLiteralClassName</body><body package="SSG-Core" selector="addLiteral:">addLiteral: aClassName	^ self addAssignment: (self newLiteral: aClassName)</body><body package="SSG-Core" selector="addMessage">addMessage	| receiver methods |	receiver := self pickAnObjectVariable.	methods := self pickMessagesOf: receiver returnType.	methods		ifEmpty: [ self				error: 'There are no method typeInfos for: ' , receiver returnType , '.' ]		ifNotEmpty: [ ^ self				addMessage: (self selectMethod: methods)				withReceiver: receiver ]</body><body package="SSG-Core" selector="addMessage:from:">addMessage: aSelector from: aClassName	| receiver aMethod |	aMethod := (self pickMessagesOf: aClassName)		, (typeInfo factoryMessagesFrom: aClassName)		detect: [ :aMessage | aMessage selector = aSelector ]		ifNone: [ nil ].	aMethod		ifNil: [ self				error:					'None message of selector: ' , aSelector , ' matches with: '						, aClassName ].	receiver := self pickOrCreateObjectVariableOf: aClassName.	^ self addMessage: aMethod withReceiver: receiver</body><body package="SSG-Core" selector="addMessage:withReceiver:">addMessage: method withReceiver: receiver	^ self		addAssignment: (self messageUsing: method and: receiver before: nil)</body><body package="SSG-Core" selector="addStatement:">addStatement: anExpression	self canAddStatement		ifTrue: [ statements add: anExpression ]</body><body package="SSG-Core" selector="addStatement:after:">addStatement: newExpression after: aStatement	| anIndex |	self canAddStatement		ifFalse: [ ^ self ].	anIndex := statements indexOf: aStatement.	anIndex = 0		ifTrue: [ self addStatement: newExpression ]		ifFalse: [ anIndex := self random selectAtRandom: (anIndex to: self length).			statements add: newExpression afterIndex: anIndex ].	^ newExpression</body><body package="SSG-Core" selector="addStatement:before:">addStatement: newExpression before: aStatement	"I add a newExpression before aStatement"	self canAddStatement		ifFalse: [ ^ self ].	statements		add: newExpression		afterIndex: (self randomIndexToAdd: newExpression before: aStatement)</body><body package="SSG-Core" selector="addStatementOfType:before:">addStatementOfType: aType before: expression	| newExpression |	newExpression := self newStatementOfType: aType before: expression.	newExpression mutated: true.	newExpression := self newAssignment: newExpression.	self addStatement: newExpression before: expression.	^ newExpression</body><body package="SSG-Core" selector="addStatements:">addStatements: collStatements	self		assert: statements isEmpty		description: 'statements must be empty'.	collStatements		do: [ :stm | "	statements addAll: collStatements" self addStatement: stm ]</body><body package="SSG-Core" selector="insertAsParameter:after:">insertAsParameter: expression after: aStatement	(self random		collectAtRandom:			(statements				copyFrom: (statements indexOf: aStatement) + 1				to: self length))		do: [ :stm | 			[ | mutatedStm |			mutatedStm := stm replaceArgBy: expression.			(mutatedStm pickUpReferences: expression)				ifNotEmpty: [ mutatedStm value mutated: true.					mutatedStm needsBeFixed: true ].			^ mutatedStm ]				on: SError				do: [  ] ].	self		error: 'Cannot insert any parameter by: ' , expression printString</body><body package="SSG-Core" selector="insertExpression:after:">insertExpression: expression after: aStatement	^ self		addStatement: (self newAssignment: expression)		after: aStatement</body><body package="SSG-Core" selector="insertExpressionRandomly">insertExpressionRandomly	(self random		collectAtRandom:			#(#insertRandomMessage:using: #insertMethodMessage:using: #insertAsParameter:using:))		do: [ :selector | 			[ | insertedStm |			insertedStm := self insertStatementOfSelector: selector.			insertedStm value mutated				ifTrue: [ self fixTypeReturnOf: insertedStm ].			^ insertedStm ]				on: Error				do: [  ] ]</body><body package="SSG-Core" selector="insertStatement">insertStatement	| l stop alpha count |	l := 1.	count := 1.	stop := self length.	alpha := 0.5.	[ l &lt; stop and: [ self next &lt;= (alpha raisedTo: count) ] ]		whileTrue: [ self insertExpressionRandomly.			l := l + 1.			count := count + 1 ]</body><body package="SSG-Core" selector="insertStatementOfSelector:">insertStatementOfSelector: selector	(self random collectAtRandom: statements copy)		do: [ :stm | 			[ ^ self perform: selector inStatement: stm ]				on: SError				do: [  ] ].	self		error: 'Cannot insert statement of selector: ' , selector printString</body><body package="SSG-Core" selector="randomLiteralClassName">randomLiteralClassName	^ [ self random		selectAtRandom: typeInfo scalars keys asOrderedCollection ]		on: Error		do: [ self				error: 'TypeInfo does not have scalars. Set scalars on typeInfo.' ]</body><body package="SSG-Core" selector="repair:of:">repair: exprToReplace of: expression	| aType replacement |	aType := exprToReplace returnType.	replacement := (self random		collectAtRandom: (self subStatementsFrom: 1 toPrevIndexOf: expression))		detect:			[ :stm | stm reference ~= exprToReplace and: [ stm returnType = aType ] ]		ifNone: [ self addStatementOfType: aType before: expression ].	self replace: exprToReplace by: replacement on: expression</body><body package="SSG-Core" selector="selectMethod:">selectMethod: aCollection	selectionStrategy		ifNil: [ ^ self random selectAtRandom: aCollection ]		ifNotNil: [ ^ selectionStrategy				selectJustOneOf: aCollection				with: (aCollection collect: #executions) ]</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>accessing</category><body package="SSG-Core" selector="addParent:">addParent: aTestCase	parents add: aTestCase.	aTestCase addChild: self</body><body package="SSG-Core" selector="addParents:">addParents: aCollection	aCollection do: [ :e | self addParent: e ]</body><body package="SSG-Core" selector="allParents:on:using:">allParents: testCase on: collection using: associationSet	testCase parents		reject:			[ :tC | associationSet includes: tC generationNumber -&gt; tC idPopulation ]		thenDo: [ :tC | 			associationSet add: tC generationNumber -&gt; tC idPopulation.			collection add: tC.			self allParents: tC on: collection using: associationSet ]</body><body package="SSG-Core" selector="allVarNames">allVarNames	^ statements collect: [ :stm | stm reference printString ]</body><body package="SSG-Core" selector="assertions">assertions	^ assertions</body><body package="SSG-Core" selector="assignedIds">assignedIds	^ statements collect: #id</body><body package="SSG-Core" selector="assignId">assignId	| idToAssign assignedIds |	assignedIds := self assignedIds.	[ assignedIds includes: nextId ] whileTrue: [ nextId := nextId + 1 ].	idToAssign := nextId.	nextId := nextId + 1.	^ idToAssign</body><body package="SSG-Core" selector="children">children	^ children</body><body package="SSG-Core" selector="fitness">fitness	^ fitness</body><body package="SSG-Core" selector="fitnessByClass">fitnessByClass	^ fitnessByClass</body><body package="SSG-Core" selector="lastMessage">lastMessage	^ lastMessage</body><body package="SSG-Core" selector="lastMessage:">lastMessage: anObject	lastMessage := anObject</body><body package="SSG-Core" selector="length">length	^ statements size</body><body package="SSG-Core" selector="maxNumberOfStatements">maxNumberOfStatements	^ maxNumberOfStatements</body><body package="SSG-Core" selector="maxNumberOfStatements:">maxNumberOfStatements: anObject	maxNumberOfStatements := anObject</body><body package="SSG-Core" selector="notEmpty">notEmpty	^ self length &gt; 0</body><body package="SSG-Core" selector="numMaxStatements">numMaxStatements	^ maxNumberOfStatements</body><body package="SSG-Core" selector="numMaxStatements:">numMaxStatements: anObject	maxNumberOfStatements := anObject</body><body package="SSG-Core" selector="parents">parents	^ parents</body><body package="SSG-Core" selector="selectionStrategy:">selectionStrategy: selectStrategy	selectionStrategy := selectStrategy</body><body package="SSG-Core" selector="statementAt:">statementAt: statement	statements		detect: [ :stm | stm = statement ]		ifFound: [ :stm | ^ stm ].	self		error: 'Statement: ' , statement printString , ' is not found in testCase.'</body><body package="SSG-Core" selector="statementOfVarName:">statementOfVarName: aString	statements		detect: [ :stm | stm reference printString = aString ]		ifFound: [ :stm | ^ stm ].	self error: 'Statement of varName: ' , aString , 'is not found.'</body><body package="SSG-Core" selector="statements">statements	^ statements</body><body package="SSG-Core" selector="targetClassesNames">targetClassesNames	^ targetClassesNames</body><body package="SSG-Core" selector="typeInfo">typeInfo	^ typeInfo</body><body package="SSG-Core" selector="typeInfo:">typeInfo: anObject	typeInfo := anObject</body><body package="SSG-Core" selector="validReferences">validReferences	| references |	references := Set new.	^ statements		detect: [ :stm | 			| variables |			variables := stm variablesWithId asSet.			references add: stm reference.			(references includesAll: variables)				ifFalse: [ self halt.					true ]				ifTrue: [ references addAll: variables.					false ] ]		ifFound: [ false ]		ifNone: [ true ]</body><body package="SSG-Core" selector="validTargetClassName:">validTargetClassName: aClassName	(validatedTargetClassName		and: [ (targetClassesNames includes: aClassName) not				and: [ | classInfo |					classInfo := typeInfo classAt: aClassName ifNone: [  ].					classInfo isNil not and: [ classInfo allMethods isNotEmpty ] ] ])		ifTrue: [ self addTargetClassName: aClassName ].	((targetClassesNames includes: aClassName) not		or: [ typeInfo isAbstractClass: aClassName ])		ifTrue: [ [ typeInfo scalars at: aClassName ]				on: Error				do: [ self error: 'Class: ' , aClassName , ' is not able to be used.' ] ]		ifFalse: [ validatedTargetClassName := true ]</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>modifying</category><body package="SSG-Core" selector="changeMessageNotUnderstood:from:">changeMessageNotUnderstood: aSelector from: aClassName	^ false</body><body package="SSG-Core" selector="changeStatement">changeStatement	(self random collectAtRandom: statements)		do: [ :stm | 			[ ^ self changeStatement: stm ]				on: SError				do: [  ] ]</body><body package="SSG-Core" selector="changeStatement:">changeStatement: aStatement	| statementChanged newStm |	statementChanged := aStatement copy		repairOn: self		changing: aStatement.	(self statementAt: aStatement) replaceBy: statementChanged.	newStm := self statementAt: statementChanged.	self fixTypeReturnOf: (newStm needsBeFixed: true).	^ statementChanged</body><body package="SSG-Core" selector="changeStatementOfClassName:">changeStatementOfClassName: aClassName	| varExpressions changed |	varExpressions := self messagesVariablesFrom: aClassName.	changed := false.	"if the expression can't be replaced by another, then it will be removed"	varExpressions		do: [ :var | 			| changedStm origStm |			origStm := self statementOfVarName: var printString.			changedStm := self changeStatement: origStm.			changedStm = origStm				ifTrue: [ self removeStatementNoRepairing: origStm ]				ifFalse: [ changed := true ] ].	^ changed</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>repairing</category><body package="SSG-Core" selector="alternativeFactoryMessage:before:">alternativeFactoryMessage: aFactoryMessage before: aExpression	| returnType |	returnType := aFactoryMessage returnType.	^ (typeInfo factoryMessagesFrom: returnType)		detect: [ :meth | 			meth returnType = returnType				and: [ meth selector ~= aFactoryMessage selector ] ]		ifFound: [ :meth | self factoryMessageUsing: meth before: aExpression ]		ifNone: [ SFactoryMessage default: returnType ]</body><body package="SSG-Core" selector="alternativeFieldAccessMessage:">alternativeFieldAccessMessage: aFieldAccessMessage	| returnType receiver |	receiver := aFieldAccessMessage receiver.	returnType := aFieldAccessMessage returnType.	(self pickAccessorsOf: receiver returnType)		detect: [ :meth | 			meth returnType = returnType				and: [ meth selector ~= aFieldAccessMessage selector ] ]		ifFound:			[ :meth | ^ SFieldAccessMessage newFromReceiver: receiver andMethod: meth ].	self		error:			'There is no alternative for fieldAccessMessage of selector: '				, aFieldAccessMessage selector</body><body package="SSG-Core" selector="alternativeMessage:before:">alternativeMessage: aMessage before: expression	| returnType receiver |	receiver := aMessage receiver.	returnType := aMessage returnType.	(self pickMessagesOf: receiver returnType)		detect: [ :meth | 			meth returnType = returnType				and: [ meth selector ~= aMessage selector ] ]		ifFound: [ :meth | ^ self messageUsing: meth and: receiver before: expression ].	self		error:			'There is no alternative for message of selector: '				, aMessage selector</body><body package="SSG-Core" selector="alternativeOfVariable:before:">alternativeOfVariable: aVariable before: aExpression	| returnType |	self statementOfVarName: aVariable printString.	returnType := aVariable returnType.	(self statementsOfType: returnType before: aExpression)		detect: [ :stm | stm reference ~= aVariable ]		ifFound: [ :stm | ^ stm reference ].	^ (self addStatementOfType: returnType before: aExpression) reference</body><body package="SSG-Core" selector="buildArgs:before:">buildArgs: argTypes before: aStatement	argTypes		ifNotNil: [ | prevTypes scalarsKeys |			prevTypes := (self subStatementsFrom: 1 toPrevIndexOf: aStatement)				select: [ :stm | stm needsBeFixed not and: [ stm returnType isNil not ] ]				thenCollect: #returnType.			scalarsKeys := typeInfo scalars keys asOrderedCollection.			argTypes				do: [ :arg | 					self						addArgument: arg						before: aStatement						considering: prevTypes						and: scalarsKeys ] ]</body><body package="SSG-Core" selector="clean">clean	| literals unused |	literals := self statements		select:			[ :e | (e value isKindOf: SLiteral) or: [ e value isKindOf: SFactoryMessage ] ].	unused := literals		difference:			(literals				select: [ :e | 					(self statements collect: [ :stm | stm pickUpReferences: e ])						anySatisfy: [ :x | x isNotEmpty ] ]).	unused do: [ :stm | self removeStatement: stm ]</body><body package="SSG-Core" selector="error:">error: string	^ SError signal: string</body><body package="SSG-Core" selector="factoryMessageUsing:before:">factoryMessageUsing: method before: aStatement	self buildArgs: method argTypes before: aStatement.	^ SFactoryMessage		method: method		previousStatements: (self subStatementsFrom: 1 toPrevIndexOf: aStatement)</body><body package="SSG-Core" selector="invariant">invariant	self typeInfo		ifNil:			[ self error: 'TypeInfo is nil. Set the testCase with a typeInfo' ]</body><body package="SSG-Core" selector="literal:">literal: aClassName	^ self newLiteral: aClassName</body><body package="SSG-Core" selector="messagesVariablesFrom:">messagesVariablesFrom: aClassName	| varExpressions |	varExpressions := self		messagesVariablesWhichContain: aClassName		before: nil.	varExpressions		ifEmpty: [ typeInfo classes				at: aClassName				ifPresent: [ (typeInfo classes at: aClassName) subclasses						detect: [ :aClass | 							varExpressions := self								messagesVariablesWhichContain: aClass name								before: nil.							varExpressions isNotEmpty ] ]				ifAbsent: [ typeInfo scalars						at: aClassName						ifPresent: [ varExpressions := self								messagesVariablesWhichContain: aClassName								before: nil.							varExpressions isNotEmpty ] ] ].	^ varExpressions</body><body package="SSG-Core" selector="messageUsing:and:before:">messageUsing: method and: receiver before: aStatement	self buildArgs: method argTypes before: aStatement.	^ SMessage		newFromReceiver: receiver copy		method: method		andPreviousStatements: (self subStatementsFrom: 1 toPrevIndexOf: aStatement)</body><body package="SSG-Core" selector="newStatementOfType:before:">newStatementOfType: aType before: aStatement	(self random		collectAtRandom:			#(#newFactoryMessage:before: #newLiteral: #newFieldAccessMessageOfType:before: #newMessageOfType:before:))		do: [ :message | 			[ ^ self				perform: message				withEnoughArguments: (Array with: aType with: aStatement) ]				on: SError				do: [ "try with the next one" ] ].	self error: 'Cannot create expression of returnType: ' , aType</body><body package="SSG-Core" selector="perform:inStatement:">perform: selector inStatement: stm	^ stm		perform: selector		withArguments: (Array with: stm copy with: self)</body><body package="SSG-Core" selector="randomIndexToAdd:before:">randomIndexToAdd: aExpression before: aStatement	| refIndexes anIndex |	anIndex := statements indexOf: aStatement.	anIndex = 0		ifTrue: [ ^ self length ].	refIndexes := self referencesIndexes: aExpression.	anIndex := anIndex - 1.	refIndexes		ifNotEmpty: [ | ini end maxIndex |			maxIndex := refIndexes max.			ini := anIndex min: maxIndex.			end := anIndex max: maxIndex.			^ self random selectAtRandom: (ini to: end) ].	anIndex = 0		ifTrue: [ ^ anIndex ].	^ self random selectAtRandom: (1 to: anIndex)</body><body package="SSG-Core" selector="referencesIndexes:">referencesIndexes: expression	^ expression variablesWithId allButFirst		collect:			[ :var | statements indexOf: (self statementOfVarName: var printString) ]</body><body package="SSG-Core" selector="repair:">repair: expression	[ self statementAt: expression ]		on: SError		do: [ ^ self statements copy				flatCollect: [ :stm | self repairReferenceTo: expression of: stm ] ].	self error: expression printString , ' does not exist.'</body><body package="SSG-Core" selector="repairReferenceTo:of:">repairReferenceTo: removedExpression of: expression	| references exprsToDelete |	references := expression pickUpReferences: removedExpression.	exprsToDelete := OrderedCollection new.	references		do: [ :reference | 			[ self repair: reference of: expression ]				on: SError				do: [ exprsToDelete add: reference ] ].	^ exprsToDelete</body><body package="SSG-Core" selector="replace:by:on:">replace: exprToReplace by: otherExpression on: expression	(self statementAt: expression)		replaceExpression: exprToReplace		by: otherExpression</body><body package="SSG-Core" selector="statementsOfType:before:">statementsOfType: aType before: expression	(statements includes: expression)		ifFalse: [ self				error: 'Statement: ' , expression printString , 'is not found in testCase.' ].	^ (self subStatementsFrom: 1 toPrevIndexOf: expression)		select: [ :stm | stm returnType = aType ]</body><body package="SSG-Core" selector="subStatementsAfterIndexOf:">subStatementsAfterIndexOf: aStatement	| start |	start := statements indexOf: aStatement.	start &lt; self length		ifFalse: [ ^ Array new ].	^ statements copyFrom: start + 1 to: self length</body><body package="SSG-Core" selector="subStatementsFrom:toPrevIndexOf:">subStatementsFrom: start toPrevIndexOf: aStatement	| stop |	stop := statements indexOf: aStatement.	stop = 0		ifTrue: [ ^ statements ].	start &lt;= stop		ifFalse: [ ^ self				error:					start printString , ' (indexIni) is greater than ' , stop printString						, ' (indexPos).' ].	^ statements copyFrom: start to: stop - 1</body><body package="SSG-Core" selector="updateNextId">updateNextId	nextId = 0		ifTrue: [ nextId := statements size ]</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>printing</category><body package="SSG-Core" selector="printDescriptiveComment">printDescriptiveComment	^ self printSummaryFitness , (String with: Character cr)		, self printSummaryFitnessByClass</body><body package="SSG-Core" selector="printFunctionByClassName:on:">printFunctionByClassName: dict on: stream	(dict associations select: [ :assoc | assoc value &gt; 0 ])		do: [ :assoc | 			stream				nextPutAll: assoc key;				nextPut: $:;				nextPutAll: assoc value printString;				nextPut: $%;				nextPutAll: (String with: Character cr) ]</body><body package="SSG-Core" selector="printStatements">printStatements	^ statements collect: #printString</body><body package="SSG-Core" selector="printSummaryFitness">printSummaryFitness	^ String		streamContents: [ :stream | 			stream				nextPutAll: '"Fitness: ';				nextPut: Character cr.			fitness				associationsDo: [ :assoc | 					stream						nextPutAll: assoc key;						nextPutAll: ': ';						nextPutAll: assoc value printString;						nextPut: Character cr ].			stream nextPutAll: '"' ]</body><body package="SSG-Core" selector="printSummaryFitnessByClass">printSummaryFitnessByClass	^ String		streamContents: [ :stream | 			stream				nextPutAll: '"This test covers: ';				nextPut: Character cr.			fitnessByClass				associationsDo: [ :assoc | 					stream						nextPutAll: assoc key;						nextPutAll: (String with: Character cr).					self printFunctionByClassName: assoc value on: stream ].			stream				nextPutAll: '"';				nextPutAll: (String with: Character cr) ]</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>parsing</category><body package="SSG-Core" selector="getStringOf:">getStringOf: stm	stm isString		ifTrue: [ ^ stm ].	^ stm printString</body><body package="SSG-Core" selector="parseTree">parseTree	| stmList |	stmList := self statements		, (lastMessage ifNil: [ #() ] ifNotNil: [ Array with: lastMessage ]).	SPlatform asDict		ifTrue: [ ^ self parseTreeAsDictWith: stmList ]		ifFalse: [ ^ self parseTreeWith: stmList ]</body><body package="SSG-Core" selector="parseTreeAsDictWith:">parseTreeAsDictWith: statementCollection	| node temporaries rbParserClass |	statementCollection		ifEmpty: [ self error: 'testCase does not have statements' ].	rbParserClass := SPlatform rbParserClass.	node := rbParserClass parseExpression: '[]'.	temporaries := Array with: (self aVariableNodeClass named: 'var').	node body temporaries: temporaries.	node body		addNode: (rbParserClass parseExpression: 'var := Dictionary new.').	statementCollection		do: [ :stm | 			| aNode |			[ aNode := rbParserClass parseExpression: (self getStringOf: stm).			node body addNode: aNode ]				on: Error				do: [  ] ].	^ node</body><body package="SSG-Core" selector="parseTreeWith:">parseTreeWith: statementCollection	| node temporaries rbParserClass |	statementCollection		ifEmpty: [ self error: 'testCase does not have statements' ].	rbParserClass := SPlatform rbParserClass.	node := rbParserClass parseExpression: '[]'.	temporaries := (self allVarNames		collect: [ :varName | rbParserClass parseExpression: varName ])		select: [ :e | e isKindOf: self aVariableNodeClass ].	node body temporaries: temporaries.	statementCollection		do: [ :stm | 			| aNode |			[ aNode := rbParserClass parseExpression: (self getStringOf: stm).			node body addNode: aNode ]				on: Error				do: [  ] ].	^ node</body><body package="SSG-Core" selector="parseTreeWithAssertions">parseTreeWithAssertions	| stmList |	stmList := self statements		, (lastMessage ifNil: [ #() ] ifNotNil: [ Array with: lastMessage ])		, self assertions.	SPlatform asDict		ifTrue: [ ^ self parseTreeAsDictWith: stmList ]		ifFalse: [ ^ self parseTreeWith: stmList ]</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>querying</category><body package="SSG-Core" selector="factoryMessageVariablesBefore:">factoryMessageVariablesBefore: aStatement	^ (self subStatementsFrom: 1 toPrevIndexOf: aStatement)		select: [ :stm | stm value isFactoryMessage ]		thenCollect: [ :stm | stm variable ]</body><body package="SSG-Core" selector="involvedClasses">involvedClasses	^ (self objectVariables collect: [ :var | var returnType ]) asSet</body><body package="SSG-Core" selector="messagesVariablesWhichContain:before:">messagesVariablesWhichContain: aClassName before: aStatement	^ (self subStatementsFrom: 1 toPrevIndexOf: aStatement)		select: [ :stm | stm referenceTo: aClassName ]		thenCollect: [ :stm | stm variable ]</body><body package="SSG-Core" selector="objectVariables">objectVariables	^ statements		select: [ :stm | 			stm needsBeFixed not				and: [ (self typeInfo classAt: stm returnType ifNone: [ nil ]) isNil not ] ]		thenCollect: [ :stm | stm variable ]</body><body package="SSG-Core" selector="pickAccessorsOf:">pickAccessorsOf: aType	^ typeInfo accessMessagesFrom: aType</body><body package="SSG-Core" selector="pickAnObjectVariable">pickAnObjectVariable	| variables |	variables := self objectVariables.	variables		ifEmpty: [ self addFactoryMessage.			variables := self objectVariables ].	^ self random selectAtRandom: variables</body><body package="SSG-Core" selector="pickMessagesOf:">pickMessagesOf: aType	^ typeInfo messagesFrom: aType</body><body package="SSG-Core" selector="pickObjectVariableOf:">pickObjectVariableOf: aClassName	(self random		collectAtRandom: (self subStatementsFrom: 1 toPrevIndexOf: nil))		detect: [ :stm | stm returnType = aClassName ]		ifFound: [ :stm | ^ stm reference ]		ifNone: [  ].	self error: 'Does not exist a statement of type: ' , aClassName</body><body package="SSG-Core" selector="pickOrCreateObjectVariableOf:">pickOrCreateObjectVariableOf: aClassName	^ [ self pickObjectVariableOf: aClassName ]		on: SError		do: [ (self addFactoryMessage: aClassName) variable ]</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>hierarchy</category><body package="SSG-Core" selector="allChildren">allChildren	^ (Set newFrom: children)		addAll: (children flatCollect: [ :tC | tC allChildren ]);		yourself</body><body package="SSG-Core" selector="allParents">allParents	| list |	list := OrderedCollection new.	self allParents: self on: list using: Set new.	^ list</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>instance creation</category><body package="SSG-Core" selector="newAssignment:">newAssignment: anExpression	[ ^ SAssignment		name:			(SVariable new				varName: '_var';				id: self assignId;				returnType: anExpression returnType;				yourself)		value: anExpression copy ]		on: MessageNotUnderstood		do:			[ :error | self error: anExpression printString , ' is not an expression.' ]</body><body package="SSG-Core" selector="newFactoryMessage:before:">newFactoryMessage: aClassName before: aStatement	| methods |	typeInfo		classAt: aClassName		ifNone: [ self				error:					'Error to create factoryMessage of: ' , aClassName						, ' because it is not found in typeInfo.' ].	self validTargetClassName: aClassName.	methods := typeInfo factoryMessagesFrom: aClassName.	^ methods		ifEmpty: [ SFactoryMessage default: aClassName ]		ifNotEmpty: [ self newFactoryMessageUsing: aClassName and: aStatement ]</body><body package="SSG-Core" selector="newFactoryMessageUsing:and:">newFactoryMessageUsing: aClassName and: aStatement	| methods |	methods := typeInfo factoryMessagesFrom: aClassName.	(self random collectAtRandom: methods)		do: [ :method | 			[ self buildArgs: method argTypes before: aStatement.			^ SFactoryMessage				method: method				class: aClassName				previousStatements: (self subStatementsFrom: 1 toPrevIndexOf: aStatement) ]				on: SError				do: [  ] ].	self error: 'Error to create a factoryMessage of: ' , aClassName</body><body package="SSG-Core" selector="newFieldAccessMessageOfType:andReceiver:">newFieldAccessMessageOfType: aType andReceiver: receiver	(self pickAccessorsOf: receiver returnType)		detect: [ :aMethod | 			aMethod returnType hasOnlyOneType				and: [ aMethod returnType includes: aType ] ]		ifFound: [ :aMethod | 			^ SFieldAccessMessage				newFromReceiver: receiver copy				andMethod: aMethod ]		ifNone: [ self				error:					'Cannot create a field access message of type: ' , aType						, ' and receiver of type: ' , receiver returnType ]</body><body package="SSG-Core" selector="newFieldAccessMessageOfType:before:">newFieldAccessMessageOfType: aType before: aStatement	(self factoryMessageVariablesBefore: aStatement)		do: [ :receiver | 			[ ^ self newFieldAccessMessageOfType: aType andReceiver: receiver ]				on: SError				do: [  ] ].	self error: 'Cannot create a field access message of type: ' , aType</body><body package="SSG-Core" selector="newLiteral:">newLiteral: aClassName	typeInfo scalars		at: aClassName		ifPresent: [ :values | 			values				ifEmpty: [ self error: 'Scalar of type: ' , aClassName , ' is empty.' ].			^ SLiteral new				returnType: aClassName;				value: (self random selectAtRandom: values asOrderedCollection) ].	self error: 'Scalars dont include: ' , aClassName</body><body package="SSG-Core" selector="newMessageOfType:before:">newMessageOfType: aType before: aStatement	(self factoryMessageVariablesBefore: aStatement)		do: [ :receiver | 			[ ^ self newMessageOfType: aType using: receiver before: aStatement ]				on: SError				do: [  ] ].	self		error:			'Cannot create a message of type: ' , aType printString				,					'. A possible reason is because there is none factoryMessage which has a message of this return type.'</body><body package="SSG-Core" selector="newMessageOfType:using:before:">newMessageOfType: aType using: receiver before: aStatement	(self pickMessagesOf: receiver returnType)		detect: [ :aMethod | 			aMethod returnType hasOnlyOneType				and: [ aMethod returnType includes: aType ] ]		ifFound: [ :aMethod | 			[ ^ self messageUsing: aMethod and: receiver before: aStatement ]				on: SError				do: [  ] ].	^ self		error:			'Error to create a message of type: ' , aType				, ' with receiver of type: ' , receiver returnType</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>adding</category><body package="SSG-Core" selector="addArgument:before:considering:and:">addArgument: arg before: aStatement considering: prevTypes and: scalarNames	| res addArgBlock |	res := arg types anySatisfy: [ :type | prevTypes includes: type ].	addArgBlock := [ (self random collectAtRandom: arg types)		detect: [ :missType | 			[ (scalarNames includes: missType)				ifTrue: [ self						addStatement: (self newAssignment: (self newLiteral: missType))						before: aStatement ]				ifFalse: [ self						addAssignment: (self newFactoryMessage: missType before: aStatement)	"(self newStatementOfType: missType before: aStatement)" ].			true ]				on: SError				do: [ false ] ]		ifNone: [ self				error: 'It is not possible to meet the arguments of this method call' ] ].	(res not or: [ self next &gt; 0.5 ])		ifTrue: addArgBlock</body><body package="SSG-Core" selector="addChild:">addChild: aTestCase	children add: aTestCase</body><body package="SSG-Core" selector="addTargetClassName:">addTargetClassName: aSymbol	typeInfo types		at: aSymbol		ifAbsent: [ self error: 'Class name: ' , aSymbol , ' is not found in typeInfo' ].	targetClassesNames add: aSymbol</body><body package="SSG-Core" selector="addTargetClassNames:">addTargetClassNames: symbols	symbols do: [ :symbol | self addTargetClassName: symbol ]</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>initalize</category><body package="SSG-Core" selector="initialize">initialize	super initialize.	statements := OrderedCollection new.	assertions := OrderedCollection new.	fitness := Dictionary new.	fitnessByClass := Dictionary new.	nextId := 0.	maxNumberOfStatements := 10.	targetClassesNames := Set new.	validatedTargetClassName := false.	parents := OrderedCollection new.	children := OrderedCollection new.	selectionStrategy := SGARouletteSelection new</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>removing</category><body package="SSG-Core" selector="changeStatementOfVarName:">changeStatementOfVarName: varName	^ self changeStatement: (self statementOfVarName: varName)</body><body package="SSG-Core" selector="removeChild:">removeChild: testCase	| index |	index := 0.	children		detect: [ :tC | 			index := index + 1.			tC generationNumber == testCase generationNumber				and: [ tC idPopulation == testCase idPopulation ] ]		ifFound: [ :tC | children removeAt: index ]</body><body package="SSG-Core" selector="removeExpression:">removeExpression: expression	self removeFromStatements: expression.	statements copy		do: [ :stm | 			(stm pickUpReferences: expression)				ifNotEmpty: [ self repairReferenceTo: expression of: stm ] ]</body><body package="SSG-Core" selector="removeExpressionWithoutRepairing:">removeExpressionWithoutRepairing: expression	self removeFromStatements: expression.	[ self statementAt: expression ]		on: SError		do: [ (self statements copy				flatCollect:					[ :stm | (stm pickUpReferences: expression) ifNotEmpty: [ Array with: stm ] ])				do: [ :stm | self removeExpressionWithoutRepairing: stm ] ]</body><body package="SSG-Core" selector="removeFromStatements:">removeFromStatements: expression	[ statements remove: expression ]		on: Error		do: [ self error: expression printString , ' is not found.' ]</body><body package="SSG-Core" selector="removeStatement">removeStatement	"If other statements refer the statement to remove, then this reference is replaced with another value out of the set which has the same type"	statements ifEmpty: [ ^ #() ].	self		removeStatement:			(statements				at: (self random selectAtRandom: (1 to: self length) asArray))</body><body package="SSG-Core" selector="removeStatement:">removeStatement: anExpression	self removeExpression: (self statementAt: anExpression)</body><body package="SSG-Core" selector="removeStatementNoRepairing:">removeStatementNoRepairing: aStatement	"remove all statements that reference to statement because this cant be fixed"	self removeExpressionWithoutRepairing: (self statementAt: aStatement)</body><body package="SSG-Core" selector="removeStatementOfVarName:">removeStatementOfVarName: varName	^ self removeStatement: (self statementOfVarName: varName) copy</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCase</class-id> <category>accessing</category><body package="SSG-Core" selector="generationNumber">generationNumber	^ generationNumber</body><body package="SSG-Core" selector="generationNumber:">generationNumber: anObject	generationNumber := anObject</body><body package="SSG-Core" selector="idPopulation">idPopulation	^ idPopulation</body><body package="SSG-Core" selector="idPopulation:">idPopulation: anObject	idPopulation := anObject</body><body package="SSG-Core" selector="isBetterThan:using:">isBetterThan: testCase2 using: fitnessStrategy	| fitness1 fitness2 |	fitness1 := self fitness at: fitnessStrategy.	fitness2 := testCase2 fitness at: fitnessStrategy.	fitness1 &gt; fitness2		ifTrue: [ ^ true ].	(self hasErrors		and: [ testCase2 hasErrors not and: [ self next &lt; 0.5 ] ])		ifTrue: [ ^ false ].	(fitness1 = fitness2 and: [ self length &lt; testCase2 length ])		ifTrue: [ ^ true ].	(fitness1 = fitness2		and: [ self length = testCase2 length				and: [ self idPopulation &gt; testCase2 idPopulation ] ])		ifTrue: [ ^ true ].	^ false</body><body package="SSG-Core" selector="summaryExecutionMethods">summaryExecutionMethods	^ summaryExecutionMethods</body><body package="SSG-Core" selector="summaryExecutionMethods:">summaryExecutionMethods: summaryExecutionMethod	summaryExecutionMethods := summaryExecutionMethod</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCase</class-id> <category>actions</category><body package="SSG-Core" selector="analyze">analyze	" we delegate the responsibility to a test runner, in the future we would like to add new ways to run the tests "	| result |	self setUp.	result := SSTestRunner new evaluate: self.	self tearDown.	SPlatform asDict		ifTrue: [ result := result at: 'var' ].	^ result</body><body package="SSG-Core" selector="computeFitness:">computeFitness: fitnessClass	| valueFitness |	valueFitness := fitnessClass computeFitness: self.	[ fitness addAll: valueFitness ]		on: MessageNotUnderstood		do: [ fitness add: valueFitness ]</body><body package="SSG-Core" selector="fitnessFor:">fitnessFor: functionName	^ self fitness at: functionName</body><body package="SSG-Core" selector="hasErrors">hasErrors	^ hasErrors</body><body package="SSG-Core" selector="hasErrors:">hasErrors: aBoolean	hasErrors := aBoolean</body><body package="SSG-Core" selector="run">run	" we delegate the responsibility to a test runner, in the future we would like to add new ways to run the tests "	| result |	self setUp.	result := SSTestRunner new run: self.	self tearDown.	^ result</body><body package="SSG-Core" selector="runWithoutAssertions">runWithoutAssertions	" we delegate the responsibility to a test runner, in the future we would like to add new ways to run the tests "	| result |	self setUp.	result := SSTestRunner new runWithoutAssertions: self.	self tearDown.	^ result</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCase</class-id> <category>initialization</category><body package="SSG-Core" selector="initialize">initialize	super initialize.	generationNumber := 1.	idPopulation := 1.	summaryExecutionMethods := OrderedCollection new.	hasErrors := false</body><body package="SSG-Core" selector="setFitness:">setFitness: aDictionary	fitness := aDictionary copy</body><body package="SSG-Core" selector="setFitnessByClass:">setFitnessByClass: aDictionary	fitnessByClass := aDictionary copy</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCase</class-id> <category>copying</category><body package="SSG-Core" selector="copy">copy	| copy |	copy := self class with: typeInfo copy.	copy addTargetClassNames: targetClassesNames.	statements do: [ :stm | copy addStatement: stm copy ].	copy updateNextId.	^ copy</body><body package="SSG-Core" selector="deepCopy">deepCopy	| copy |	copy := self copy.	copy setFitness: self fitness.	copy setFitnessByClass: self fitnessByClass.	copy generationNumber: self generationNumber.	copy summaryExecutionMethods: self summaryExecutionMethods.	copy hasErrors: self hasErrors.	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCase</class-id> <category>printing</category><body package="SSG-Core" selector="printOn:">printOn: aStream	self statements		do: [ :stm | 			stm printOn: aStream.			aStream nextPut: Character cr ]</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCase</class-id> <category>repairing</category><body package="SSG-Core" selector="updateWith:">updateWith: anotherTestCase	self generationNumber: anotherTestCase generationNumber.	self idPopulation: anotherTestCase idPopulation.	anotherTestCase parents		do: [ :parent | 			parent removeChild: anotherTestCase.			self addParent: parent ]</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCase</class-id> <category>comparing</category><body package="SSG-Core" selector="=">= another	^ self class = another class		and: [ statements = another statements				and: [ fitness = another fitness						and: [ parents = another parents								and: [ generationNumber = another generationNumber										and: [ idPopulation = another idPopulation ] ] ] ] ]</body><body package="SSG-Core" selector="hash">hash	^ super hash bitXor: self statements hash	"(self number hash bitXor:"	")"</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCase class</class-id> <category>instance creation</category><body package="SSG-Core" selector="with:">with: aTypeInfo	| testCase |	testCase := self new.	testCase typeInfo: aTypeInfo.	^ testCase</body></methods><methods><class-id>SmallSuiteGenerator.SReport</class-id> <category>accessing</category><body package="SSG-Utility" selector="fileReference:">fileReference: aString	| filename |	filename := aString , '.csv'.	filename asFileReference ensureDelete.	^ filename asFileReference</body></methods><methods><class-id>SmallSuiteGenerator.SReport class</class-id> <category>accessing</category><body package="SSG-Utility" selector="fileReference:">fileReference: aString	^ self new fileReference: aString</body><body package="SSG-Utility" selector="titles">titles	self subclassResponsibility</body></methods><methods><class-id>SmallSuiteGenerator.SReportSTestCaseFactory</class-id> <category>actions</category><body package="SSG-Utility" selector="engine">engine	^ factoryTestCase engine</body><body package="SSG-Utility" selector="evolutionTypeInfo">evolutionTypeInfo	| typeInfos evolution |	typeInfos := Array		with: factoryTestCase typeInfoSeed		withAll: (self engine logs collect: #typeInfoGeneration).	evolution := Dictionary new.	2 to: typeInfos size do: [ :index | 		| partialResult |		partialResult := (typeInfos at: index - 1)			difference: (typeInfos at: index).		(partialResult notNil and: [ partialResult notEmpty ])			ifTrue: [ evolution					at: ('{1} -&gt; {2}' format: (Array with: index - 2 with: index - 1))					put: partialResult ] ].	^ evolution</body><body package="SSG-Utility" selector="generateReportForAllMethodsOf:">generateReportForAllMethodsOf: aLog	self generateReportOf: aLog usingFilter: #all</body><body package="SSG-Utility" selector="generateReportForAllMethodsOfAllLogs">generateReportForAllMethodsOfAllLogs	self engine logs		do: [ :aLog | self generateReportForAllMethodsOf: aLog ]</body><body package="SSG-Utility" selector="generateReportForUnexecutedMethodsOf:">generateReportForUnexecutedMethodsOf: anIndex	self generateReportOf: anIndex usingFilter: #notAllBlocksExecuted</body><body package="SSG-Utility" selector="generateReportForUnexecutedMethodsOfAllLogs">generateReportForUnexecutedMethodsOfAllLogs	self engine logs		do: [ :aLog | self generateReportForUnexecutedMethodsOf: aLog ]</body><body package="SSG-Utility" selector="generateReportOf:usingFilter:">generateReportOf: aLog usingFilter: aSymbol	SReportSGALog		exportData: aLog		onCSV:			'Report_' , aLog generationNumber asString , '_'				, aSymbol asString capitalized				, factoryTestCase targetClassName asString		usingFilter: aSymbol</body><body package="SSG-Utility" selector="generateReportOfAllMethods">generateReportOfAllMethods	self generateReportForAllMethodsOf: self engine logs last</body><body package="SSG-Utility" selector="generateResumeDifferenceOfGeneration">generateResumeDifferenceOfGeneration	SReportSGALog		generateReportForDifferencesBtwGenerationsOf: self engine</body><body package="SSG-Utility" selector="generateResumeReportOfLogs">generateResumeReportOfLogs	SReportSGALog		exportResumeOf: self engine logs		onCSV: 'Report_Resume_' , factoryTestCase targetClassName asString</body></methods><methods><class-id>SmallSuiteGenerator.SReportSTestCaseFactory</class-id> <category>accessing</category><body package="SSG-Utility" selector="factoryTestCase:">factoryTestCase: anObject	factoryTestCase := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SReportSTestCaseFactory class</class-id> <category>class-factory</category><body package="SSG-Utility" selector="on:">on: anObject	^ self new factoryTestCase: anObject</body></methods><methods><class-id>SmallSuiteGenerator.SReportTypeInfo class</class-id> <category>export as CSV</category><body package="SSG-Utility" selector="exportData:onCSV:">exportData: aTypeInfo onCSV: aString	self exportData: aTypeInfo onCSV: aString usingFilter: #all</body><body package="SSG-Utility" selector="exportReportData:">exportReportData: projectName	self exportReportData: projectName withName: projectName</body><body package="SSG-Utility" selector="exportReportData:usingFilter:">exportReportData: projectName usingFilter: aSymbol	self		exportReportData: projectName		withName: projectName		usingFilter: aSymbol</body><body package="SSG-Utility" selector="exportReportData:withName:">exportReportData: projectName withName: aString	self		exportData: (STypeInfo asTypeInfo: (self profilerProject: projectName))		onCSV: aString</body><body package="SSG-Utility" selector="exportReportData:withName:usingFilter:">exportReportData: projectName withName: aString usingFilter: aSymbol	self		exportData: (STypeInfo asTypeInfo: (self profilerProject: projectName))		onCSV: aString		usingFilter: aSymbol</body><body package="SSG-Utility" selector="titles">titles	^ #('ClassName' 'MethodName' 'Receivers' 'CommSupcls' 'ArgTypes' 'CommSupcls' 'ReturnTypes' 'CommSupcls')</body></methods><methods><class-id>SmallSuiteGenerator.SReportTypeInfo class</class-id> <category>export</category><body package="SSG-Utility" selector="dataCaseStudy:from:">dataCaseStudy: profiler from: projectName	^ Array		with: projectName		with: profiler numberOfClasses		with: profiler numberOfMethods		with:			(profiler allMethods				collect: #selector				thenSelect: [ :selector | selector beginsWith: 'test' ]) size		with:			(((profiler allMethods count: #wasExecuted) / profiler numberOfMethods)				asFloat round: 4) * 100</body><body package="SSG-Utility" selector="dataFrequency:from:">dataFrequency: typeInfo from: projectName	^ (Array with: projectName)		, (typeInfo reportFrequencyByFilter associations sort collect: #value)</body><body package="SSG-Utility" selector="exportReportsCaseStudyAndFrequency:of:">exportReportsCaseStudyAndFrequency: fileNames of: projectsName	| data |	self		assert: fileNames size = 2		description: 'Set the fileNames correctly'.	data := projectsName		collect: [ :projectName | 			| profiler |			profiler := self profilerProject: projectName.			Array				with: (self dataCaseStudy: profiler from: projectName)				with:					(self						dataFrequency: (STypeInfo asTypeInfo: profiler)						from: projectName) ].	self writeReport: fileNames first ofCaseStudy: (data collect: #first).	self		writeReport: fileNames second		ofFrequency: (data collect: #second)</body><body package="SSG-Utility" selector="exportReportsCaseStudyAndFrequencyOf:">exportReportsCaseStudyAndFrequencyOf: projectsName	self		exportReportsCaseStudyAndFrequency: #('CaseStudy' 'Frequency')		of: projectsName</body><body package="SSG-Utility" selector="profilerProject:">profilerProject: projectName	^ self aSTypeCollectorClass		profile: [ (SPlatform testCaseClass withAllSubclasses				select: [ :t | t category beginsWith: projectName ])				do: [ :tc | 					[ tc buildSuite run ]						on: Exception						do: [ :e | 							Transcript								show: e printString;								cr ] ]				displayingProgress: 'working' ]		onPackagesMatching: projectName , '*'</body></methods><methods><class-id>SmallSuiteGenerator.SReportTypeInfo class</class-id> <category>accessing</category><body package="SSG-Utility" selector="fileReference:">fileReference: aString	| filename |	filename := aString , '.csv'.	filename asFileReference ensureDelete.	^ filename asFileReference</body></methods><methods><class-id>SmallSuiteGenerator.SUtilityTypeInfo</class-id> <category>examples</category><body package="SSG-Tests-Utility" selector="typeInfoArrayedCollection">typeInfoArrayedCollection	^ STypeInfo new		type:			(self fullSymbolOf: #ArrayedCollection)				-&gt;					(Array						with:							(Array								with: #add -&gt; #(#AthensCairoCanvas #nil #() false)								with: #size -&gt; #(#AthensCairoCanvas #nil #() false))						with: #());		scalar: (self fullSymbolOf: #ByteString) with: #('hello')</body><body package="SSG-Tests-Utility" selector="typeInfoOnPackage1">typeInfoOnPackage1	"the first typeInfo is about a class has as argument other class from other package"	^ STypeInfo new		type:			(self fullSymbolOf: #SEvent)				-&gt;					(Array						with:							(Array								with:									#canRegister:										-&gt;											(Array												with: (self fullSymbolOf: #SConference)												with: (self fullSymbolOf: #False)												with: (Array with: (self fullSymbolOf: #SStudent))												with: false)								with:									#price										-&gt;											(Array												with: (self fullSymbolOf: #SConference)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: false))						with: #());		type:			(self fullSymbolOf: #SConference)				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: (self fullSymbolOf: #SConference)												with: (self fullSymbolOf: #SConference)												with: #()												with: false)								with:									#offerPrice										-&gt;											(Array												with: (self fullSymbolOf: #SConference)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: true)								with:									#offerPrice:										-&gt;											(Array												with: (self fullSymbolOf: #SConference)												with: (self fullSymbolOf: #SConference)												with: (Array with: (self fullSymbolOf: #SmallInteger))												with: false)								with:									#discount										-&gt;											(Array												with: (self fullSymbolOf: #SConference)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: true))						with: #());		scalar: (self fullSymbolOf: #SmallInteger) with: #(95 100);		scalar: (self fullSymbolOf: #False) with: #(false);		scalar: (self fullSymbolOf: #SStudent)			with: (Array with: (SStudent new name: 'Mary'))</body><body package="SSG-Tests-Utility" selector="typeInfoOnPackage2">typeInfoOnPackage2	"the first typeInfo is about a class has as argument other class from other package"	^ STypeInfo new		type:			(self fullSymbolOf: #SEvent)				-&gt;					(Array						with:							(Array								with:									#price:										-&gt;											(Array												with: (self fullSymbolOf: #SConference)												with: (self fullSymbolOf: #SConference)												with: (Array with: (self fullSymbolOf: #SmallInteger))												with: false))						with:							(Array								with:									#price:										-&gt;											(Array												with: (self fullSymbolOf: #SConference)												with: (self fullSymbolOf: #SConference)												with: (Array with: (self fullSymbolOf: #SmallInteger))												with: false)));		type:			(self fullSymbolOf: #SConference)				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: (self fullSymbolOf: #SConference)												with: (self fullSymbolOf: #SConference)												with: #()												with: false))						with: #());		scalar: (self fullSymbolOf: #SmallInteger) with: #(95)</body><body package="SSG-Tests-Utility" selector="typeInfoOnPackage3">typeInfoOnPackage3	"the first typeInfo is about a class has as argument other class from other package"	"review and modify"	^ STypeInfo new		type:			(self fullSymbolOf: #SSTeacher)				-&gt;					(Array						with:							(OrderedCollection new								add:									#name:										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SSTeacher)												with: (Array with: (self fullSymbolOf: #ByteString))												with: false);								add:									#id:										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SSTeacher)												with: (Array with: (self fullSymbolOf: #SmallInteger))												with: false);								add:									#nickname:										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SSTeacher)												with: (Array with: (self fullSymbolOf: #ByteString))												with: false);								add:									#initialize										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SSTeacher)												with: #()												with: false);								add:									#nickname										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #ByteString)												with: #()												with: false);								add:									#name										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #ByteString)												with: #()												with: true);								add:									#id										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: true);								add:									#yearsWorkExperience										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: true);								add:									#idTeacher										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: true);								yourself)						with:							(Array								with:									#name:with:										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SSTeacher)												with:													(Array														with: (self fullSymbolOf: #ByteString)														with: (self fullSymbolOf: #SmallInteger))												with: false)));		type:			(self fullSymbolOf: #SConference)				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: (self fullSymbolOf: #SConference)												with: (self fullSymbolOf: #SConference)												with: #()												with: false)								with:									#offerPrice										-&gt;											(Array												with: (self fullSymbolOf: #SConference)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: true)								with:									#offerPrice:										-&gt;											(Array												with: (self fullSymbolOf: #SConference)												with: (self fullSymbolOf: #SConference)												with: (Array with: (self fullSymbolOf: #SmallInteger))												with: false)								with:									#discount										-&gt;											(Array												with: (self fullSymbolOf: #SConference)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: true))						with: #());		scalar: (self fullSymbolOf: #SmallInteger) with: #(95);		scalar: (self fullSymbolOf: #False) with: #(false);		scalar: (self fullSymbolOf: #SStudent)			with: (Array with: (SStudent new name: 'Mary'));		scalar: (self fullSymbolOf: #ByteString) with: #('Mary')</body><body package="SSG-Tests-Utility" selector="typeInfoOnPackage4">typeInfoOnPackage4	"the first typeInfo is about a class has as argument other class from other package"	"review and modify"	^ STypeInfo new		type:			(self fullSymbolOf: #SEvent)				-&gt;					(Array						with:							(Array								with:									#price:										-&gt;											(Array												with: (self fullSymbolOf: #SConference)												with: (self fullSymbolOf: #SConference)												with: (Array with: (self fullSymbolOf: #SmallInteger))												with: false))						with:							(Array								with:									#price:										-&gt;											(Array												with: (self fullSymbolOf: #SConference)												with: (self fullSymbolOf: #SConference)												with: (Array with: (self fullSymbolOf: #SmallInteger))												with: false)));		type:			(self fullSymbolOf: #SConference)				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: (self fullSymbolOf: #SConference)												with: (self fullSymbolOf: #SConference)												with: #()												with: false))						with: #());		type: (self fullSymbolOf: #SParty) -&gt; #(#() #());		scalar: (self fullSymbolOf: #SmallInteger) with: #(95)</body><body package="SSG-Tests-Utility" selector="typeInfoSAbstractClass">typeInfoSAbstractClass	^ STypeInfo new		type:			(self fullSymbolOf: #SAbstractClass)				-&gt;					(Array						with:							(Array								with:									#id										-&gt;											(Array												with: (self fullSymbolOf: #SAbstractClass)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: false))						with: #());		scalar: (self fullSymbolOf: #SmallInteger) with: #(1)</body><body package="SSG-Tests-Utility" selector="typeInfoSEvent1">typeInfoSEvent1	^ STypeInfo new		type:			(self fullSymbolOf: #SEvent)				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: (self fullSymbolOf: #SEvent)												with: (self fullSymbolOf: #SEvent)												with: #()												with: false)								with:									#discount										-&gt;											(Array												with: (self fullSymbolOf: #SEvent)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: true)								with:									#discount:										-&gt;											(Array												with: (self fullSymbolOf: #SEvent)												with: (self fullSymbolOf: #SEvent)												with: (Array with: (self fullSymbolOf: #SmallInteger))												with: false)								with:									#price										-&gt;											(Array												with: (self fullSymbolOf: #SEvent)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: true)								with:									#price:										-&gt;											(Array												with: (self fullSymbolOf: #SEvent)												with: (self fullSymbolOf: #SEvent)												with: (Array with: (self fullSymbolOf: #SmallInteger))												with: false))						with:							(Array								with:									#price:										-&gt;											(Array												with: (self fullSymbolOf: #SEvent)												with: (self fullSymbolOf: #SEvent)												with: (Array with: (self fullSymbolOf: #SmallInteger))												with: false)));		scalar: (self fullSymbolOf: #SmallInteger) with: #(8)</body><body package="SSG-Tests-Utility" selector="typeInfoSEvent2">typeInfoSEvent2	^ STypeInfo new		type:			(self fullSymbolOf: #SEvent)				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: (self fullSymbolOf: #SEvent)												with: (self fullSymbolOf: #SEvent)												with: #()												with: false)								with:									#discount										-&gt;											(Array												with: (self fullSymbolOf: #SEvent)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: true)								with:									#price										-&gt;											(Array												with: (self fullSymbolOf: #SEvent)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: true))						with:							(Array								with:									#price:										-&gt;											(Array												with: (self fullSymbolOf: #SEvent)												with: (self fullSymbolOf: #SEvent)												with: (Array with: (self fullSymbolOf: #SmallInteger))												with: false)));		scalar: (self fullSymbolOf: #SmallInteger) with: #(0 15)</body><body package="SSG-Tests-Utility" selector="typeInfoSEventOnPackage1">typeInfoSEventOnPackage1	^ STypeInfo new		type:			(self fullSymbolOf: #SEvent)				-&gt;					(Array						with:							(Array								with:									#price										-&gt;											(Array												with: (self fullSymbolOf: #SEvent)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: false)								with:									#discount										-&gt;											(Array												with: (self fullSymbolOf: #SEvent)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: true)								with:									#initialize										-&gt;											(Array												with: (self fullSymbolOf: #SEvent)												with: (self fullSymbolOf: #SEvent)												with: #()												with: false)								with:									#price:										-&gt;											(Array												with: (self fullSymbolOf: #SEvent)												with: (self fullSymbolOf: #SEvent)												with: (Array with: (self fullSymbolOf: #SmallInteger))												with: false))						with:							(Array								with:									#price:										-&gt;											(Array												with: (self fullSymbolOf: #SEvent)												with: (self fullSymbolOf: #SEvent)												with: (Array with: (self fullSymbolOf: #SmallInteger))												with: false)));		type: (self fullSymbolOf: #SSTeacher) -&gt; #(#() #());		type: (self fullSymbolOf: #SSPerson) -&gt; #(#() #());		type: (self fullSymbolOf: #SStack) -&gt; #(#() #());		type: (self fullSymbolOf: #SConference) -&gt; #(#() #());		type: (self fullSymbolOf: #SFoo) -&gt; #(#() #());		type: (self fullSymbolOf: #SParty) -&gt; #(#() #());		type: (self fullSymbolOf: #SEventTest) -&gt; #(#() #());		scalar: (self fullSymbolOf: #SmallInteger) with: #(15 0)</body><body package="SSG-Tests-Utility" selector="typeInfoSFoo2">typeInfoSFoo2	^ STypeInfo new		type:			(self fullSymbolOf: #SFoo)				-&gt;					(Array						with:							(Array								with:									#return:										-&gt;											(Array												with: (self fullSymbolOf: #SFoo)												with: (self fullSymbolOf: #SFoo)												with: (Array with: (self fullSymbolOf: #SFoo))												with: false))						with: #())</body><body package="SSG-Tests-Utility" selector="typeInfoSFoo4">typeInfoSFoo4	^ STypeInfo new		type:			(self fullSymbolOf: #SFoo)				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: (self fullSymbolOf: #SFoo)												with: (self fullSymbolOf: #SFoo)												with: #()												with: false)								with:									#return:										-&gt;											(Array												with: (self fullSymbolOf: #SFoo)												with: (self fullSymbolOf: #SStudent)												with: (Array with: (self fullSymbolOf: #SStudent))												with: false))						with: #());		scalar: (self fullSymbolOf: #SStudent)			with: (Array with: SStudent new)</body><body package="SSG-Tests-Utility" selector="typeInfoSFoo5">typeInfoSFoo5	^ STypeInfo new		type:			(self fullSymbolOf: #SFoo)				-&gt;					(Array						with:							(Array								with:									#return:										-&gt;											(Array												with: (self fullSymbolOf: #SFoo)												with: (self fullSymbolOf: #OrderedCollection)												with: (Array with: (self fullSymbolOf: #OrderedCollection))												with: false))						with: #());		scalar: (self fullSymbolOf: #OrderedCollection)			with:			(Array				with:					(OrderedCollection new						addAll: #(1 4 5);						yourself))</body><body package="SSG-Tests-Utility" selector="typeInfoSFooEmpty">typeInfoSFooEmpty	^ STypeInfo new		type: (self fullSymbolOf: #SFoo) -&gt; (Array with: #() with: #())</body><body package="SSG-Tests-Utility" selector="typeInfoSFooOnPackage1">typeInfoSFooOnPackage1	^ STypeInfo new		type:			(self fullSymbolOf: #SFoo)				-&gt;					(Array						with:							(Array								with:									#returnCollection										-&gt;											(Array												with: (self fullSymbolOf: #SFoo)												with: (self fullSymbolOf: #OrderedCollection)												with: #()												with: false)								with:									#returnString										-&gt;											(Array												with: (self fullSymbolOf: #SFoo)												with: (self fullSymbolOf: #ByteString)												with: #()												with: false)								with:									#score										-&gt;											(Array												with: (self fullSymbolOf: #SFoo)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: true)								with:									#score:										-&gt;											(Array												with: (self fullSymbolOf: #SFoo)												with: (self fullSymbolOf: #SFoo)												with: (Array with: (self fullSymbolOf: #SmallInteger))												with: false)								with:									#return:										-&gt;											(Array												with: (self fullSymbolOf: #SFoo)												with: (self fullSymbolOf: #SStudent)												with: (Array with: (self fullSymbolOf: #SStudent))												with: false))						with:							(Array								with:									#score:										-&gt;											(Array												with: (self fullSymbolOf: #SFoo)												with: (self fullSymbolOf: #SFoo)												with: (Array with: (self fullSymbolOf: #SmallInteger))												with: false)));		type:			(self fullSymbolOf: #SSPerson)				-&gt;					(Array						with:							(Array								with:									#id:										-&gt;											(Array												with: (self fullSymbolOf: #SStudent)												with: (self fullSymbolOf: #SStudent)												with: (Array with: (self fullSymbolOf: #SmallInteger))												with: false)								with:									#nickname:										-&gt;											(Array												with: (self fullSymbolOf: #SStudent)												with: (self fullSymbolOf: #SStudent)												with: (Array with: (self fullSymbolOf: #ByteString))												with: false)								with:									#name:										-&gt;											(Array												with: (self fullSymbolOf: #SStudent)												with: (self fullSymbolOf: #SStudent)												with: (Array with: (self fullSymbolOf: #ByteString))												with: false))						with:							(Array								with:									#name:										-&gt;											(Array												with: (self fullSymbolOf: #SStudent)												with: (self fullSymbolOf: #SStudent)												with: (Array with: (self fullSymbolOf: #ByteString))												with: false)));		type: (self fullSymbolOf: #SStack) -&gt; #(#() #());		type: (self fullSymbolOf: #SConference) -&gt; #(#() #());		type: (self fullSymbolOf: #SEvent) -&gt; #(#() #());		type: (self fullSymbolOf: #SSTeacher) -&gt; #(#() #());		type: (self fullSymbolOf: #SParty) -&gt; #(#() #());		type: (self fullSymbolOf: #SEventTest) -&gt; #(#() #());		scalar: (self fullSymbolOf: #SmallInteger) with: #(5 1 4);		scalar: (self fullSymbolOf: #ByteString) with: #('Emily' 'Hello');		scalar: (self fullSymbolOf: #OrderedCollection)			with: (Array with: OrderedCollection new);		scalar: (self fullSymbolOf: #SStudent)			with:			(Array				with:					((SStudent name: 'Emily')						nickname;						scoreStudent;						yourself))</body><body package="SSG-Tests-Utility" selector="typeInfoSFooOnPackage3">typeInfoSFooOnPackage3	^ STypeInfo new		type:			(self fullSymbolOf: #SSPerson)				-&gt;					(Array						with:							(Array								with:									#id:										-&gt;											(Array												with: (self fullSymbolOf: #SStudent)												with: (self fullSymbolOf: #SStudent)												with: (Array with: (self fullSymbolOf: #SmallInteger))												with: false)								with:									#nickname:										-&gt;											(Array												with: (self fullSymbolOf: #SStudent)												with: (self fullSymbolOf: #SStudent)												with: (Array with: (self fullSymbolOf: #ByteString))												with: false)								with:									#name:										-&gt;											(Array												with: (self fullSymbolOf: #SStudent)												with: (self fullSymbolOf: #SStudent)												with: (Array with: (self fullSymbolOf: #ByteString))												with: false))						with:							(Array								with:									#name:with:										-&gt;											(Array												with: (self fullSymbolOf: #SStudent)												with: (self fullSymbolOf: #SStudent)												with:													(Array														with: (self fullSymbolOf: #ByteString)														with: (self fullSymbolOf: #SmallInteger))												with: false)));		type:			(self fullSymbolOf: #SFoo)				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: (self fullSymbolOf: #SFoo)												with: (self fullSymbolOf: #SFoo)												with: #()												with: false)								with:									#return:										-&gt;											(Array												with: (self fullSymbolOf: #SFoo)												with: (self fullSymbolOf: #Dictionary)												with: (Array with: (self fullSymbolOf: #Dictionary))												with: false))						with: #());		type:			(self fullSymbolOf: #SStack)				-&gt;					(Array						with:							(Array								with:									#push:										-&gt;											(Array												with: (self fullSymbolOf: #SStack)												with: (self fullSymbolOf: #SStudent)												with: (Array with: (self fullSymbolOf: #SStudent))												with: false))						with: #());		type: (self fullSymbolOf: #SConference) -&gt; #(#() #());		type: (self fullSymbolOf: #SEvent) -&gt; #(#() #());		type: (self fullSymbolOf: #SParty) -&gt; #(#() #());		type: (self fullSymbolOf: #SSTeacher) -&gt; #(#() #());		type: (self fullSymbolOf: #SEventTest) -&gt; #(#() #());		scalar: (self fullSymbolOf: #SStudent)			with:			(Array				with: (SStudent name: 'Mery' with: 5)				with: (SStudent name: 'Josh' with: 2)				with: (SStudent name: 'Lian'));		scalar: (self fullSymbolOf: #Dictionary)			with:			(Array				with:					(Dictionary new						at: 1							put:							(SStack new								push: (SStudent name: 'Josh' with: 2);								push: (SStudent name: 'Lian');								yourself);						at: 2							put:							(OrderedCollection new								add: (SStudent name: 'Mery' with: 5);								yourself);						yourself));		scalar: (self fullSymbolOf: #SmallInteger) with: #(5 1 2);		scalar: (self fullSymbolOf: #ByteString)			with: #('Josh' 'Lian' 'Mery')</body><body package="SSG-Tests-Utility" selector="typeInfoSSPerson1">typeInfoSSPerson1	^ STypeInfo new		type:			(self fullNameOfClass: #SSPerson)				-&gt;					(Array						with:							(Array								with:									#name										-&gt;											(Array												with: (self fullNameOfClass: #SSPerson)												with: (self fullNameOfClass: #ByteString)												with: #()												with: true)								with:									#id										-&gt;											(Array												with: (self fullNameOfClass: #SSPerson)												with: (self fullNameOfClass: #SmallInteger)												with: #()												with: false))						with:							(Array								with:									#name:with:										-&gt;											(Array												with: (self fullNameOfClass: #SSPerson)												with: (self fullNameOfClass: #SSPerson)												with:													(Array														with: (self fullNameOfClass: #ByteString)														with: (self fullNameOfClass: #SmallInteger))												with: false)));		scalar: (self fullNameOfClass: #SmallInteger) with: #(50);		scalar: (self fullNameOfClass: #ByteString) with: #('Ann')</body><body package="SSG-Tests-Utility" selector="typeInfosSStudent">typeInfosSStudent	^ OrderedCollection new		add:			(STypeInfo new				type:					(self fullSymbolOf: #SStudent)						-&gt;							(Array								with:									(Array										with:											#initialize												-&gt;													(Array														with: (self fullSymbolOf: #SStudent)														with: (self fullSymbolOf: #SStudent)														with: #()														with: false)										with:											#scoreStudent												-&gt;													(Array														with: (self fullSymbolOf: #SStudent)														with: (self fullSymbolOf: #SmallInteger)														with: #()														with: true)										with:											#scoreStudent:												-&gt;													(Array														with: (self fullSymbolOf: #SStudent)														with: (self fullSymbolOf: #SStudent)														with: (Array with: (self fullSymbolOf: #SmallInteger))														with: false)										with:											#idStudent												-&gt;													(Array														with: (self fullSymbolOf: #SStudent)														with: (self fullSymbolOf: #SmallInteger)														with: #()														with: true))								with: #());				scalar: (self fullSymbolOf: #SmallInteger) with: #(1);				scalar: (self fullSymbolOf: #ByteString) with: #('student_Jane'));		add:			(STypeInfo new				type:					(self fullSymbolOf: #SStudent)						-&gt;							(Array								with:									(Array										with:											#scoreStudent:												-&gt;													(Array														with: (self fullSymbolOf: #SStudent)														with: (self fullSymbolOf: #SStudent)														with: (Array with: (self fullSymbolOf: #SmallInteger))														with: false)										with:											#nickname												-&gt;													(Array														with: (self fullSymbolOf: #SStudent)														with: (self fullSymbolOf: #ByteString)														with: #()														with: false))								with: #());				scalar: (self fullSymbolOf: #SmallInteger) with: #(1 6 8);				scalar: (self fullSymbolOf: #ByteString)					with: #('Jane' 'Ann' 'Peter'));		yourself</body><body package="SSG-Tests-Utility" selector="typeInfoSStack1">typeInfoSStack1	^ STypeInfo new		type:			(self fullSymbolOf: #SStack)				-&gt;					(Array						with:							(Array								with:									#firstLinkStack										-&gt;											(Array												with: (self fullSymbolOf: #SStack)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: true)								with:									#pop										-&gt;											(Array												with: (self fullSymbolOf: #SStack)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: false)								with:									#push:										-&gt;											(Array												with: (self fullSymbolOf: #SStack)												with: (self fullSymbolOf: #SmallInteger)												with: (Array with: (self fullSymbolOf: #SmallInteger))												with: false))						with:							(Array								with:									#newStackWith:										-&gt;											(Array												with: (self fullSymbolOf: #SStack)												with: (self fullSymbolOf: #SStack)												with: (Array with: (self fullSymbolOf: #Array))												with: false)));		scalar: (self fullSymbolOf: #Array) with: #(#(2 4 6 1));		scalar: (self fullSymbolOf: #SmallInteger) with: #(1 2 4 6 8)</body><body package="SSG-Tests-Utility" selector="typeInfoSStack2">typeInfoSStack2	^ STypeInfo new		type:			(self fullSymbolOf: #SStack)				-&gt;					(Array						with:							(Array								with:									#lastLinkStack										-&gt;											(Array												with: (self fullSymbolOf: #SStack)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: true)								with:									#pop										-&gt;											(Array												with: (self fullSymbolOf: #SStack)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: false)								with:									#top										-&gt;											(Array												with: (self fullSymbolOf: #SStack)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: false))						with:							(Array								with:									#newStack										-&gt;											(Array												with: (self fullSymbolOf: #SStack)												with: (self fullSymbolOf: #SStack)												with: #()												with: false)								with:									#newStackWith:										-&gt;											(Array												with: (self fullSymbolOf: #SStack)												with: (self fullSymbolOf: #SStack)												with: (Array with: (self fullSymbolOf: #Array))												with: false)));		scalar: (self fullSymbolOf: #Array) with: #(#(2 4 6 1) #(5 7 9 0));		scalar: (self fullSymbolOf: #SmallInteger) with: #(1 2 5 8 9)</body><body package="SSG-Tests-Utility" selector="typeInfoSStack3">typeInfoSStack3	^ STypeInfo new		type:			(self fullSymbolOf: #SStack)				-&gt;					(Array						with:							(Array								with:									#pop										-&gt;											(Array												with: (self fullSymbolOf: #SStack)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: false)								with:									#push:										-&gt;											(Array												with: (self fullSymbolOf: #SStack)												with: (self fullSymbolOf: #SmallInteger)												with: (Array with: (self fullSymbolOf: #SmallInteger))												with: false)								with:									#top										-&gt;											(Array												with: (self fullSymbolOf: #SStack)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: false))						with:							(Array								with:									#newStackWith:										-&gt;											(Array												with: (self fullSymbolOf: #SStack)												with: (self fullSymbolOf: #SStack)												with: (Array with: (self fullSymbolOf: #Array))												with: false)));		scalar: (self fullSymbolOf: #Array) with: (Array with: #(2 4 6 1));		scalar: (self fullSymbolOf: #SmallInteger) with: #(7 5 9 1)</body><body package="SSG-Tests-Utility" selector="typeInfoSStack4">typeInfoSStack4	^ STypeInfo new		type:			(self fullSymbolOf: #SStack)				-&gt;					(Array						with:							(Array								with:									#firstLinkStack										-&gt;											(Array												with: (self fullSymbolOf: #SStack)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: true)								with:									#lastLinkStack										-&gt;											(Array												with: (self fullSymbolOf: #SStack)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: true)								with:									#pop										-&gt;											(Array												with: (self fullSymbolOf: #SStack)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: false)								with:									#push:										-&gt;											(Array												with: (self fullSymbolOf: #SStack)												with: (self fullSymbolOf: #SmallInteger)												with: (Array with: (self fullSymbolOf: #SmallInteger))												with: false)								with:									#top										-&gt;											(Array												with: (self fullSymbolOf: #SStack)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: false))						with:							(Array								with:									#newStack										-&gt;											(Array												with: (self fullSymbolOf: #SStack)												with: (self fullSymbolOf: #SStack)												with: #()												with: false)								with:									#newStackWith:										-&gt;											(Array												with: (self fullSymbolOf: #SStack)												with: (self fullSymbolOf: #SStack)												with: (Array with: (self fullSymbolOf: #Array))												with: false)));		scalar: (self fullSymbolOf: #SmallInteger) with: #(5);		scalar: (self fullSymbolOf: #Array) with: #(#(1 4 5))</body><body package="SSG-Tests-Utility" selector="typeInfoSStackOnPackage1">typeInfoSStackOnPackage1	^ STypeInfo new		type:			(self fullSymbolOf: #SStack)				-&gt;					(Array						with:							(Array								with:									#pop										-&gt;											(Array												with: (self fullSymbolOf: #SStack)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: false)								with:									#push:										-&gt;											(Array												with: (self fullSymbolOf: #SStack)												with: (self fullSymbolOf: #SmallInteger)												with: (Array with: (self fullSymbolOf: #SmallInteger))												with: false)								with:									#top										-&gt;											(Array												with: (self fullSymbolOf: #SStack)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: false))						with:							(Array								with:									#newStackWith:										-&gt;											(Array												with: (self fullSymbolOf: #SStack)												with: (self fullSymbolOf: #SStack)												with: (Array with: (self fullSymbolOf: #Array))												with: false)));		type: (self fullSymbolOf: #SSPerson) -&gt; #(#() #());		type: (self fullSymbolOf: #SSTeacher) -&gt; #(#() #());		type: (self fullSymbolOf: #SConference) -&gt; #(#() #());		type: (self fullSymbolOf: #SEvent) -&gt; #(#() #());		type: (self fullSymbolOf: #SFoo) -&gt; #(#() #());		type: (self fullSymbolOf: #SParty) -&gt; #(#() #());		type: (self fullSymbolOf: #SEventTest) -&gt; #(#() #());		scalar: (self fullSymbolOf: #SmallInteger) with: #(1 2 4 6 8);		scalar: (self fullSymbolOf: #Array) with: #(#(2 4 6 1))</body><body package="SSG-Tests-Utility" selector="typeInfoSStackOnPackage2">typeInfoSStackOnPackage2	^ STypeInfo new		type:			#SSPerson				-&gt;					(Array						with:							(Array								with: #id: -&gt; #(#SStudent #SStudent #(#SmallInteger) false)								with: #nickname: -&gt; #(#SStudent #SStudent #(#ByteString) false)								with: #name: -&gt; #(#SStudent #SStudent #(#ByteString) false))						with:							(Array								with:									#name:with:										-&gt; #(#SStudent #SStudent #(#ByteString #SMallInteger) false)));		type:			#SStack				-&gt;					(Array						with:							(Array								with: #push: -&gt; #(#SStack #OrderedCollection #(#OrderedCollection) false))						with: #());		type: #SFoo -&gt; #(#() #());		type: #SConference -&gt; #(#() #());		type: #SEvent -&gt; #(#() #());		type: #SParty -&gt; #(#() #());		type: #SSTeacher -&gt; #(#() #());		type: #SEventTest -&gt; #(#() #());		scalar: #SStudent			with:			(Array				with: (SStudent name: 'Josh' with: 2)				with: (SStudent name: 'Mery' with: 5)				with: (SStudent name: 'Lian'));		scalar: #OrderedCollection			with:			(Array				with:					(OrderedCollection new						add: (SStudent name: 'Mery' with: 5);						yourself)				with:					(OrderedCollection new						add: (SStudent name: 'Lian');						add: (SStudent name: 'Josh' with: 2);						yourself));		scalar: #SmallInteger with: #(5 1 2);		scalar: #ByteString with: #('Josh' 'Lian' 'Mery')</body><body package="SSG-Tests-Utility" selector="typeInfoSSTeacher1">typeInfoSSTeacher1	^ STypeInfo new		type:			(self fullSymbolOf: #SSTeacher)				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SSTeacher)												with: #()												with: false)								with:									#yearsWorkExperience										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: true)								with:									#yearsWorkExperience:										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SSTeacher)												with: (Array with: (self fullSymbolOf: #SmallInteger))												with: false))						with: #());		scalar: #SmallInteger with: #(0 100);		scalar: #ByteString with: #('teacher_Ann')</body><body package="SSG-Tests-Utility" selector="typeInfoSSTeacher2">typeInfoSSTeacher2	^ STypeInfo new		type:			(self fullSymbolOf: #SSTeacher)				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SSTeacher)												with: #()												with: false)								with:									#idTeacher										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: true)								with:									#yearsWorkExperience:										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SSTeacher)												with: (Array with: (self fullSymbolOf: #SmallInteger))												with: false)								with:									#nickname										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #ByteString)												with: #()												with: false))						with: #());		scalar: (self fullSymbolOf: #SmallInteger) with: #(1 29 -7 9);		scalar: (self fullSymbolOf: #ByteString)			with: #('teacher_Amy' 'teacher_Mark')</body><body package="SSG-Tests-Utility" selector="typeInfoSSTeacher3">typeInfoSSTeacher3	^ STypeInfo new		type:			(self fullSymbolOf: #SSTeacher)				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SSTeacher)												with: #()												with: false)								with:									#yearsWorkExperience										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: false)								with:									#nickname										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #ByteString)												with: #()												with: false))						with: #());		scalar: (self fullSymbolOf: #SmallInteger) with: #(1 10);		scalar: (self fullSymbolOf: #ByteString)			with: #('teacher_Amy' 'teacher_Mark')</body><body package="SSG-Tests-Utility" selector="typeInfoSSTeacher4">typeInfoSSTeacher4	^ STypeInfo new		type:			(self fullSymbolOf: #SSTeacher)				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SSTeacher)												with: #()												with: false)								with:									#idTeacher										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: true)								with:									#yearsWorkExperience										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SSTeacher)												with: #()												with: true))						with: #());		scalar: (self fullSymbolOf: #SmallInteger) with: #(1 29 9);		scalar: (self fullSymbolOf: #ByteString)			with: #('teacher_Amy' 'teacher_Mark')</body><body package="SSG-Tests-Utility" selector="typeInfoSSTeacherOnPackage1">typeInfoSSTeacherOnPackage1	^ STypeInfo new		type:			(self fullSymbolOf: #SSPerson)				-&gt;					(Array						with:							(Array								with:									#id:										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SSTeacher)												with: (Array with: (self fullSymbolOf: #SmallInteger))												with: false)								with:									#nickname:										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SSTeacher)												with: (Array with: (self fullSymbolOf: #ByteString))												with: false)								with:									#name										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #ByteString)												with: #()												with: true)								with:									#id										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: true)								with:									#name:										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SSTeacher)												with: (Array with: (self fullSymbolOf: #ByteString))												with: false))						with:							(Array								with:									#name:with:										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SSTeacher)												with:													(Array														with: (self fullSymbolOf: #ByteString)														with: (self fullSymbolOf: #SmallInteger))												with: false)));		type:			(self fullSymbolOf: #SSTeacher)				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SSTeacher)												with: #()												with: false)								with:									#idTeacher										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: true)								with:									#yearsWorkExperience:										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SSTeacher)												with: (Array with: (self fullSymbolOf: #SmallInteger))												with: false)								with:									#nickname										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #ByteString)												with: #()												with: false))						with: #());		type: (self fullSymbolOf: #SStack) -&gt; #(#() #());		type: (self fullSymbolOf: #SConference) -&gt; #(#() #());		type: (self fullSymbolOf: #SEvent) -&gt; #(#() #());		type: (self fullSymbolOf: #SFoo) -&gt; #(#() #());		type: (self fullSymbolOf: #SParty) -&gt; #(#() #());		type: (self fullSymbolOf: #SEventTest) -&gt; #(#() #());		scalar: (self fullSymbolOf: #SmallInteger) with: #(0 100 34);		scalar: (self fullSymbolOf: #ByteString)			with: #('Ann' 'teacher_Ann')</body><body package="SSG-Tests-Utility" selector="typeInfoSSTeacherOnPackage2">typeInfoSSTeacherOnPackage2	^ STypeInfo new		type:			(self fullSymbolOf: #SSTeacher)				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SSTeacher)												with: #()												with: false)								with:									#nickname										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SSTeacher)												with: #()												with: false)								with:									#yearsWorkExperience										-&gt;											(Array												with: (self fullSymbolOf: #SSTeacher)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: true))						with: #());		type: (self fullSymbolOf: #SSPerson) -&gt; #(#() #());		type: (self fullSymbolOf: #SStack) -&gt; #(#() #());		type: (self fullSymbolOf: #SConference) -&gt; #(#() #());		type: (self fullSymbolOf: #SEvent) -&gt; #(#() #());		type: (self fullSymbolOf: #SFoo) -&gt; #(#() #());		type: (self fullSymbolOf: #SParty) -&gt; #(#() #());		type: (self fullSymbolOf: #SEventTest) -&gt; #(#() #());		scalar: (self fullSymbolOf: #SmallInteger) with: #(0);		scalar: (self fullSymbolOf: #ByteString) with: #('teacher_1')</body><body package="SSG-Tests-Utility" selector="typeInfoSStudentOnPackage1">typeInfoSStudentOnPackage1	^ STypeInfo new		type:			(self fullSymbolOf: #SStudent)				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: (self fullSymbolOf: #SStudent)												with: (self fullSymbolOf: #SStudent)												with: #()												with: false)								with:									#idStudent										-&gt;											(Array												with: (self fullSymbolOf: #SStudent)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: true)								with:									#scoreStudent										-&gt;											(Array												with: (self fullSymbolOf: #SStudent)												with: (self fullSymbolOf: #SmallInteger)												with: #()												with: true)								with:									#scoreStudent:										-&gt;											(Array												with: (self fullSymbolOf: #SStudent)												with: (self fullSymbolOf: #SmallInteger)												with: (Array with: (self fullSymbolOf: #SmallInteger))												with: false))						with: #());		type: (self fullSymbolOf: #SAbstractClass) -&gt; #(#() #());		scalar: (self fullSymbolOf: #SmallInteger) with: #(10 1)</body><body package="SSG-Tests-Utility" selector="typeInfoStringSEvent">typeInfoStringSEvent	"(SSTypeCollector				profile: [ (SEvent price: 15)						price;						discount ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario')"	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : { },			#classMethodTypes : { }		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : { },			#classMethodTypes : { }		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : {				#price : STypeMethodInfo {					#selector : #price,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SEvent ]				},				#discount : STypeMethodInfo {					#selector : #discount,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SEvent ]				},				#initialize : STypeMethodInfo {					#selector : #initialize,					#returnType : SMultiTypeInfo [ #SEvent ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SEvent ]				},				#''price:'' : STypeMethodInfo {					#selector : #''price:'',					#returnType : SMultiTypeInfo [ #SEvent ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SEvent ]				}			},			#classMethodTypes : {				#''price:'' : STypeMethodInfo {					#selector : #''price:'',					#returnType : SMultiTypeInfo [ #SEvent ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SEvent ]				}			}		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : { },			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : { },			#classMethodTypes : { }		}	},	#scalars : {		#SmallInteger : [			15,			0		]	}}'</body><body package="SSG-Tests-Utility" selector="typeInfoStringSFoo2">typeInfoStringSFoo2	"SSTypeCollector				profile: [ (SFoo score: 15)						returnCollection;						returnFloat;						score;						return: #(1 5 6) ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario'"	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : { },			#classMethodTypes : { }		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : { },			#classMethodTypes : { }		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : { },			#classMethodTypes : { }		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : { },			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : {				#returnFloat : STypeMethodInfo {					#selector : #returnFloat,					#returnType : SMultiTypeInfo [ #SmallFloat64 ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#''score:'' : STypeMethodInfo {					#selector : #''score:'',					#returnType : SMultiTypeInfo [ #SFoo ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#initialize : STypeMethodInfo {					#selector : #initialize,					#returnType : SMultiTypeInfo [ #SFoo ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#returnCollection : STypeMethodInfo {					#selector : #returnCollection,					#returnType : SMultiTypeInfo [ #OrderedCollection ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#''return:'' : STypeMethodInfo {					#selector : #''return:'',					#returnType : SMultiTypeInfo [ #Array ],					#argTypes : [						SMultiTypeInfo [ #Array ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#score : STypeMethodInfo {					#selector : #score,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				}			},			#classMethodTypes : {				#''score:'' : STypeMethodInfo {					#selector : #''score:'',					#returnType : SMultiTypeInfo [ #SFoo ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				}			}		}	},	#scalars : {		#OrderedCollection : [			OrderedCollection [ ]		],		#Array : [			[				1,				5,				6			]		],		#SmallInteger : [			15		],		#SmallFloat64 : [			2.3		]	}}'</body><body package="SSG-Tests-Utility" selector="typeInfoStringSFoo3">typeInfoStringSFoo3	"SSTypeCollector profile:[ (SFoo score: 4)				score;				returnCollection;				returnString;				score: 5;				return:					((SStudent name: 'Emily')						nickname;						scoreStudent;						yourself) ] onPackagesMatching: 'SmallSuiteGenerator-Scenario'."	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : { },			#classMethodTypes : { }		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : {				#''id:'' : STypeMethodInfo {					#selector : #''id:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#''nickname:'' : STypeMethodInfo {					#selector : #''nickname:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#''name:'' : STypeMethodInfo {					#selector : #''name:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				}			},			#classMethodTypes : {				#''name:'' : STypeMethodInfo {					#selector : #''name:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				}			}		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : { },			#classMethodTypes : { }		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : { },			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : {				#''score:'' : STypeMethodInfo {					#selector : #''score:'',					#returnType : SMultiTypeInfo [ #SFoo ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#initialize : STypeMethodInfo {					#selector : #initialize,					#returnType : SMultiTypeInfo [ #SFoo ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#returnCollection : STypeMethodInfo {					#selector : #returnCollection,					#returnType : SMultiTypeInfo [ #OrderedCollection ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#returnString : STypeMethodInfo {					#selector : #returnString,					#returnType : SMultiTypeInfo [ #ByteString ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#''return:'' : STypeMethodInfo {					#selector : #''return:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #SStudent ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#score : STypeMethodInfo {					#selector : #score,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				}			},			#classMethodTypes : {				#''score:'' : STypeMethodInfo {					#selector : #''score:'',					#returnType : SMultiTypeInfo [ #SFoo ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				}			}		}	},	#scalars : {		#OrderedCollection : [			OrderedCollection [ ]		],		#SmallInteger : [			5,			1,			4		],		#ByteString : [			''Emily'',			''Hello''		],		#SStudent : [			SStudent {				#name : ''Emily'',				#id : 1,				#nickname : ''Emily'',				#scoreStudent : 1			}		]	}}'</body><body package="SSG-Tests-Utility" selector="typeInfoStringSFoo6">typeInfoStringSFoo6	"SSTypeCollector profile: [ SFoo new return: (Dictionary new at: 1 put: (SStack new push: (SStudent  name: 'Lian' with: 1); push: (SStudent name: 'Josh' with: 2); yourself ); at: 2 put: (OrderedCollection new add: (SStudent name: 'Mery' with: 5); yourself); yourself ) ] onPackagesMatching: 'SmallSuiteGenerator-Scenario'."	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : {				#''push:'' : STypeMethodInfo {					#selector : #''push:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #SStudent ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStack ]				}			},			#classMethodTypes : { }		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : {				#''id:'' : STypeMethodInfo {					#selector : #''id:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#''nickname:'' : STypeMethodInfo {					#selector : #''nickname:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#''name:'' : STypeMethodInfo {					#selector : #''name:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				}			},			#classMethodTypes : {				#''name:with:'' : STypeMethodInfo {					#selector : #''name:with:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ],						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				}			}		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : { },			#classMethodTypes : { }		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : { },			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : {				#initialize : STypeMethodInfo {					#selector : #initialize,					#returnType : SMultiTypeInfo [ #SFoo ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#''return:'' : STypeMethodInfo {					#selector : #''return:'',					#returnType : SMultiTypeInfo [ #Dictionary ],					#argTypes : [						SMultiTypeInfo [ #Dictionary ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				}			},			#classMethodTypes : { }		}	},	#scalars : {		#Dictionary : [			{				1 : SStack [					SStudent {						#name : ''Josh'',						#id : 2,						#nickname : ''Josh'',						#scoreStudent : 1,						#idStudent : 1					},					SStudent {						#name : ''Lian'',						#id : 1,						#nickname : ''Lian'',						#scoreStudent : 1,						#idStudent : 1					}				],				2 : OrderedCollection [					SStudent {						#name : ''Mery'',						#id : 5,						#nickname : ''Mery'',						#scoreStudent : 1,						#idStudent : 1					}				]			}		],		#ByteString : [			''Josh'',			''Lian'',			''Mery''		],		#SmallInteger : [			5,			1,			2		],		#SStudent : [			@65,			@68,			@66		]	}}'</body><body package="SSG-Tests-Utility" selector="typeInfoStringSStack1">typeInfoStringSStack1	"SSTypeCollector profile: [ SStack new push: (OrderedCollection new add: (SStudent  name: 'Lian' with: 1); add: (SStudent name: 'Josh' with: 2); yourself); push: (OrderedCollection new add: (SStudent name: 'Mery' with: 5); yourself); yourself ] onPackagesMatching: 'SmallSuiteGenerator-Scenario'."	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : {				#''push:'' : STypeMethodInfo {					#selector : #''push:'',					#returnType : SMultiTypeInfo [ #OrderedCollection ],					#argTypes : [						SMultiTypeInfo [ #OrderedCollection ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStack ]				}			},			#classMethodTypes : { }		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : {				#''id:'' : STypeMethodInfo {					#selector : #''id:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#''nickname:'' : STypeMethodInfo {					#selector : #''nickname:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#''name:'' : STypeMethodInfo {					#selector : #''name:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				}			},			#classMethodTypes : {				#''name:with:'' : STypeMethodInfo {					#selector : #''name:with:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ],						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				}			}		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : { },			#classMethodTypes : { }		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : { },			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : { },			#classMethodTypes : { }		}	},	#scalars : {		#OrderedCollection : [			OrderedCollection [				SStudent {					#name : ''Mery'',					#id : 5,					#nickname : ''Mery'',					#scoreStudent : 1,					#idStudent : 1				}			],			OrderedCollection [				SStudent {					#name : ''Lian'',					#id : 1,					#nickname : ''Lian'',					#scoreStudent : 1,					#idStudent : 1				},				SStudent {					#name : ''Josh'',					#id : 2,					#nickname : ''Josh'',					#scoreStudent : 1,					#idStudent : 1				}			]		],		#ByteString : [			''Josh'',			''Lian'',			''Mery''		],		#SmallInteger : [			5,			1,			2		],		#SStudent : [			@56,			@59,			@58		]	}}'</body><body package="SSG-Tests-Utility" selector="typeInfoStringSStack2">typeInfoStringSStack2	"SSTypeCollector				profile: [ (SStack newStackWith: #(2 4 6 1))						push: 8;						pop;						top ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario'"	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : {				#''push:'' : STypeMethodInfo {					#selector : #''push:'',					#returnType : SMultiTypeInfo [ #SmallInteger ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStack ]				},				#pop : STypeMethodInfo {					#selector : #pop,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStack ]				},				#top : STypeMethodInfo {					#selector : #top,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStack ]				}			},			#classMethodTypes : {				#''newStackWith:'' : STypeMethodInfo {					#selector : #''newStackWith:'',					#returnType : SMultiTypeInfo [ #SStack ],					#argTypes : [						SMultiTypeInfo [ #Array ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStack ]				}			}		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : { },			#classMethodTypes : { }		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : { },			#classMethodTypes : { }		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : { },			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : { },			#classMethodTypes : { }		}	},	#scalars : {		#Array : [			[				2,				4,				6,				1			]		],		#SmallInteger : [			1,			2,			4,			6,			8		]	}}'</body><body package="SSG-Tests-Utility" selector="typeInfoStringSSTeacher1">typeInfoStringSSTeacher1	"SSTypeCollector		profile: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario'."	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : { },			#classMethodTypes : { }		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : {				#''id:'' : STypeMethodInfo {					#selector : #''id:'',					#returnType : SMultiTypeInfo [ #SSTeacher ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#''nickname:'' : STypeMethodInfo {					#selector : #''nickname:'',					#returnType : SMultiTypeInfo [ #SSTeacher ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#name : STypeMethodInfo {					#selector : #name,					#returnType : SMultiTypeInfo [ #ByteString ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#id : STypeMethodInfo {					#selector : #id,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#''name:'' : STypeMethodInfo {					#selector : #''name:'',					#returnType : SMultiTypeInfo [ #SSTeacher ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				}			},			#classMethodTypes : {				#''name:with:'' : STypeMethodInfo {					#selector : #''name:with:'',					#returnType : SMultiTypeInfo [ #SSTeacher ],					#argTypes : [						SMultiTypeInfo [ #ByteString ],						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				}			}		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : { },			#classMethodTypes : { }		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : {				#yearsWorkExperience : STypeMethodInfo {					#selector : #yearsWorkExperience,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#initialize : STypeMethodInfo {					#selector : #initialize,					#returnType : SMultiTypeInfo [ #SSTeacher ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#idTeacher : STypeMethodInfo {					#selector : #idTeacher,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#nickname : STypeMethodInfo {					#selector : #nickname,					#returnType : SMultiTypeInfo [ #ByteString ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				}			},			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : { },			#classMethodTypes : { }		}	},	#scalars : {		#ByteString : [			''Ann'',			''teacher_Ann''		],		#SmallInteger : [			0,			100,			34		]	}}'</body><body package="SSG-Tests-Utility" selector="typeInfoStringSSTeacher2">typeInfoStringSSTeacher2	"SSTypeCollector				profile: [ SSTeacher new						nickname;						yearsWorkExperience ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario'"	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : { },			#classMethodTypes : { }		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : { },			#classMethodTypes : { }		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : { },			#classMethodTypes : { }		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : {				#yearsWorkExperience : STypeMethodInfo {					#selector : #yearsWorkExperience,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#initialize : STypeMethodInfo {					#selector : #initialize,					#returnType : SMultiTypeInfo [ #SSTeacher ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#nickname : STypeMethodInfo {					#selector : #nickname,					#returnType : SMultiTypeInfo [ #ByteString ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				}			},			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : { },			#classMethodTypes : { }		}	},	#scalars : {		#ByteString : [			''teacher_1''		],		#SmallInteger : [			0		]	}}'</body><body package="SSG-Tests-Utility" selector="typeInfoStringSStudent1">typeInfoStringSStudent1	"SSTypeCollector				profile: [ SStudent new						idStudent;						scoreStudent: 10;						scoreStudent ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario2'"	^ 'STypeInfo {	#types : {		#SAbstractClass : STypeClassInfo {			#typeName : #SAbstractClass,			#methodTypes : { },			#classMethodTypes : { }		},		#SStudent : STypeClassInfo {			#typeName : #SStudent,			#methodTypes : {				#initialize : STypeMethodInfo {					#selector : #initialize,					#returnType : SMultiTypeInfo [ #SStudent ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#idStudent : STypeMethodInfo {					#selector : #idStudent,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#scoreStudent : STypeMethodInfo {					#selector : #scoreStudent,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#''scoreStudent:'' : STypeMethodInfo {					#selector : #''scoreStudent:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				}			},			#classMethodTypes : { }		}	},	#scalars : {		#SmallInteger : [			10,			1		]	}}'</body></methods><methods><class-id>SmallSuiteGenerator.SUtilityTypeInfo</class-id> <category>tests</category><body package="SSG-Tests-Utility" selector="testSuiteOf:withTargetClassName:">testSuiteOf: aCollection withTargetClassName: symbol	self		assert: aCollection size &gt;= 2		description: 'list must have at least two or more testCases.'.	^ OrderedCollection new		add:			((SSTestCase with: aCollection first)				addTargetClassName: symbol;				generateStatements);		add:			((SSTestCase with: aCollection second)				addTargetClassName: symbol;				generateStatements);		yourself</body><body package="SSG-Tests-Utility" selector="testSuiteSStack">testSuiteSStack	^ self		testSuiteOf:			(Array				with: self typeInfoSStack1				with: self typeInfoSStack2				with: self typeInfoSStack3				with: self typeInfoSStack4)		withTargetClassName: (self fullSymbolOf: #SStack)</body><body package="SSG-Tests-Utility" selector="testSuiteSSTeacher">testSuiteSSTeacher	^ self		testSuiteOf:			(Array				with: self typeInfoSSTeacher1				with: self typeInfoSSTeacher2				with: self typeInfoSSTeacher3)		withTargetClassName: (self fullSymbolOf: #SSTeacher)</body><body package="SSG-Tests-Utility" selector="testSuiteSStudent">testSuiteSStudent	^ self		testSuiteOf: self typeInfosSStudent		withTargetClassName: (self fullSymbolOf: #SStudent)</body><body package="SSG-Tests-Utility" selector="testSuiteSStudentManual">testSuiteSStudentManual	^ OrderedCollection new		add:			((SSTestCase with: self typeInfosSStudent first)				addTargetClassName: (self fullSymbolOf: #SStudent);				addFactoryMessage: (self fullSymbolOf: #SStudent)					ofSelector: #new;				addLiteral: (self fullSymbolOf: #ByteString);				addFieldAccessMessage: #idStudent					from: (self fullSymbolOf: #SStudent);				addMessage: #scoreStudent: from: (self fullSymbolOf: #SStudent);				addFactoryMessage: (self fullSymbolOf: #SStudent)					ofSelector: #new;				addFieldAccessMessage: #scoreStudent					from: (self fullSymbolOf: #SStudent);				yourself);		add:			((SSTestCase with: self typeInfosSStudent first)				addTargetClassName: (self fullSymbolOf: #SStudent);				addLiteral: (self fullSymbolOf: #SmallInteger);				addFactoryMessage: (self fullSymbolOf: #SStudent)					ofSelector: #new;				addMessage: #scoreStudent: from: (self fullSymbolOf: #SStudent);				addFactoryMessage: (self fullSymbolOf: #SStudent)					ofSelector: #new;				addFieldAccessMessage: #idStudent					from: (self fullSymbolOf: #SStudent);				yourself);		add:			((SSTestCase with: self typeInfosSStudent first)				addTargetClassName: (self fullSymbolOf: #SStudent);				addFactoryMessage: (self fullSymbolOf: #SStudent)					ofSelector: #new;				addLiteral: (self fullSymbolOf: #SmallInteger);				addMessage: #scoreStudent: from: (self fullSymbolOf: #SStudent);				addLiteral: (self fullSymbolOf: #SmallInteger);				addFactoryMessage: (self fullSymbolOf: #SStudent)					ofSelector: #new;				yourself);		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SFitnessFunction</class-id> <category>accessing</category><body package="SSG-GA" selector="tagetPackagesRegex">tagetPackagesRegex	^ tagetPackagesRegex</body><body package="SSG-GA" selector="tagetPackagesRegex:">tagetPackagesRegex: anObject	tagetPackagesRegex := anObject</body><body package="SSG-GA" selector="targetClass:">targetClass: anObject	targetClass := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SFitnessFunction</class-id> <category>actions</category><body package="SSG-GA" selector="compute:">compute: testCaseCollection	^ self subclassResponsibility</body></methods><methods><class-id>SmallSuiteGenerator.SMultiFitnessFunction</class-id> <category>initialization</category><body package="SSG-GA" selector="initialize">initialize	super initialize.	fitness := Dictionary new</body></methods><methods><class-id>SmallSuiteGenerator.SMultiFitnessFunction</class-id> <category>actions</category><body package="SSG-GA" selector="compute:">compute: aTestCase	"^ fitness associations inject: 0 into:[:assoc :acum |  				acum +  ((assoc first compute: aTestCase)* (assoc second))s]."	</body></methods><methods><class-id>SmallSuiteGenerator.SMultiFitnessFunction</class-id> <category>accessing</category><body package="SSG-GA" selector="add:weight:">add: aFitness weight: aFloat	fitness at: aFitness put: aFloat</body></methods><methods><class-id>SmallSuiteGenerator.SSimpleFitnessFunction</class-id> <category>accessing</category><body package="SSG-GA" selector="typeInfo:">typeInfo: anObject	profiler typeInfo: anObject</body></methods><methods><class-id>SmallSuiteGenerator.SSimpleFitnessFunction</class-id> <category>accesing</category><body package="SSG-GA" selector="functionName">functionName	^ self subclassResponsibility</body><body package="SSG-GA" selector="profiler">profiler	^ profiler</body><body package="SSG-GA" selector="profiler:">profiler: aProfiler	profiler := aProfiler</body></methods><methods><class-id>SmallSuiteGenerator.SSimpleFitnessFunction</class-id> <category>actions</category><body package="SSG-GA" selector="compute:">compute: testCaseCollection	self setUp.	self run: testCaseCollection.	self tearDown</body><body package="SSG-GA" selector="fitnessOf:withKey:">fitnessOf: testCase withKey: string	self subclassResponsibility</body><body package="SSG-GA" selector="run:">run: testCaseCollection	| string |	string := self functionName.	testCaseCollection		do: [ :testCase | 			testCase length &gt; 0				ifTrue: [ profiler cleanBlocksOfMethods.					testCase runWithoutAssertions.					testCase						summaryExecutionMethods: profiler summaryExecutionMethods.					"self abstractDataOn: testCase."					self fitnessOf: testCase withKey: string ]				ifFalse: [ testCase fitness at: string put: 0 ] ]</body><body package="SSG-GA" selector="runPopulation:">runPopulation: testCaseCollection	profiler cleanBlocksOfMethods.	testCaseCollection		do: [ :testCase | 			testCase length &gt; 0				ifTrue: [ testCase runWithoutAssertions ] ].	^ profiler summaryMethodsOf: targetClass</body><body package="SSG-GA" selector="setUp">setUp	</body><body package="SSG-GA" selector="tearDown">tearDown	</body></methods><methods><class-id>SmallSuiteGenerator.SStatementCoverage</class-id> <category>actions</category><body package="SSG-GA" selector="computeFitness">computeFitness	^ profiler statementCoverage</body><body package="SSG-GA" selector="fitnessOf:withKey:">fitnessOf: testCase withKey: string	testCase fitness		at: string		put: (profiler statementCoverageFor: targetClass).	testCase fitnessByClass at: string put: profiler statementCoverage1</body><body package="SSG-GA" selector="setUp">setUp	</body><body package="SSG-GA" selector="tearDown">tearDown	</body></methods><methods><class-id>SmallSuiteGenerator.SStatementCoverage</class-id> <category>accesing</category><body package="SSG-GA" selector="functionName">functionName	^ 'block-coverage'</body></methods><methods><class-id>SmallSuiteGenerator.SAssertionMessage</class-id> <category>initialization</category><body package="SSG-AST" selector="initialize">initialize	super initialize.	receiver := SSelf new</body></methods><methods><class-id>SmallSuiteGenerator.SAssertionMessage</class-id> <category>override</category><body package="SSG-AST" selector="changeSelectorFrom:in:">changeSelectorFrom: aExpression in: aTestCase	"not sure what it should return"	</body></methods><methods><class-id>SmallSuiteGenerator.SAssertionMessage</class-id> <category>printing</category><body package="SSG-AST" selector="printOn:">printOn: stream	super printOn: stream.	stream nextPut: $.</body></methods><methods><class-id>SmallSuiteGenerator.SAssertionMessage class</class-id> <category>instance creation</category><body package="SSG-AST" selector="for:">for: aExecutionContext	^ self subclassResponsibility</body></methods><methods><class-id>SmallSuiteGenerator.SPrimitiveAssertion class</class-id> <category>instance creation</category><body package="SSG-AST" selector="for:">for: anExecutionContext	^ anExecutionContext associations		select: [ :assoc | self isPrimitive: assoc value ]		thenCollect: [ :assoc | 			self new				selector: #assert:equals:;				args:					(Array						with: (SVariable nameOrId: assoc key)						with: (SLiteral new value: assoc value));				yourself ]</body></methods><methods><class-id>SmallSuiteGenerator.SComparisonAssertion class</class-id> <category>instance creation</category><body package="SSG-AST" selector="comparisonAssertion:with:">comparisonAssertion: anExecutionContext with: array	| varName1 varName2 val1 val2 |	varName1 := array first.	varName2 := array second.	val1 := anExecutionContext at: varName1.	val2 := anExecutionContext at: varName2.	val1 class = val2 class		ifTrue: [ (val1 class allSelectorsBelow: Object)				detect: [ :selector | selector = #= ]				ifFound: [ | selector |					selector := val1 = val2						ifTrue: [ #assert:equals: ]						ifFalse: [ #deny:equals: ].					^ self new						selector: selector;						args:							(Array								with: (SVariable nameOrId: varName1)								with: (SVariable nameOrId: varName2));						yourself ] ].	^ nil</body><body package="SSG-AST" selector="for:">for: anExecutionContext	| assertions |	assertions := OrderedCollection new.	anExecutionContext keys asOrderedCollection		combinations: 2		atATimeDo: [ :comb | 			| compareAssert |			compareAssert := self				comparisonAssertion: anExecutionContext				with: comb.			compareAssert ifNotNil: [ assertions add: compareAssert ] ].	^ assertions</body></methods><methods><class-id>SmallSuiteGenerator.SInspectorAssertion class</class-id> <category>instance creation</category><body package="SSG-AST" selector="for:">for: anExecutionContext	^ anExecutionContext associations		flatCollect: [ :assoc | self inspectorAssertionOf: assoc ]</body><body package="SSG-AST" selector="inspectorAssertionOf:and:">inspectorAssertionOf: assoc and: compiledMethod	| result |	result := assoc value perform: compiledMethod selector.	^ (self isPrimitive: result)		ifFalse: [ nil ]		ifTrue: [ self new				selector: #assert:equals:;				args:					(Array						with:							(SMessage new								receiver: (SVariable nameOrId: assoc key);								selector: compiledMethod selector;								yourself)						with: (SLiteral new value: result));				yourself ]</body></methods><methods><class-id>SmallSuiteGenerator.SEvent</class-id> <category>initialization</category><body package="SSG-Scenario" selector="initialize">initialize	price := 0.	discount := 0</body></methods><methods><class-id>SmallSuiteGenerator.SEvent</class-id> <category>accessing</category><body package="SSG-Scenario" selector="discount">discount	^ discount</body><body package="SSG-Scenario" selector="discount:">discount: aNumber	price &gt; 0		ifTrue: [ discount := aNumber ]</body><body package="SSG-Scenario" selector="price">price	^ price - (discount * price / 100)</body></methods><methods><class-id>SmallSuiteGenerator.SEvent</class-id> <category>testing</category><body package="SSG-Scenario" selector="canRegister:">canRegister: aPerson	^ aPerson canRegister: self</body></methods><methods><class-id>SmallSuiteGenerator.SEvent</class-id> <category>as yet unclassified</category><body package="SSG-Scenario" selector="price:">price: aNumber	price := aNumber</body></methods><methods><class-id>SmallSuiteGenerator.SEvent class</class-id> <category>as yet unclassified</category><body package="SSG-Scenario" selector="price:">price: aNumber	^ self new price: aNumber</body></methods><methods><class-id>SmallSuiteGenerator.SConference</class-id> <category>accessing</category><body package="SSG-Scenario" selector="date">date	^ date</body><body package="SSG-Scenario" selector="date:">date: anObject	date := anObject</body><body package="SSG-Scenario" selector="offerPrice">offerPrice	^ offerPrice</body><body package="SSG-Scenario" selector="offerPrice:">offerPrice: aNumber	offerPrice := aNumber</body><body package="SSG-Scenario" selector="speaker">speaker	^ speaker</body><body package="SSG-Scenario" selector="speaker:">speaker: anObject	speaker := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SConference</class-id> <category>initialization</category><body package="SSG-Scenario" selector="initialize">initialize	price := 100.	discount := 0.	offerPrice := price.	date := Date today</body></methods><methods><class-id>SmallSuiteGenerator.SParty</class-id> <category>accessing</category><body package="SSG-Scenario" selector="date">date	^ date</body><body package="SSG-Scenario" selector="date:">date: anObject	date := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SFieldAccessMessage</class-id> <category>override</category><body package="SSG-AST" selector="changeSelectorFrom:in:">changeSelectorFrom: expression in: aTestCase	| otherFieldAccessMessage |	otherFieldAccessMessage := aTestCase		alternativeFieldAccessMessage: self.	mutated := otherFieldAccessMessage selector ~= self selector.	self selector: otherFieldAccessMessage selector</body></methods><methods><class-id>SmallSuiteGenerator.SFieldAccessMessage</class-id> <category>mutation</category><body package="SSG-AST" selector="insertOn:">insertOn: aTestCase	[ ^ aTestCase		addFieldAccessMessage: self selector		from: self receiver returnType ]		on: SError		do: [  ]</body></methods><methods><class-id>SmallSuiteGenerator.SFieldAccessMessage</class-id> <category>actions</category><body package="SSG-AST" selector="replaceArg:by:">replaceArg: expressions by: newExpressions	</body></methods><methods><class-id>SmallSuiteGenerator.SFieldAccessMessage</class-id> <category>fixing</category><body package="SSG-AST" selector="fixWith:in:">fixWith: anObject in: aTestCase	(anObject receiver types includes: receiver returnType)		ifFalse: [ self halt ].	returnType := self random selectAtRandom: anObject returnType types.	needsBeFixed := false</body></methods><methods><class-id>SmallSuiteGenerator.SFieldAccessMessage class</class-id> <category>instance creation</category><body package="SSG-AST" selector="newFromReceiver:andMethod:">newFromReceiver: aReceiver andMethod: aMethod	^ SFieldAccessMessage new		returnType: aMethod returnType type;		selector: aMethod selector;		receiver: aReceiver;		needsBeFixed: (aMethod returnType types size &gt; 1 or: [ aMethod hasProfiler not ]);		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SMethodCoverage</class-id> <category>actions</category><body package="SSG-GA" selector="fitnessOf:withKey:">fitnessOf: testCase withKey: string	testCase fitness at: string put: profiler methodCoverage.	testCase fitnessByClass at: string put: profiler methodCoverage1</body><body package="SSG-GA" selector="setUp">setUp	</body><body package="SSG-GA" selector="tearDown">tearDown	</body></methods><methods><class-id>SmallSuiteGenerator.SMethodCoverage</class-id> <category>accesing</category><body package="SSG-GA" selector="functionName">functionName	^ 'method-coverage'</body></methods><methods><class-id>SmallSuiteGenerator.SSPerson</class-id> <category>accessing</category><body package="SSG-Scenario" selector="age:">age: aNumber	^ aNumber</body><body package="SSG-Scenario" selector="id">id	^ id</body><body package="SSG-Scenario" selector="id:">id: anObject	id := anObject</body><body package="SSG-Scenario" selector="identifier">identifier	^ name , id printString</body><body package="SSG-Scenario" selector="name">name	^ name</body><body package="SSG-Scenario" selector="name:">name: anObject	name := anObject</body><body package="SSG-Scenario" selector="nickname">nickname	self subclassResponsibility</body><body package="SSG-Scenario" selector="nickname:">nickname: anObject	nickname := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SSPerson</class-id> <category>testing</category><body package="SSG-Scenario" selector="canRegister:">canRegister: aConference	^ aConference price - aConference offerPrice		&gt; (aConference price * 0.05)</body></methods><methods><class-id>SmallSuiteGenerator.SSPerson</class-id> <category>as yet unclassified</category><body package="SSG-Scenario" selector="fullIdentifier">fullIdentifier	^ name , '_' , nickname , '_' , id printString</body></methods><methods><class-id>SmallSuiteGenerator.SSPerson class</class-id> <category>as yet unclassified</category><body package="SSG-Scenario" selector="name:">name: aString	| inst |	inst := self new		name: aString;		id: 1;		nickname: aString.	^ inst</body><body package="SSG-Scenario" selector="name:with:">name: aString with: aNumber	| inst |	inst := self new		name: aString;		id: aNumber;		nickname: aString.	^ inst</body></methods><methods><class-id>SmallSuiteGenerator.SSTeacher</class-id> <category>initialization</category><body package="SSG-Scenario" selector="initialize">initialize	idTeacher := 100 + (id ifNil: [ 0 ]).	yearsWorkExperience := 0</body></methods><methods><class-id>SmallSuiteGenerator.SSTeacher</class-id> <category>accessing</category><body package="SSG-Scenario" selector="idTeacher">idTeacher	^ idTeacher</body><body package="SSG-Scenario" selector="nickname">nickname	^ 'teacher_' , (nickname ifNil: [ '1' ])</body><body package="SSG-Scenario" selector="yearsWorkExperience">yearsWorkExperience	^ yearsWorkExperience</body><body package="SSG-Scenario" selector="yearsWorkExperience:">yearsWorkExperience: anObject	yearsWorkExperience := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SGACrossoverOperation</class-id> <category>actions</category><body package="SSG-GA" selector="crossover:with:">crossover: testCaseA with: testCaseB	| alpha offSpring1 offSpring2 |	self checkReferencesOf: testCaseA withDescription: 'testCase'.	self checkReferencesOf: testCaseB withDescription: 'testCase'.	"join typeInfo of testCaseA with testCaseB"	testCaseA typeInfo joinWith: testCaseB typeInfo.	alpha := self alpha.	"first alpha(P1) and last (1-alpha)(P2)"	offSpring1 := self offSpringOf: testCaseA and: testCaseB using: alpha.	self checkReferencesOf: offSpring1 withDescription: 'offspring'.	"first alpha(P2) and last (1-alpha)(P1)"	offSpring2 := self offSpringOf: testCaseB and: testCaseA using: alpha.	self checkReferencesOf: offSpring2 withDescription: 'offspring'.	^ (Array with: offSpring1 with: offSpring2)		do: [ :e | e lastMessage: testCaseA lastMessage ]</body><body package="SSG-GA" selector="offSpringOf:and:using:">offSpringOf: parentA and: parentB using: alpha	| sizeA sizeB offSpring |	sizeA := parentA length.	sizeB := parentB length.	offSpring := SSTestCase with: parentA typeInfo copy.	offSpring		addTargetClassNames: parentA targetClassesNames;		addTargetClassNames: parentB targetClassesNames.	offSpring		addStatements:			(parentA statements copyFrom: 1 to: ((sizeA * alpha) asInteger max: 1))				copy.	(parentB statements		copyFrom: ((alpha * sizeB) asInteger max: 1) + 1		to: sizeB)		do: [ :aStm | 			[ | lastStm |			aStm insertOn: offSpring.			lastStm := offSpring statements last.			lastStm needsBeFixed				ifTrue: [ offSpring fixTypeReturnOf: lastStm ] ]				on: SError				do: [  ] ].	offSpring		generationNumber: parentA generationNumber + 1;		clean.	^ offSpring</body></methods><methods><class-id>SmallSuiteGenerator.SGACrossoverOperation</class-id> <category>validation</category><body package="SSG-GA" selector="checkReferencesOf:withDescription:">checkReferencesOf: testCase withDescription: aString	self		assert: testCase validReferences		description: aString , ' must have valid references'</body></methods><methods><class-id>SmallSuiteGenerator.SGACrossoverOperation</class-id> <category>accessing</category><body package="SSG-GA" selector="alpha">alpha	^ (self random selectAtRandom: (0.1 to: 0.9 by: 0.1)) round: 1</body></methods><methods><class-id>SmallSuiteGenerator.SReportSGALog</class-id> <category>groups collecting</category><body package="SSG-Utility" selector="methodTrackingFor:">methodTrackingFor: aSymbol	| methodCalls dict idMethods |	idMethods := #().	methodCalls := engine logs		collect: [ :log | 			log population				select: [ :testCase | 					testCase statements						anySatisfy: [ :e | 							[ e value selector = aSymbol ]								on: Error								do: [ false ] ] ] ].	dict := Dictionary new.	methodCalls		doWithIndex: [ :methods :i | 			methods				ifNotEmpty: [ dict at: i put: (self reportOf: methods withParents: idMethods).					idMethods := methods collect: #idPopulation ]				ifEmpty: [ idMethods := #() ] ].	^ dict</body><body package="SSG-Utility" selector="reportOf:withParents:">reportOf: methods withParents: idMethods	| keys |	keys := #('TestCase' 'hasError' 'parentHasMethod').	^ methods		collect: [ :method | 			Dictionary				newFromKeys: keys				andValues:					(Array						with: method						with: method hasErrors						with: ((method parents collect: #idPopulation) includesAny: idMethods)) ]</body></methods><methods><class-id>SmallSuiteGenerator.SReportSGALog</class-id> <category>reporting</category><body package="SSG-Utility" selector="differencesBtw:and:">differencesBtw: summary1 and: summary2	| result |	result := OrderedCollection new.	summary1		with: summary2		do: [ :x :y | 			x = y				ifFalse: [ | aux |					aux := OrderedCollection new.					x						keysAndValuesDo: [ :key :value | 							(x at: key) = (y at: key)								ifFalse: [ aux add: key -&gt; (Array with: value with: (y at: key)) ] ].					aux						ifNotEmpty: [ aux addFirst: (x at: 'MethodName').							result add: aux ] ] ].	^ result</body><body package="SSG-Utility" selector="differencesBtwGenerations">differencesBtwGenerations	| generations result |	generations := self summaryGenerations.	result := OrderedCollection new.	2 to: generations size do: [ :index | 		| diff |		diff := self			differencesBtw: (generations at: index - 1)			and: (generations at: index).		diff ifNotEmpty: [ result add: index -&gt; diff ] ].	^ result</body><body package="SSG-Utility" selector="summaryGenerations">summaryGenerations	^ engine logs		collect: [ :aLog | 			aLog summaryTargetClass				collect: [ :e | 					e						ifNotNil: [ Dictionary								newFromKeys:									#('ClassName' 'MethodName' 'IsClassSide' 'WasExecuted' 'HasTypeInfo' 'Code' 'ArgTypes' 'ReturnType' 'ExecutedBlock' 'UnexecutedBlock')								andValues: e summaryAsColl ] ] ]</body></methods><methods><class-id>SmallSuiteGenerator.SReportSGALog</class-id> <category>accessing</category><body package="SSG-Utility" selector="dictOfDifferences:">dictOfDifferences: differences	| result keys |	result := OrderedCollection new.	keys := #('Generations' 'Method' 'UpdateReturnType' 'UpdateArgsType' 'ConvertToExecutedMethod' 'ConvertToUnexecutedMethod' 'AddTypeInfo' 'AddExecutedBlocks' 'DecreaseExecutedBlocks').	differences		do: [ :e | 			| generationText |			generationText := '{1} -&gt; {2}'				format: (Array with: e key - 1 with: e key).			e value				do: [ :diff | 					| aux |					aux := Dictionary						newFromKeys: keys						andValues: (OrderedCollection ofSize: 9).					aux at: 'Generations' put: generationText.					aux at: 'Method' put: diff first.					diff allButFirst						do: [ :d | 							d key = 'WasExecuted'								ifTrue: [ d value = #(false true)										ifTrue: [ aux at: 'ConvertToExecutedMethod' put: true ]										ifFalse: [ aux at: 'ConvertToUnexecutedMethod' put: true ] ].							d key = 'ReturnType'								ifTrue: [ aux at: 'UpdateReturnType' put: true ].							d key = 'HasTypeInfo'								ifTrue: [ aux at: 'AddTypeInfo' put: true ].							d key = 'ArgTypes'								ifTrue: [ aux at: 'UpdateArgsType' put: true ].							d key = 'ExecutedBlock'								ifTrue: [ aux										at: 'AddExecutedBlocks'										put: (d value second difference: d value first) asString ].							d key = 'UnexecutedBlock'								ifTrue: [ aux										at: 'DecreaseExecutedBlocks'										put: (d value second difference: d value first) asString ] ].					result add: aux ] ].	^ result</body><body package="SSG-Utility" selector="engine:">engine: anObject	engine := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SReportSGALog class</class-id> <category>class-factory</category><body package="SSG-Utility" selector="engine:">engine: aSGAEngine	^ self new engine: aSGAEngine</body></methods><methods><class-id>SmallSuiteGenerator.SReportSGALog class</class-id> <category>export</category><body package="SSG-Utility" selector="generateReportForDifferencesBtwGenerationsOf:">generateReportForDifferencesBtwGenerationsOf: aSGAEngine	^ (self engine: aSGAEngine)		generateReportForDifferencesBtwGenerations</body></methods><methods><class-id>SmallSuiteGenerator.SReportSGALog class</class-id> <category>accessing</category><body package="SSG-Utility" selector="titles">titles	^ #('ID' 'Class Name' 'Method Name' 'Is Class Side' 'Was Executed' 'Has TypeInfo' 'Code' 'Args Types' 'Return Type' 'Executed Block' 'Unexecuted Block')</body></methods><methods><class-id>SmallSuiteGenerator.SStringAssertion class</class-id> <category>instance creation</category><body package="SSG-AST" selector="for:">for: anExecutionContext	^ (anExecutionContext associations		reject: [ :assoc | self isPrimitive: assoc value ])		collect: [ :assoc | self stringAssertionsOf: assoc ]		thenSelect: [ :stringAssertion | stringAssertion isNil not ]</body><body package="SSG-AST" selector="stringAssertionsOf:">stringAssertionsOf: assoc	| aValue |	aValue := assoc value.	^ (aValue class allSelectorsBelow: Object)		detect: [ :aSelector | aSelector = #printOn: or: [ aSelector = #asString ] ]		ifFound: [ | fieldValue |			[ fieldValue := aValue perform: #printString.			self new				selector: #assert:equals:;				args:					(Array						with:							(SMessage new								receiver: (SVariable nameOrId: assoc key);								selector: #printString;								yourself)						with: (SLiteral new value: fieldValue));				yourself ]				on: Error				do: [ Transcript						show: aValue class name , ' cant answer printString without error' ] ]		ifNone: [ nil ]</body></methods><methods><class-id>SmallSuiteGenerator.SGATournamentSelection</class-id> <category>initialization</category><body package="SSG-GA" selector="initialize">initialize	super initialize.	tournamentSize := 5</body></methods><methods><class-id>SmallSuiteGenerator.SGATournamentSelection</class-id> <category>selection</category><body package="SSG-GA" selector="selectJustOneOf:with:">selectJustOneOf: aCollection with: probabilities	| sample index |	index := 0.	sample := (self random		collectAtRandom:			(probabilities				collect: [ :prob | 					index := index + 1.					index -&gt; prob ])) first: (2 min: probabilities size).	sample := (sample sort: [ :a :b | a value &gt; b value ]) first.	^ aCollection at: sample key</body><body package="SSG-GA" selector="selectOf:">selectOf: aCollection	"Return the best testCases from tournamentSize testCase randomly chosen from the population"	| sample |	sample := (self random collectAtRandom: aCollection)		first: (tournamentSize min: aCollection size).	sample := sample		asSortedCollection: [ :a :b | 			(a fitnessFor: fitness functionName)				&gt; (b fitnessFor: fitness functionName) ].	^ sample</body></methods><methods><class-id>SmallSuiteGenerator.SGATournamentSelection</class-id> <category>accessing</category><body package="SSG-GA" selector="tournamentSize:">tournamentSize: anInteger	tournamentSize := anInteger</body></methods><methods><class-id>SmallSuiteGenerator.SInitialization</class-id> <category>initialization</category><body package="SSG-Initialization" selector="initialize">initialize	configurationDict := self initializeDictionary</body><body package="SSG-Initialization" selector="initializeDictionary">initializeDictionary	^ self subclassResponsibility</body></methods><methods><class-id>SmallSuiteGenerator.SInitialization</class-id> <category>public tree building</category><body package="SSG-Initialization" selector="newInstance:with:">newInstance: testCaseFactory with: key	| instance |	instance := self copy: testCaseFactory.	(configurationDict at: key) value: instance.	instance createTestCases.	^ instance</body></methods><methods><class-id>SmallSuiteGenerator.SInitialization</class-id> <category>copying</category><body package="SSG-Initialization" selector="copy:">copy: testCaseFactory	^ testCaseFactory class new		typeInfo: testCaseFactory typeInfoOrigin copy;		fitness: testCaseFactory fitness class new;		targetClassName: testCaseFactory targetClassName;		targetPackageRegex: testCaseFactory targetPackageRegex;		outputPackageName: testCaseFactory outputPackageName;		asDict: testCaseFactory initialAsDict;		seed: testCaseFactory initialSeed;		fitnessSeedCalculated: testCaseFactory fitnessSeed;		numberOfGenerations: testCaseFactory numberOfGenerations;		numberOfStatements: testCaseFactory engine numberOfStatements;		populationSize: testCaseFactory engine populationSize;		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SSeedingParameterization</class-id> <category>initialization</category><body package="SSG-Initialization" selector="initialize">initialize	super initialize.	numberToChangeSeed := 0</body><body package="SSG-Initialization" selector="initializeDictionary">initializeDictionary	^ Dictionary new		at: #lowerSeed			put: [ :testCaseFactory | 			testCaseFactory				seed: testCaseFactory initialSeed - self numberToChangeSeed ];		at: #greaterSeed			put: [ :testCaseFactory | 			testCaseFactory				seed: testCaseFactory initialSeed + self numberToChangeSeed ];		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SSeedingParameterization</class-id> <category>accessing</category><body package="SSG-Initialization" selector="numberToChangeSeed">numberToChangeSeed	numberToChangeSeed == 0		ifTrue: [ numberToChangeSeed := 10 ].	^ numberToChangeSeed</body><body package="SSG-Initialization" selector="numberToChangeSeed:">numberToChangeSeed: number	numberToChangeSeed := number</body></methods><methods><class-id>SmallSuiteGenerator.SSelectionParameterization</class-id> <category>initialization</category><body package="SSG-Initialization" selector="initializeDictionary">initializeDictionary	^ Dictionary new		at: #rankSelection			put:				[ :testCaseFactory | testCaseFactory selectionStrategy: SGARankSelection new ];		at: #tournamentSelection			put:				[ :testCaseFactory | testCaseFactory selectionStrategy: SGATournamentSelection new ];		at: #rouleteWheelSelection			put:				[ :testCaseFactory | testCaseFactory selectionStrategy: SGARouletteSelection new ];		at: #rankSelectionForTestCase			put:				[ :testCaseFactory | testCaseFactory selectionStrategyTestCase: SGARankSelection new ];		at: #tournamentSelectionForTestCase			put:				[ :testCaseFactory | testCaseFactory selectionStrategyTestCase: SGATournamentSelection new ];		at: #rouleteWheelSelectionForTestCase			put:				[ :testCaseFactory | testCaseFactory selectionStrategyTestCase: SGARouletteSelection new ];		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SNumericParameterization</class-id> <category>initialization</category><body package="SSG-Initialization" selector="initializeDictionary">initializeDictionary	^ Dictionary new		at: #largePopulationNumber			put: [ :testCaseFactory | 			testCaseFactory engine populationSize &lt; 30				ifTrue: [ testCaseFactory populationSize: 30 ] ];		at: #largeGenerationNumber			put: [ :testCaseFactory | 			testCaseFactory numberOfGenerations &lt; 50				ifTrue: [ testCaseFactory numberOfGenerations: 50 ] ];		at: #largeStatementNumber			put: [ :testCaseFactory | 			testCaseFactory engine numberOfStatements &lt; 50				ifTrue: [ testCaseFactory numberOfStatements: 50 ] ];		at: #smallPopulationNumber			put: [ :testCaseFactory | 			testCaseFactory engine populationSize &gt; 5				ifTrue: [ testCaseFactory populationSize: 5 ] ];		at: #smallGenerationNumber			put: [ :testCaseFactory | 			testCaseFactory numberOfGenerations &gt; 3				ifTrue: [ testCaseFactory numberOfGenerations: 3 ] ];		at: #smallStatementNumber			put: [ :testCaseFactory | 			testCaseFactory engine numberOfStatements &gt; 3				ifTrue: [ testCaseFactory numberOfStatements: 3 ] ];		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SError class</class-id> <category>exceptioninstantiator</category><body package="SSG-Core" selector="signal:">signal: anObject	^ self new signal: anObject</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractClass</class-id> <category>initialization</category><body package="SSG-Scenario2" selector="initialize">initialize	id := 1</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractClass</class-id> <category>accessing</category><body package="SSG-Scenario2" selector="id:">id: anObject	id := anObject</body><body package="SSG-Scenario2" selector="id">id	^ id</body><body package="SSG-Scenario2" selector="identifier">identifier	^ self subclassResponsibility</body></methods><methods><class-id>SmallSuiteGenerator.SSubclassChild</class-id> <category>accessing</category><body package="SSG-Scenario2" selector="identifier">identifier	^ self className , '_' , self id asString</body></methods><methods><class-id>SmallSuiteGenerator.SStudent</class-id> <category>accessing</category><body package="SSG-Scenario2" selector="idStudent">idStudent	^ idStudent</body><body package="SSG-Scenario2" selector="scoreStudent">scoreStudent	^ scoreStudent</body></methods><methods><class-id>SmallSuiteGenerator.SStudent</class-id> <category>initialization</category><body package="SSG-Scenario2" selector="initialize">initialize	id := 1.	scoreStudent := 1.	idStudent := id</body></methods><methods><class-id>SmallSuiteGenerator.SStudent</class-id> <category>accessing</category><body package="SSG-Scenario2" selector="nickname">nickname	^ 'student_' , (nickname ifNil: [ '1' ])</body><body package="SSG-Scenario2" selector="scoreStudent:">scoreStudent: aNumber	scoreStudent := aNumber</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>LinkedList</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>firstLink lastLink </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>SConfigGenerationTestCase</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>blackList typeInfos defaultTypeInfo </class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SSG-Extension-UI</package></attributes></class><class><name>MinimumStandardRandom</name><environment>Core</environment><super>Core.Random</super><private>false</private><indexed-type>none</indexed-type><inst-vars>a m q r </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>