<?xml version="1.0"?><st-source><!-- Name: SmallSuiteGeneratorBundleName: SmallSuiteGeneratorBundleStructure: a Store.BundleForParcelParcel: #('SmallSuiteGenerator')ParcelName: SmallSuiteGeneratorDate: 1:00:50 pm December 28, 2020 --><time-stamp>From VisualWorksÂ®, 7.4 of December 5, 2005 on December 28, 2020 at 1:00:50 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>SmallSuiteGenerator</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>SmallSuiteGenerator</category><attributes><package>SmallSuiteGenerator</package></attributes></name-space><class><name>SClassInfoTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Info</category><attributes><package>SmallSuiteGenerator-Tests-Info</package></attributes></class><comment><class-id>SmallSuiteGenerator.SClassInfoTest</class-id><body>This class contains tests</body></comment><class><name>SGACrossoverOperationTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mutationOperation operation utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-GA</category><attributes><package>SmallSuiteGenerator-Tests-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGACrossoverOperationTest</class-id><body>This class contains tests</body></comment><class><name>SRandom</name><environment>SmallSuiteGenerator</environment><super>Core.MinimumStandardRandom</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SRandom</class-id><body>SRandom is a subclass of Random that is responsible for select an item of the collection or collect items randomly in a collection</body></comment><class><name>SEventTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario</category><attributes><package>SmallSuiteGenerator-Scenario</package></attributes></class><comment><class-id>SmallSuiteGenerator.SEventTest</class-id><body>This class contains tests</body></comment><class><name>SRandomTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SmallSuiteGenerator-Tests-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SRandomTest</class-id><body>This class contains tests</body></comment><class><name>SExpressionTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-AST</category><attributes><package>SmallSuiteGenerator-Tests-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SExpressionTest</class-id><body>This class contains tests</body></comment><class><name>SAssertionTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpressionTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-AST</category><attributes><package>SmallSuiteGenerator-Tests-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SAssertionTest</class-id><body>This class contains tests</body></comment><class><name>SSTestCaseTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SmallSuiteGenerator-Tests-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSTestCaseTest</class-id><body>This class contains tests</body></comment><class><name>SChangeTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSTestCaseTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SmallSuiteGenerator-Tests-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SChangeTest</class-id><body>This class contains tests</body></comment><class><name>SSTestShifterTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SmallSuiteGenerator-Tests-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSTestShifterTest</class-id><body>This class contains tests</body></comment><class><name>SmallTypeCollectorTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-SmallType</category><attributes><package>SmallSuiteGenerator-Tests-SmallType</package></attributes></class><comment><class-id>SmallSuiteGenerator.SmallTypeCollectorTest</class-id><body>This class contains tests</body></comment><class><name>SMultiFitnessFunctionTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>function utility fitnessFunctions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-GA</category><attributes><package>SmallSuiteGenerator-Tests-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SMultiFitnessFunctionTest</class-id><body>This class contains tests</body></comment><class><name>SObject</name><environment>SmallSuiteGenerator</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SObject</class-id><body>Superclass of almost all project classes, between them:	- AST classes used to create statements and assertions	- Core classes which configure the environment, manage assertions creation and so.	- GA classes that are responsible for testCase's fitness increasing. It means coverage augmentation.	- Info classes which transform the profiler result in nodes that are easier to use in the assertions and statements creation.	- Profiler classes which get classes' info types.</body></comment><class><name>SReport</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Utility</category><attributes><package>SmallSuiteGenerator-Utility</package></attributes></class><class><name>SGAAbstractViz</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Strategies</category><attributes><package>SmallSuiteGenerator-Strategies</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGAAbstractViz</class-id><body>I am an abstract class to generate the visualization of the genetic algorithms.I define the necessary methods that must be implemented to show the visualization from the inspector of the STestCaseFactory class</body></comment><class><name>SSAbstractSettingMethods</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testCase executeBlock factory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Strategies</category><attributes><package>SmallSuiteGenerator-Strategies</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSAbstractSettingMethods</class-id><body>I am an abstract class to define the configuration methods of the class where the tests are generated with GA.The configuration methods considered are: setUp and tearDown.</body></comment><class><name>SGAAbstractLog</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>generationNumber timeToProduceGeneration fittestTestCase lowestFit </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Strategies</category><attributes><package>SmallSuiteGenerator-Strategies</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGAAbstractLog</class-id><body>I'm an abstract class for Log generation</body></comment><class><name>SGANullLog</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGAAbstractLog</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Strategies</category><attributes><package>SmallSuiteGenerator-Strategies</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGANullLog</class-id><body>SGANullLog saves only the data that is important for the genetic evolution algorithm to work, that is: generationNumber, fittestTestCase, timeToProduceGeneration and lowestFit.</body></comment><class><name>SSVisitor</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSVisitor</class-id><body>SSVisitor is an abstract visitor for SSG nodes</body></comment><class><name>SSMetaInterpreter</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>context type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSMetaInterpreter</class-id><body>Visit all SSG node in a generated test evaluating their results, finally return a context with all the returnTypes of the variable assignments.</body></comment><class><name>SGANullViz</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGAAbstractViz</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Strategies</category><attributes><package>SmallSuiteGenerator-Strategies</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGANullViz</class-id><body>I am the standard visualization class that SmallSuiteGeneration has, I show two types of visualizations:- Fitness evolution: a line graph that shows the evolution of fitness through the generations; a line is displayed for the best, worst and average fitness.- TestEvoViz: a complex chart made up of 3 subgraphs: Generation evolution, TestCase evolution and Coverage evolution</body></comment><class><name>SGALog</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGAAbstractLog</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mutationResult averageFit population summaryTargetClass typeInfoGeneration </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Strategies</category><attributes><package>SmallSuiteGenerator-Strategies</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGALog</class-id><body>SGALog saves some important data about genetic algorithm evolution like: genetic algotithm's generation number, testCase with the highest fitness and time in which is produced the generation.In each iteration of the genetic algorithm a new instance of the class is created.Instance Variables	fittestTestCase:				&amp;lt;STestCase&amp;gt;	generationNumber:				&amp;lt;Smallnteger&amp;gt;	timeToProduceGeneration:		&amp;lt;SmallInteger&amp;gt;</body></comment><class><name>SGACrossover</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Strategies</category><attributes><package>SmallSuiteGenerator-Strategies</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGACrossover</class-id><body>SGACrossover is an abstract class that defines a technique that decides whether two GA individuals should crossover or not.</body></comment><class><name>SGACrossoverRate</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGACrossover</super><private>false</private><indexed-type>none</indexed-type><inst-vars>crossoverRate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Strategies</category><attributes><package>SmallSuiteGenerator-Strategies</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGACrossoverRate</class-id><body>SGACrossoverRate is a technique where two individuals crossover if and only if the next random number is less than crossoverRate (by default 0.8)</body></comment><class><name>SAbstractClass</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario2</category><attributes><package>SmallSuiteGenerator-Scenario2</package></attributes></class><comment><class-id>SmallSuiteGenerator.SAbstractClass</class-id><body>SAbstractClass is a proof abstract class created to test project functionality</body></comment><class><name>SSubclassChild</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SAbstractClass</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario2</category><attributes><package>SmallSuiteGenerator-Scenario2</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSubclassChild</class-id><body>SSubclassChild is a proof class created to test project functionality</body></comment><class><name>SGAViz</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGAAbstractViz</super><private>false</private><indexed-type>none</indexed-type><inst-vars>aTestCaseFactory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Strategies</category><attributes><package>SmallSuiteGenerator-Strategies</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGAViz</class-id><body>I am a null visualization class, that is, when using this class you will not get any visualization of the GA</body></comment><class><name>SGAObject</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGAObject</class-id><body>Abstract class of those nodes responsible for the genetic algorithm evolution:	- engine (like its name says, it is responsible to execute the algorithm in order to get the testCases with the highest fitness value)	- operations classes -&amp;gt; Responsible for executing crossover and mutation operation	- selection algorithm class -&amp;gt; It selects the fittest individuals testCases</body></comment><class><name>SGASelection</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fitness </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGASelection</class-id><body>Abstract class for strategy selection</body></comment><class><name>SGATournamentSelection</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGASelection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tournamentSize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGATournamentSelection</class-id><body>SGATournamentSelection is responsible for select the fittest testCase based in their fitness.</body></comment><class><name>SMultiTypeInfoTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Info</category><attributes><package>SmallSuiteGenerator-Tests-Info</package></attributes></class><comment><class-id>SmallSuiteGenerator.SMultiTypeInfoTest</class-id><body>This class contains tests</body></comment><class><name>SGAOperation</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGAOperation</class-id><body>SGAOperation is an abstract class for operation nodes which are necessary to create a new population  	- crossover operation 	- mutation operation </body></comment><class><name>SFoo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>score </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario</category><attributes><package>SmallSuiteGenerator-Scenario</package></attributes></class><comment><class-id>SmallSuiteGenerator.SFoo</class-id><body>SFoo is a proof class created to test project functionality</body></comment><class><name>STestCaseFactory</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>reportClass engine typeInfo targetClassName fitness numberOfIterations profiler lastMessage fitnessSeed initialSeed typeInfoSeed typeInfoOrigin firstExecution generatedClass </inst-vars><class-inst-vars>instance </class-inst-vars><imports></imports><category>SmallSuiteGenerator-Builder</category><attributes><package>SmallSuiteGenerator-Builder</package></attributes></class><comment><class-id>SmallSuiteGenerator.STestCaseFactory</class-id><body>STestCaseFactory is an abstract class that represents the project facade. It contains the main methods to run the project</body></comment><class><name>STestCaseFactoryPharo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.STestCaseFactory</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Builder</category><attributes><package>SmallSuiteGenerator-Builder</package></attributes></class><comment><class-id>SmallSuiteGenerator.STestCaseFactoryPharo</class-id><body>STestCaseFactoryPharo is a subclass that it is called when the project runs in Pharo</body></comment><class><name>STestCaseFactoryVisualWorks</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.STestCaseFactory</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Builder</category><attributes><package>SmallSuiteGenerator-Builder</package></attributes></class><comment><class-id>SmallSuiteGenerator.STestCaseFactoryVisualWorks</class-id><body>STestCaseFactoryVisualWorks is a subclass that it is called when the project runs in VisualWorks</body></comment><class><name>SInitialization</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>configurationDict </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Initialization</category><attributes><package>SmallSuiteGenerator-Initialization</package></attributes></class><comment><class-id>SmallSuiteGenerator.SInitialization</class-id><body>SInitialization is abstract class to create an instance taking some considerations</body></comment><class><name>SSelectionParameterization</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SInitialization</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Initialization</category><attributes><package>SmallSuiteGenerator-Initialization</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSelectionParameterization</class-id><body>SSelectionParametrization creates instances changing selectionStrategy of GA and use: 		- SGATournamentSelection 	- SGARankSelectionModified 	- SGARouletteSelection </body></comment><class><name>SmallTypeCollector</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>classDict </class-inst-vars><imports></imports><category>SmallSuiteGenerator-SmallType</category><attributes><package>SmallSuiteGenerator-SmallType</package></attributes></class><comment><class-id>SmallSuiteGenerator.SmallTypeCollector</class-id><body>SmallTypeCollector is a class to obtain information about the parameters of those methods that do not have enough information.This information is obtained in two ways: using NEVENA techniques and using the type information provided by RoelfTyper.EXAMPLE OF USE---------------SmallTypeCollector new collectTypeFrom: aClass</body></comment><class><name>SPlatform</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>level randomGenerator seed configurationClass logName </class-inst-vars><imports></imports><category>SmallSuiteGenerator-Builder</category><attributes><package>SmallSuiteGenerator-Builder</package></attributes></class><comment><class-id>SmallSuiteGenerator.SPlatform</class-id><body>SConfiguration is responsible for defining or instantiating some classes or values used in the project.Furthermore, some configuration parameters are defined depending the environment, it means Pharo or VisualWorks</body></comment><class><name>SPlatformPharo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SPlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Builder</category><attributes><package>SmallSuiteGenerator-Builder</package></attributes></class><comment><class-id>SmallSuiteGenerator.SPlatformPharo</class-id><body>SConfigurationPharo is a subclass called when the project environment is running in Pharo. Furthermore, it defines parameters used in Pharo.</body></comment><class><name>SGARandomSelection</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGASelection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGARandomSelection</class-id><body>SGARankSelection is responsible for select testCases randomly regardless of fitness</body></comment><class><name>SUndefinedObject</name><environment>SmallSuiteGenerator</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Info</category><attributes><package>SmallSuiteGenerator-Info</package></attributes></class><comment><class-id>SmallSuiteGenerator.SUndefinedObject</class-id><body>I'm a generic class for returnType of methods unexecuted</body></comment><class><name>SSeedingParameterization</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SInitialization</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numberToChangeSeed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Initialization</category><attributes><package>SmallSuiteGenerator-Initialization</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSeedingParameterization</class-id><body>SSeedingParametrization creates instances changing the seed whether adding or reducing a value to the original seed</body></comment><class><name>SGACrossoverOperation</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGAOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGACrossoverOperation</class-id><body>SGACrossoverOperation is the operation node that is responsible to create offsprings combining the statements of their parents.To create a new offspring it gets a random percent of statements of a testCase and the rest of another testCase. Furthermore, it checks the statements references (dependencies) and repairs them if it is necessary.For example if the parents are:	Parent1	_var0 := 1.	_var1 := 'hello'.		Parent2	_var0 := SFoo new.	_var1 := _var0 returnString.	The new offspring with a 50% of statements of each parent:	_var0 := 1.	_var1 := _var0 returnString.	Like it has an inconsistency because '_var0' in the first parent is of type SFoo, it is repaired. Then the new offspring resultant is:	_var0 := 1.	_var2 := SFoo new.	_var1 := _var2 returnString. </body></comment><class><name>SExtensionsTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SmallSuiteGenerator-Tests-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SExtensionsTest</class-id><body>This class contains tests</body></comment><class><name>SConfigurationTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SmallSuiteGenerator-Tests-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SConfigurationTest</class-id><body>This class contains tests</body></comment><class><name>SSVariableNameSwapper</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nameMap </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSVariableNameSwapper</class-id><body>Visit all SSG node in a generated test to fix order of assignments, for instance, given a testCase like this:'	_var99 := 1.	_var23 := 1.	_var2 := Point x: _var99 y: _var23.	_var33 := Point x: _var23 y: _var99.	_var4 := _var2 x.	_var5 := _var2 equals: _var33.'is transformed in this:'	_var0 := 1.	_var1 := 1.	_var2 := Point x: _var0 y: _var1 .	_var3 := Point x: _var1 y: _var0 .	_var4 := _var2 x.	_var5 := _var2 equals: _var3 .'</body></comment><class><name>SExpression</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>returnType id parent identifier </inst-vars><class-inst-vars>nextId </class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SExpression</class-id><body>Superclass of all nodes for 	- expressions (they represent nodes which are used to create messages),	- messages (concerned with: assertion messages, factory messages, access messages and mesasges that modify the behavior of a class)	Instance Variables	id:		               &amp;lt;Integer&amp;gt; 	randomGenerator:		&amp;lt;SRandom&amp;gt;	returnType:		      &amp;lt;Symbol&amp;gt;</body></comment><class><name>SAbstractMessage</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>receiver selector args </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SAbstractMessage</class-id><body>Abstract class of nodes for	- messages (access messages and messages that update the state of a class)	- factory methods (to represent the class creation messages),	- assertion messages (to represent assertion messages that match with an according requirement)Instance Variables	args:		    &amp;lt;Collection&amp;gt;	receiver:		 &amp;lt;Symbol&amp;gt;	selector:		 &amp;lt;Symbol&amp;gt;</body></comment><class><name>SAssertionMessage</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SAbstractMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SAssertionMessage</class-id><body>Superclass of assertion messages nodes for 	- comparison assertion (it compares an object with other)	- inspector assertion (it compares the result of a method executed with a value)	- primitive assertion (it compares the primitive values)	- string assertion (it compares the way to represent an object as string with a string)</body></comment><class><name>SFactoryMessage</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SAbstractMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SFactoryMessage</class-id><body>SFactoryMessage is a node that represents the class' creation with methods of meta class.For example: 	1.			SStack newStack.			#SStack -&amp;gt; It's the receiver 		#newStack -&amp;gt; It's a method of meta class.			2. 		SFoo score: _var1.				#SFoo -&amp;gt; Receiver		#score: -&amp;gt; Message of receiver		_var1 -&amp;gt; Argument 			3. 		SFoo new.				#SFoo new -&amp;gt; Receiver		#new -&amp;gt; Default selector</body></comment><class><name>SMessage</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SAbstractMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SMessage</class-id><body>SMessage is a node which represents method calls that not return an instance variable of a class. They are a little more complex. It can receive arguments also.For example: 	1.			_var1 returnCollection.			_var1 -&amp;gt; Receiver which points to SFoo's factoryMessage.		#returnCollection -&amp;gt; selector of the method.			2. 		_var1 return: _var2.				_var1 -&amp;gt; Receiver		#return: -&amp;gt; selector		_var2 -&amp;gt; Argument of type ByteString</body></comment><class><name>SRemoveTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSTestCaseTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SmallSuiteGenerator-Tests-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SRemoveTest</class-id><body>This class contains tests</body></comment><class><name>SSNullMethods</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSAbstractSettingMethods</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Strategies</category><attributes><package>SmallSuiteGenerator-Strategies</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSNullMethods</class-id><body>I am a class that defines the setUp and tearDown configuration methods as null.</body></comment><class><name>SFitnessFunction</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>profiler targetClass aClass </inst-vars><class-inst-vars>operator </class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SFitnessFunction</class-id><body>SFitnessFunction is an abstract class that represents a fitness abstract function used in genetic algorithm evolution to determine how fit a testCase is.</body></comment><class><name>SError</name><environment>SmallSuiteGenerator</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SError</class-id><body>SError is a subclass of Error. It is used to represent error's conditions in test generation process.Additionally, it saves in a log all the errors gotten.</body></comment><class><name>STypeInfo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>types classes noneAbstractClasses scalars blackList cacheMessagesFrom </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Info</category><attributes><package>SmallSuiteGenerator-Info</package></attributes></class><comment><class-id>SmallSuiteGenerator.STypeInfo</class-id><body>STypeInfo is responsible for collecting the STypeCollector's main data and building a new instance from the collected data.It is composed of STypeClassInfo collection and each item likewise is formed by STypeMethodInfo collection.Instance Variables	types:						&amp;lt;Dictionary&amp;gt;	All the classes (represented as an instance of STypeClassInfo) for which information is collected	classes:					&amp;lt;Dictionary&amp;gt;	noneAbstractClasses:	&amp;lt;Collection&amp;gt;	scalars: 					&amp;lt;Dictionary&amp;gt;	collection of classes that cannot be instrumented</body></comment><class><name>SGATruncatedSelection</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGASelection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>discarding </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGATruncatedSelection</class-id><body>SGATrouncateSelection is responsible for select testCases, this type of selection descart the worst N testCases (less fitness) and then select randomly testCases</body></comment><class><name>SNumericParameterization</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SInitialization</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Initialization</category><attributes><package>SmallSuiteGenerator-Initialization</package></attributes></class><comment><class-id>SmallSuiteGenerator.SNumericParameterization</class-id><body>SNumericParametrization creates instances changing values like: 		- numberOfStatements 	- numberOfPopulation	- numberOfGenerations</body></comment><class><name>STestCaseFactoryExample</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Examples</category><attributes><package>SmallSuiteGenerator-Examples</package></attributes></class><comment><class-id>SmallSuiteGenerator.STestCaseFactoryExample</class-id><body>STestCaseFactoryExample contains some examples to run and validate the project functionality</body></comment><class><name>SStack</name><environment>SmallSuiteGenerator</environment><super>Core.LinkedList</super><private>false</private><indexed-type>none</indexed-type><inst-vars>firstLinkStack lastLinkStack </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario</category><attributes><package>SmallSuiteGenerator-Scenario</package></attributes></class><comment><class-id>SmallSuiteGenerator.SStack</class-id><body>SStack is a proof class created to test project functionality</body></comment><class><name>SSExecutionContext</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>values </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSExecutionContext</class-id><body>SSExecutionContext takes a snapshot of the SSTestRunner's instance context. It saves the tempNames of variables and values as dictionaryInstance Variables	values:		&amp;lt;Dictionary&amp;gt;</body></comment><class><name>SInspectorAssertion</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SAssertionMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SInspectorAssertion</class-id><body>A SInspectorAssertion selects methods categorized as returnField and creates an instance for each one if the execution result is primitive.For example: 		List with classes' items categorized as returnField: 		Array with: '_var2' -&amp;gt; (2@10).	It returns items like: 		self assert: _var2 x equals: 2.		self assert: _var2 y equals: 10.</body></comment><class><name>SEvent</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>discount price </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario</category><attributes><package>SmallSuiteGenerator-Scenario</package></attributes></class><comment><class-id>SmallSuiteGenerator.SEvent</class-id><body>SEVent is a proof class created to test project functionalityInstance Variables	discount:		&amp;lt;Object&amp;gt;	price:			&amp;lt;Object&amp;gt;</body></comment><class><name>SParty</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SEvent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>date </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario</category><attributes><package>SmallSuiteGenerator-Scenario</package></attributes></class><comment><class-id>SmallSuiteGenerator.SParty</class-id><body>SParty is a proof class created to test project functionalityInstance Variables	date:		&amp;lt;Object&amp;gt;</body></comment><class><name>SGAMutationOperation</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGAOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mutationRate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGAMutationOperation</class-id><body>SGAMutationOperation is an operator which modifies some statements of the testCase. However this operation depends of a random probability to be applied.This operation can apply three different types of mutation: 		- remove -&amp;gt; It means that a statement choosen randomly can be removed of the testCase.	- change -&amp;gt; According to the statement choosen, it is modified in value or selector.	- insert -&amp;gt; A statement is added following one of these options: asRandomMessage, asMethodMessage or asParameter. The reason for these options is because statements are usually of different expressions.</body></comment><class><name>SCascade</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messages </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SCascade</class-id><body>SCascade is a node equivalent to RBCascadeNode</body></comment><class><name>SGACrossoverOnlyDifferentCoverages</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGACrossover</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Strategies</category><attributes><package>SmallSuiteGenerator-Strategies</package></attributes></class><class><name>SReportSGALog</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SReport</super><private>false</private><indexed-type>none</indexed-type><inst-vars>engine </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Utility</category><attributes><package>SmallSuiteGenerator-Utility</package></attributes></class><class><name>SFieldAccessMessage</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SAbstractMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SFieldAccessMessage</class-id><body>SFieldAccessMessage is a node which represents method calls that return an instance variable of a class.For example: 	1.			_var1 x.			_var1 -&amp;gt; Receiver which points to Point's factoryMessage.		#x -&amp;gt; selector of the method</body></comment><class><name>SGAEngineExample</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Examples</category><attributes><package>SmallSuiteGenerator-Examples</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGAEngineExample</class-id><body>SGAEngineExample contains some examples to validate correct project functionality </body></comment><class><name>SGARankSelection</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGASelection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGARankSelection</class-id><body>SGARankSelection is responsible for select testCases based of their rank</body></comment><class><name>SGAEngine</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>populationSize mutationOperator crossoverOperator numberOfStatements population logs typeInfo fitness selectionStrategy targetClassName numberOfGenerations lastMessage packageRegex initialPopulation typeInfoProfiler targetPackageRegex elitismRate crossoverStrategy stopIterations totalExecutionGA selectionStrategyTestCase </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGAEngine</class-id><body>SGAEngine is responsible for executing the genetic algorithm, it means that it follows the phases to get a testCase population with the highest fitness score.The phases followed are:	1. Create an initial population 	2. Use the fitness function established to calculate the fitness score of each testCase in the population	3. Determine the selection strategy to select the fittest testCases and let them pass their statements to the next generation	4. Apply the crossover operation to get offsprings (new testCases) by exchanging the statements of parents (testCases). 	5. Apply mutation operation with a low random probability to modify some statements. Internal Representation and Key Implementation Points.Instance Variables	crossoverOperator:			&amp;lt;SGACrossoverOperator&amp;gt;	fitness:						&amp;lt;SFitnessFunction&amp;gt;	logs:							&amp;lt;OrderedCollection&amp;gt;	mutationOperator:			&amp;lt;SGAMutationOperator&amp;gt;	numberOfIterations:		&amp;lt;SmallInteger&amp;gt;	numberOfStatements:		&amp;lt;SmallInteger&amp;gt;	population:					&amp;lt;OrderedCollection&amp;gt;	populationSize:				&amp;lt;SmallInteger&amp;gt;	selectionStrategy:			&amp;lt;SGATournamentSelection&amp;gt;	targetClassName:			&amp;lt;ByteString&amp;gt;	typeInfo:						&amp;lt;STypeInfo&amp;gt;</body></comment><class><name>SPlatformVisualWorks</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SPlatform</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Builder</category><attributes><package>SmallSuiteGenerator-Builder</package></attributes></class><comment><class-id>SmallSuiteGenerator.SPlatformVisualWorks</class-id><body>SConfigurationVisualWorks is a subclass called when the project environment is running in VisualWorks.</body></comment><class><name>SStringAssertion</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SAssertionMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SStringAssertion</class-id><body>A SStringAssertion select execution context's values that their class implement some method of printing like: 'printOn:', 'asString'. From the resulting collection each item is used to create an instance of the class using #printString as selector.For example: 		List with classes' items which have implemented printing methods: 		Array with: '_var1' -&amp;gt; 'hello'		with: '_var2' -&amp;gt; 2.3		with: '_var3' -&amp;gt; (3@5).	It returns items like: 		self assert: _var1 printString equals: ''hello''.		self assert: _var2 printString equals: '2.3'.		self assert: _var3 printString equals: (2@3).</body></comment><class><name>SReportTypeInfo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SReport</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Utility</category><attributes><package>SmallSuiteGenerator-Utility</package></attributes></class><comment><class-id>SmallSuiteGenerator.SReportTypeInfo</class-id><body>SReportTypeInfo exports data about coverage and patterns frequency of projects in Smalltalk. It exports two kinds of reports:	1. Project's coverage covered in the genetic algorithm. It presents 	- Project -&amp;gt; Project name in Smalltalk.	- Classes -&amp;gt; Number of classes executed in the project.	- Methods -&amp;gt; Number of methods executed in the project.	- Test -&amp;gt; Number of tests that are evaluated in the project.	- Coverage -&amp;gt; Project coverage percent covered.	2. Patterns frequency of type method info. Each type method info is categorized according its receiver, arguments and return type. The report contains:	- Project name	- Number of all methods	- Number of type method infos categorized in each pattern.</body></comment><class><name>SMethodInfoTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Info</category><attributes><package>SmallSuiteGenerator-Tests-Info</package></attributes></class><comment><class-id>SmallSuiteGenerator.SMethodInfoTest</class-id><body>This class contains tests</body></comment><class><name>SMultiFitnessFunction</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SFitnessFunction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>functionList </inst-vars><class-inst-vars>multiFitnessFunction </class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SMultiFitnessFunction</class-id><body>SMultiFitnessFunciton is the fitness function that contains simple fitness function's collection.</body></comment><class><name>SLiteral</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SLiteral</class-id><body>SLiteral is a node which is compossed by a value that is included in typeInfo scalars.For example: 	1.			10				10 -&amp;gt; SmallInteger.			2. 		'hello'				'hello' -&amp;gt; ByteString.</body></comment><class><name>SGAEngineTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>engine profiler utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-GA</category><attributes><package>SmallSuiteGenerator-Tests-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGAEngineTest</class-id><body>This class contains tests</body></comment><class><name>STypeInfoTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Info</category><attributes><package>SmallSuiteGenerator-Tests-Info</package></attributes></class><comment><class-id>SmallSuiteGenerator.STypeInfoTest</class-id><body>This class contains tests</body></comment><class><name>SSVisitorTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpressionTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-AST</category><attributes><package>SmallSuiteGenerator-Tests-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSVisitorTest</class-id><body>This class contains tests</body></comment><class><name>SAssignment</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>variable value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SAssignment</class-id><body>SAssignment is a node which is compossed by a variable and an expression.For example: 	1.			_var0 := 1.			_var0 -&amp;gt; Variable.		1 -&amp;gt; value (in this case a literal).			2. 		_var1 := SFoo new.				_var1 -&amp;gt; Varaible		SFoo new -&amp;gt; an instance of factoryMessage</body></comment><class><name>SSStandardPrinter</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Strategies</category><attributes><package>SmallSuiteGenerator-Strategies</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSStandardPrinter</class-id><body>I am a class that prints the testCases in a standard way, that is, creating a variable for each statement.For example, a result obtained by this class would be like the following:	| _var0 _var1 _var2 _var3 |	_var0 := 0.	_var1 := SFoo score: _var0 .	_var2 := _var1 returnFloat.	_var3 := _var1 score.	self assert: _var0 equals: _var3 .</body></comment><class><name>SSDictionaryBasedPrinter</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSStandardPrinter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionaryName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Strategies</category><attributes><package>SmallSuiteGenerator-Strategies</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSDictionaryBasedPrinter</class-id><body>I am a class that prints the testCases in a dictionary format, this type of printing is useful when you have testCases that have a large number of variables that is not supported by the Pharo compiler.For example, a result obtained by this class would be like the following:	| var |	var := Dictionary new.	var at: 1 put: (0 ).	var at: 2 put: (SFoo score: ( var at: 1 )  ).	var at: 3 put: (( var at: 2 ) returnFloat ).	self assert: ( var at: 2 ) score equals: 0 .</body></comment><class><name>SSTestShifter</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>statements assertions typeInfo nextId maxNumberOfStatements lastMessage hasErrors targetClassName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSTestShifter</class-id><body>SSTestShifter is responsible for creating, mutating and validating statements. It is responsible to for creating different kind of statements: primitive, factory messages, messages, accessor messages.Genetic algorithm's evolution depends this class' increasing fitness. For this reason it is one of the main classes and essential for the project.Instance Variables	assertions:						&amp;lt;OrderedCollection&amp;gt;	fitness:							&amp;lt;Dictionary&amp;gt;	fitnessByClass:					&amp;lt;Dictionary&amp;gt;	maxNumberOfStatements:		&amp;lt;SmallInteger&amp;gt;	nextId:							&amp;lt;SmallInteger&amp;gt;	randomGenerator:				&amp;lt;SRandomGenerator&amp;gt;	statements:						&amp;lt;OrderedCollection&amp;gt;	targetClassesNames:			&amp;lt;Set&amp;gt;	typeInfo:							&amp;lt;STypeInfo&amp;gt;	validatedTargetClassName:	&amp;lt;Boolean&amp;gt;</body></comment><class><name>SSTestCase</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSTestShifter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fitness idPopulation summaryExecutionMethods generationNumber summaryTargetClass fitnessByClass selectionStrategy parents children properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSTestCase</class-id><body>SSTestCase is a subclass that defines or initializes some instance variables which are util in the genetic algorithm evolution</body></comment><class><name>SGARouletteSelection</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGASelection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGARouletteSelection</class-id><body>SGARoulleteSelection is responsible for select testCases, gives more probaility of be selected when a testCase has more fitness</body></comment><class><name>SPrimitiveAssertion</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SAssertionMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SPrimitiveAssertion</class-id><body>A SPrimitiveAssertion collects instances of the class if the execution context's values are primitives.For example: 		List with items classified as primitive: 		Array with: '_var1' -&amp;gt; 'hello'		with: '_var2' -&amp;gt; 2		with: '_var3' -&amp;gt; (3@5).	It returns items like: 		self assert: _var1 equals: 'hello'.		self assert: _var2 equals: 2.</body></comment><class><name>SUtilityTypeInfo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Utility</category><attributes><package>SmallSuiteGenerator-Tests-Utility</package></attributes></class><comment><class-id>SmallSuiteGenerator.SUtilityTypeInfo</class-id><body>SUtilityTypeInfo is a class which declares typeInfos for tests. </body></comment><class><name>SReportSTestCaseFactory</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SReport</super><private>false</private><indexed-type>none</indexed-type><inst-vars>factoryTestCase </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Utility</category><attributes><package>SmallSuiteGenerator-Utility</package></attributes></class><class><name>SSimpleFitnessFunction</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SFitnessFunction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>weight superclasses n </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSimpleFitnessFunction</class-id><body>SSimpleFitnessFunction is an abstract class of simple fitness function like: 		- SMethodCoverage -&amp;gt; It calculates the number of class methods executed	- SStatementCoverage -&amp;gt; It calculates the number of statements executed 	Instance Variables	profiler:		&amp;lt;SSTypeCollector&amp;gt;	</body></comment><class><name>SMethodCoverage</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSimpleFitnessFunction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SMethodCoverage</class-id><body>SMethodCoverage is responsible for calculating the method coverage in each testCase of a testSuite. It means that for each class defined in the testCase it calculates how many methods were executed.</body></comment><class><name>SStatementCoverage</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSimpleFitnessFunction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SStatementCoverage</class-id><body>SStatementCoverage is responsible for calculating statement coverage of each testCase in the testSuite. It calculates how many statements were executed in each class defined of the testSuite. The number of statements refers to number of lines of code executed </body></comment><class><name>SVariable</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>varName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SVariable</class-id><body>SVariable is a node which is represented by a name and id.For example: 	1.			_var2				_var -&amp;gt; Name of variable.		2 -&amp;gt; Id of variable			2. 		_int3				'_int' -&amp;gt; Name		3 -&amp;gt; Id</body></comment><class><name>SSelf</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SVariable</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSelf</class-id><body>SSelf is a node which is part of the assertion message.</body></comment><class><name>SSPerson</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name id nickname </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario</category><attributes><package>SmallSuiteGenerator-Scenario</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSPerson</class-id><body>SSPerson is a proof class created to test project functionality</body></comment><class><name>SPrototypeClass</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>a b c </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario2</category><attributes><package>SmallSuiteGenerator-Scenario2</package></attributes></class><comment><class-id>SmallSuiteGenerator.SPrototypeClass</class-id><body>SPrototypeClass is a proof to tests generation of tests with different scalars.- To test this you can run a script like the following:|typeInfo aBlock generated |aBlock := [SPrototypeClass new 	methWithArguments: #(3 4 5 2 7 0 8 15 20);	methWithDoubleCondition: 10.7;	methWithDoubleCondition: 5;	returnStringWithSeparetors: #($, $:);	c: 'fdsg,dgf,fgd:4t';	returnStringWithSeparetors: ',';	yourself. ].typeInfo := STypeInfo asTypeInfo: (        SSTypeCollector profile: aBlock onPackagesMatching: 'SmallSuiteGenerator-Scenario2').generated := SPrototypeClass createTestCaseConfigWithName: 'SPrototypeClassTest'.generated addTypeInfo: typeInfo withKey: 'art';	typeInfo: 'art';	fitness: #statement;	numberOfGenerations: 30;	numberOfStatements: 50;	populationSize: 30;	stopIterations: 7;	targetPackageRegex: 'SmallSuiteGenerator-Scenario2';	outputPackageName: 'Generated';	lastMessage: 'Transcript show: ''prot'''. (STestCaseFactoryPharo from: SPrototypeClassTest )	generateViews;    createTestCases;    yourself.</body></comment><class><name>SSVariablesWithIdCollector</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>variablesWithId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSVariablesWithIdCollector</class-id><body>SSVariablesWithIdCollector collect all references of variables in a sentence, with the objective of not having reference errors in the construction of the testCase.</body></comment><class><name>SConference</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SEvent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>date speaker offerPrice </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario</category><attributes><package>SmallSuiteGenerator-Scenario</package></attributes></class><comment><class-id>SmallSuiteGenerator.SConference</class-id><body>SConference is a proof class created to test project functionalityInstance Variables	date:				&amp;lt;Object&amp;gt;	offerPrice:		&amp;lt;Object&amp;gt;	speaker:			&amp;lt;Object&amp;gt;</body></comment><class><name>SSequense</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>temporaries messages </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSequense</class-id><body>SSequence is a node equivalent to RBSequenceNode</body></comment><class><name>SGAMutationOperationTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>operation utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-GA</category><attributes><package>SmallSuiteGenerator-Tests-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGAMutationOperationTest</class-id><body>This class contains tests</body></comment><class><name>SSGParser</name><environment>SmallSuiteGenerator</environment><super>Refactory.Browser.RBProgramNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Utility</category><attributes><package>SmallSuiteGenerator-Utility</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSGParser</class-id><body>SSGParser is an abstract visitor to convert RBNodes to SNodes</body></comment><class><name>SCoverageTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>utility fitness profiler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-GA</category><attributes><package>SmallSuiteGenerator-Tests-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SCoverageTest</class-id><body>This class contains tests</body></comment><class><name>SStatementCoverageTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SCoverageTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-GA</category><attributes><package>SmallSuiteGenerator-Tests-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SStatementCoverageTest</class-id><body>This class contains tests</body></comment><class><name>SMultiCoverageTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SCoverageTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-GA</category><attributes><package>SmallSuiteGenerator-Tests-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SMultiCoverageTest</class-id><body>This class contains tests</body></comment><class><name>SMethodCoverageTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SCoverageTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-GA</category><attributes><package>SmallSuiteGenerator-Tests-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SMethodCoverageTest</class-id><body>This class contains tests</body></comment><class><name>SSTeacher</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSPerson</super><private>false</private><indexed-type>none</indexed-type><inst-vars>yearsWorkExperience idTeacher </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario</category><attributes><package>SmallSuiteGenerator-Scenario</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSTeacher</class-id><body>SSTeacher is a proof class created to test project functionality</body></comment><class><name>SStudent</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSPerson</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scoreStudent idStudent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario2</category><attributes><package>SmallSuiteGenerator-Scenario2</package></attributes></class><comment><class-id>SmallSuiteGenerator.SStudent</class-id><body>SStudent is a proof class created to test project functionality</body></comment><class><name>SConfigGenerationTestCase</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>executionBlock executedCase </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SConfigGenerationTestCase</class-id><body>This class contains tests</body></comment><class><name>SComparisonAssertion</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SAssertionMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SComparisonAssertion</class-id><body>A SComparisonAssertion selects the execution context values that are comparable.Collection's items of the same class are compared and for each one is created a new instance of this class with the selector depending the result of the comparison.For example: 	List with items that are comparable: 		Array with: '_var1'-&amp;gt; 9		with: '_var2' -&amp;gt; 5		with: '_var3' -&amp;gt; 9		with: '_var4' -&amp;gt; 'hello'.	It returns items like: 		self deny: _var1 equals: _var2.		self assert: _var1 equals: _var3.		</body></comment><class><name>SInsertTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSTestCaseTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SmallSuiteGenerator-Tests-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SInsertTest</class-id><body>This class contains tests</body></comment><class><name>STypeObjectInfo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Info</category><attributes><package>SmallSuiteGenerator-Info</package></attributes></class><comment><class-id>SmallSuiteGenerator.STypeObjectInfo</class-id><body>STypeObjectInfo is an abstract class of info nodes: 			- type class -&amp;gt; Which collect type info data of a class in the profiler	- type method -&amp;gt; Collect types of the receiver, arguments and returnType of a method in the profiler</body></comment><class><name>STypeMethodInfo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.STypeObjectInfo</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector returnType argTypes isQuick isDeprecated receiver scalars executions hasProfiler abstract </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Info</category><attributes><package>SmallSuiteGenerator-Info</package></attributes></class><comment><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id><body>STypeMethodInfo is an info type node for a method.Instance Variables	argTypes:			&amp;lt;Array&amp;gt;	isDeprecated:	&amp;lt;Boolean&amp;gt;	isQuick:			&amp;lt;Boolean&amp;gt;	receiver:			&amp;lt;SMultiTypeInfo&amp;gt;	returnType:		&amp;lt;SMultiTypeInfo&amp;gt;	selector:			&amp;lt;Symbol&amp;gt;</body></comment><class><name>SMultiTypeInfo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.STypeObjectInfo</super><private>false</private><indexed-type>none</indexed-type><inst-vars>types cleanTypes mustBeFixed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Info</category><attributes><package>SmallSuiteGenerator-Info</package></attributes></class><comment><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id><body>SMultiTypeInfo is a set of types.Instance Variables	types:		&amp;lt;Set&amp;gt;</body></comment><class><name>STypeClassInfo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.STypeObjectInfo</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeName methodTypes classMethodTypes scalars abstract </inst-vars><class-inst-vars>classMethodTypes </class-inst-vars><imports></imports><category>SmallSuiteGenerator-Info</category><attributes><package>SmallSuiteGenerator-Info</package></attributes></class><comment><class-id>SmallSuiteGenerator.STypeClassInfo</class-id><body>STypeClassInfo is an info type node for a class.Instance Variables	classMethodTypes:	&amp;lt;Dictionary&amp;gt;	methodTypes:			&amp;lt;Dictionary&amp;gt;	typeName:				&amp;lt;Symbol&amp;gt;</body></comment><shared-variable><name>DefaultTypeInfo</name><environment>SmallSuiteGenerator.SConfigGenerationTestCase</environment><private>false</private><constant>false</constant><category>class variables</category><initializer>nil</initializer><attributes><package>SmallSuiteGenerator-Core</package></attributes></shared-variable><shared-variable><name>TypeInfos</name><environment>SmallSuiteGenerator.SConfigGenerationTestCase</environment><private>false</private><constant>false</constant><category>class variables</category><initializer>nil</initializer><attributes><package>SmallSuiteGenerator-Core</package></attributes></shared-variable><methods><class-id>SmallSuiteGenerator.SClassInfoTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-Info" selector="testEquals">testEquals	| sfooSymbol studentSymbol stringSymbol intSymbol |	sfooSymbol := #SFoo fullClassNameSymbol.	studentSymbol := #SStudent fullClassNameSymbol.	stringSymbol := #ByteString fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	self		assert: (STypeClassInfo type: sfooSymbol -&gt; #(#() #()))		equals: (STypeClassInfo type: sfooSymbol -&gt; #(#() #())).	self		assert:			(STypeClassInfo				type:					studentSymbol						-&gt;							(Array								with:									(Array										with:											#name												-&gt;													(Array														with: studentSymbol														with: stringSymbol														with: #()														with: false))								with: #()))		equals:			(STypeClassInfo				type:					studentSymbol						-&gt;							(Array								with:									(Array										with:											#name												-&gt;													(Array														with: studentSymbol														with: stringSymbol														with: #()														with: false))								with: #())).	self		assert:			(STypeClassInfo				type:					sfooSymbol						-&gt;							(Array								with:									(Array										with:											#score												-&gt;													(Array														with: sfooSymbol														with: intSymbol														with: #()														with: false))								with:									(Array										with:											#score:												-&gt;													(Array														with: sfooSymbol														with: sfooSymbol														with: (Array with: intSymbol)														with: false))))		equals:			(STypeClassInfo				type:					sfooSymbol						-&gt;							(Array								with:									(Array										with:											#score												-&gt;													(Array														with: sfooSymbol														with: intSymbol														with: #()														with: false))								with:									(Array										with:											#score:												-&gt;													(Array														with: sfooSymbol														with: sfooSymbol														with: (Array with: intSymbol)														with: false))))</body><body package="SmallSuiteGenerator-Tests-Info" selector="testType">testType	| classInfo methodInfo sfooSymbol floatSymbol stringSymbol collSymbol intSymbol |	sfooSymbol := #SFoo fullClassNameSymbol.	floatSymbol := #SmallFloat64 fullClassNameSymbol.	stringSymbol := #ByteSymbol fullClassNameSymbol.	collSymbol := #OrderedCollection fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	classInfo := STypeClassInfo		type:			sfooSymbol				-&gt;					(Array						with:							(Array								with:									#returnFloat										-&gt;											(Array												with: sfooSymbol												with: floatSymbol												with: #()												with: false)								with:									#returnString										-&gt;											(Array												with: sfooSymbol												with: stringSymbol												with: #()												with: false)								with:									#return:										-&gt;											(Array												with: sfooSymbol												with: collSymbol												with: (Array with: collSymbol)												with: false)								with:									#score:										-&gt;											(Array												with: sfooSymbol												with: sfooSymbol												with: (Array with: intSymbol)												with: false)								with:									#score										-&gt;											(Array												with: sfooSymbol												with: intSymbol												with: #()												with: true))						with:							(Array								with:									#score:										-&gt;											(Array												with: sfooSymbol												with: sfooSymbol												with: (Array with: intSymbol)												with: false))).	classInfo		typeMethod:			#returnNum				-&gt;					(Array						with: sfooSymbol						with: intSymbol						with: #()						with: false).	self assert: classInfo methodTypes size equals: 6.	self assert: classInfo classMethodTypes size equals: 1.	methodInfo := classInfo methodTypes at: #return:.	self assert: methodInfo receiver type equals: sfooSymbol.	self assert: methodInfo returnType type equals: collSymbol.	self		assertCollection: methodInfo allArgTypes		hasSameElements: (Array with: collSymbol).	self		assert: (classInfo methodTypes at: #returnFloat) returnType type		equals: floatSymbol.	self		assert: (classInfo methodTypes at: #returnString) returnType type		equals: stringSymbol.	self		assert: (classInfo methodTypes at: #score) returnType type		equals: intSymbol.	methodInfo := classInfo methodTypes at: #score:.	self assert: methodInfo receiver type equals: sfooSymbol.	self assert: methodInfo returnType type equals: sfooSymbol.	self		assertCollection: methodInfo allArgTypes		hasSameElements: (Array with: intSymbol).	self		assert: (classInfo classMethodTypes at: #score:) returnType type		equals: sfooSymbol.	self		assert: (classInfo methodTypes at: #returnNum) returnType type		equals: intSymbol</body></methods><methods><class-id>SmallSuiteGenerator.SGACrossoverOperationTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-GA" selector="crossOver:">crossOver: listTestCase	| offSprings offSpring1 offSpring2 |	self assert: listTestCase size &gt;= 2.	offSprings := operation		crossover: listTestCase first		with: listTestCase second.	offSpring1 := offSprings first.	offSpring2 := offSprings second.	self assert: offSpring1 validReferences.	self assert: offSpring2 validReferences</body><body package="SmallSuiteGenerator-Tests-GA" selector="crossOverWithMutation:">crossOverWithMutation: listTestCase	| offSprings offSpring1 offSpring2 |	self assert: listTestCase size &gt;= 2.	self assert: listTestCase first validReferences.	self assert: listTestCase second validReferences.	offSpring1 := mutationOperation mutate: listTestCase first.	offSpring2 := mutationOperation mutate: listTestCase second.	offSprings := operation crossover: offSpring1 with: offSpring2.	offSpring1 := offSprings first.	offSpring2 := offSprings second.	offSpring1 := mutationOperation mutate: offSpring1.	offSpring2 := mutationOperation mutate: offSpring2.	offSprings := operation crossover: offSpring1 with: offSpring2.	self assert: offSpring1 validReferences.	self assert: offSpring2 validReferences</body><body package="SmallSuiteGenerator-Tests-GA" selector="testCrossOverToSStack">testCrossOverToSStack	self crossOver: utility testSuiteSStack.	self crossOverWithMutation: utility testSuiteSStack</body><body package="SmallSuiteGenerator-Tests-GA" selector="testCrossOverToSStudent">testCrossOverToSStudent	self crossOver: utility testSuiteSStudent</body><body package="SmallSuiteGenerator-Tests-GA" selector="testCrossOverToSStudent2">testCrossOverToSStudent2	self crossOver: utility testSuiteSStudentManual.	self crossOverWithMutation: utility testSuiteSStudentManual</body></methods><methods><class-id>SmallSuiteGenerator.SGACrossoverOperationTest</class-id> <category>running</category><body package="SmallSuiteGenerator-Tests-GA" selector="setUp">setUp	super setUp.	SPlatform resetRandomGenerator.	operation := SGACrossoverOperation new.	mutationOperation := SGAMutationOperation new.	utility := SUtilityTypeInfo new</body></methods><methods><class-id>SmallSuiteGenerator.SRandom</class-id> <category>enumerating</category><body package="SmallSuiteGenerator-Core" selector="collectAtRandom:">collectAtRandom: collection	| indexes |	indexes := self shuffleCollection: collection size.	^ indexes		inject: OrderedCollection new		into: [ :result :index | 			result add: (collection at: index).			result ]</body><body package="SmallSuiteGenerator-Core" selector="nextIntBetween:and:">nextIntBetween: min and: max	^ (self next * (max - min)) truncated + min</body><body package="SmallSuiteGenerator-Core" selector="selectAtRandom:">selectAtRandom: collection	^ collection at: (self nextInt: collection size)</body><body package="SmallSuiteGenerator-Core" selector="selectIndexAtRandom:">selectIndexAtRandom: collection	^ self nextInt: collection size</body><body package="SmallSuiteGenerator-Core" selector="shuffleCollection:">shuffleCollection: stop	| numbers |	numbers := (1 to: stop) asArray.	stop to: 2 by: -1 do: [ :i | numbers swap: i with: (self nextInt: i) ].	^ numbers</body></methods><methods><class-id>SmallSuiteGenerator.SRandom class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Core" selector="seed:">seed: anObject	^ self new seed: anObject</body></methods><methods><class-id>SmallSuiteGenerator.SEventTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Scenario" selector="testDiscount">testDiscount	| event |	event := SEvent new.	event price: 80.	event discount: 20.	self assert: event discount equals: 20.	self assert: event price equals: 64</body><body package="SmallSuiteGenerator-Scenario" selector="testDiscountWithZeroPrice">testDiscountWithZeroPrice	| event |	event := SEvent new.	event discount: 20.	self assert: event discount equals: 0.	self assert: event price equals: 0</body><body package="SmallSuiteGenerator-Scenario" selector="testPrice">testPrice	| event |	event := SEvent new.	event price: 80.	self assert: event price equals: 80</body></methods><methods><class-id>SmallSuiteGenerator.SRandomTest</class-id> <category>running</category><body package="SmallSuiteGenerator-Tests-Core" selector="setUp">setUp	super setUp.	utility := SUtilityTypeInfo new</body></methods><methods><class-id>SmallSuiteGenerator.SRandomTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-Core" selector="testCollectAtRandom">testCollectAtRandom	| generator array |	generator := SRandom seed: 100.	array := (1 to: 10) asArray.	self		assertCollection: (generator collectAtRandom: array)		hasSameElements: array</body><body package="SmallSuiteGenerator-Tests-Core" selector="testCollectAtRandomOnStatements">testCollectAtRandomOnStatements	| generator testCase sfooSymbol |	sfooSymbol := #SFoo fullClassNameSymbol.	generator := SRandom seed: 100.	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		targetClassName: sfooSymbol;		addFactoryMessage;		addMessage: #returnNum from: sfooSymbol;		addFieldAccessMessage: #score from: sfooSymbol.	self		assertCollection: testCase printStatements		hasSameElements:			((generator collectAtRandom: testCase statements)				collect: #printString)</body><body package="SmallSuiteGenerator-Tests-Core" selector="testSelectAtRandom">testSelectAtRandom	| generator array |	generator := SRandom seed: 100.	array := (1 to: 10) asArray.	self assert: ((generator selectAtRandom: array) between: 1 and: 10)</body><body package="SmallSuiteGenerator-Tests-Core" selector="testSelectAtRandomOnStatements">testSelectAtRandomOnStatements	| generator testCase stringStatements statements sfooSymbol |	sfooSymbol := #SFoo fullClassNameSymbol.	generator := SRandom seed: 100.	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		targetClassName: sfooSymbol;		addFactoryMessage;		addMessage: #returnNum from: sfooSymbol;		addFieldAccessMessage: #score from: sfooSymbol.	stringStatements := testCase printStatements.	statements := testCase statements.	100		timesRepeat: [ self				assert:					(stringStatements						includes: (generator selectAtRandom: statements) printString) ]</body><body package="SmallSuiteGenerator-Tests-Core" selector="testShuffleCollection">testShuffleCollection	| generator array |	generator := SRandom seed: 100.	array := (1 to: 10) asArray.	self		assertCollection: (generator shuffleCollection: 10)		hasSameElements: array</body></methods><methods><class-id>SmallSuiteGenerator.SExpressionTest</class-id> <category>running</category><body package="SmallSuiteGenerator-Tests-AST" selector="setUp">setUp	super setUp.	utility := SUtilityTypeInfo new.	SPlatform resetRandomGenerator</body><body package="SmallSuiteGenerator-Tests-AST" selector="tearDown">tearDown	SPlatform resetRandomGenerator</body></methods><methods><class-id>SmallSuiteGenerator.SExpressionTest</class-id> <category>parsing</category><body package="SmallSuiteGenerator-Tests-AST" selector="parse:">parse: anExpresion	| sequence |	sequence := SPlatform rbParserClass parseExpression: anExpresion.	^ (SSGParser parseFrom: sequence) messages</body></methods><methods><class-id>SmallSuiteGenerator.SAssertionTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-AST" selector="testAssertComparison">testAssertComparison	| test |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var0 := 1.			 _var1 := 1.			 _var2 := Point x: _var0 y: _var1.			 _var3 := Point x: _var1 y: _var0.').	test generateAssertions: (Array with: SComparisonAssertion).	self assert: test assertions size equals: 2.	self		assert: test assertions first printString		equals: 'self assert: _var3 equals: _var2 '.	self		assert: test assertions second printString		equals: 'self assert: _var1 equals: _var0 '</body><body package="SmallSuiteGenerator-Tests-AST" selector="testAssertComparison2">testAssertComparison2	| test |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var0 := 1.			 _var1 := 2.			 _var2 := Point x: _var0 y: _var1.			 _var3 := Point x: _var1 y: _var0.').	test generateAssertions: (Array with: SComparisonAssertion).	self assert: test assertions size equals: 2.	self		assert: test assertions first printString		equals: 'self deny: _var3 equals: _var2 '.	self		assert: test assertions second printString		equals: 'self deny: _var1 equals: _var0 '</body><body package="SmallSuiteGenerator-Tests-AST" selector="testAssertInspector">testAssertInspector	| test |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var0 := 1.			 _var1 := 2.			 _var3 := Point x: _var1 y: _var0.').	test generateAssertions: (Array with: SInspectorAssertion).	self assert: test assertions size equals: 2.	self		assertCollection: (test assertions collect: #printString)		hasSameElements: #('self assert: _var3 x equals: 2 ' 'self assert: _var3 y equals: 1 ')</body><body package="SmallSuiteGenerator-Tests-AST" selector="testAssertPrimitive">testAssertPrimitive	| test |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var0 := 1.			 _var1 := 2.			 _var3 := Point x: _var1 y: _var0.').	test generateAssertions: (Array with: SPrimitiveAssertion).	self assert: test assertions size equals: 2.	self		assert: test assertions first printString		equals: 'self assert: _var0 equals: 1 '.	self		assert: test assertions second printString		equals: 'self assert: _var1 equals: 2 '</body><body package="SmallSuiteGenerator-Tests-AST" selector="testAssertString">testAssertString	| test |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var0 := 1.			 _var1 := 2.			 _var3 := Point x: _var1 y: _var0.').	test generateAssertions: (Array with: SStringAssertion).	self assert: test assertions size equals: 1.	self		assert: test assertions first printString		equals: 'self assert: _var3 printString equals: ''(2@1)'' '</body><body package="SmallSuiteGenerator-Tests-AST" selector="testExecutionContext">testExecutionContext	| test context |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var0 := 1.			 _var1 := 2.			 _var2 := Point x: _var0 y: _var1.').	context := test analyze.	self assert: (context at: '_var0') equals: 1.	self assert: (context at: '_var1') equals: 2.	self assert: (context at: '_var2') equals: 1 @ 2</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCaseTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-Core" selector="setUp">setUp	utility := SUtilityTypeInfo new.	SPlatform resetRandomGenerator.	SPlatform fileLogger: 'STestCaseTestLogger.log'</body><body package="SmallSuiteGenerator-Tests-Core" selector="testCopy">testCopy	| testCase typeInfo otherTestCase sfooSymbol sfooName |	sfooSymbol := #SFoo fullClassNameSymbol.	sfooName := 'SFoo' fullClassName.	typeInfo := self typeInfo.	testCase := SSTestCase with: typeInfo.	testCase		targetClassName: sfooSymbol;		addMessage: #returnNum from: sfooSymbol;		addFieldAccessMessage: #score from: sfooSymbol;		addLiteral: #SmallInteger fullClassNameSymbol.	otherTestCase := testCase copy.	self assert: testCase length equals: 5.	self assert: testCase equals: otherTestCase.	self		assert: testCase targetClassesName		equals: #SFoo fullClassNameSymbol.	testCase addLiteral: #ByteString fullClassNameSymbol.	otherTestCase addMessage: #returnFloat from: sfooSymbol.	otherTestCase addMessage: #return: from: sfooSymbol.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3'				with: '_var1 := ' , sfooName , ' score: _var0 '				with: '_var2 := _var1 returnNum'				with: '_var3 := _var1 score'				with: '_var4 := 5'				with: '_var5 := ''hello''').	self		assertCollection: (otherTestCase statements collect: #printString)		hasSameElements:			(OrderedCollection new				add: '_var0 := 7.3';				add: '_var1 := ' , sfooName , ' score: _var0 ';				add: '_var2 := _var1 returnNum';				add: '_var3 := _var1 score';				add: '_var4 := 5';				add: '_var5 := _var1 returnFloat';				add: '_var6 := ''hello''';				add: '_var7 := _var1 return: _var6 ';				yourself)</body><body package="SmallSuiteGenerator-Tests-Core" selector="testFieldAccessMessage">testFieldAccessMessage	| testCase sfooSymbol smallIntegerSymbol |	sfooSymbol := #SFoo fullClassNameSymbol.	smallIntegerSymbol := #SmallInteger fullClassNameSymbol.	testCase := SSTestCase		with:			(STypeInfo new				type:					sfooSymbol						-&gt;							(Array								with:									(Array										with:											#score												-&gt;													(Array														with: sfooSymbol														with: smallIntegerSymbol														with: #()														with: true)										with:											#score:												-&gt;													(Array														with: sfooSymbol														with: smallIntegerSymbol														with: (Array with: sfooSymbol)														with: false))								with:									(Array										with:											#score:												-&gt;													(Array														with: sfooSymbol														with: sfooSymbol														with: (Array with: smallIntegerSymbol)														with: false)));				scalar: smallIntegerSymbol with: #(5)).	testCase		targetClassName: sfooSymbol;		addFieldAccessMessage.	self assert: testCase statements size equals: 3.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 5'				with: '_var1 := ' , sfooSymbol asString , ' score: _var0 '				with: '_var2 := _var1 score')</body><body package="SmallSuiteGenerator-Tests-Core" selector="testGenerateStatements">testGenerateStatements	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		targetClassName: #SFoo fullClassNameSymbol;		numMaxStatements: 30.	self shouldnt: [ testCase generateStatements ] raise: SError</body><body package="SmallSuiteGenerator-Tests-Core" selector="testPickAccessorsOf">testPickAccessorsOf	| testCase |	testCase := SSTestCase new.	testCase typeInfo: utility typeInfoOnPackage1.	self		assert: (testCase pickAccessorsOf: #SEvent fullClassNameSymbol) isEmpty.	self		assertCollection:			((testCase pickAccessorsOf: #SConference fullClassNameSymbol)				collect: #selector)		hasSameElements: #(#discount #offerPrice)</body><body package="SmallSuiteGenerator-Tests-Core" selector="testPickMessagesOf">testPickMessagesOf	| testCase |	testCase := SSTestCase new.	testCase typeInfo: utility typeInfoOnPackage1.	self		assertCollection:			((testCase pickMessagesOf: #SEvent fullClassNameSymbol)				collect: #selector)		hasSameElements: #(#canRegister: #price).	self		assertCollection:			((testCase pickMessagesOf: #SConference fullClassNameSymbol)				collect: #selector)		hasSameElements: #(#initialize #offerPrice: #canRegister: #price)</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCaseTest</class-id> <category>running</category><body package="SmallSuiteGenerator-Tests-Core" selector="tearDown">tearDown	"SConfiguration clearFileLog: 'STestCaseTestLogger.log'"	SPlatform resetRandomGenerator</body></methods><methods><class-id>SmallSuiteGenerator.SChangeTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-Core" selector="testArgumentChange">testArgumentChange	| testCase newTestCase targetClass index |	targetClass := 'SFoo' fullClassNameSymbol.	testCase := SSTestCase with: utility typeInfoSFoo100.	testCase		targetClassName: targetClass;		addLiteral: #ByteString fullClassNameSymbol;		addLiteral: #ByteString fullClassNameSymbol;		addFactoryMessage: targetClass;		addFactoryMessage: targetClass;		addMessage: #return: from: targetClass.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			((Array new: 7)				at: 1 put: '_var0 := ''hello''';				at: 2 put: '_var1 := ''hello''';				at: 3 put: '_var2 := 4.7';				at: 4 put: '_var3 := ' , targetClass asString , ' score: _var2 ';				at: 5 put: '_var4 := ' , targetClass asString , ' score: _var2 ';				at: 6 put: '_var5 := ''hello''';				at: 7 put: '_var6 := _var3 return: _var1 ';				yourself).	newTestCase := SSTestCase with: testCase typeInfo.	index := 7.	1 to: index - 1 do: [ :i | 		| stm |		stm := testCase statements at: i.		newTestCase addStatement: stm copy.		newTestCase assignId ].	newTestCase		addAlternativeArgsFor: (testCase statements at: index) value.	self		assertCollection: (newTestCase statements collect: #printString)		hasSameElements:			((Array new: 7)				at: 1 put: '_var0 := ''hello''';				at: 2 put: '_var1 := ''hello''';				at: 3 put: '_var2 := 4.7';				at: 4 put: '_var3 := ' , targetClass asString , ' score: _var2 ';				at: 5 put: '_var4 := ' , targetClass asString , ' score: _var2 ';				at: 6 put: '_var5 := ''hello''';				at: 7 put: '_var6 := _var3 return: _var5 ';				yourself).	self assert: testCase validReferences</body><body package="SmallSuiteGenerator-Tests-Core" selector="testFactoryErrorChange">testFactoryErrorChange	| testCase newTestCase targetClass index |	targetClass := 'SFoo' fullClassNameSymbol.	testCase := SSTestCase with: utility typeInfoSFoo100.	testCase		targetClassName: targetClass;		addFactoryMessage: targetClass;		addFactoryMessage: targetClass;		addMessage: #return: from: targetClass.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			((Array new: 5)				at: 1 put: '_var0 := 7.3';				at: 2 put: '_var1 := ' , targetClass asString , ' score: _var0 ';				at: 3 put: '_var2 := ' , targetClass asString , ' score: _var0 ';				at: 4 put: '_var3 := ''hello''';				at: 5 put: '_var4 := _var2 return: _var3 ';				yourself).	newTestCase := SSTestCase with: testCase typeInfo.	index := 2.	1 to: index - 1 do: [ :i | 		| stm |		stm := testCase statements at: i.		newTestCase addStatement: stm copy.		newTestCase assignId ].	self		should: [ newTestCase				addAlternativeFactoryMessage: (testCase statements at: index) value ]		raise: SError</body><body package="SmallSuiteGenerator-Tests-Core" selector="testLiteralChange">testLiteralChange	| testCase newTestCase targetClass |	targetClass := 'SFoo' fullClassNameSymbol.	testCase := SSTestCase with: utility typeInfoSFoo100.	testCase		targetClassName: targetClass;		addMessage: #return: from: targetClass.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			((Array new: 4)				at: 1 put: '_var0 := 7.3';				at: 2 put: '_var1 := ' , targetClass asString , ' score: _var0 ';				at: 3 put: '_var2 := ''hello''';				at: 4 put: '_var3 := _var1 return: _var2 ';				yourself).	newTestCase := testCase changeStatementAt: 1.	self		assertCollection: (newTestCase statements collect: #printString)		hasSameElements:			((Array new: 4)				at: 1 put: '_var0 := 344.09999999999997';				at: 2 put: '_var1 := ' , targetClass asString , ' score: _var0 ';				at: 3 put: '_var2 := ''hello''';				at: 4 put: '_var3 := _var1 return: _var2 ';				yourself).	self assert: testCase validReferences</body><body package="SmallSuiteGenerator-Tests-Core" selector="testReceiverChange">testReceiverChange	| testCase newTestCase targetClass index |	targetClass := 'SFoo' fullClassNameSymbol.	testCase := SSTestCase with: utility typeInfoSFoo100.	testCase		targetClassName: targetClass;		addFactoryMessage: targetClass;		addFactoryMessage: targetClass;		addMessage: #return: from: targetClass.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			((Array new: 5)				at: 1 put: '_var0 := 7.3';				at: 2 put: '_var1 := ' , targetClass asString , ' score: _var0 ';				at: 3 put: '_var2 := ' , targetClass asString , ' score: _var0 ';				at: 4 put: '_var3 := ''hello''';				at: 5 put: '_var4 := _var2 return: _var3 ';				yourself).	newTestCase := SSTestCase with: testCase typeInfo.	index := 5.	1 to: index - 1 do: [ :i | 		| stm |		stm := testCase statements at: i.		newTestCase addStatement: stm copy.		newTestCase assignId ].	newTestCase		addAlternativeReceiverFor: (testCase statements at: index) value.	self		assertCollection: (newTestCase statements collect: #printString)		hasSameElements:			((Array new: 5)				at: 1 put: '_var0 := 7.3';				at: 2 put: '_var1 := ' , targetClass asString , ' score: _var0 ';				at: 3 put: '_var2 := ' , targetClass asString , ' score: _var0 ';				at: 4 put: '_var3 := ''hello''';				at: 5 put: '_var4 := _var1 return: _var3 ';				yourself).	self assert: testCase validReferences</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifterTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-Core" selector="testAddAssignment">testAddAssignment	| testCase expression |	testCase := SSTestCase new.	expression := testCase addAssignment: (SLiteral new value: 3).	self assert: expression printString equals: '_var0 := 3'.	expression := testCase		addAssignment:			(SMessage new				receiver: (SVariable new id: 0);				selector: #foo;				yourself).	self assert: expression printString equals: '_var1 := _var0 foo'</body><body package="SmallSuiteGenerator-Tests-Core" selector="testAddFactoryMessage">testAddFactoryMessage	| testCase aTypeInfo targetClass stackSymbol arraySymbol |	targetClass := #SFoo fullClassNameSymbol.	stackSymbol := #SStack fullClassNameSymbol.	arraySymbol := #Array fullClassNameSymbol.	aTypeInfo := utility typeInfoSFoo3.	testCase := SSTestCase with: aTypeInfo.	testCase		targetClassName: targetClass;		addFactoryMessage: targetClass.	self assert: testCase statements size equals: 2.	self		assertCollection: (testCase statements collect: #printString) asArray		hasSameElements:			(Array				with: '_var0 := 4'				with: '_var1 := ' , targetClass asString , ' score: _var0 ').	self		should: [ testCase addFactoryMessage: stackSymbol ]		raise: SError.	aTypeInfo		type:			stackSymbol				-&gt;					(Array						with:							(Array								with:									#top										-&gt;											(Array												with: stackSymbol												with: nil												with: #()												with: false))						with:							(Array								with:									#newStack:										-&gt;											(Array												with: stackSymbol												with: stackSymbol												with: (Array with: arraySymbol)												with: false)));		scalar: arraySymbol with: #(#(1 3 2)).	testCase		targetClassName: stackSymbol;		addFactoryMessage: stackSymbol.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 4'				with: '_var1 := ' , targetClass asString , ' score: _var0 '				with: '_var2 := #(1 3 2 )'				with: '_var3 := ' , stackSymbol asString , ' newStack: _var2 ')</body><body package="SmallSuiteGenerator-Tests-Core" selector="testAddFactoryMessageOfInexistentSelector">testAddFactoryMessageOfInexistentSelector	| testCase targetClass typeInfo |	targetClass := 'SFoo' fullClassName.	typeInfo := utility typeInfoSFoo2.	testCase := SSTestCase with: typeInfo.	testCase targetClassName: targetClass asSymbol.	self		should: [ testCase				addFactoryMessage: targetClass asSymbol				usingSelector: #score: ]		raise: SError.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #()</body><body package="SmallSuiteGenerator-Tests-Core" selector="testAddFactoryMessageOfSelector">testAddFactoryMessageOfSelector	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo3.	testCase		targetClassName: 'SFoo' fullClassNameSymbol;		addFactoryMessage: 'SFoo' fullClassNameSymbol			usingSelector: #score:.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			((Array new: 2)				at: 1 put: '_var0 := 4';				at: 2 put: '_var1 := ' , 'SFoo' fullClassName , ' score: _var0 ';				yourself)</body><body package="SmallSuiteGenerator-Tests-Core" selector="testAddFactoryMessageOnPackage">testAddFactoryMessageOnPackage	| testCase expression targetClass targetClassName |	targetClass := 'SSTeacher' fullClassNameSymbol.	targetClassName := 'SSTeacher' fullClassName.	testCase := SSTestCase with: utility typeInfoOnPackage3.	testCase targetClassName: targetClass.	expression := testCase addFactoryMessage: targetClass.	self		assert: '_var2 := ' , targetClassName , ' name: _var0 with: _var1 '		equals: expression printString.	self		shouldnt: [ expression := testCase				addFactoryMessage: #SConference fullClassNameSymbol ]		raise: SError.	self		assert: expression printString		equals: '_var3 := ' , 'SConference' fullClassName , ' new'</body><body package="SmallSuiteGenerator-Tests-Core" selector="testAddFactoryMessageWithAbstractClasses">testAddFactoryMessageWithAbstractClasses	| testCase |	testCase := SSTestCase with: utility typeInfoSSPerson1.	self should: [ testCase addFactoryMessage ] raise: SError.	self		should: [ testCase addFactoryMessage: #SSPerson fullClassName ]		raise: SError.	testCase := SSTestCase with: utility typeInfoSAbstractClass.	self should: [ testCase addFactoryMessage ] raise: SError.	self		should: [ testCase addFactoryMessage: #SAbstractClass fullClassName ]		raise: SError</body><body package="SmallSuiteGenerator-Tests-Core" selector="testAddFieldAccessMessage">testAddFieldAccessMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSSTeacher2.	self		assert: testCase addFieldAccessMessage printString		equals: '_var1 := _var0 idTeacher'</body><body package="SmallSuiteGenerator-Tests-Core" selector="testAddFieldAccessMessageFrom">testAddFieldAccessMessageFrom	| testCase targetClass |	targetClass := #SFoo fullClassNameSymbol.	testCase := SSTestCase with: utility typeInfoSFoo3.	self		assert: (testCase addFieldAccessMessage: #score from: targetClass) printString		equals: '_var2 := _var1 score'</body><body package="SmallSuiteGenerator-Tests-Core" selector="testAddFieldAccessMessageFromWithError">testAddFieldAccessMessageFromWithError	| testCase targetClass |	targetClass := #SFoo fullClassNameSymbol.	testCase := SSTestCase with: utility typeInfoSFoo2.	self		should: [ testCase addFieldAccessMessage: #score from: targetClass ]		raise: SError.	testCase targetClassName: targetClass.	self		should: [ testCase addFieldAccessMessage: #score from: targetClass ]		raise: SError.	self		should: [ testCase addFieldAccessMessage: #return: from: targetClass ]		raise: SError</body><body package="SmallSuiteGenerator-Tests-Core" selector="testAddFieldAccessMessageFromWithInvalidClassName">testAddFieldAccessMessageFromWithInvalidClassName	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo4.	testCase targetClassName: #SFoo fullClassNameSymbol.	self		should: [ testCase				addFieldAccessMessage: #score				from: #SStudent fullClassNameSymbol ]		raise: SError</body><body package="SmallSuiteGenerator-Tests-Core" selector="testAddFieldAccessMessageWithLackTypeInfo">testAddFieldAccessMessageWithLackTypeInfo	| testCase |	testCase := SSTestCase with: utility typeInfoSSTeacher3.	self should: [ testCase addFieldAccessMessage ] raise: SError.	testCase targetClassName: #SSTeacher fullClassNameSymbol.	self should: [ testCase addFieldAccessMessage ] raise: SError</body><body package="SmallSuiteGenerator-Tests-Core" selector="testAddFieldAccessMessageWithReceiver">testAddFieldAccessMessageWithReceiver	| testCase typeInfo receiver targetClass |	targetClass := #SFoo fullClassNameSymbol.	typeInfo := utility typeInfoSFoo1.	testCase := (SSTestCase with: typeInfo) targetClassName: targetClass.	receiver := testCase addFactoryMessage variable.	self		assert:			(testCase				addFieldAccessMessage: (typeInfo accessMessagesFrom: targetClass) first				withReceiver: receiver) printString		equals: '_var2 := _var1 score'</body><body package="SmallSuiteGenerator-Tests-Core" selector="testAddInvalidAssignment">testAddInvalidAssignment	| testCase |	testCase := SSTestCase new.	self should: [ testCase addAssignment: 3 ] raise: Error.	self should: [ testCase addAssignment: 'hello' ] raise: Error.	self should: [ testCase addAssignment: #name ] raise: Error.	self should: [ testCase addAssignment: 3.4 ] raise: Error.	self should: [ testCase addAssignment: #() ] raise: Error</body><body package="SmallSuiteGenerator-Tests-Core" selector="testAddLiteral">testAddLiteral	| testCase aTypeInfo collSymbol stringSymbol intSymbol studentSymbol |	collSymbol := #OrderedCollection fullClassNameSymbol.	stringSymbol := #ByteString fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	studentSymbol := #SStudent fullClassNameSymbol.	aTypeInfo := STypeInfo new.	aTypeInfo		scalar: collSymbol			with: (Array with: (OrderedCollection newFrom: #(1 4)));		scalar: stringSymbol with: #('World');		scalar: intSymbol with: #(2);		scalar: studentSymbol with: (Array with: SStudent new).	testCase := SSTestCase with: aTypeInfo.	testCase		addLiteral: stringSymbol;		addLiteral: collSymbol;		addLiteral: intSymbol;		addLiteral: studentSymbol.	self assert: testCase statements size equals: 4.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := ''World'''				with:					'_var1 := '						,							(OrderedCollection new								add: 1;								add: 4;								yourself) storeString , ''				with: '_var2 := 2'				with: '_var3 := ' , SStudent new storeString , '')</body><body package="SmallSuiteGenerator-Tests-Core" selector="testAddLiteralWithError">testAddLiteralWithError	| testCase |	testCase := SSTestCase with: STypeInfo new.	self should: [ testCase addLiteral ] raise: SError</body><body package="SmallSuiteGenerator-Tests-Core" selector="testAddLiteralWithWrongClassName">testAddLiteralWithWrongClassName	| testCase aTypeInfo |	aTypeInfo := STypeInfo new.	aTypeInfo scalar: #SmallInteger fullClassNameSymbol with: #(2).	testCase := SSTestCase with: aTypeInfo.	self		should: [ testCase addLiteral: #ByteString fullClassNameSymbol ]		raise: SError</body><body package="SmallSuiteGenerator-Tests-Core" selector="testAddMessage">testAddMessage	| testCase targetClass |	targetClass := #SFoo fullClassNameSymbol.	testCase := SSTestCase with: utility typeInfoSFoo5.	testCase		targetClassName: targetClass;		addMessage.	self assert: testCase statements size equals: 3.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := ' , targetClass asString , ' new'				with: '_var1 := ' , (OrderedCollection newFrom: #(1 4 5)) storeString , ''				with: '_var2 := _var0 return: _var1 ')</body><body package="SmallSuiteGenerator-Tests-Core" selector="testAddMessageFrom">testAddMessageFrom	| testCase targetClass |	targetClass := #SFoo fullClassNameSymbol.	testCase := SSTestCase with: utility typeInfoSFoo3.	testCase		targetClassName: targetClass;		addMessage: #returnFloat from: targetClass.	self assert: testCase statements size equals: 3.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 4'				with: '_var1 := ' , targetClass asString , ' score: _var0 '				with: '_var2 := _var1 returnFloat').	self		assert: (testCase addMessage: #returnNum from: targetClass) printString		equals: '_var3 := _var1 returnNum'.	self		assert:			(#('_var4 := _var1 score: _var0 ' '_var4 := _var1 score: _var3 ' '_var5 := _var1 score: _var3' '_var5 := _var1 score: _var4')				includes: (testCase addMessage: #score: from: targetClass) printString)</body><body package="SmallSuiteGenerator-Tests-Core" selector="testAddMessageFromDifferentReceiver">testAddMessageFromDifferentReceiver	| testCase eventSymbol confSymbol |	eventSymbol := #SEvent fullClassNameSymbol.	confSymbol := #SConference fullClassNameSymbol.	testCase := (SSTestCase with: utility typeInfoOnPackage1)		targetClassName: eventSymbol.	testCase targetClassName: confSymbol.	testCase addMessage: #canRegister: from: confSymbol.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := ' , confSymbol asString , ' new'				with: '_var1 := ' , (SStudent new name: 'Mary') storeString , ''				with: '_var2 := _var0 canRegister: _var1 ')</body><body package="SmallSuiteGenerator-Tests-Core" selector="testAddMessageWithEmptyTypeMethodInfo">testAddMessageWithEmptyTypeMethodInfo	| testCase |	testCase := SSTestCase with: utility typeInfoSFooEmpty.	testCase targetClassName: #SFoo fullClassNameSymbol.	self should: [ testCase addMessage ] raise: SError</body><body package="SmallSuiteGenerator-Tests-Core" selector="testAddMessageWithReceiver">testAddMessageWithReceiver	| testCase typeInfo receiver targetClass |	targetClass := #SFoo fullClassNameSymbol.	typeInfo := utility typeInfoSFoo2.	testCase := (SSTestCase with: typeInfo) targetClassName: targetClass.	receiver := testCase addFactoryMessage variable.	self		assert:			(testCase				addMessage: (typeInfo messagesFrom: targetClass) first				withReceiver: receiver) printString		equals: '_var2 := _var0 return: _var1 '</body><body package="SmallSuiteGenerator-Tests-Core" selector="testAddMessageWithTwoDeepScalarSFoo">testAddMessageWithTwoDeepScalarSFoo	" This feature is not covered yet		| testCase targetClass |	targetClass := #SFoo fullClassNameSymbol.	testCase := SSTestCase		with: utility typeInfoSFooOnPackage3.	testCase		targetClassName: targetClass;		addMessage: #return: from: targetClass.	self assert: testCase statements size equals: 3.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(OrderedCollection new				add: '_var0 := ', targetClass asString,' new.';				add: '_var1 := ' , (SStudent name: 'Lian' with: 1) storeString , '.';				add: '_var2 := ', 'SStack' fullClassName,' new.';				add: '_var3 := _var2 push: _var1.';				add: '_var4 := ' , (SStudent name: 'Josh' with: 2) storeString , '.';				add: '_var5 := _var2 push: _var4.';				add: '_var6 := ' , (SStudent name: 'Mery' with: 5) storeString , '.';				add: '_var7 := ((OrderedCollection new) add: _var6; yourself).';				add: '_var8 := ((Dictionary new) add: (1-&gt;_var5); add: (2-&gt;_var7); yourself).';				add: '_var9 := _var0 return: _var8.';				yourself)"	</body><body package="SmallSuiteGenerator-Tests-Core" selector="testAddMessageWithTwoDeepScalarSStack">testAddMessageWithTwoDeepScalarSStack	"This feature is not covered yet		| testCase targetClass |	targetClass := #SStack fullClassNameSymbol.	testCase := SSTestCase		with: utility typeInfoSStackOnPackage2.	testCase		targetClassName: targetClass;		addMessage: #push: from: targetClass.	self assert: testCase statements size equals: 3.	self		assert:			((testCase statements collect: #printString)				includesAny:					(Array						with:							(OrderedCollection new								add: '_var0 := ', targetClass asString,' new';								add: '_var1 := ' , (SStudent name: 'Lian' with: 1) storeString , ' ';								add: '_var2 := ' , (SStudent name: 'Josh' with: 2) storeString , ' ';								add: '_var3 := ((OrderedCollection new) add: _var1; add: _var2; yourself)';								add: '_var4 := _var0 push: _var3 ';								yourself)						with:							(OrderedCollection new								add: '_var0 := ', targetClass asString,' new';								add: '_var1 := ' , (SStudent name: 'Mery' with: 5) storeString , ' ';								add: '_var2 := ((OrderedCollection new) add: _var1; yourself)';								add: '_var3 := _var0 push: _var2 ';								yourself)))"	</body><body package="SmallSuiteGenerator-Tests-Core" selector="testAddTargetClassName">testAddTargetClassName	| testCase expression eventSymbol teacherSymbol |	eventSymbol := #SEvent fullClassNameSymbol.	teacherSymbol := #SSTeacher fullClassNameSymbol.	testCase := SSTestCase with: utility typeInfoOnPackage3.	self should: [ testCase targetClassName: eventSymbol ] raise: SError.	self		shouldnt: [ testCase targetClassName: teacherSymbol ]		raise: SError.	expression := testCase addFactoryMessage: teacherSymbol.	self		assert: expression printString		equals: '_var2 := ' , teacherSymbol asString , ' name: _var0 with: _var1 '</body><body package="SmallSuiteGenerator-Tests-Core" selector="testNewFactoryMessageUsingAnd">testNewFactoryMessageUsingAnd	| testCase factory targetClass method typeInfo |	targetClass := 'SEvent' fullClassNameSymbol.	typeInfo := utility typeInfoSEvent1.	testCase := SSTestCase with: typeInfo.	testCase targetClassName: targetClass.	testCase addLiteral.	method := typeInfo		classMethodType: #price:		from: #SEvent fullClassNameSymbol.	factory := testCase		newFactoryMessage: method		from: #SEvent fullClassNameSymbol.	self		assert: factory printString		equals: targetClass , ' price: _var0 '.	self		assertCollection: testCase printStatements		hasSameElements: #('_var0 := 8')</body><body package="SmallSuiteGenerator-Tests-Core" selector="testObjectVariables">testObjectVariables	| testCase |	testCase := SSTestCase with: utility typeInfoSSTeacher3.	self assert: testCase objectVariables isEmpty.	testCase		targetClassName: #SSTeacher fullClassNameSymbol;		addFactoryMessage.	self		assertCollection: (testCase objectVariables collect: #printString)		hasSameElements: #('_var0')</body><body package="SmallSuiteGenerator-Tests-Core" selector="testPickAccessorsOf">testPickAccessorsOf	| testCase targetClass |	targetClass := #SSTeacher fullClassNameSymbol.	testCase := (SSTestCase with: utility typeInfoSSTeacher4)		targetClassName: targetClass.	self		assertCollection: ((testCase pickAccessorsOf: targetClass) collect: #selector)		hasSameElements: #(#yearsWorkExperience #idTeacher).	testCase := (SSTestCase with: utility typeInfoSSTeacher3)		targetClassName: targetClass.	self assert: (testCase pickAccessorsOf: targetClass) isEmpty</body><body package="SmallSuiteGenerator-Tests-Core" selector="testPickAccessorsOfWithInvalidClassName">testPickAccessorsOfWithInvalidClassName	| testCase |	testCase := (SSTestCase with: utility typeInfoSSTeacher4)		targetClassName: #SSTeacher fullClassNameSymbol.	self		assert: (testCase pickAccessorsOf: #SStudent fullClassNameSymbol) isEmpty</body><body package="SmallSuiteGenerator-Tests-Core" selector="testPickAnObjectVariable">testPickAnObjectVariable	| testCase |	testCase := SSTestCase with: utility typeInfoSSTeacher3.	testCase targetClassName: 'SSTeacher' fullClassNameSymbol.	testCase addFactoryMessage: 'SSTeacher' fullClassNameSymbol.	self		assert: testCase pickAnObjectVariable printString		equals: '_var0'</body><body package="SmallSuiteGenerator-Tests-Core" selector="testPickFactoryMessagesFrom">testPickFactoryMessagesFrom	| testCase targetClass |	targetClass := #SConference fullClassNameSymbol.	testCase := SSTestCase new.	testCase typeInfo: utility typeInfoOnPackage2.	testCase targetClassName: targetClass.	testCase addFactoryMessage: targetClass usingSelector: #price:.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 95'				with: '_var1 := ' , targetClass asString , ' price: _var0 ')</body><body package="SmallSuiteGenerator-Tests-Core" selector="testPickMessagesOf">testPickMessagesOf	| testCase |	testCase := SSTestCase with: utility typeInfoOnPackage2.	self		assertCollection:			((testCase pickMessagesOf: #SEvent fullClassNameSymbol)				collect: #selector)		hasSameElements: #(#price:).	self		assertCollection:			((testCase pickMessagesOf: #SConference fullClassNameSymbol)				collect: #selector)		hasSameElements: #(#price: #initialize).	testCase := SSTestCase with: utility typeInfoOnPackage3.	self		assertCollection:			((testCase pickMessagesOf: #SSTeacher fullClassNameSymbol)				collect: #selector)		hasSameElements: #(#name: #id: #nickname: #initialize #nickname)</body><body package="SmallSuiteGenerator-Tests-Core" selector="testPickMessagesOfWrongClassName">testPickMessagesOfWrongClassName	| testCase |	testCase := SSTestCase with: utility typeInfoOnPackage2.	self		assert: (testCase pickMessagesOf: #SSTeacher fullClassNameSymbol) isEmpty.	testCase := SSTestCase with: utility typeInfoOnPackage3.	self		assert: (testCase pickMessagesOf: #SSPerson fullClassNameSymbol) isEmpty.	self		assert: (testCase pickMessagesOf: #SStudent fullClassNameSymbol) isEmpty</body><body package="SmallSuiteGenerator-Tests-Core" selector="testPickOrCreateObjectVariableOf">testPickOrCreateObjectVariableOf	| testCase targetClass |	targetClass := #SFoo fullClassNameSymbol.	testCase := (SSTestCase with: utility typeInfoSFoo2)		targetClassName: targetClass.	self assert: testCase statements isEmpty.	self		assert: (testCase pickOrCreateObjectVariableOf: targetClass) printString		equals: '_var0'.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: (Array with: '_var0 := ' , targetClass asString , ' new').	testCase pickOrCreateObjectVariableOf: targetClass.	self assert: testCase statements size equals: 1</body><body package="SmallSuiteGenerator-Tests-Core" selector="testPickOrCreateObjectVariableOfWrongClassName">testPickOrCreateObjectVariableOfWrongClassName	| testCase |	testCase := (SSTestCase with: utility typeInfoSFoo2)		targetClassName: #SFoo fullClassNameSymbol.	self		should: [ testCase				pickOrCreateObjectVariableOf: #SSTeacher fullClassNameSymbol ]		raise: SError</body><body package="SmallSuiteGenerator-Tests-Core" selector="testRandomLiteralClassName">testRandomLiteralClassName	| testCase |	testCase := SSTestCase		with:			(STypeInfo new				scalar: #SmallInteger fullClassNameSymbol				with: #(1 3 4)).	self		assert: testCase randomLiteralClassName		equals: #SmallInteger fullClassNameSymbol.	testCase := SSTestCase		with:			(STypeInfo new				scalar: #ByteString fullClassNameSymbol with: #('hello');				scalar: #SmallInteger fullClassNameSymbol with: #(1 5 6)).	self		assert:			((Array				with: #ByteString fullClassNameSymbol				with: #SmallInteger fullClassNameSymbol)				includes: testCase randomLiteralClassName)</body><body package="SmallSuiteGenerator-Tests-Core" selector="testRandomLiteralClassNameWithEmptyScalars">testRandomLiteralClassNameWithEmptyScalars	| testCase |	testCase := SSTestCase with: STypeInfo new.	self should: [ testCase randomLiteralClassName ] raise: SError</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifterTest</class-id> <category>running</category><body package="SmallSuiteGenerator-Tests-Core" selector="setUp">setUp	SPlatform resetRandomGenerator.	utility := SUtilityTypeInfo new.	SPlatform fileLogger: 'STestShifterTestLogger.log'</body><body package="SmallSuiteGenerator-Tests-Core" selector="tearDown">tearDown	SPlatform resetRandomGenerator</body></methods><methods><class-id>SmallSuiteGenerator.SmallTypeCollectorTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-SmallType" selector="testAnInteger">testAnInteger	self assert: #Integer equals: (self typeFor: 'anInteger')</body><body package="SmallSuiteGenerator-Tests-SmallType" selector="testInteger">testInteger	self assert: #Integer equals: (self typeFor: 'integer')</body><body package="SmallSuiteGenerator-Tests-SmallType" selector="typeFor:">typeFor: aName	^ SmallTypeCollector new typeFor: aName</body></methods><methods><class-id>SmallSuiteGenerator.SMultiFitnessFunctionTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-GA" selector="testComputeFitnessOnFactoryMessage">testComputeFitnessOnFactoryMessage	"| aTestCase res fitness |	aTestCase := SSTestCase with: utility typeInfoSFoo1.	aTestCase addFactoryMessage.	fitness := SStatementCoverage new.	res := (function computeFitness: aTestCase) values.	self assertCollection: res hasSameElements: #(33.33 28.57)"	</body><body package="SmallSuiteGenerator-Tests-GA" selector="testComputeFitnessOnFieldAccessMessage">testComputeFitnessOnFieldAccessMessage	"| aTestCase res |	aTestCase := SSTestCase with: utility typeInfoSFoo1.	aTestCase addFieldAccessMessage: #score from: #SFoo.	""fitness := SStatementCoverage new.""	res := (function computeFitness: aTestCase) values.	self assertCollection: res hasSameElements: #(44.44 35.71)"	</body><body package="SmallSuiteGenerator-Tests-GA" selector="testComputeFitnessOnLiteral">testComputeFitnessOnLiteral	"| aTestCase res |	aTestCase := SSTestCase with: utility typeInfoSFoo1.	aTestCase addLiteral.	""fitness := SStatementCoverage new.""	res := (function computeFitness: aTestCase) values.	self assertCollection: res hasSameElements: #(0 0)"	</body><body package="SmallSuiteGenerator-Tests-GA" selector="testComputeFitnessOnMessage">testComputeFitnessOnMessage	"| aTestCase res |	aTestCase := SSTestCase with: utility typeInfoSFoo1.	aTestCase addMessage: #returnFloat from: #SFoo.	""fitness := SStatementCoverage new.""	res := (function computeFitness: aTestCase) values.	self assertCollection: res hasSameElements: #(44.44 42.86)"	</body><body package="SmallSuiteGenerator-Tests-GA" selector="testIsBetterThan">testIsBetterThan	"| testCase1 testCase2 functions |	testCase1 := utility testSuiteSStudentManual second.	testCase2 := utility testSuiteSStudentManual second.	""testCase2 addFieldAccessMessage: #scoreStudent from: #SStudent.	functions := SStatementCoverage new, SMethodCoverage new.""	testCase1 computeFitness: functions first.	testCase1 computeFitness: functions second.	testCase2 computeFitness: functions first.	testCase2 computeFitness: functions second	""self deny: (function is: testCase1 betterThan: testCase2).	self assert: (function is: testCase2 betterThan: testCase1)"""	</body></methods><methods><class-id>SmallSuiteGenerator.SMultiFitnessFunctionTest</class-id> <category>running</category><body package="SmallSuiteGenerator-Tests-GA" selector="setUp">setUp	super setUp	"function := SMultiFitnessFunction.	function clean.	fitnessFunctions := Array		with: SMethodCoverage		with: SStatementCoverage.	utility := SUtilityTypeInfo new"</body><body package="SmallSuiteGenerator-Tests-GA" selector="tearDown">tearDown	"fitnessFunctions do: #clean.	function		clean;		reset."	super tearDown</body></methods><methods><class-id>SmallSuiteGenerator.SObject</class-id> <category>random</category><body package="SmallSuiteGenerator-Core" selector="next">next	^ self random next</body><body package="SmallSuiteGenerator-Core" selector="random">random	^ SPlatform randomGenerator</body></methods><methods><class-id>SmallSuiteGenerator.SObject</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Core" selector="initialize">initialize	</body></methods><methods><class-id>SmallSuiteGenerator.SObject</class-id> <category>error handling</category><body package="SmallSuiteGenerator-Core" selector="serror:">serror: aString	"It throws an error signal with the string passed as argument, it is important to distinguish parsing error with others"	^ SError signal: aString</body></methods><methods><class-id>SmallSuiteGenerator.SObject class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Core" selector="new">new	"Answer a newly created and initialized instance."	^ super new initialize</body></methods><methods><class-id>SmallSuiteGenerator.SReport</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Utility" selector="fileReference:">fileReference: aString	| filename |	filename := aString , '.csv'.	filename asFileReference ensureDelete.	^ filename asFileReference</body></methods><methods><class-id>SmallSuiteGenerator.SReport class</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Utility" selector="fileReference:">fileReference: aString	^ self new fileReference: aString</body><body package="SmallSuiteGenerator-Utility" selector="titles">titles	self subclassResponsibility</body></methods><methods><class-id>SmallSuiteGenerator.SGAAbstractViz class</class-id> <category>gt-inspector-extension</category><body package="SmallSuiteGenerator-Strategies" selector="gtInspectorCanvasIn:for:">gtInspectorCanvasIn: composite for: testCaseFactory	self shouldBeImplemented</body><body package="SmallSuiteGenerator-Strategies" selector="gtInspectorViewIn:for:">gtInspectorViewIn: composite for: testCaseFactory	self shouldBeImplemented</body></methods><methods><class-id>SmallSuiteGenerator.SSAbstractSettingMethods</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Strategies" selector="executeBlock:">executeBlock: aBlock	executeBlock := aBlock</body><body package="SmallSuiteGenerator-Strategies" selector="exportMethods">exportMethods	self exportMethod: #setUp.	self exportMethod: #tearDown</body><body package="SmallSuiteGenerator-Strategies" selector="factory:">factory: aFactory	factory := aFactory</body><body package="SmallSuiteGenerator-Strategies" selector="run">run	| context |	self setUp.	context := executeBlock value: testCase.	self tearDown.	^ context</body><body package="SmallSuiteGenerator-Strategies" selector="setUp">setUp	</body><body package="SmallSuiteGenerator-Strategies" selector="tearDown">tearDown	</body><body package="SmallSuiteGenerator-Strategies" selector="testCase:">testCase: aTestCase	testCase := aTestCase</body></methods><methods><class-id>SmallSuiteGenerator.SSAbstractSettingMethods class</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Strategies" selector="exportMethodsFor:">exportMethodsFor: aFactory	^ self new		factory: aFactory;		exportMethods</body><body package="SmallSuiteGenerator-Strategies" selector="on:execute:">on: aTestCase execute: aBlock	^ self new		testCase: aTestCase;		executeBlock: aBlock;		run</body></methods><methods><class-id>SmallSuiteGenerator.SGAAbstractLog</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Strategies" selector="fittestTestCase">fittestTestCase	^ fittestTestCase</body><body package="SmallSuiteGenerator-Strategies" selector="fittestTestCase:">fittestTestCase: anObject	fittestTestCase := anObject</body><body package="SmallSuiteGenerator-Strategies" selector="generationNumber">generationNumber	^ generationNumber</body><body package="SmallSuiteGenerator-Strategies" selector="generationNumber:">generationNumber: anObject	generationNumber := anObject</body><body package="SmallSuiteGenerator-Strategies" selector="lowestFit">lowestFit	^ lowestFit</body><body package="SmallSuiteGenerator-Strategies" selector="lowestFit:">lowestFit: anObject	lowestFit := anObject</body><body package="SmallSuiteGenerator-Strategies" selector="timeToProduceGeneration">timeToProduceGeneration	^ timeToProduceGeneration</body><body package="SmallSuiteGenerator-Strategies" selector="timeToProduceGeneration:">timeToProduceGeneration: anObject	timeToProduceGeneration := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SGANullLog class</class-id> <category>log</category><body package="SmallSuiteGenerator-Strategies" selector="logOf:inGeneration:inTime:">logOf: aSGAEngine inGeneration: anInteger inTime: t	| log |	log := self new		generationNumber: anInteger;		fittestTestCase: aSGAEngine population first;		timeToProduceGeneration: Time new asSeconds - t;		lowestFit: aSGAEngine population last fitness.	^ log</body></methods><methods><class-id>SmallSuiteGenerator.SGANullLog class</class-id> <category>summaries</category><body package="SmallSuiteGenerator-Strategies" selector="summaryExecutionMethodsOf:with:">summaryExecutionMethodsOf: aTestCase with: aProfiler	</body></methods><methods><class-id>SmallSuiteGenerator.SSVisitor</class-id> <category>visiting-assertions</category><body package="SmallSuiteGenerator-Core" selector="visitAssertionMessage:">visitAssertionMessage: aMessage	^ self visitAbstractMessage: aMessage</body><body package="SmallSuiteGenerator-Core" selector="visitComparisonAssertionMessage:">visitComparisonAssertionMessage: aMessage	^ self visitAssertionMessage: aMessage</body><body package="SmallSuiteGenerator-Core" selector="visitInspectorAssertionMessage:">visitInspectorAssertionMessage: aMessage	^ self visitAssertionMessage: aMessage</body><body package="SmallSuiteGenerator-Core" selector="visitPrimitiveAssertionMessage:">visitPrimitiveAssertionMessage: aMessage	^ self visitAssertionMessage: aMessage</body><body package="SmallSuiteGenerator-Core" selector="visitStringAssertionMessage:">visitStringAssertionMessage: aMessage	^ self visitAssertionMessage: aMessage</body></methods><methods><class-id>SmallSuiteGenerator.SSVisitor</class-id> <category>visiting-core</category><body package="SmallSuiteGenerator-Core" selector="visitAssignment:">visitAssignment: anAssignmnet	anAssignmnet variable accept: self.	anAssignmnet value accept: self</body><body package="SmallSuiteGenerator-Core" selector="visitCascade:">visitCascade: aCascade	aCascade messages do: [ :msj | msj accept: self ]</body><body package="SmallSuiteGenerator-Core" selector="visitFactoryMessage:">visitFactoryMessage: aMessage	^ self visitAbstractMessage: aMessage</body><body package="SmallSuiteGenerator-Core" selector="visitFieldAccessMessage:">visitFieldAccessMessage: aMessage	^ self visitAbstractMessage: aMessage</body><body package="SmallSuiteGenerator-Core" selector="visitLiteral:">visitLiteral: aLiteral	</body><body package="SmallSuiteGenerator-Core" selector="visitMessage:">visitMessage: aMessage	^ self visitAbstractMessage: aMessage</body><body package="SmallSuiteGenerator-Core" selector="visitSelf:">visitSelf: aSelf	</body><body package="SmallSuiteGenerator-Core" selector="visitStatements:">visitStatements: expresions	expresions do: [ :exp | exp accept: self ]</body><body package="SmallSuiteGenerator-Core" selector="visitVariable:">visitVariable: aVariable	</body></methods><methods><class-id>SmallSuiteGenerator.SSVisitor</class-id> <category>util</category><body package="SmallSuiteGenerator-Core" selector="visitAbstractMessage:">visitAbstractMessage: aMessage	"this only propagate the visit"	aMessage receiver accept: self.	aMessage args do: [ :arg | arg accept: self ]</body></methods><methods><class-id>SmallSuiteGenerator.SSMetaInterpreter</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Core" selector="accept:">accept: aSSVisitor	aSSVisitor visitVariable: self</body><body package="SmallSuiteGenerator-Core" selector="initialize">initialize	super initialize.	context := Dictionary new.	type := Dictionary new.	context at: 'self' put: SPlatform testCaseClass new</body><body package="SmallSuiteGenerator-Core" selector="visitAbstractMessage:">visitAbstractMessage: aMessage	| object objArgs result |	object := aMessage receiver accept: self.	objArgs := aMessage args collect: [ :arg | arg accept: self ].	result := object		perform: aMessage selector		withArguments: objArgs asArray.	aMessage returnType: result class nameAsSymbol.	^ result</body><body package="SmallSuiteGenerator-Core" selector="visitAssignment:">visitAssignment: anAssignmnet	| result returnType |	result := anAssignmnet value accept: self.	returnType := result class nameAsSymbol.	context at: anAssignmnet variable fullName put: result.	anAssignmnet variable returnType: returnType.	anAssignmnet returnType: returnType.	type at: anAssignmnet variable id put: returnType.	^ result</body><body package="SmallSuiteGenerator-Core" selector="visitCascade:">visitCascade: aCascade	| object objArgs result |	object := aCascade messages first receiver accept: self.	aCascade messages		do: [ :msj | 			objArgs := msj args collect: [ :arg | arg accept: self ].			result := object				perform: msj selector				withArguments: objArgs asArray.			msj returnType: result class nameAsSymbol ].	^ result</body><body package="SmallSuiteGenerator-Core" selector="visitLiteral:">visitLiteral: aLiteral	^ aLiteral value</body><body package="SmallSuiteGenerator-Core" selector="visitSelf:">visitSelf: aSelf	^ context at: 'self'</body><body package="SmallSuiteGenerator-Core" selector="visitSequenceNode:">visitSequenceNode: aSequenceNode	self visitStatements: aSequenceNode statements</body><body package="SmallSuiteGenerator-Core" selector="visitVariable:">visitVariable: aVariable	aVariable id		ifNotNil: [ aVariable returnType: (type at: aVariable id) ].	^ aVariable id		ifNil: [ Smalltalk at: aVariable varName ]		ifNotNil: [ context at: aVariable fullName ]</body></methods><methods><class-id>SmallSuiteGenerator.SSMetaInterpreter</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Core" selector="clean">clean	context removeKey: 'self'</body><body package="SmallSuiteGenerator-Core" selector="context">context	^ context</body><body package="SmallSuiteGenerator-Core" selector="context:">context: anObject	context := anObject</body><body package="SmallSuiteGenerator-Core" selector="setUp">setUp	(context at: 'self') setUp</body><body package="SmallSuiteGenerator-Core" selector="tearDown">tearDown	(context at: 'self') tearDown</body><body package="SmallSuiteGenerator-Core" selector="waitThread">waitThread	(context at: 'self') waitThread</body></methods><methods><class-id>SmallSuiteGenerator.SGANullViz class</class-id> <category>gt-inspector-extension</category><body package="SmallSuiteGenerator-Strategies" selector="gtInspectorCanvasIn:for:">gtInspectorCanvasIn: composite for: testCaseFactory	</body><body package="SmallSuiteGenerator-Strategies" selector="gtInspectorViewIn:for:">gtInspectorViewIn: composite for: testCaseFactory	</body></methods><methods><class-id>SmallSuiteGenerator.SGALog</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Strategies" selector="averageFit">averageFit	^ averageFit</body><body package="SmallSuiteGenerator-Strategies" selector="averageFit:">averageFit: aNumber	averageFit := aNumber</body><body package="SmallSuiteGenerator-Strategies" selector="averageTestSize">averageTestSize	^ (self population collect: [ :x | x statements size ]) average		asFloat</body><body package="SmallSuiteGenerator-Strategies" selector="fitness">fitness	^ fittestTestCase fitness</body><body package="SmallSuiteGenerator-Strategies" selector="mutationResult:">mutationResult: mutationTestingResult	self		assert: mutationResult isEmpty		description: 'The analysis of mutants has already been calculated'.	[ mutationResult		at: 'noEvaluatedMutants'			put: mutationTestingResult numberOfEvaluatedMutants;		at: 'noKilledOrTerminatedMutants'			put: mutationTestingResult numberOfKilledOrTerminatedMutants;		at: 'noAliveMutants'			put: mutationTestingResult numberOfAliveMutants;		at: 'mutationScore' put: mutationTestingResult mutationScore ]		on: Exception		do: [ nil ]</body><body package="SmallSuiteGenerator-Strategies" selector="percentageOftestCasesWithErrors">percentageOftestCasesWithErrors	^ ((population select: [ :e | e hasErrors ]) size / population size)		asFloat</body><body package="SmallSuiteGenerator-Strategies" selector="population">population	^ population</body><body package="SmallSuiteGenerator-Strategies" selector="population:">population: anObject	population := anObject</body><body package="SmallSuiteGenerator-Strategies" selector="summaryTargetClass">summaryTargetClass	^ summaryTargetClass</body><body package="SmallSuiteGenerator-Strategies" selector="summaryTargetClass:">summaryTargetClass: anObject	summaryTargetClass := anObject</body><body package="SmallSuiteGenerator-Strategies" selector="typeInfoGeneration">typeInfoGeneration	^ typeInfoGeneration</body><body package="SmallSuiteGenerator-Strategies" selector="typeInfoGeneration:">typeInfoGeneration: anObject	typeInfoGeneration := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SGALog</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Strategies" selector="exportDataCSV:withFilter:">exportDataCSV: neoCSVWriter withFilter: aSymbol	(self filteredMethodsBy: aSymbol)		doWithIndex: [ :each :i | each writeDataCSV: neoCSVWriter withIndex: i ]</body><body package="SmallSuiteGenerator-Strategies" selector="filteredMethodsBy:">filteredMethodsBy: aSymbol	^ ((self selectorsFilter includes: aSymbol)		ifTrue: [ self summaryTargetClass select: aSymbol ]		ifFalse: [ self summaryTargetClass ]) select: #isNotNil</body><body package="SmallSuiteGenerator-Strategies" selector="initialize">initialize	mutationResult := Dictionary new</body><body package="SmallSuiteGenerator-Strategies" selector="selectorsFilter">selectorsFilter	^ #(#executed #unexecuted #notAllBlocksExecuted #allBlocksExecuted)</body></methods><methods><class-id>SmallSuiteGenerator.SGALog</class-id> <category>printing</category><body package="SmallSuiteGenerator-Strategies" selector="printOn:">printOn: str	super printOn: str.	str		nextPut: $&lt;;		nextPutAll: fittestTestCase statements printString;		nextPut: $&gt;</body></methods><methods><class-id>SmallSuiteGenerator.SGALog class</class-id> <category>log</category><body package="SmallSuiteGenerator-Strategies" selector="logOf:inGeneration:inTime:">logOf: aSGAEngine inGeneration: anInteger inTime: t	| log dictFitness |	log := self new		generationNumber: anInteger;		fittestTestCase: aSGAEngine population first;		timeToProduceGeneration: Time new asSeconds - t;		population: aSGAEngine population.	dictFitness := self collectFitnessByNameOf: aSGAEngine population.	log		lowestFit: aSGAEngine population last fitness;		averageFit: (self pickAverageFitTest: dictFitness).	log		summaryTargetClass: (aSGAEngine fitness runPopulation: aSGAEngine population).	log		typeInfoGeneration: (aSGAEngine typeInfo classAt: aSGAEngine targetClassName) deepCopy.	^ log</body></methods><methods><class-id>SmallSuiteGenerator.SGALog class</class-id> <category>summaries</category><body package="SmallSuiteGenerator-Strategies" selector="summaryExecutionMethodsOf:with:">summaryExecutionMethodsOf: aTestCase with: aProfiler	aTestCase summaryExecutionMethods: aProfiler summaryExecutionMethods</body></methods><methods><class-id>SmallSuiteGenerator.SGALog class</class-id> <category>actions</category><body package="SmallSuiteGenerator-Strategies" selector="collectFitnessByNameOf:">collectFitnessByNameOf: population	| dictFit |	dictFit := Dictionary new.	(self fitnessAndAssociationsOf: population)		do: [ :assoc | 			| aValue |			aValue := dictFit				at: assoc key				ifAbsentPut: [ OrderedCollection new ].			aValue add: assoc value ].	^ dictFit</body><body package="SmallSuiteGenerator-Strategies" selector="fitnessAndAssociationsOf:">fitnessAndAssociationsOf: population	^ (population collect: #fitness) flatCollect: #associations</body><body package="SmallSuiteGenerator-Strategies" selector="pickAverageFitTest:">pickAverageFitTest: aDictionary	^ (aDictionary keys		collect: [ :key | key -&gt; (aDictionary at: key) average ])		asDictionary</body></methods><methods><class-id>SmallSuiteGenerator.SGACrossover</class-id> <category>asserting</category><body package="SmallSuiteGenerator-Strategies" selector="shouldCrossOver:with:">shouldCrossOver: testCaseA with: testCaseB	self subclassResponsibility</body></methods><methods><class-id>SmallSuiteGenerator.SGACrossoverRate</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Strategies" selector="crossoverRate:">crossoverRate: aFloat	crossoverRate := aFloat</body><body package="SmallSuiteGenerator-Strategies" selector="initialize">initialize	super initialize.	crossoverRate := 0.8</body><body package="SmallSuiteGenerator-Strategies" selector="shouldCrossOver:with:">shouldCrossOver: testCaseA with: testCaseB	^ self next &lt; crossoverRate		and: [ testCaseA validReferences and: [ testCaseB validReferences ] ]</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractClass</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Scenario2" selector="initialize">initialize	id := 1</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractClass</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Scenario2" selector="id">id	^ id</body><body package="SmallSuiteGenerator-Scenario2" selector="id:">id: anObject	id := anObject</body><body package="SmallSuiteGenerator-Scenario2" selector="identifier">identifier	^ self subclassResponsibility</body></methods><methods><class-id>SmallSuiteGenerator.SSubclassChild</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Scenario2" selector="identifier">identifier	^ self className , '_' , self id asString</body></methods><methods><class-id>SmallSuiteGenerator.SGAViz</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Strategies" selector="aTestCaseFactory">aTestCaseFactory	^ aTestCaseFactory</body><body package="SmallSuiteGenerator-Strategies" selector="aTestCaseFactory:">aTestCaseFactory: anObject	aTestCaseFactory := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SGAViz class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Strategies" selector="gtInspectorCanvasIn:for:">gtInspectorCanvasIn: composite for: testCaseFactory	composite roassal3		title: 'GenerationEvolution';		initializeCanvas: [ self new				aTestCaseFactory: testCaseFactory;				generationEvolutionCanvas ]</body><body package="SmallSuiteGenerator-Strategies" selector="gtInspectorViewIn:for:">gtInspectorViewIn: composite for: testCaseFactory	composite roassal3		title: 'Evolution';		initializeCanvas: [ self new				aTestCaseFactory: testCaseFactory;				visualizeEvolutionFitness ]</body><body package="SmallSuiteGenerator-Strategies" selector="on:">on: testCaseFactory	^ self new aTestCaseFactory: testCaseFactory</body></methods><methods><class-id>SmallSuiteGenerator.SGASelection</class-id> <category>selection</category><body package="SmallSuiteGenerator-GA" selector="selectJustOneOf:with:">selectJustOneOf: aCollection with: probabilities	^ self subclassResponsibility</body><body package="SmallSuiteGenerator-GA" selector="selectOf:">selectOf: collection	^ self subclassResponsibility</body></methods><methods><class-id>SmallSuiteGenerator.SGASelection</class-id> <category>initialization</category><body package="SmallSuiteGenerator-GA" selector="initialize">initialize	</body></methods><methods><class-id>SmallSuiteGenerator.SGASelection</class-id> <category>accessing</category><body package="SmallSuiteGenerator-GA" selector="fitness:">fitness: anObject	fitness := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SGASelection</class-id> <category>actions</category><body package="SmallSuiteGenerator-GA" selector="fitnessFor:">fitnessFor: aTestCase	^ aTestCase fitness at: fitness functionName</body></methods><methods><class-id>SmallSuiteGenerator.SGATournamentSelection</class-id> <category>selection</category><body package="SmallSuiteGenerator-GA" selector="selectJustOneOf:with:">selectJustOneOf: aCollection with: probabilities	| sample index |	index := 0.	sample := (self random		collectAtRandom:			(probabilities				collect: [ :prob | 					index := index + 1.					index -&gt; prob ])) first: (2 min: probabilities size).	sample := (sample sort: [ :a :b | a value &gt; b value ]) first.	^ aCollection at: sample key</body><body package="SmallSuiteGenerator-GA" selector="selectOf:">selectOf: aCollection	"Return the best testCases from tournamentSize testCase randomly chosen from the population"	| sample |	sample := (self random collectAtRandom: aCollection)		first: (tournamentSize min: aCollection size).	sample := sample		asSortedCollection: [ :a :b | 			(a fitnessFor: fitness functionName)				&gt; (b fitnessFor: fitness functionName) ].	^ sample</body></methods><methods><class-id>SmallSuiteGenerator.SGATournamentSelection</class-id> <category>initialization</category><body package="SmallSuiteGenerator-GA" selector="initialize">initialize	super initialize.	tournamentSize := 5</body></methods><methods><class-id>SmallSuiteGenerator.SGATournamentSelection</class-id> <category>accessing</category><body package="SmallSuiteGenerator-GA" selector="tournamentSize:">tournamentSize: anInteger	tournamentSize := anInteger</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfoTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-Info" selector="testEqual">testEqual	| stringSymbol |	stringSymbol := #ByteString fullClassNameSymbol.	self		assert: (SMultiTypeInfo new type: stringSymbol)		equals: (SMultiTypeInfo new type: stringSymbol)</body></methods><methods><class-id>SmallSuiteGenerator.SFoo</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Scenario" selector="return:">return: aType	^ aType</body><body package="SmallSuiteGenerator-Scenario" selector="score">score	^ score</body><body package="SmallSuiteGenerator-Scenario" selector="score:">score: aNumber	score := aNumber</body></methods><methods><class-id>SmallSuiteGenerator.SFoo</class-id> <category>initailize-release</category><body package="SmallSuiteGenerator-Scenario" selector="initialize">initialize	score := 0</body></methods><methods><class-id>SmallSuiteGenerator.SFoo</class-id> <category>handling</category><body package="SmallSuiteGenerator-Scenario" selector="returnCollection">returnCollection	| a |	a := OrderedCollection new.	^ a</body><body package="SmallSuiteGenerator-Scenario" selector="returnFloat">returnFloat	| a |	a := 2.3.	^ a</body><body package="SmallSuiteGenerator-Scenario" selector="returnNum">returnNum	| a |	a := 4.	^ a</body><body package="SmallSuiteGenerator-Scenario" selector="returnString">returnString	| a |	a := 'Hello'.	^ a</body></methods><methods><class-id>SmallSuiteGenerator.SFoo class</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Scenario" selector="score:">score: aNumber	| ins |	ins := self new score: aNumber.	^ ins</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>actions</category><body package="SmallSuiteGenerator-Builder" selector="checkInvariants">checkInvariants	self		assert: typeInfo isNil not		description: 'Please provide type information of the target project'.	self		assert: self targetPackageRegex isNil not		description: 'Please provide a regex that match the packages under analysis'</body><body package="SmallSuiteGenerator-Builder" selector="compile:classified:">compile: aString classified: category	^ self generatedClass compile: aString classified: category</body><body package="SmallSuiteGenerator-Builder" selector="createTestCases">createTestCases	self checkInvariants.	self setUp.	self run.	self tearDown</body><body package="SmallSuiteGenerator-Builder" selector="crossoverOperator:">crossoverOperator: aCrossoverOperator	self generatedClass crossoverStrategy: aCrossoverOperator</body><body package="SmallSuiteGenerator-Builder" selector="crossoverStrategy:">crossoverStrategy: aCrossoverStrategy	self generatedClass crossoverStrategy: aCrossoverStrategy</body><body package="SmallSuiteGenerator-Builder" selector="initializeProfiler">initializeProfiler	self subclassResponsibility</body><body package="SmallSuiteGenerator-Builder" selector="lastMessage:">lastMessage: aMessage	lastMessage := aMessage.	engine lastMessage: lastMessage</body><body package="SmallSuiteGenerator-Builder" selector="run">run	engine run</body><body package="SmallSuiteGenerator-Builder" selector="selectionStrategy:">selectionStrategy: aSelectionStrategy	self generatedClass selectionStrategy: aSelectionStrategy</body><body package="SmallSuiteGenerator-Builder" selector="selectionStrategyTestCase:">selectionStrategyTestCase: aSelectionStrategy	self generatedClass selectionStrategyTestCase: aSelectionStrategy</body><body package="SmallSuiteGenerator-Builder" selector="uninstall">uninstall	</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>running</category><body package="SmallSuiteGenerator-Builder" selector="run:">run: aNumber	numberOfIterations := aNumber.	self createTestCases</body><body package="SmallSuiteGenerator-Builder" selector="setUp">setUp	self initializeProfiler.	self firstExecution		ifTrue: [ SPlatform resetRandomGenerator.			self fitness				profiler: profiler;				typeInfo: typeInfo;				targetClass: self targetClassName;				consideringNSuperclasses: self generatedClass nsuperclasses.			self setUpEngine.			typeInfoSeed := (typeInfo classAt: targetClassName) deepCopy.			self generatedClass compilePrinterClass ]		ifFalse: [ profiler typeInfo: typeInfo.			engine fitness profiler: profiler.			engine numberOfGenerations: numberOfIterations ]</body><body package="SmallSuiteGenerator-Builder" selector="setUpEngine">setUpEngine	engine		selectionStrategy: self generatedClass selectionStrategy new;		fitness: self fitness;		numberOfGenerations: numberOfIterations;		typeInfo: self typeInfo;		targetClassName: self targetClassName;		targetPackageRegex: self targetPackageRegex;		elitismRate: self generatedClass elitismRate;		numberOfStatements: self generatedClass numberOfStatements;		populationSize: self generatedClass populationSize;		stopIterations: self generatedClass stopIterations;		numberOfGenerations: self generatedClass numberOfGenerations;		selectionStrategyTestCase: self generatedClass selectionStrategyTestCase new;		crossoverStrategy: self generatedClass crossoverStrategy;		crossoverOperator: self generatedClass crossoverOperator</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Builder" selector="initialize">initialize	self resetToDefaults.	numberOfIterations := 20.	engine := self engineDefault.	initialSeed := 100.	lastMessage := SSGParser		parseFrom: (SPlatform rbParserClass parseExpression: '')</body><body package="SmallSuiteGenerator-Builder" selector="nsuperclasses:">nsuperclasses: aNumber	self generatedClass nsuperclasses: aNumber</body><body package="SmallSuiteGenerator-Builder" selector="numberOfGenerations:">numberOfGenerations: aNumber	engine numberOfGenerations: aNumber.	numberOfIterations := aNumber</body><body package="SmallSuiteGenerator-Builder" selector="resetToDefaults">resetToDefaults	super initialize.	SPlatform resetRandomGenerator.	self class resetToDefaults.	SSTestShifter resetToDefaults.	SGAEngine resetToDefaults</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>configuration</category><body package="SmallSuiteGenerator-Builder" selector="fitness">fitness	fitness ifNotNil: [ ^ fitness ].	fitness := self generatedClass fitnessValue.	^ fitness</body><body package="SmallSuiteGenerator-Builder" selector="fitness:">fitness: aFitness	self generatedClass fitness: aFitness</body><body package="SmallSuiteGenerator-Builder" selector="generatedClass:">generatedClass: anObject	generatedClass := anObject</body><body package="SmallSuiteGenerator-Builder" selector="numberOfStatements:">numberOfStatements: anInteger	self generatedClass numberOfStatements: anInteger</body><body package="SmallSuiteGenerator-Builder" selector="populationSize:">populationSize: anInteger	self generatedClass populationSize: anInteger</body><body package="SmallSuiteGenerator-Builder" selector="seedBlock:">seedBlock: aBlock	| copy |	copy := self generatedClass fitnessValue		profiler:			(self aSLProfilerCoverage				profile: aBlock				inPackagesMatching: self targetPackageRegex);		typeInfo: typeInfo;		targetClass: self targetClassName;		consideringNSuperclasses: self generatedClass nsuperclasses.	fitnessSeed := copy computeFitness first</body><body package="SmallSuiteGenerator-Builder" selector="stopIterations:">stopIterations: anInteger	self generatedClass stopIterations: anInteger</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Builder" selector="elitismRate:">elitismRate: aNumber	self generatedClass elitismRate: aNumber</body><body package="SmallSuiteGenerator-Builder" selector="engine">engine	^ engine</body><body package="SmallSuiteGenerator-Builder" selector="engineDefault">engineDefault	^ SGAEngine new		numberOfStatements: 30;		numberOfGenerations: numberOfIterations;		yourself</body><body package="SmallSuiteGenerator-Builder" selector="firstExecution">firstExecution	^ firstExecution		ifNil: [ firstExecution := true ]		ifNotNil: [ firstExecution := false ]</body><body package="SmallSuiteGenerator-Builder" selector="fitnessSeed">fitnessSeed	^ fitnessSeed</body><body package="SmallSuiteGenerator-Builder" selector="fitnessSeed:">fitnessSeed: number	fitnessSeed := number</body><body package="SmallSuiteGenerator-Builder" selector="generateLogs">generateLogs	self logClass: SGALog</body><body package="SmallSuiteGenerator-Builder" selector="initialSeed">initialSeed	^ initialSeed</body><body package="SmallSuiteGenerator-Builder" selector="numberOfGenerations">numberOfGenerations	^ numberOfIterations</body><body package="SmallSuiteGenerator-Builder" selector="outputPackageName">outputPackageName	^ self generatedClass outputPackageName</body><body package="SmallSuiteGenerator-Builder" selector="outputPackageName:">outputPackageName: anObject	self generatedClass outputPackageName: anObject</body><body package="SmallSuiteGenerator-Builder" selector="reportClass">reportClass	reportClass		ifNil: [ reportClass := SReportSTestCaseFactory on: self ].	^ reportClass</body><body package="SmallSuiteGenerator-Builder" selector="targetClassName">targetClassName	^ targetClassName</body><body package="SmallSuiteGenerator-Builder" selector="targetClassName:">targetClassName: aSymbol	targetClassName := aSymbol</body><body package="SmallSuiteGenerator-Builder" selector="targetPackageRegex">targetPackageRegex	^ self generatedClass targetPackageRegex</body><body package="SmallSuiteGenerator-Builder" selector="targetPackageRegex:">targetPackageRegex: anObject	self generatedClass targetPackageRegex: anObject</body><body package="SmallSuiteGenerator-Builder" selector="typeInfo">typeInfo	^ typeInfo</body><body package="SmallSuiteGenerator-Builder" selector="typeInfo:">typeInfo: aTypeInfo	aTypeInfo initializeIsAbstract.	typeInfoOrigin := aTypeInfo copy.	typeInfo := aTypeInfo</body><body package="SmallSuiteGenerator-Builder" selector="typeInfoOrigin">typeInfoOrigin	^ typeInfoOrigin</body><body package="SmallSuiteGenerator-Builder" selector="typeInfoSeed">typeInfoSeed	^ typeInfoSeed</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>set strategies</category><body package="SmallSuiteGenerator-Builder" selector="asDict:">asDict: aBoolean	self generatedClass asDict: aBoolean</body><body package="SmallSuiteGenerator-Builder" selector="limitToWait:">limitToWait: anInteger	SSTestShifter class		compile: 'limitToWait' , String cr , '	^ ' , anInteger printString</body><body package="SmallSuiteGenerator-Builder" selector="logClass:">logClass: aClass	SGAEngine class		compile: 'logClass' , String cr , '	^ ' , aClass printString</body><body package="SmallSuiteGenerator-Builder" selector="settingMethodClass:">settingMethodClass: aClass	SSTestShifter class		compile: 'defaultMethodsClass' , String cr , '	^ ' , aClass printString</body><body package="SmallSuiteGenerator-Builder" selector="setUpMethod:">setUpMethod: aString	aString ifNil: [ ^ self ].	self generatedClass compile: aString.	self settingMethodClass: self generatedClass</body><body package="SmallSuiteGenerator-Builder" selector="tearDownMethod:">tearDownMethod: aString	aString ifNil: [ ^ self ].	self generatedClass compile: aString.	self settingMethodClass: self generatedClass</body><body package="SmallSuiteGenerator-Builder" selector="vizClass:">vizClass: aClass	STestCaseFactory class		compile: 'vizClass' , String cr , '	^ ' , aClass printString</body><body package="SmallSuiteGenerator-Builder" selector="waitThreadMethod:">waitThreadMethod: aString	aString ifNil: [ ^ self ].	self generatedClass compile: aString.	self settingMethodClass: self generatedClass</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Builder" selector="seed:">seed: aNumber	initialSeed := aNumber.	SPlatform seed: aNumber</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>export</category><body package="SmallSuiteGenerator-Builder" selector="export:with:">export: aTestCase with: aSelector	| carReturn |	carReturn := String cr.	[ aTestCase generateAssertions.	self		compile:			aSelector , carReturn , aTestCase printDescriptiveComment , carReturn				, aTestCase printStringWithAssertions		classified: 'tests' ]		on: Error		do: [ self				compile:					aSelector , carReturn , 'self should:['						, aTestCase printStringWithAssertions , carReturn						, '] raise:Error.' , carReturn				classified: 'tests' ]</body><body package="SmallSuiteGenerator-Builder" selector="exportTests">exportTests	engine population		doWithIndex: [ :test :index | 			test lastMessage: lastMessage.			self export: test with: 'test' , index asString ].	self openOnGeneratedClass</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory class</class-id> <category>settings</category><body package="SmallSuiteGenerator-Builder" selector="parse:">parse: aString	^ [ SSGParser		parseFrom: (SPlatform rbParserClass parseExpression: aString) ]		on: Error		do: [ nil ]</body><body package="SmallSuiteGenerator-Builder" selector="resetToDefaults">resetToDefaults	"reset visualization class to NullViz"	((Array new: 1)		at: 1 put: #vizClass -&gt; SGANullViz;		yourself)		do: [ :val | 			STestCaseFactory class				compile: val key asString , String cr , '	^ ' , val value printString ]</body><body package="SmallSuiteGenerator-Builder" selector="vizClass">vizClass	^ SGANullViz</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Builder" selector="from:">from: configClass	| aTypeInfo parser |	aTypeInfo := configClass typeInfoValue copy.	aTypeInfo blackList: configClass decodeBlackList.	parser := self parse: configClass lastMessage asString.	^ self new		generatedClass: configClass;		fitness: configClass fitnessValue;		targetClassName: configClass aClass nameAsSymbol;		numberOfGenerations: configClass numberOfGenerations;		limitToWait: configClass limitToWait;		lastMessage: parser;		typeInfo: aTypeInfo;		yourself</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactoryPharo</class-id> <category>actions</category><body package="SmallSuiteGenerator-Builder" selector="initializeProfiler">initializeProfiler	profiler := self aSLProfilerCoverage		profilerForPackagesMatching: self targetPackageRegex.	(profiler allMethods select: #isNotMethodExtension)		do: #installGhosts		displayingProgress: 'Instrumenting ' , self targetPackageRegex</body><body package="SmallSuiteGenerator-Builder" selector="uninstall">uninstall	profiler uninstall</body></methods><methods><class-id>SmallSuiteGenerator.SInitialization</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Initialization" selector="initialize">initialize	configurationDict := self initializeDictionary</body><body package="SmallSuiteGenerator-Initialization" selector="initializeDictionary">initializeDictionary	^ self subclassResponsibility</body></methods><methods><class-id>SmallSuiteGenerator.SInitialization</class-id> <category>public tree building</category><body package="SmallSuiteGenerator-Initialization" selector="newInstance:with:">newInstance: testCaseFactory with: key	| instance |	instance := self copy: testCaseFactory.	(configurationDict at: key) value: instance.	instance createTestCases.	^ instance</body></methods><methods><class-id>SmallSuiteGenerator.SInitialization</class-id> <category>copying</category><body package="SmallSuiteGenerator-Initialization" selector="copy:">copy: testCaseFactory	^ testCaseFactory class new		typeInfo: testCaseFactory typeInfoOrigin copy;		fitness: testCaseFactory fitness class new;		targetClassName: testCaseFactory targetClassName;		targetPackageRegex: testCaseFactory targetPackageRegex;		outputPackageName: testCaseFactory outputPackageName;		seed: testCaseFactory initialSeed;		fitnessSeed: testCaseFactory fitnessSeed;		numberOfGenerations: testCaseFactory numberOfGenerations;		numberOfStatements: testCaseFactory engine numberOfStatements;		populationSize: testCaseFactory engine populationSize;		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SSelectionParameterization</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Initialization" selector="initializeDictionary">initializeDictionary	^ Dictionary new		at: #rankSelection			put:				[ :testCaseFactory | testCaseFactory selectionStrategy: SGARankSelection new ];		at: #tournamentSelection			put:				[ :testCaseFactory | testCaseFactory selectionStrategy: SGATournamentSelection new ];		at: #rouleteWheelSelection			put:				[ :testCaseFactory | testCaseFactory selectionStrategy: SGARouletteSelection new ];		at: #rankSelectionForTestCase			put:				[ :testCaseFactory | testCaseFactory selectionStrategyTestCase: SGARankSelection new ];		at: #tournamentSelectionForTestCase			put:				[ :testCaseFactory | testCaseFactory selectionStrategyTestCase: SGATournamentSelection new ];		at: #rouleteWheelSelectionForTestCase			put:				[ :testCaseFactory | testCaseFactory selectionStrategyTestCase: SGARouletteSelection new ];		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SmallTypeCollector class</class-id> <category>reset</category><body package="SmallSuiteGenerator-SmallType" selector="resetClassDict">resetClassDict	classDict := nil</body></methods><methods><class-id>SmallSuiteGenerator.SmallTypeCollector class</class-id> <category>accessing</category><body package="SmallSuiteGenerator-SmallType" selector="classDict">classDict	classDict		ifNil: [ classDict := Dictionary new.			Object withAllSubclasses				do: [ :class | classDict at: class name asLowercase put: class ] ].	^ classDict</body></methods><methods><class-id>SmallSuiteGenerator.SPlatform class</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Builder" selector="classConfigurationName">classConfigurationName	^ self subclassResponsibility</body><body package="SmallSuiteGenerator-Builder" selector="classTestCaseFactory">classTestCaseFactory	^ self configurationClass classTestCaseFactory</body><body package="SmallSuiteGenerator-Builder" selector="configurationClass">configurationClass	"answer the correct configurationClass according to Platform"	configurationClass		ifNil: [ configurationClass := self subclasses				detect: [ :aClass | 					[ Smalltalk at: aClass classConfigurationName.					true ]						on: Error						do: [ false ] ]				ifNone: [ nil ].			configurationClass				ifNil: [ self error: 'Error to look a configurationClass' ] ].	^ configurationClass</body><body package="SmallSuiteGenerator-Builder" selector="defaultLogName">defaultLogName	^ 'SmallSuiteLogger.log'</body><body package="SmallSuiteGenerator-Builder" selector="defaultSeed">defaultSeed	^ 100</body><body package="SmallSuiteGenerator-Builder" selector="implementationType">implementationType	^ self subclassResponsibility</body><body package="SmallSuiteGenerator-Builder" selector="initLevelToPrint">initLevelToPrint	level := 10</body><body package="SmallSuiteGenerator-Builder" selector="levelToPrint">levelToPrint	^ level</body><body package="SmallSuiteGenerator-Builder" selector="logName">logName	^ logName ifNil: [ self defaultLogName ]</body><body package="SmallSuiteGenerator-Builder" selector="logName:">logName: string	logName := string</body><body package="SmallSuiteGenerator-Builder" selector="lookUpClass:">lookUpClass: aClassName	^ Smalltalk at: aClassName ifAbsent: [ nil ]</body><body package="SmallSuiteGenerator-Builder" selector="randomGenerator">randomGenerator	randomGenerator ifNil: [ randomGenerator := self newRandomGenerator ].	^ randomGenerator</body><body package="SmallSuiteGenerator-Builder" selector="randomGenerator:">randomGenerator: sRandom	randomGenerator := sRandom</body><body package="SmallSuiteGenerator-Builder" selector="resetRandomGenerator">resetRandomGenerator	self randomGenerator: self newRandomGenerator</body><body package="SmallSuiteGenerator-Builder" selector="seed">seed	seed ifNil: [ seed := self defaultSeed ].	^ seed</body></methods><methods><class-id>SmallSuiteGenerator.SPlatform class</class-id> <category>tests</category><body package="SmallSuiteGenerator-Builder" selector="createTestCaseClass:inPackage:">createTestCaseClass: aClassName inPackage: aPackageName	^ self configurationClass		createTestCaseClass: aClassName		inPackage: aPackageName</body><body package="SmallSuiteGenerator-Builder" selector="testCaseClass">testCaseClass	^ self configurationClass testCaseClass</body></methods><methods><class-id>SmallSuiteGenerator.SPlatform class</class-id> <category>logging</category><body package="SmallSuiteGenerator-Builder" selector="cleanAllLogs">cleanAllLogs	self configurationClass cleanAllLogs</body><body package="SmallSuiteGenerator-Builder" selector="clearLog">clearLog	self configurationClass clearLog</body><body package="SmallSuiteGenerator-Builder" selector="saveOnLog:">saveOnLog: message	self configurationClass saveOnLog: message</body></methods><methods><class-id>SmallSuiteGenerator.SPlatform class</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Builder" selector="resetConfigurationClass">resetConfigurationClass	configurationClass := nil</body></methods><methods><class-id>SmallSuiteGenerator.SPlatform class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Builder" selector="fileLogger:">fileLogger: fileName	self configurationClass fileLogger: fileName</body><body package="SmallSuiteGenerator-Builder" selector="newRandomGenerator">newRandomGenerator	^ SRandom seed: self seed</body><body package="SmallSuiteGenerator-Builder" selector="seed:">seed: aNumber	seed := aNumber</body></methods><methods><class-id>SmallSuiteGenerator.SPlatform class</class-id> <category>actions</category><body package="SmallSuiteGenerator-Builder" selector="reduceLevel">reduceLevel	level ifNil: [ self initLevelToPrint ].	level := level - 1</body></methods><methods><class-id>SmallSuiteGenerator.SPlatform class</class-id> <category>settings</category><body package="SmallSuiteGenerator-Builder" selector="rbParserClass">rbParserClass	^ self configurationClass rbParserClass</body></methods><methods><class-id>SmallSuiteGenerator.SPlatformPharo class</class-id> <category>logging</category><body package="SmallSuiteGenerator-Builder" selector="cleanAllLogs">cleanAllLogs	self instanceLogger removeAllLoggers</body><body package="SmallSuiteGenerator-Builder" selector="clearLog">clearLog	self instanceLogger clearLog</body><body package="SmallSuiteGenerator-Builder" selector="saveOnLog:">saveOnLog: string	self defaultFileLogger record: string</body></methods><methods><class-id>SmallSuiteGenerator.SPlatformPharo class</class-id> <category>tests</category><body package="SmallSuiteGenerator-Builder" selector="createTestCaseClass:inPackage:">createTestCaseClass: aClassName inPackage: aPackageName	^ self testCaseClass		subclass: aClassName		instanceVariableNames: ''		classVariableNames: ''		package: aPackageName</body></methods><methods><class-id>SmallSuiteGenerator.SPlatformPharo class</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Builder" selector="classConfigurationName">classConfigurationName	^ superclass name , self implementationType</body><body package="SmallSuiteGenerator-Builder" selector="classTestCaseFactory">classTestCaseFactory	^ STestCaseFactoryPharo</body><body package="SmallSuiteGenerator-Builder" selector="instanceLogger">instanceLogger	^ self classLogger default</body></methods><methods><class-id>SmallSuiteGenerator.SPlatformPharo class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Builder" selector="fileLogger:">fileLogger: fileName	self logName: fileName.	^ self classLogger		ifNotNil: [ self instanceLogger fileLoggers ifEmpty: [ self createFileLogger ].			self instanceLogger fileLoggers				detect: [ :fileLogger | fileLogger fileName = fileName ]				ifNone: [ self createFileLogger.					self fileLogger: fileName ] ]		ifNil: [ nil ]</body></methods><methods><class-id>SmallSuiteGenerator.SPlatformPharo class</class-id> <category>actions</category><body package="SmallSuiteGenerator-Builder" selector="clearFileLog:">clearFileLog: string	self instanceLogger fileLoggers		detect: [ :fileLogger | fileLogger fileName = string ]		ifFound: [ :fileLogger | fileLogger clearLog ]</body><body package="SmallSuiteGenerator-Builder" selector="createFileLogger">createFileLogger	self instanceLogger ensureFileLoggerNamed: self logName</body><body package="SmallSuiteGenerator-Builder" selector="defaultFileLogger">defaultFileLogger	self classLogger		ifNotNil: [ self instanceLogger fileLoggers ifEmpty: [ self createFileLogger ].			^ self instanceLogger fileLoggers				detect: [ :fileLogger | fileLogger fileName = self logName ] ]</body></methods><methods><class-id>SmallSuiteGenerator.SGARandomSelection</class-id> <category>selection</category><body package="SmallSuiteGenerator-GA" selector="selectJustOneOf:with:">selectJustOneOf: aCollection with: probabilities	^ self random selectAtRandom: aCollection</body><body package="SmallSuiteGenerator-GA" selector="selectOf:">selectOf: aCollection	^ self random collectAtRandom: aCollection</body></methods><methods><class-id>SmallSuiteGenerator.SUndefinedObject</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Info" selector="printOn:">printOn: aStream	"Refer to the comment in Object|printOn:."	aStream nextPutAll: 'nil'</body></methods><methods><class-id>SmallSuiteGenerator.SSeedingParameterization</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Initialization" selector="initialize">initialize	super initialize.	numberToChangeSeed := 0</body><body package="SmallSuiteGenerator-Initialization" selector="initializeDictionary">initializeDictionary	^ Dictionary new		at: #lowerSeed			put: [ :testCaseFactory | 			testCaseFactory				seed: testCaseFactory initialSeed - self numberToChangeSeed ];		at: #greaterSeed			put: [ :testCaseFactory | 			testCaseFactory				seed: testCaseFactory initialSeed + self numberToChangeSeed ];		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SSeedingParameterization</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Initialization" selector="numberToChangeSeed">numberToChangeSeed	numberToChangeSeed == 0		ifTrue: [ numberToChangeSeed := 10 ].	^ numberToChangeSeed</body><body package="SmallSuiteGenerator-Initialization" selector="numberToChangeSeed:">numberToChangeSeed: number	numberToChangeSeed := number</body></methods><methods><class-id>SmallSuiteGenerator.SGACrossoverOperation</class-id> <category>actions</category><body package="SmallSuiteGenerator-GA" selector="crossover:with:">crossover: testCaseA with: testCaseB	| alpha offSpring1 offSpring2 |	self checkReferencesOf: testCaseA withDescription: 'testCase'.	self checkReferencesOf: testCaseB withDescription: 'testCase'.	"join typeInfo of testCaseA with testCaseB"	testCaseA typeInfo joinWith: testCaseB typeInfo.	alpha := self alpha.	"first alpha(p1) and last (1-alpha)(p2)"	offSpring1 := self offSpringOf: testCaseA and: testCaseB using: alpha.	self checkReferencesOf: offSpring1 withDescription: 'offspring'.	"first alpha(p2) and last (1-alpha)(p1)"	offSpring2 := self offSpringOf: testCaseB and: testCaseA using: alpha.	self checkReferencesOf: offSpring2 withDescription: 'offspring'.	^ (Array with: offSpring1 with: offSpring2)		do: [ :e | e lastMessage: testCaseA lastMessage ]</body><body package="SmallSuiteGenerator-GA" selector="offSpringOf:and:using:">offSpringOf: parentA and: parentB using: alpha	| sizeA sizeB offSpring limitA limitB |	sizeA := parentA length.	sizeB := parentB length.	offSpring := SSTestCase with: parentA typeInfo copy.	offSpring targetClassName: parentA targetClassesName.	limitA := (sizeA * alpha) asInteger max: 1.	1 to: limitA do: [ :i | 		| stm |		stm := parentA statements at: i.		offSpring addStatement: stm copy.		offSpring assignId ].	limitB := ((alpha * sizeB) asInteger max: 1) + 1.	limitB to: sizeB do: [ :i | 		| stm |		stm := parentB statements at: i.		[ stm insertOn: offSpring ]			on: Error			do: [ "nothing" nil ] ].	offSpring		generationNumber: parentA generationNumber + 1;		clean.	^ offSpring</body></methods><methods><class-id>SmallSuiteGenerator.SGACrossoverOperation</class-id> <category>validation</category><body package="SmallSuiteGenerator-GA" selector="checkReferencesOf:withDescription:">checkReferencesOf: testCase withDescription: aString	self		assert: testCase validReferences		description: aString , ' must have valid references'</body></methods><methods><class-id>SmallSuiteGenerator.SGACrossoverOperation</class-id> <category>accessing</category><body package="SmallSuiteGenerator-GA" selector="alpha">alpha	^ (self random selectAtRandom: (0.1 to: 0.9 by: 0.1)) round: 1</body></methods><methods><class-id>SmallSuiteGenerator.SExtensionsTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-Core" selector="createStudent">createStudent	^ SStudent new		name: 'Pedro';		id: 5</body><body package="SmallSuiteGenerator-Tests-Core" selector="testMutateToChange">testMutateToChange	self assert: true mutateToChange equals: false.	self assert: false mutateToChange equals: true.	self deny: 1234 mutateToChange equals: 1234.	self deny: 23.34 mutateToChange equals: 23.34.	self deny: $e mutateToChange equals: $e.	self deny: '$character' mutateToChange equals: '$character'.	self deny: 'hello' mutateToChange equals: 'hello'.	self assert: #(1 2 5 6) mutateToChange equals: #(1 2 5 6).	self deny: '#(1 2 5 6' mutateToChange equals: '#(1 2 5 6'.	self		assert: (SStack newStackWith: #(1 6 2 4)) mutateToChange		equals: (SStack newStackWith: #(1 6 2 4)).	self		assert: self createStudent mutateToChange storeString		equals: self createStudent storeString</body><body package="SmallSuiteGenerator-Tests-Core" selector="testStoreString">testStoreString	self assert: 1 storeString equals: '1'.	self assert: 4.6 storeString equals: '4.6'.	self assert: true storeString equals: 'true'.	self assert: false storeString equals: 'false'.	self assert: 'hello' storeString equals: '''hello'''.	self assert: $d storeString equals: '$d'.	self assert: (SSTeacher new name: 'Mary') storeString isNotEmpty.	self assert: (SStudent new name: 'Alan') storeString isNotEmpty</body></methods><methods><class-id>SmallSuiteGenerator.SConfigurationTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-Core" selector="testFileLogger">testFileLogger	self shouldnt: (SPlatform fileLogger: 'STestLog.log') raise: Error</body></methods><methods><class-id>SmallSuiteGenerator.SConfigurationTest</class-id> <category>running</category><body package="SmallSuiteGenerator-Tests-Core" selector="tearDown">tearDown	SPlatform clearLog.	SPlatform cleanAllLogs</body></methods><methods><class-id>SmallSuiteGenerator.SSVariableNameSwapper</class-id> <category>intialization</category><body package="SmallSuiteGenerator-Core" selector="initialize">initialize	super initialize.	nameMap := Dictionary new</body></methods><methods><class-id>SmallSuiteGenerator.SSVariableNameSwapper</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Core" selector="nameMap">nameMap	^ nameMap</body><body package="SmallSuiteGenerator-Core" selector="nameMap:">nameMap: anObject	nameMap := anObject</body><body package="SmallSuiteGenerator-Core" selector="visitVariable:">visitVariable: aVariable	aVariable id ifNotNil: [ aVariable id: (nameMap at: aVariable id) ]</body></methods><methods><class-id>SmallSuiteGenerator.SSVariableNameSwapper class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Core" selector="negate:">negate: testCase	| map |	map := Dictionary new.	testCase statements		do:			[ :assign | map at: assign variable id put: assign variable id * -1 ].	testCase accept: (self new nameMap: map)</body><body package="SmallSuiteGenerator-Core" selector="repairNamesOf:">repairNamesOf: testCase	| map |	map := Dictionary new.	self negate: testCase.	testCase statements		doWithIndex: [ :stm :index | map at: stm variable id put: index - 1 ].	testCase accept: (self new nameMap: map)</body></methods><methods><class-id>SmallSuiteGenerator.SExpression</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Core" selector="allParents">allParents	"I return my self with all my parents"	^ parent		ifNil: #()		ifNotNil: [ Set new				add: parent;				addAll: parent allParents;				yourself ]</body><body package="SmallSuiteGenerator-Core" selector="id">id	^ id</body><body package="SmallSuiteGenerator-Core" selector="id:">id: anObject	id := anObject</body><body package="SmallSuiteGenerator-Core" selector="parent">parent	^ parent</body><body package="SmallSuiteGenerator-Core" selector="parent:">parent: anObject	parent := anObject</body><body package="SmallSuiteGenerator-Core" selector="reference">reference	^ self</body><body package="SmallSuiteGenerator-Core" selector="referenceTo:">referenceTo: aClassName	^ false</body><body package="SmallSuiteGenerator-Core" selector="returnType">returnType	^ returnType</body><body package="SmallSuiteGenerator-Core" selector="returnType:">returnType: anObject	returnType := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SExpression</class-id> <category>querying</category><body package="SmallSuiteGenerator-Core" selector="containsVariable:">containsVariable: aVariable	^ self subclassResponsibility</body><body package="SmallSuiteGenerator-Core" selector="isPrimitive:">isPrimitive: anObject	^ (anObject isKindOf: Number)		or: [ (anObject isKindOf: Boolean) or: [ anObject isKindOf: String ] ]</body><body package="SmallSuiteGenerator-Core" selector="isThereEnoughArgumentsToBuild:">isThereEnoughArgumentsToBuild: aTestCase	^ true</body></methods><methods><class-id>SmallSuiteGenerator.SExpression</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Core" selector="initialize">initialize	super initialize.	identifier := self class nextIdentifier</body></methods><methods><class-id>SmallSuiteGenerator.SExpression</class-id> <category>copying</category><body package="SmallSuiteGenerator-Core" selector="copy">copy	^ self class new		id: self id;		returnType: self returnType;		parent: self</body></methods><methods><class-id>SmallSuiteGenerator.SExpression</class-id> <category>testing</category><body package="SmallSuiteGenerator-Core" selector="isFactoryMessage">isFactoryMessage	^ false</body><body package="SmallSuiteGenerator-Core" selector="isMessage">isMessage	^ false</body><body package="SmallSuiteGenerator-Core" selector="isSequence">isSequence	^ false</body></methods><methods><class-id>SmallSuiteGenerator.SExpression</class-id> <category>actions</category><body package="SmallSuiteGenerator-Core" selector="changeOn:">changeOn: aTestCase	^ self subclassResponsibility</body><body package="SmallSuiteGenerator-Core" selector="insertOn:">insertOn: aTestCase	</body></methods><methods><class-id>SmallSuiteGenerator.SExpression</class-id> <category>printing</category><body package="SmallSuiteGenerator-Core" selector="printOn:">printOn: aStream	self accept: (SSStandardPrinter on: aStream)</body></methods><methods><class-id>SmallSuiteGenerator.SExpression</class-id> <category>error handling</category><body package="SmallSuiteGenerator-Core" selector="serror:">serror: aString	"It throws an error signal with the string passed as argument, it is important to distinguish parsing error with others"	^ SError signal: aString</body></methods><methods><class-id>SmallSuiteGenerator.SExpression</class-id> <category>visitor</category><body package="SmallSuiteGenerator-Core" selector="accept:">accept: aSSVisitor	^ self subclassResponsibility</body></methods><methods><class-id>SmallSuiteGenerator.SExpression</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Core" selector="=">= another	"I return true if all my attributes are equals than the another"	^ self class = another class		and:			[ self id = another id and: [ returnType = another returnType ] ]</body><body package="SmallSuiteGenerator-Core" selector="hash">hash	^ self id hash bitXor: self returnType hash</body></methods><methods><class-id>SmallSuiteGenerator.SExpression class</class-id> <category>as yet unclassified</category><body package="SmallSuiteGenerator-Core" selector="nextIdentifier">nextIdentifier	nextId ifNil: [ nextId := 0 ].	^ nextId := nextId + 1</body></methods><methods><class-id>SmallSuiteGenerator.SExpression class</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Core" selector="resetId">resetId	nextId := nil</body></methods><methods><class-id>SmallSuiteGenerator.SExpression class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Core" selector="isPrimitive:">isPrimitive: anObject	^ self new isPrimitive: anObject</body></methods><methods><class-id>SmallSuiteGenerator.SExpression class</class-id> <category>error handling</category><body package="SmallSuiteGenerator-Core" selector="error:">error: string	^ SError signal: string</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Core" selector="args">args	^ args</body><body package="SmallSuiteGenerator-Core" selector="args:">args: anObject	args := anObject</body><body package="SmallSuiteGenerator-Core" selector="id">id	^ receiver id</body><body package="SmallSuiteGenerator-Core" selector="receiver">receiver	^ receiver</body><body package="SmallSuiteGenerator-Core" selector="receiver:">receiver: anObject	receiver := anObject</body><body package="SmallSuiteGenerator-Core" selector="selector">selector	^ selector</body><body package="SmallSuiteGenerator-Core" selector="selector:">selector: anObject	selector := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage</class-id> <category>querying</category><body package="SmallSuiteGenerator-Core" selector="containsVariable:">containsVariable: aVariable	^ (self receiver containsVariable: aVariable)		or: [ self args anySatisfy: [ :arg | arg containsVariable: aVariable ] ]</body><body package="SmallSuiteGenerator-Core" selector="isThereEnoughArgumentsToBuild:">isThereEnoughArgumentsToBuild: aTestCase	^ (SSVariablesWithIdCollector new visit: self) variablesWithId		allSatisfy: [ :var | 			(aTestCase containsVariable: var)				or: (aTestCase containsVariableWithReturnType: var returnType) ]</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Core" selector="initialize">initialize	super initialize.	args := OrderedCollection new: 2</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage</class-id> <category>copying</category><body package="SmallSuiteGenerator-Core" selector="copy">copy	| copy |	copy := super copy.	copy		args: args deepCopy;		receiver: receiver copy;		selector: selector copy.	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage</class-id> <category>actions</category><body package="SmallSuiteGenerator-Core" selector="changeOn:">changeOn: aTestCase	"nothing to change"	| val |	val := self random next.	val &lt;= 0.3		ifTrue: [ aTestCase addAlternativeReceiverFor: self ]		ifFalse: [ val &lt;= 0.6				ifTrue: [ aTestCase addAlternativeSelectorFor: self ]				ifFalse: [ aTestCase addAlternativeArgsFor: self ] ]</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage</class-id> <category>visitor</category><body package="SmallSuiteGenerator-Core" selector="accept:">accept: aSSVisitor	^ aSSVisitor visitAbstractMessage: self</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Core" selector="=">= other	^ super = other		and: [ args = other args				and:					[ receiver = other receiver and: [ selector = other selector ] ] ]</body><body package="SmallSuiteGenerator-Core" selector="hash">hash	^ super hash		bitXor: (receiver hash bitXor: (selector hash bitXor: args hash))</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage class</class-id> <category>creation</category><body package="SmallSuiteGenerator-Core" selector="args:with:">args: aMethodTypeInfo with: statements	| dict |	(statements isEmpty or: [ aMethodTypeInfo argTypes isNil ])		ifTrue: [ ^ #() ].	dict := Dictionary new.	(SPlatform randomGenerator collectAtRandom: statements)		do: [ :stm | dict at: stm returnType put: stm variable copy ].	^ aMethodTypeInfo argTypes		collect: [ :aTypeReturn | 			| ft |			ft := (SPlatform randomGenerator collectAtRandom: aTypeReturn types)				detect: [ :type | dict at: type ifPresent: [ true ] ifAbsent: [ false ] ]				ifNone: [ nil ].	"lack to update types of MultiTypeInfo"			ft				ifNil: [ self						error:							'Cannot build the method call: ' , aMethodTypeInfo selector								, ', even it was tried to build the argument first' ].			dict at: ft ]</body><body package="SmallSuiteGenerator-Core" selector="receiver:selector:args:">receiver: receiver selector: aSelector args: aArgCollection	^ self new		selector: aSelector;		receiver: receiver;		args: aArgCollection;		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SAssertionMessage</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Core" selector="initialize">initialize	super initialize.	receiver := SSelf new</body></methods><methods><class-id>SmallSuiteGenerator.SAssertionMessage</class-id> <category>visitor</category><body package="SmallSuiteGenerator-Core" selector="accept:">accept: aSSVisitor	^ aSSVisitor visitAssertionMessage: self</body></methods><methods><class-id>SmallSuiteGenerator.SAssertionMessage class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Core" selector="for:">for: aExecutionContext	^ self subclassResponsibility</body></methods><methods><class-id>SmallSuiteGenerator.SFactoryMessage</class-id> <category>action</category><body package="SmallSuiteGenerator-Core" selector="changeOn:">changeOn: aTestCase	"nothing to change"	aTestCase addAlternativeFactoryMessage: self</body><body package="SmallSuiteGenerator-Core" selector="insertOn:">insertOn: aTestCase	^ aTestCase		addFactoryMessage: self returnType		usingSelector: self selector</body></methods><methods><class-id>SmallSuiteGenerator.SFactoryMessage</class-id> <category>querying</category><body package="SmallSuiteGenerator-Core" selector="referenceTo:">referenceTo: aClassName	^ receiver referenceTo: aClassName</body></methods><methods><class-id>SmallSuiteGenerator.SFactoryMessage</class-id> <category>visitor</category><body package="SmallSuiteGenerator-Core" selector="accept:">accept: aSSVisitor	^ aSSVisitor visitFactoryMessage: self</body></methods><methods><class-id>SmallSuiteGenerator.SFactoryMessage</class-id> <category>testing</category><body package="SmallSuiteGenerator-Core" selector="isFactoryMessage">isFactoryMessage	^ true</body></methods><methods><class-id>SmallSuiteGenerator.SFactoryMessage class</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Core" selector="default:">default: aClassName	^ self new		receiver:			(SVariable new				varName: aClassName;				returnType: aClassName;				yourself);		selector: #new;		returnType: aClassName;		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SMessage</class-id> <category>testing</category><body package="SmallSuiteGenerator-Core" selector="isMessage">isMessage	^ true</body></methods><methods><class-id>SmallSuiteGenerator.SMessage</class-id> <category>action</category><body package="SmallSuiteGenerator-Core" selector="insertOn:">insertOn: aTestCase	^ aTestCase addMessage: self selector from: self receiver returnType</body></methods><methods><class-id>SmallSuiteGenerator.SMessage</class-id> <category>visitor</category><body package="SmallSuiteGenerator-Core" selector="accept:">accept: aSSVisitor	^ aSSVisitor visitMessage: self</body></methods><methods><class-id>SmallSuiteGenerator.SMessage class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Core" selector="newFromReceiver:method:andPreviousStatements:">newFromReceiver: aReceiver method: aMethod andPreviousStatements: statements	^ self new		returnType: (aMethod returnTypeFor: aReceiver);		selector: aMethod selector;		receiver: aReceiver;		args: (self args: aMethod with: statements);		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SRemoveTest</class-id> <category>mutation-remove</category><body package="SmallSuiteGenerator-Tests-Core" selector="testRemoveArgsFactoryMessage">testRemoveArgsFactoryMessage	| testCase newTestCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		targetClassName: 'SFoo' fullClassNameSymbol;		addFactoryMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3'				with: '_var1 := ' , 'SFoo' fullClassName , ' score: _var0 ').	newTestCase := testCase removeStatementAt: 1.	self		assertCollection: (newTestCase statements collect: #printString)		hasSameElements: Array new.	self assert: newTestCase validReferences</body><body package="SmallSuiteGenerator-Tests-Core" selector="testRemoveArgsMessage">testRemoveArgsMessage	| testCase newTestCase targetClass |	targetClass := 'SFoo' fullClassNameSymbol.	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		targetClassName: targetClass;		addMessage: #return: from: targetClass.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			((Array new: 4)				at: 1 put: '_var0 := 7.3';				at: 2 put: '_var1 := ' , targetClass asString , ' score: _var0 ';				at: 3 put: '_var2 := ''hello''';				at: 4 put: '_var3 := _var1 return: _var2 ';				yourself).	newTestCase := testCase removeStatementAt: 3.	self		assertCollection: (newTestCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3'				with: '_var1 := ' , targetClass asString , ' score: _var0 ').	self assert: testCase validReferences</body><body package="SmallSuiteGenerator-Tests-Core" selector="testRemoveArgsMessage2">testRemoveArgsMessage2	| testCase newTestCase targetClass |	targetClass := 'SFoo' fullClassNameSymbol.	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase targetClassName: targetClass.	testCase		addMessage: #return: from: targetClass;		addMessage: #return: from: targetClass.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			((Array new: 5)				at: 1 put: '_var0 := 7.3';				at: 2 put: '_var1 := ' , targetClass asString , ' score: _var0 ';				at: 3 put: '_var2 := ''hello''';				at: 4 put: '_var3 := _var1 return: _var2 ';				at: 5 put: '_var4 := _var1 return: _var3 ';				yourself).	newTestCase := testCase removeStatementAt: 4.	newTestCase repairIds.	self		assertCollection: (newTestCase statements collect: #printString)		hasSameElements:			((Array new: 4)				at: 1 put: '_var0 := 7.3';				at: 2 put: '_var1 := ' , targetClass asString , ' score: _var0 ';				at: 3 put: '_var2 := ''hello''';				at: 4 put: '_var3 := _var1 return: _var2 ';				yourself).	self assert: newTestCase validReferences</body><body package="SmallSuiteGenerator-Tests-Core" selector="testRemoveFactoryMessage">testRemoveFactoryMessage	| testCase newTestCase targetClass |	targetClass := 'SFoo' fullClassNameSymbol.	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		targetClassName: targetClass;		addFactoryMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 7.3'				with: '_var1 := ' , targetClass asString , ' score: _var0 ').	newTestCase := testCase removeStatementAt: 2.	newTestCase repairIds.	self		assertCollection: (newTestCase statements collect: #printString)		hasSameElements: #('_var0 := 7.3')</body><body package="SmallSuiteGenerator-Tests-Core" selector="testRemoveFieldAccessMessage">testRemoveFieldAccessMessage	| testCase newTestCase targetClass |	targetClass := 'SFoo' fullClassName.	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		targetClassName: #SFoo fullClassNameSymbol;		addFieldAccessMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			((Array new: 3)				at: 1 put: '_var0 := 7.3';				at: 2 put: '_var1 := ' , targetClass , ' score: _var0 ';				at: 3 put: '_var2 := _var1 score';				yourself).	newTestCase := testCase removeStatementAt: 3.	newTestCase repairIds.	self		assertCollection: (newTestCase statements collect: #printString)		hasSameElements:			((Array new: 2)				at: 1 put: '_var0 := 7.3';				at: 2 put: '_var1 := ' , targetClass , ' score: _var0 ';				yourself)</body><body package="SmallSuiteGenerator-Tests-Core" selector="testRemoveLiteral">testRemoveLiteral	| testCase targetClass newTestCase |	targetClass := 'SFoo' fullClassNameSymbol.	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		targetClassName: targetClass;		addMessage: #return: from: targetClass.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			((Array new: 4)				at: 1 put: '_var0 := 7.3';				at: 2 put: '_var1 := ' , targetClass asString , ' score: _var0 ';				at: 3 put: '_var2 := ''hello''';				at: 4 put: '_var3 := _var1 return: _var2 ';				yourself).	newTestCase := testCase removeStatementAt: 1.	newTestCase repairIds.	self		assertCollection: (newTestCase statements collect: #printString)		hasSameElements:			((Array new: 1)				at: 1 put: '_var0 := ''hello''';				yourself)</body><body package="SmallSuiteGenerator-Tests-Core" selector="testRemoveMessage">testRemoveMessage	| testCase targetClass newTestCase |	targetClass := 'SFoo' fullClassNameSymbol.	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		targetClassName: targetClass;		addMessage: #return: from: targetClass.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			((Array new: 4)				at: 1 put: '_var0 := 7.3';				at: 2 put: '_var1 := ' , targetClass asString , ' score: _var0 ';				at: 3 put: '_var2 := ''hello''';				at: 4 put: '_var3 := _var1 return: _var2 ';				yourself).	newTestCase := testCase removeStatementAt: 4.	self		assertCollection: (newTestCase statements collect: #printString)		hasSameElements:			((Array new: 3)				at: 1 put: '_var0 := 7.3';				at: 2 put: '_var1 := ' , targetClass asString , ' score: _var0 ';				at: 3 put: '_var2 := ''hello''';				yourself)</body><body package="SmallSuiteGenerator-Tests-Core" selector="testRemoveReceiverFieldAccessMessage">testRemoveReceiverFieldAccessMessage	| testCase targetClass newTestCase |	targetClass := 'SFoo' fullClassNameSymbol.	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		targetClassName: targetClass;		addFieldAccessMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			((Array new: 3)				at: 1 put: '_var0 := 7.3';				at: 2 put: '_var1 := ' , targetClass asString , ' score: _var0 ';				at: 3 put: '_var2 := _var1 score';				yourself).	newTestCase := testCase removeStatementAt: 2.	self		assertCollection: (newTestCase statements collect: #printString)		hasSameElements:			((Array new: 1)				at: 1 put: '_var0 := 7.3';				yourself)</body><body package="SmallSuiteGenerator-Tests-Core" selector="testRemoveReceiverFieldAccessMessage2">testRemoveReceiverFieldAccessMessage2	| testCase targetClass newTestCase |	targetClass := 'SFoo' fullClassNameSymbol.	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		targetClassName: targetClass;		addFactoryMessage;		addFactoryMessage;		addFieldAccessMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			((Array new: 4)				at: 1 put: '_var0 := 7.3';				at: 2 put: '_var1 := ' , targetClass asString , ' score: _var0 ';				at: 3 put: '_var2 := ' , targetClass asString , ' score: _var0 ';				at: 4 put: '_var3 := _var1 score';				yourself).	newTestCase := testCase removeStatementAt: 3.	newTestCase repairIds.	self		assertCollection: (newTestCase statements collect: #printString)		hasSameElements:			((Array new: 3)				at: 1 put: '_var0 := 7.3';				at: 2 put: '_var1 := ' , targetClass asString , ' score: _var0 ';				at: 3 put: '_var2 := _var1 score';				yourself)</body><body package="SmallSuiteGenerator-Tests-Core" selector="testRemoveReceiverMessage">testRemoveReceiverMessage	| testCase targetClass newTestCase |	targetClass := 'SFoo' fullClassNameSymbol.	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		targetClassName: targetClass;		addMessage: #return: from: targetClass.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			((Array new: 4)				at: 1 put: '_var0 := 7.3';				at: 2 put: '_var1 := ' , targetClass asString , ' score: _var0 ';				at: 3 put: '_var2 := ''hello''';				at: 4 put: '_var3 := _var1 return: _var2 ';				yourself).	newTestCase := testCase removeStatementAt: 2.	newTestCase repairIds.	self		assertCollection: (newTestCase statements collect: #printString)		hasSameElements:			((Array new: 2)				at: 1 put: '_var0 := 7.3';				at: 2 put: '_var1 := ''hello''';				yourself)</body></methods><methods><class-id>SmallSuiteGenerator.SSNullMethods class</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Strategies" selector="exportMethodsFor:">exportMethodsFor: aFactory	</body><body package="SmallSuiteGenerator-Strategies" selector="on:execute:">on: aTestCase execute: aBlock	^ aBlock value: aTestCase</body></methods><methods><class-id>SmallSuiteGenerator.SFitnessFunction</class-id> <category>accesing</category><body package="SmallSuiteGenerator-GA" selector="functionName">functionName	^ self subclassResponsibility</body><body package="SmallSuiteGenerator-GA" selector="profiler">profiler	^ profiler</body><body package="SmallSuiteGenerator-GA" selector="profiler:">profiler: aProfiler	profiler := aProfiler</body></methods><methods><class-id>SmallSuiteGenerator.SFitnessFunction</class-id> <category>actions</category><body package="SmallSuiteGenerator-GA" selector="compute:">compute: testCaseCollection	self setUp.	self run: testCaseCollection.	self tearDown</body><body package="SmallSuiteGenerator-GA" selector="fitnessOf:">fitnessOf: aTestCase	self subclassResponsibility</body><body package="SmallSuiteGenerator-GA" selector="fitnessOfBlock:">fitnessOfBlock: aBlock	</body><body package="SmallSuiteGenerator-GA" selector="run:">run: testCaseCollection	testCaseCollection		do: [ :testCase | 			testCase length &gt; 0				ifTrue: [ profiler cleanBlocksOfMethods.					testCase runWithoutAssertionsAndLastStatement.					SGAEngine logClass						summaryExecutionMethodsOf: testCase						with: profiler.					self fitnessOf: testCase ]				ifFalse: [ testCase fitness at: self functionName put: 0 ] ]</body><body package="SmallSuiteGenerator-GA" selector="runPopulation:">runPopulation: testCaseCollection	profiler cleanBlocksOfMethods.	testCaseCollection		do: [ :testCase | 			testCase length &gt; 0				ifTrue: [ testCase runWithoutAssertionsAndLastStatement ] ].	^ profiler summaryMethodsOf: targetClass</body><body package="SmallSuiteGenerator-GA" selector="setUp">setUp	</body><body package="SmallSuiteGenerator-GA" selector="tearDown">tearDown	</body></methods><methods><class-id>SmallSuiteGenerator.SFitnessFunction</class-id> <category>accessing</category><body package="SmallSuiteGenerator-GA" selector="targetClass:">targetClass: anObject	targetClass := anObject</body><body package="SmallSuiteGenerator-GA" selector="typeInfo:">typeInfo: anObject	profiler typeInfo: anObject</body></methods><methods><class-id>SmallSuiteGenerator.SError class</class-id> <category>exceptioninstantiator</category><body package="SmallSuiteGenerator-Core" selector="signal:">signal: anObject	^ self new signal: anObject</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>converting</category><body package="SmallSuiteGenerator-Info" selector="asTypeInfo:">asTypeInfo: aTypeCollector	"Transform a type collector as type information"	| aBlackList |	aBlackList := self blackList.	self cleanBlockClosuresOf: aTypeCollector.	aTypeCollector allClasses		do: [ :aSpyClass | 			aBlackList				select: [ :aMethod | aMethod fullClassName == aSpyClass className ]				thenDo: [ :aMethod | aSpyClass removeMethod: aMethod ].			self addClassInfo: (STypeClassInfo asClassInfo: aSpyClass) ].	self joinScalars: aTypeCollector scalars copy.	^ self</body><body package="SmallSuiteGenerator-Info" selector="cleanBlockClosuresOf:">cleanBlockClosuresOf: aTypeCollector	[ | cleanBlocks |	cleanBlocks := (aTypeCollector scalars at: #BlockClosure)		select: [ :aBlock | aBlock isClean ].	aTypeCollector scalars at: #BlockClosure put: cleanBlocks ]		on: Error		do: [  ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>lookup</category><body package="SmallSuiteGenerator-Info" selector="classMethodType:from:">classMethodType: aSelector from: aClassName	aSelector = #new		ifTrue: [ ^ self defaultFactoryMessageFrom: aClassName ].	(self factoryMessagesFrom: aClassName)		detect: [ :aMessage | aMessage selector = aSelector ]		ifFound: [ :aMessage | ^ aMessage ].	self		error:			'ClassMethodType of selector: ' , aSelector				, ' is not found in class: ' , aClassName</body><body package="SmallSuiteGenerator-Info" selector="factoryMessagesFrom:">factoryMessagesFrom: aClassName	^ types		flatCollect: [ :aClassType | 			aClassType factoryMessages				select: [ :aMessage | aMessage returnType types includes: aClassName ] ]</body><body package="SmallSuiteGenerator-Info" selector="methodType:from:">methodType: aSelector from: aClassName	| messages |	messages := self messagesFrom: aClassName.	^ messages		detect: [ :methodInfo | methodInfo selector = aSelector ]		ifNone: [ self				error:					('MethodType of selector: {1} is not found in class: {2}'						format:							((Array new: 2)								at: 1 put: aSelector;								at: 2 put: aClassName;								yourself)) ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>actions</category><body package="SmallSuiteGenerator-Info" selector="collectSubclassesOf:">collectSubclassesOf: type	[ (#(#Object #Metaclass #Class #ProtoObject #Behavior #ClassDescription)		includes: type)		ifTrue: [ ^ Array with: type ]		ifFalse: [ ^ Array				with: type				withAll: (type asClass allSubclasses collect: #name) ] ]		on: Error		do: [ ^ Array with: type ]</body><body package="SmallSuiteGenerator-Info" selector="exportDataCSV:withFilter:">exportDataCSV: neoCSVWriter withFilter: aSymbol	types		do: [ :type | type exportDataCSV: neoCSVWriter withFilter: aSymbol ]</body><body package="SmallSuiteGenerator-Info" selector="joinScalars:">joinScalars: aDict	aDict associations		do: [ :assoc | 			scalars				at: assoc key				ifPresent:					[ :values | scalars at: assoc key put: (self union: values with: assoc value) ]				ifAbsentPut: [ assoc value asOrderedCollection asSet asOrderedCollection ] ]</body><body package="SmallSuiteGenerator-Info" selector="joinWith:">joinWith: otherTypeInfo	cacheMessagesFrom := Dictionary new.	otherTypeInfo types		do: [ :aTypeClass | self addClassInfo: aTypeClass ].	self joinScalars: otherTypeInfo scalars</body><body package="SmallSuiteGenerator-Info" selector="scalar:with:">scalar: aClassName with: aValue	scalars at: aClassName put: aValue asSet asOrderedCollection</body><body package="SmallSuiteGenerator-Info" selector="union:with:">union: aColl1 with: aColl2	[ | set |	set := aColl1 asSet		addAll: aColl2;		yourself.	^ set asOrderedCollection ]		on: Error		do: [ ^ aColl1 ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Info" selector="initialize">initialize	super initialize.	types := Dictionary new.	scalars := Dictionary new.	cacheMessagesFrom := Dictionary new.	self initializeBlackList</body><body package="SmallSuiteGenerator-Info" selector="initializeBlackList">initializeBlackList	blackList ifNil: [ blackList := Array new ]</body><body package="SmallSuiteGenerator-Info" selector="initializeIsAbstract">initializeIsAbstract	self types values do: [ :e | e isAbstract ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Info" selector="accessMessagesFrom:">accessMessagesFrom: aClassName	^ types		flatCollect: [ :aClassType | 			aClassType accessMessages				select: [ :aMessage | aMessage receiver types includes: aClassName ] ]</body><body package="SmallSuiteGenerator-Info" selector="classAt:">classAt: aClassName	^ types at: aClassName</body><body package="SmallSuiteGenerator-Info" selector="classAt:ifNone:">classAt: aClassName ifNone: aBlock	^ types at: aClassName ifAbsent: aBlock</body><body package="SmallSuiteGenerator-Info" selector="classAt:ifPresent:">classAt: aClassName ifPresent: aBlock	^ types at: aClassName ifPresent: aBlock ifAbsent: [  ]</body><body package="SmallSuiteGenerator-Info" selector="classes">classes	classes ifNil: [ classes := Dictionary new ].	types		keysDo: [ :aClassName | 			classes				at: aClassName				ifAbsentPut: (SPlatform lookUpClass: aClassName) ].	^ classes</body><body package="SmallSuiteGenerator-Info" selector="isAbstractClass:">isAbstractClass: symbol	^ (self classAt: symbol) isAbstract</body><body package="SmallSuiteGenerator-Info" selector="isMethodWith:and:in:">isMethodWith: selector and: aClass in: aBlackList	^ aBlackList		anySatisfy: [ :each | each mclass = aClass and: [ each selector = selector ] ]</body><body package="SmallSuiteGenerator-Info" selector="messagesFrom:">messagesFrom: aClassName	^ cacheMessagesFrom		at: aClassName		ifAbsentPut: [ | classInfos |			classInfos := self allParentClassesInfoFrom: aClassName.			classInfos := classInfos				flatCollect: [ :classInfo | classInfo messages ].			classInfos ]</body><body package="SmallSuiteGenerator-Info" selector="noneAbstractClasses">noneAbstractClasses	noneAbstractClasses		ifNil: [ noneAbstractClasses := self classes associations				select: [ :assoc | (self isAbstractClass: assoc key) not ]				thenCollect: [ :assoc | assoc value ] ].	^ noneAbstractClasses</body><body package="SmallSuiteGenerator-Info" selector="reportFrequencyByFilter">reportFrequencyByFilter	| report |	report := Dictionary new.	STypeMethodInfo selectorsFilter , #(#others #all)		do: [ :aSelector | 			report				at: aSelector				put:					(types						inject: 0						into: [ :sum :type | sum + (type reportFrequencyByFilter: aSelector) ]) ].	^ report</body><body package="SmallSuiteGenerator-Info" selector="scalars">scalars	^ scalars</body><body package="SmallSuiteGenerator-Info" selector="scalars:">scalars: aDictionary	aDictionary		associationsDo:			[ :assoc | self scalar: assoc key with: assoc value asOrderedCollection ]</body><body package="SmallSuiteGenerator-Info" selector="types">types	^ types</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>copying</category><body package="SmallSuiteGenerator-Info" selector="copy">copy	| copy |	copy := self class new.	types		do: [ :aClassTypeInfo | copy addClassInfo: aClassTypeInfo copy ].	copy scalars: scalars copy.	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>error handling</category><body package="SmallSuiteGenerator-Info" selector="error:">error: aString	^ SError signal: aString</body><body package="SmallSuiteGenerator-Info" selector="intersect:">intersect: typeList	| result |	result := Set new.	typeList		do: [ :type | 			| allTypes |			allTypes := self collectSubclassesOf: type.			allTypes				do: [ :t | 					(self isScalar: t)						ifTrue: [ result add: t ]						ifFalse: [ self								classAt: type								ifPresent: [ :cls | 									cls isAbstract										ifFalse: [ result add: t ] ] ] ] ].	^ result asOrderedCollection</body><body package="SmallSuiteGenerator-Info" selector="isScalar:">isScalar: aClassName	^ scalars at: aClassName ifPresent: [ true ] ifAbsent: [ false ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>accessing structure variables</category><body package="SmallSuiteGenerator-Info" selector="defaultFactoryMessageFrom:">defaultFactoryMessageFrom: aClassName	(self messagesFrom: aClassName)		detect: [ :message | message selector = #initialize ]		ifFound: [ ^ STypeMethodInfo				type:					#new						-&gt;							(Array								with: aClassName								with: aClassName								with: #()								with: false) ].	self		error:			'ClassMethodType of selector new cannot be applied at class: '				, aClassName</body><body package="SmallSuiteGenerator-Info" selector="type:">type: aAssoc	self addClassInfo: (STypeClassInfo type: aAssoc)</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>adding</category><body package="SmallSuiteGenerator-Info" selector="addClassInfo:">addClassInfo: aTypeClassInfo	"Adding class information and scalars"	types		at: aTypeClassInfo typeName		ifPresent: [ :aTypeClass | aTypeClass joinWith: aTypeClassInfo ]		ifAbsentPut: [ aTypeClassInfo ].	self joinScalars: aTypeClassInfo scalars</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Info" selector="=">= other	^ self class = other class		and: [ types = other types				and: [ | otherScalars |					otherScalars := other scalars.					scalars keys = otherScalars keys						and: [ (scalars values collect: #size)								= (otherScalars values collect: #size) ] ] ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo class</class-id> <category>converting</category><body package="SmallSuiteGenerator-Info" selector="asTypeInfo:">asTypeInfo: aTypeCollector	^ self new asTypeInfo: aTypeCollector</body><body package="SmallSuiteGenerator-Info" selector="asTypeInfo:methodsBlacklist:">asTypeInfo: aTypeCollector methodsBlacklist: aList	^ self new		blackList: aList;		asTypeInfo: aTypeCollector	" methodsBlacklist: aList"</body></methods><methods><class-id>SmallSuiteGenerator.SGATruncatedSelection</class-id> <category>selection</category><body package="SmallSuiteGenerator-GA" selector="selectJustOneOf:with:">selectJustOneOf: aCollection with: probabilities	^ (self selectOf: aCollection) first</body><body package="SmallSuiteGenerator-GA" selector="selectOf:">selectOf: aCollection	| newColl |	newColl := aCollection		sort: [ :a :b | (self fitnessFor: a) &gt; (self fitnessFor: b) ].	discarding &lt; aCollection size		ifTrue: [ newColl := newColl copyFrom: 1 to: aCollection size - discarding ].	^ newColl</body></methods><methods><class-id>SmallSuiteGenerator.SGATruncatedSelection</class-id> <category>initialization</category><body package="SmallSuiteGenerator-GA" selector="initialize">initialize	super initialize.	discarding := 5</body></methods><methods><class-id>SmallSuiteGenerator.SGATruncatedSelection</class-id> <category>accessing</category><body package="SmallSuiteGenerator-GA" selector="discarding:">discarding: aNumber	discarding := aNumber</body></methods><methods><class-id>SmallSuiteGenerator.SNumericParameterization</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Initialization" selector="initializeDictionary">initializeDictionary	^ Dictionary new		at: #largePopulationNumber			put: [ :testCaseFactory | 			testCaseFactory engine populationSize &lt; 30				ifTrue: [ testCaseFactory populationSize: 30 ] ];		at: #largeGenerationNumber			put: [ :testCaseFactory | 			testCaseFactory numberOfGenerations &lt; 50				ifTrue: [ testCaseFactory numberOfGenerations: 50 ] ];		at: #largeStatementNumber			put: [ :testCaseFactory | 			testCaseFactory engine numberOfStatements &lt; 50				ifTrue: [ testCaseFactory numberOfStatements: 50 ] ];		at: #smallPopulationNumber			put: [ :testCaseFactory | 			testCaseFactory engine populationSize &gt; 5				ifTrue: [ testCaseFactory populationSize: 5 ] ];		at: #smallGenerationNumber			put: [ :testCaseFactory | 			testCaseFactory numberOfGenerations &gt; 3				ifTrue: [ testCaseFactory numberOfGenerations: 3 ] ];		at: #smallStatementNumber			put: [ :testCaseFactory | 			testCaseFactory engine numberOfStatements &gt; 3				ifTrue: [ testCaseFactory numberOfStatements: 3 ] ];		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SStack</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Scenario" selector="firstLinkStack">firstLinkStack	^ firstLink</body><body package="SmallSuiteGenerator-Scenario" selector="lastLinkStack">lastLinkStack	^ lastLink</body><body package="SmallSuiteGenerator-Scenario" selector="top">top	self isEmpty		ifTrue: [ ^ nil ]		ifFalse: [ ^ self firstLink value ]</body></methods><methods><class-id>SmallSuiteGenerator.SStack</class-id> <category>adding</category><body package="SmallSuiteGenerator-Scenario" selector="push:">push: anObject	self addFirst: anObject.	^ anObject</body></methods><methods><class-id>SmallSuiteGenerator.SStack</class-id> <category>removing</category><body package="SmallSuiteGenerator-Scenario" selector="pop">pop	self isEmpty		ifTrue: [ ^ nil ]		ifFalse: [ ^ self removeFirst ]</body></methods><methods><class-id>SmallSuiteGenerator.SStack class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Scenario" selector="newStack">newStack	^ self new</body><body package="SmallSuiteGenerator-Scenario" selector="newStackWith:">newStackWith: aList	| inst |	inst := self newStack.	aList do: [ :element | inst push: element ].	^ inst</body></methods><methods><class-id>SmallSuiteGenerator.SSExecutionContext</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Core" selector="at:">at: aSymbol	^ values at: aSymbol ifAbsent: [ Smalltalk at: aSymbol ]</body><body package="SmallSuiteGenerator-Core" selector="at:put:">at: aSymbol put: aValue	values at: aSymbol put: aValue</body><body package="SmallSuiteGenerator-Core" selector="initialize">initialize	super initialize.	values := OrderedDictionary new</body><body package="SmallSuiteGenerator-Core" selector="keys">keys	^ values keys asOrderedCollection</body><body package="SmallSuiteGenerator-Core" selector="removeKey:">removeKey: key	^ values removeKey: key</body></methods><methods><class-id>SmallSuiteGenerator.SSExecutionContext</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Core" selector="associations">associations	^ values associations</body></methods><methods><class-id>SmallSuiteGenerator.SInspectorAssertion</class-id> <category>visitor</category><body package="SmallSuiteGenerator-Core" selector="accept:">accept: aSSVisitor	^ aSSVisitor visitInspectorAssertionMessage: self</body></methods><methods><class-id>SmallSuiteGenerator.SInspectorAssertion class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Core" selector="for:">for: anExecutionContext	^ anExecutionContext associations		flatCollect: [ :assoc | self inspectorAssertionOf: assoc ]</body><body package="SmallSuiteGenerator-Core" selector="inspectorAssertionOf:and:">inspectorAssertionOf: assoc and: compiledMethod	| result |	result := assoc value perform: compiledMethod selector.	^ (self isPrimitive: result)		ifFalse: [ nil ]		ifTrue: [ self new				selector: #assert:equals:;				args:					(Array						with:							(SMessage new								receiver: (SVariable nameOrId: assoc key);								selector: compiledMethod selector;								yourself)						with: (SLiteral new value: result));				yourself ]</body></methods><methods><class-id>SmallSuiteGenerator.SEvent</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Scenario" selector="discount">discount	^ discount</body><body package="SmallSuiteGenerator-Scenario" selector="discount:">discount: aNumber	price &gt; 0		ifTrue: [ discount := aNumber ]</body><body package="SmallSuiteGenerator-Scenario" selector="price">price	^ price - (discount * price / 100)</body><body package="SmallSuiteGenerator-Scenario" selector="price:">price: aNumber	price := aNumber</body></methods><methods><class-id>SmallSuiteGenerator.SEvent</class-id> <category>testing</category><body package="SmallSuiteGenerator-Scenario" selector="canRegister:">canRegister: aPerson	^ aPerson canRegister: self</body></methods><methods><class-id>SmallSuiteGenerator.SEvent</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Scenario" selector="initialize">initialize	price := 0.	discount := 0</body></methods><methods><class-id>SmallSuiteGenerator.SEvent class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Scenario" selector="price:">price: aNumber	^ self new price: aNumber</body></methods><methods><class-id>SmallSuiteGenerator.SParty</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Scenario" selector="date">date	^ date</body><body package="SmallSuiteGenerator-Scenario" selector="date:">date: anObject	date := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SGAMutationOperation</class-id> <category>actions</category><body package="SmallSuiteGenerator-GA" selector="doMutate:">doMutate: aTestCase	| result |	result := aTestCase.	self next &lt;= mutationRate		ifTrue: [ result := aTestCase removeStatement ].	self next &lt;= mutationRate		ifTrue: [ result := aTestCase changeStatement ].	self next &lt;= mutationRate		ifTrue: [ result := aTestCase insertStatement ].	result repairIds.	result runWithoutAssertionsAndLastStatement.	"run"	^ result</body><body package="SmallSuiteGenerator-GA" selector="mutate:">mutate: aTestCase	"Copy for mutation"	| newTestCase |	[ newTestCase := self doMutate: aTestCase ]		on: SError		do: [ :e | newTestCase := aTestCase copy ].	^ newTestCase</body></methods><methods><class-id>SmallSuiteGenerator.SGAMutationOperation</class-id> <category>initialization</category><body package="SmallSuiteGenerator-GA" selector="initialize">initialize	super initialize.	self mutationRate: (1 / 3) asFloat</body></methods><methods><class-id>SmallSuiteGenerator.SGAMutationOperation</class-id> <category>accessing</category><body package="SmallSuiteGenerator-GA" selector="mutationRate:">mutationRate: aFloat	mutationRate := aFloat</body></methods><methods><class-id>SmallSuiteGenerator.SCascade</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Core" selector="addMessage:">addMessage: aMessage	messages add: aMessage</body><body package="SmallSuiteGenerator-Core" selector="initialize">initialize	super initialize.	messages := OrderedCollection new</body></methods><methods><class-id>SmallSuiteGenerator.SCascade</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Core" selector="messages">messages	^ messages</body><body package="SmallSuiteGenerator-Core" selector="messages:">messages: anObject	messages := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SCascade</class-id> <category>visitor</category><body package="SmallSuiteGenerator-Core" selector="accept:">accept: aSSVisitor	^ aSSVisitor visitCascade: self</body></methods><methods><class-id>SmallSuiteGenerator.SGACrossoverOnlyDifferentCoverages</class-id> <category>asserting</category><body package="SmallSuiteGenerator-Strategies" selector="shouldCrossOver:with:">shouldCrossOver: testCaseA with: testCaseB	^ testCaseA fitness ~= testCaseB fitness</body></methods><methods><class-id>SmallSuiteGenerator.SReportSGALog</class-id> <category>groups collecting</category><body package="SmallSuiteGenerator-Utility" selector="methodTrackingFor:">methodTrackingFor: aSymbol	| methodCalls dict idMethods |	idMethods := #().	methodCalls := engine logs		collect: [ :log | 			log population				select: [ :testCase | 					testCase statements						anySatisfy: [ :e | 							[ e value selector = aSymbol ]								on: Error								do: [ false ] ] ] ].	dict := Dictionary new.	methodCalls		doWithIndex: [ :methods :i | 			methods				ifNotEmpty: [ dict at: i put: (self reportOf: methods withParents: idMethods).					idMethods := methods collect: #idPopulation ]				ifEmpty: [ idMethods := #() ] ].	^ dict</body><body package="SmallSuiteGenerator-Utility" selector="reportOf:withParents:">reportOf: methods withParents: idMethods	| keys |	keys := #('TestCase' 'hasError' 'parentHasMethod').	^ methods		collect: [ :method | 			Dictionary				newFromKeys: keys				andValues:					(Array						with: method						with: method hasErrors						with: ((method parents collect: #idPopulation) includesAny: idMethods)) ]</body></methods><methods><class-id>SmallSuiteGenerator.SReportSGALog</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Utility" selector="dictOfDifferences:">dictOfDifferences: differences	| result keys |	result := OrderedCollection new.	keys := #('Generations' 'Method' 'UpdateReturnType' 'UpdateArgsType' 'ConvertToExecutedMethod' 'ConvertToUnexecutedMethod' 'AddTypeInfo' 'AddExecutedBlocks' 'DecreaseExecutedBlocks').	differences		do: [ :e | 			| generationText |			generationText := '{1} -&gt; {2}'				format: (Array with: e key - 1 with: e key).			e value				do: [ :diff | 					| aux |					aux := Dictionary						newFromKeys: keys						andValues: (OrderedCollection ofSize: 9).					aux at: 'Generations' put: generationText.					aux at: 'Method' put: diff first.					diff allButFirst						do: [ :d | 							d key = 'WasExecuted'								ifTrue: [ d value = #(false true)										ifTrue: [ aux at: 'ConvertToExecutedMethod' put: true ]										ifFalse: [ aux at: 'ConvertToUnexecutedMethod' put: true ] ].							d key = 'ReturnType'								ifTrue: [ aux at: 'UpdateReturnType' put: true ].							d key = 'HasTypeInfo'								ifTrue: [ aux at: 'AddTypeInfo' put: true ].							d key = 'ArgTypes'								ifTrue: [ aux at: 'UpdateArgsType' put: true ].							d key = 'ExecutedBlock'								ifTrue: [ aux										at: 'AddExecutedBlocks'										put: (d value second difference: d value first) asString ].							d key = 'UnexecutedBlock'								ifTrue: [ aux										at: 'DecreaseExecutedBlocks'										put: (d value second difference: d value first) asString ] ].					result add: aux ] ].	^ result</body><body package="SmallSuiteGenerator-Utility" selector="engine:">engine: anObject	engine := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SReportSGALog</class-id> <category>reporting</category><body package="SmallSuiteGenerator-Utility" selector="differencesBtw:and:">differencesBtw: summary1 and: summary2	| result |	result := OrderedCollection new.	summary1		with: summary2		do: [ :x :y | 			x = y				ifFalse: [ | aux |					aux := OrderedCollection new.					x						keysAndValuesDo: [ :key :value | 							(x at: key) = (y at: key)								ifFalse: [ aux add: key -&gt; (Array with: value with: (y at: key)) ] ].					aux						ifNotEmpty: [ aux addFirst: (x at: 'MethodName').							result add: aux ] ] ].	^ result</body><body package="SmallSuiteGenerator-Utility" selector="differencesBtwGenerations">differencesBtwGenerations	| generations result |	generations := self summaryGenerations.	result := OrderedCollection new.	2 to: generations size do: [ :index | 		| diff |		diff := self			differencesBtw: (generations at: index - 1)			and: (generations at: index).		diff ifNotEmpty: [ result add: index -&gt; diff ] ].	^ result</body><body package="SmallSuiteGenerator-Utility" selector="summaryGenerations">summaryGenerations	^ engine logs		collect: [ :aLog | 			aLog summaryTargetClass				collect: [ :e | 					e						ifNotNil: [ Dictionary								newFromKeys:									#('ClassName' 'MethodName' 'IsClassSide' 'WasExecuted' 'HasTypeInfo' 'Code' 'ArgTypes' 'ReturnType' 'ExecutedBlock' 'UnexecutedBlock')								andValues: e summaryAsColl ] ] ]</body></methods><methods><class-id>SmallSuiteGenerator.SReportSGALog class</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Utility" selector="titles">titles	^ #('ID' 'Class Name' 'Method Name' 'Is Class Side' 'Was Executed' 'Has TypeInfo' 'Code' 'Args Types' 'Return Type' 'Executed Block' 'Unexecuted Block')</body></methods><methods><class-id>SmallSuiteGenerator.SReportSGALog class</class-id> <category>class-factory</category><body package="SmallSuiteGenerator-Utility" selector="engine:">engine: aSGAEngine	^ self new engine: aSGAEngine</body></methods><methods><class-id>SmallSuiteGenerator.SReportSGALog class</class-id> <category>export</category><body package="SmallSuiteGenerator-Utility" selector="generateReportForDifferencesBtwGenerationsOf:">generateReportForDifferencesBtwGenerationsOf: aSGAEngine	^ (self engine: aSGAEngine)		generateReportForDifferencesBtwGenerations</body></methods><methods><class-id>SmallSuiteGenerator.SFieldAccessMessage</class-id> <category>actions</category><body package="SmallSuiteGenerator-Core" selector="changeOn:">changeOn: aTestCase	aTestCase addAlternativeFieldAccessMessage: self</body><body package="SmallSuiteGenerator-Core" selector="insertOn:">insertOn: aTestCase	^ aTestCase		addFieldAccessMessage: self selector		from: self receiver returnType</body></methods><methods><class-id>SmallSuiteGenerator.SFieldAccessMessage</class-id> <category>visitor</category><body package="SmallSuiteGenerator-Core" selector="accept:">accept: aSSVisitor	^ aSSVisitor visitFieldAccessMessage: self</body></methods><methods><class-id>SmallSuiteGenerator.SFieldAccessMessage class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Core" selector="newFromReceiver:andMethod:">newFromReceiver: aReceiver andMethod: aMethod	^ self new		returnType: aMethod returnType type;		selector: aMethod selector;		receiver: aReceiver;		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngineExample</class-id> <category>examples - onClass</category><body package="SmallSuiteGenerator-Examples" selector="exampleSStackOnClassWithSMethodCoverage">exampleSStackOnClassWithSMethodCoverage	| engine classFitness |	classFitness := SMethodCoverage.	engine := self		runOnClass: SStack		withBlock: [ (SStack newStackWith: #(2 4 6 1))				push: 8;				pop;				top ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName) &gt;= 14.28.	"14.28 = (1/7) * 100 round: 2"	self		assert:			(engine logs last fittestTestCase fitness				at: classFitness functionName) &gt;= 57.14.	"57.14 = (4/7) * 100 round: 2"	engine clean</body><body package="SmallSuiteGenerator-Examples" selector="exampleSStackOnClassWithSStatementCoverage">exampleSStackOnClassWithSStatementCoverage	| engine classFitness |	classFitness := SStatementCoverage.	engine := self		runOnClass: SStack		withBlock: [ (SStack newStackWith: #(2 4 6 1))				push: 8;				pop;				top ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName) &gt;= 21.05.	"21.05 = (4/19) * 100 round: 2"	self		assert:			(engine logs last fittestTestCase fitness				at: classFitness functionName) &gt;= 73.68.	"73.68 = (14/19) * 100 round: 2"	engine clean</body><body package="SmallSuiteGenerator-Examples" selector="exampleSSTeacherOnClassWithSMethodCoverage">exampleSSTeacherOnClassWithSMethodCoverage	| engine classFitness |	classFitness := SMethodCoverage.	engine := self		runOnClass: SSTeacher		withBlock: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName) &gt;= 20.	"20 = (1/5) * 100"	self		assert:			(engine logs last fittestTestCase fitness				at: classFitness functionName)		equals: 80.	"80 = (4/5) * 100"	engine clean</body><body package="SmallSuiteGenerator-Examples" selector="exampleSSTeacherOnClassWithSStatementCoverage">exampleSSTeacherOnClassWithSStatementCoverage	| engine classFitness |	classFitness := SStatementCoverage.	engine := self		runOnClass: SSTeacher		withBlock: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		andFitness: classFitness.	self		assert:			(engine logs last fittestTestCase fitness				at: classFitness functionName) &gt;= 37.5.	"37.5 = (3/8) * 100"	self		assert:			(engine logs last fittestTestCase fitness				at: classFitness functionName) &gt;= 87.5.	"87.5 = (7/8) * 100"	engine clean</body><body package="SmallSuiteGenerator-Examples" selector="exampleSStudentOnClassWithSMethodCoverage">exampleSStudentOnClassWithSMethodCoverage	| engine classFitness |	classFitness := SMethodCoverage.	engine := self		runOnClass: SStudent		withBlock: [ (SStudent name: 'Ann' with: 34)				nickname;				idStudent;				scoreStudent: 45;				scoreStudent ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName) &gt;= 20.	self		assert:			(engine logs last fittestTestCase fitness				at: classFitness functionName)		equals: 100.	engine clean</body><body package="SmallSuiteGenerator-Examples" selector="exampleSStudentOnClassWithSStatementCoverage">exampleSStudentOnClassWithSStatementCoverage	| engine classFitness |	classFitness := SStatementCoverage.	engine := self		runOnClass: SStudent		withBlock: [ (SStudent name: 'Ann' with: 34)				nickname;				idStudent;				scoreStudent: 45;				scoreStudent ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName) &gt;= 37.5.	self		assert:			(engine logs last fittestTestCase fitness				at: classFitness functionName)		equals: 100.	engine clean</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngineExample</class-id> <category>examples - onPackages</category><body package="SmallSuiteGenerator-Examples" selector="exampleSStackOnPackageWithSMethodCoverage">exampleSStackOnPackageWithSMethodCoverage	| engine classFitness |	classFitness := SMethodCoverage.	engine := self		runOnPackagesMatching: 'SmallSuiteGenerator-Examples'		withBlock: [ (SStack newStackWith: #(2 4 6 1))				push: 8;				pop;				top ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName)				&lt;=					(engine logs last fittestTestCase fitness						at: classFitness functionName).	engine clean</body><body package="SmallSuiteGenerator-Examples" selector="exampleSStackOnPackageWithSStatementCoverage">exampleSStackOnPackageWithSStatementCoverage	| engine classFitness |	classFitness := SMethodCoverage.	engine := self		runOnPackagesMatching: 'SmallSuiteGenerator-Examples'		withBlock: [ (SStack newStackWith: #(2 4 6 1))				push: 8;				pop;				top ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName)				&lt;=					(engine logs last fittestTestCase fitness						at: classFitness functionName).	engine clean</body><body package="SmallSuiteGenerator-Examples" selector="exampleSSTeacherOnPackageWithSMethodCoverage">exampleSSTeacherOnPackageWithSMethodCoverage	| engine classFitness |	classFitness := SMethodCoverage.	engine := self		runOnPackagesMatching: 'SmallSuiteGenerator-Examples'		withBlock: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName)				&lt;=					(engine logs last fittestTestCase fitness						at: classFitness functionName).	engine clean</body><body package="SmallSuiteGenerator-Examples" selector="exampleSSTeacherOnPackageWithSStatementCoverage">exampleSSTeacherOnPackageWithSStatementCoverage	| engine classFitness |	classFitness := SStatementCoverage.	engine := self		runOnPackagesMatching: 'SmallSuiteGenerator-Examples'		withBlock: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName)				&lt;=					(engine logs last fittestTestCase fitness						at: classFitness functionName).	engine clean</body><body package="SmallSuiteGenerator-Examples" selector="exampleSStudentOnPackageWithSMethodCoverage">exampleSStudentOnPackageWithSMethodCoverage	| engine classFitness |	classFitness := SMethodCoverage.	engine := self		runOnPackagesMatching: 'SmallSuiteGenerator-Scenario2'		withBlock: [ (SStudent name: 'Ann' with: 34)				nickname;				idStudent;				scoreStudent: 45;				scoreStudent ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName)				&lt;=					(engine logs last fittestTestCase fitness						at: classFitness functionName).	engine clean</body><body package="SmallSuiteGenerator-Examples" selector="exampleSStudentOnPackageWithSStatementCoverage">exampleSStudentOnPackageWithSStatementCoverage	| engine classFitness |	classFitness := SStatementCoverage.	engine := self		runOnPackagesMatching: 'SmallSuiteGenerator-Scenario2'		withBlock: [ (SStudent name: 'Ann' with: 34)				nickname;				idStudent;				scoreStudent: 45;				scoreStudent ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName)				&lt;=					(engine logs last fittestTestCase fitness						at: classFitness functionName).	engine clean</body></methods><methods><class-id>SmallSuiteGenerator.SGARankSelection</class-id> <category>selection</category><body package="SmallSuiteGenerator-GA" selector="selectJustOneOf:with:">selectJustOneOf: aCollection with: probabilities	^ SGARouletteSelection new		selectJustOneOf: aCollection		with: (self ranksOf: probabilities)</body><body package="SmallSuiteGenerator-GA" selector="selectOf:">selectOf: aCollection	^ self		selectOf: aCollection		with: (aCollection collect: [ :testCase | self fitnessFor: testCase ])</body><body package="SmallSuiteGenerator-GA" selector="selectOf:with:">selectOf: aCollection with: values	^ SGARouletteSelection new		selectOf: aCollection		with: (self ranksOf: values)</body></methods><methods><class-id>SmallSuiteGenerator.SGARankSelection</class-id> <category>actions</category><body package="SmallSuiteGenerator-GA" selector="ranksOf:">ranksOf: values	| indexValue |	indexValue := 0.	^ (self		ranksWithIndexOf:			(values				collect: [ :val | 					indexValue := indexValue + 1.					val -&gt; indexValue ])) collect: #value</body><body package="SmallSuiteGenerator-GA" selector="ranksWithIndexOf:">ranksWithIndexOf: associations	| rank sortBlock |	sortBlock := [ :a :b | a key &lt; b key ].	associations sort: sortBlock.	rank := 0.	^ (associations		collect: [ :each | 			rank := rank + 1.			each value -&gt; rank ]) sort: sortBlock</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine</class-id> <category>accessing</category><body package="SmallSuiteGenerator-GA" selector="crossoverOperator:">crossoverOperator: aCrossoverOperator	crossoverOperator := aCrossoverOperator</body><body package="SmallSuiteGenerator-GA" selector="crossoverStrategy:">crossoverStrategy: aCrossoverStrategy	crossoverStrategy := aCrossoverStrategy</body><body package="SmallSuiteGenerator-GA" selector="fitness">fitness	^ fitness</body><body package="SmallSuiteGenerator-GA" selector="fitness:">fitness: aFitness	fitness := aFitness.	selectionStrategy fitness: aFitness</body><body package="SmallSuiteGenerator-GA" selector="lastMessage:">lastMessage: anObject	lastMessage := anObject</body><body package="SmallSuiteGenerator-GA" selector="logClass">logClass	^ self class logClass</body><body package="SmallSuiteGenerator-GA" selector="logs">logs	^ logs</body><body package="SmallSuiteGenerator-GA" selector="numberOfGenerations">numberOfGenerations	^ numberOfGenerations</body><body package="SmallSuiteGenerator-GA" selector="numberOfGenerations:">numberOfGenerations: anInteger	"Set the number of generation the genetic algorithm has to run"	numberOfGenerations := anInteger</body><body package="SmallSuiteGenerator-GA" selector="numberOfStatements:">numberOfStatements: anInteger	"Set the number of statements the initial population should have.	Ideally, a small number, such as 3, is convenient. The evolution makes the individuals grow over time"	numberOfStatements := anInteger</body><body package="SmallSuiteGenerator-GA" selector="packageRegex:">packageRegex: aString	packageRegex := aString</body><body package="SmallSuiteGenerator-GA" selector="population">population	^ population</body><body package="SmallSuiteGenerator-GA" selector="populationSize:">populationSize: aInteger	populationSize := aInteger</body><body package="SmallSuiteGenerator-GA" selector="scalarsKeysOfTypeInfo">scalarsKeysOfTypeInfo	^ typeInfo scalars keys</body><body package="SmallSuiteGenerator-GA" selector="selectionStrategy:">selectionStrategy: aSelectionStrategy	selectionStrategy := aSelectionStrategy</body><body package="SmallSuiteGenerator-GA" selector="selectionStrategyTestCase:">selectionStrategyTestCase: aSelectionStrategy	selectionStrategyTestCase := aSelectionStrategy</body><body package="SmallSuiteGenerator-GA" selector="targetClassName:">targetClassName: anObject	targetClassName := anObject</body><body package="SmallSuiteGenerator-GA" selector="targetPackageRegex">targetPackageRegex	^ targetPackageRegex</body><body package="SmallSuiteGenerator-GA" selector="targetPackageRegex:">targetPackageRegex: aString	targetPackageRegex := aString</body><body package="SmallSuiteGenerator-GA" selector="totalExecutionGA">totalExecutionGA	^ totalExecutionGA</body><body package="SmallSuiteGenerator-GA" selector="typeInfo">typeInfo	^ typeInfo</body><body package="SmallSuiteGenerator-GA" selector="typeInfo:">typeInfo: aTypeInfo	typeInfo := aTypeInfo.	typeInfo completeTypeInfo</body><body package="SmallSuiteGenerator-GA" selector="typeInfoProfilerAsTypeInfo">typeInfoProfilerAsTypeInfo	^ STypeInfo asTypeInfo: typeInfoProfiler</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine</class-id> <category>actions</category><body package="SmallSuiteGenerator-GA" selector="collectNameOfAllSubclassesOf:includesOn:">collectNameOfAllSubclassesOf: type includesOn: scalar	^ (type class allSubclasses collect: #name) includes: scalar</body><body package="SmallSuiteGenerator-GA" selector="computeFitness">computeFitness	"compute fitness of all population"	fitness compute: population</body><body package="SmallSuiteGenerator-GA" selector="doSelection">doSelection	self createNewPopulation.	initialPopulation := population</body><body package="SmallSuiteGenerator-GA" selector="eliteOfCurrentPopulation">eliteOfCurrentPopulation	"select the best testCases according elitismRate"	| endIndex index popSize |	popSize := population size.	endIndex := (popSize * elitismRate round: 0) asInteger.	"* 0.01"	(popSize &gt; 0 and: [ endIndex == 0 ])		ifTrue: [ endIndex := 1 ].	index := 0.	endIndex &gt;= 1		ifTrue: [ ^ ((population copyFrom: 1 to: endIndex)				collect: [ :testCase | 					index := index + 1.					self similarChild: testCase with: index ]) asOrderedCollection ].	^ OrderedCollection new</body><body package="SmallSuiteGenerator-GA" selector="lastBestFitness">lastBestFitness	"returns the testCase that had the best fitness of the previous generation"	^ logs last fittestTestCase fitnessFor: fitness functionName</body><body package="SmallSuiteGenerator-GA" selector="lastGenerationNumber">lastGenerationNumber	"returns the ID of the previous generation"	^ logs last generationNumber</body><body package="SmallSuiteGenerator-GA" selector="logInGeneration:withTime:">logInGeneration: iteration withTime: t	"returns a log for each iteration"	^ self logClass logOf: self inGeneration: iteration inTime: t</body><body package="SmallSuiteGenerator-GA" selector="mutateAndUpdate:">mutateAndUpdate: aTestCase	| newTestCase |	newTestCase := mutationOperator mutate: aTestCase.	newTestCase updateWith: aTestCase.	^ newTestCase</body><body package="SmallSuiteGenerator-GA" selector="mutationRate:">mutationRate: aFloat	mutationOperator mutationRate: aFloat</body><body package="SmallSuiteGenerator-GA" selector="run">run	| counter bestFitness stopFlag |	totalExecutionGA := Time millisecondClockValue.	counter := 0.	stopFlag := false.	self initializePopulation.	totalExecutionGA := Time millisecondClockValue - totalExecutionGA.	bestFitness := self lastBestFitness.	(1 to: numberOfGenerations)		do: [ :iteration | 			| t lastBestFitness |			stopFlag				ifFalse: [ t := Time millisecondClockValue.					self doSelection.					logs add: (self logInGeneration: iteration withTime: t).					lastBestFitness := self lastBestFitness.					lastBestFitness &lt;= bestFitness						ifTrue: [ counter := counter + 1.							counter &gt; stopIterations								ifTrue: [ stopFlag := true ] ]						ifFalse: [ counter := 0.							bestFitness := lastBestFitness ].					totalExecutionGA := totalExecutionGA + Time millisecondClockValue						- t ] ]		displayingProgress: [ :iteration | 'Evolving - Iteration' , iteration printString ]</body><body package="SmallSuiteGenerator-GA" selector="selectTwoBestOf:excludingAll:">selectTwoBestOf: aCollection excludingAll: excludingColl	| options |	options := (aCollection asOrderedCollection select: #notEmpty)		removeAllSuchThat: [ :e | excludingColl includes: e ];		yourself.	options := self order: options.	^ options first: (2 min: options size)</body><body package="SmallSuiteGenerator-GA" selector="similarChild:with:">similarChild: testCase with: idPopulation	^ testCase deepCopy		generationNumber: testCase generationNumber + 1;		idPopulation: idPopulation;		addParent: testCase;		yourself</body><body package="SmallSuiteGenerator-GA" selector="targetClassName">targetClassName	^ targetClassName</body><body package="SmallSuiteGenerator-GA" selector="updateHierarchyData:of:">updateHierarchyData: parents of: testCase	parents do: [ :parent | testCase addParent: parent ].	^ testCase</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine</class-id> <category>creating</category><body package="SmallSuiteGenerator-GA" selector="createNewPopulation">createNewPopulation	| newPopulation currentPopulationSize lastLowestFitness options newNumber |	lastLowestFitness := logs last lowestFit at: fitness functionName.	currentPopulationSize := initialPopulation size.	newPopulation := self eliteOfCurrentPopulation.	newNumber := newPopulation size.	[ newPopulation size &lt; currentPopulationSize ]		whileTrue:			[ | selectedIndividuals p1copy p2copy p1 p2 o1 o2 om1 om2 selectedOptions children |			selectedIndividuals := selectionStrategy				selectOf: initialPopulation.			p1 := selectedIndividuals first.			p2 := selectedIndividuals second.			p1copy := self similarChild: p1 with: newNumber + 1.			p2copy := self similarChild: p2 with: newNumber + 2.			(crossoverStrategy shouldCrossOver: p1 with: p2)				ifTrue: [ children := crossoverOperator crossover: p1 with: p2.					o1 := self						updateHierarchyData:							((Array new: 2)								at: 1 put: p1;								at: 2 put: p2;								yourself)						of: (children first idPopulation: newNumber + 3).					o2 := self						updateHierarchyData:							((Array new: 2)								at: 1 put: p1;								at: 2 put: p2;								yourself)						of: (children second idPopulation: newNumber + 4) ]				ifFalse: [ o1 := p1copy deepCopy						idPopulation: newNumber + 3;						addParent: p1.					o2 := p2copy deepCopy						idPopulation: newNumber + 4;						addParent: p2 ].			om1 := self mutateAndUpdate: o1.			om2 := self mutateAndUpdate: o2.			fitness compute: (Array with: om1 with: om2).			options := Array				with: om1				with: om2				with: p1copy				with: p2copy.			selectedOptions := (self				selectTwoBestOf: options				excludingAll: newPopulation)				select:					[ :option | (option fitness at: fitness functionName) &gt;= lastLowestFitness ].			selectedOptions := selectedOptions				first: (selectedOptions size min: currentPopulationSize - newPopulation size).			options				reject: [ :opt | selectedOptions includes: opt ]				thenDo: [ :opt | 					p1 removeChild: opt.					p2 removeChild: opt ].			newPopulation				addAll:					(selectedOptions						collect: [ :option | 							newNumber := newNumber + 1.							option idPopulation: newNumber ]) ].	self updateTypeInfoWith: newPopulation.	population := newPopulation.	population := self order: population</body><body package="SmallSuiteGenerator-GA" selector="createRandomPopulation">createRandomPopulation	^ (1 to: populationSize)		collect: [ :idPop | 			| value test |			value := self next * numberOfStatements + 1.			test := SSTestCase with: typeInfo.			test				targetClassName: targetClassName;				addFactoryMessage: targetClassName;				generateStatements: value;				lastMessage: lastMessage;				idPopulation: idPop;				clean.			selectionStrategyTestCase				ifNotNil: [ test selectionStrategy: selectionStrategyTestCase ].			test ]</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine</class-id> <category>sorting</category><body package="SmallSuiteGenerator-GA" selector="order:">order: aCollection	^ aCollection		sort: [ :stm1 :stm2 | stm1 isBetterThan: stm2 using: fitness functionName ]</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine</class-id> <category>updating</category><body package="SmallSuiteGenerator-GA" selector="assignTypeToArgumentsOf:">assignTypeToArgumentsOf: argType	^ argType types		do: [ :type | 			self scalarsKeysOfTypeInfo				select:					[ :scalar | self collectNameOfAllSubclassesOf: type includesOn: scalar ]				thenDo: [ :scalar | argType type: scalar ] ]</body><body package="SmallSuiteGenerator-GA" selector="mergeTypeInfo:">mergeTypeInfo: otherTypeInfo	typeInfo joinWith: otherTypeInfo</body><body package="SmallSuiteGenerator-GA" selector="profilerForPackagesMatching">profilerForPackagesMatching	Transcript		show: 'profiling...';		cr.	typeInfoProfiler := self aSTypeCollectorClass		profilerForPackagesMatching: targetPackageRegex.	typeInfoProfiler beforeProfiling</body><body package="SmallSuiteGenerator-GA" selector="profilerForTargetClass">profilerForTargetClass	| packageSpy cls classSpy |	cls := Smalltalk at: targetClassName.	Transcript		show: 'profiling...';		cr.	typeInfoProfiler := self aSTypeCollectorClass new.	self aSTypeCollectorClass installOnClass: cls.	typeInfoProfiler beforeProfiling.	classSpy := typeInfoProfiler spyForClass: cls.	packageSpy := typeInfoProfiler class spyClassForPackage new.	packageSpy classAt: targetClassName put: classSpy.	typeInfoProfiler addPackage: packageSpy.	classSpy packageSpy: packageSpy</body><body package="SmallSuiteGenerator-GA" selector="uninstall">uninstall	typeInfoProfiler		afterProfiling;		uninstall.	Transcript		show: 'ended...';		cr</body><body package="SmallSuiteGenerator-GA" selector="updateArgsOf:">updateArgsOf: aMethod	aMethod argTypes		do: [ :argType | 			| res |			res := argType types				anySatisfy: [ :type | self scalarsKeysOfTypeInfo includes: type ].			res				ifFalse: [ self assignTypeToArgumentsOf: argType ] ]</body><body package="SmallSuiteGenerator-GA" selector="updateTypeInfoWith:">updateTypeInfoWith: aPopulation	fitness profiler uninstallClass: targetClassName.	self profilerForTargetClass.	aPopulation		do: [ :aTestCase | aTestCase runWithoutAssertionsAndLastStatement ].	self mergeTypeInfo: self typeInfoProfilerAsTypeInfo.	self uninstall.	fitness profiler		updateClass: ((self initializeProfiler packages at: 1) classes at: targetClassName).	fitness profiler deleteCache</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine</class-id> <category>initialization</category><body package="SmallSuiteGenerator-GA" selector="initialize">initialize	super initialize.	logs := OrderedCollection new.	populationSize := 30.	numberOfGenerations := 100.	selectionStrategy := SGARandomSelection new.	crossoverStrategy := SGACrossoverRate new.	elitismRate := 0.1.	numberOfStatements := 10.	stopIterations := 30.	totalExecutionGA := 0.	lastMessage := SSGParser		parseFrom: (SPlatform rbParserClass parseExpression: '').	self initializeMutationOperator.	self initializeCrossoverOperator</body><body package="SmallSuiteGenerator-GA" selector="initializeCrossoverOperator">initializeCrossoverOperator	crossoverOperator := SGACrossoverOperation new</body><body package="SmallSuiteGenerator-GA" selector="initializeMutationOperator">initializeMutationOperator	mutationOperator := SGAMutationOperation new.	mutationOperator mutationRate: (1 / 3) asFloat</body><body package="SmallSuiteGenerator-GA" selector="initializePopulation">initializePopulation	| t |	t := Time now asSeconds.	population		ifNil: [ population := self createRandomPopulation.			SExpression resetId.			self computeFitness.			population := self order: population.			initialPopulation := population.			self updateTypeInfoWith: population.			logs add: (self logClass logOf: self inGeneration: 0 inTime: t) ]</body><body package="SmallSuiteGenerator-GA" selector="initializeProfiler">initializeProfiler	| aProfiler |	aProfiler := self aSLProfilerCoverage		profilerForClass: targetClassName.	(aProfiler allMethods select: #isNotMethodExtension)		do: #installGhosts		displayingProgress: 'Instrumenting ' , targetClassName.	^ aProfiler</body><body package="SmallSuiteGenerator-GA" selector="stopIterations">stopIterations	^ stopIterations</body><body package="SmallSuiteGenerator-GA" selector="stopIterations:">stopIterations: aNumber	stopIterations := aNumber</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine</class-id> <category>testing</category><body package="SmallSuiteGenerator-GA" selector="checkFitness">checkFitness	self		assert: [ fitness notNil ]		description: 'Need to set a fitnessBlock'</body><body package="SmallSuiteGenerator-GA" selector="checkIfReadyToRun">checkIfReadyToRun	self checkTypeInfo.	self checkFitness.	self checkLogs</body><body package="SmallSuiteGenerator-GA" selector="checkLogs">checkLogs	self assert: [ logs isEmpty ] description: 'Already been run'</body><body package="SmallSuiteGenerator-GA" selector="checkTypeInfo">checkTypeInfo	self assert: [ typeInfo notNil ] description: 'Set a typeInfo'</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine</class-id> <category>cleaning</category><body package="SmallSuiteGenerator-GA" selector="clean">clean	fitness ifNotNil: [ fitness tearDown ]</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine</class-id> <category>rating</category><body package="SmallSuiteGenerator-GA" selector="elitismRate:">elitismRate: aNumber	elitismRate := aNumber</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine class</class-id> <category>API-accessing</category><body package="SmallSuiteGenerator-GA" selector="logClass">logClass	^ SGANullLog</body><body package="SmallSuiteGenerator-GA" selector="resetToDefaults">resetToDefaults	"reset log class to NullLog"	((Array new: 1)		at: 1 put: #logClass -&gt; SGANullLog;		yourself)		do: [ :val | 			self class				compile: val key asString , String cr , '	^ ' , val value printString ]</body></methods><methods><class-id>SmallSuiteGenerator.SPlatformVisualWorks class</class-id> <category>logging</category><body package="SmallSuiteGenerator-Builder" selector="cleanAllLogs">cleanAllLogs	</body><body package="SmallSuiteGenerator-Builder" selector="clearLog">clearLog	</body><body package="SmallSuiteGenerator-Builder" selector="saveOnLog:">saveOnLog: string	</body></methods><methods><class-id>SmallSuiteGenerator.SPlatformVisualWorks class</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Builder" selector="classTestCaseFactory">classTestCaseFactory	^ STestCaseFactoryVisualWorks</body></methods><methods><class-id>SmallSuiteGenerator.SPlatformVisualWorks class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Builder" selector="fileLogger:">fileLogger: fileName	</body></methods><methods><class-id>SmallSuiteGenerator.SStringAssertion</class-id> <category>visitor</category><body package="SmallSuiteGenerator-Core" selector="accept:">accept: aSSVisitor	^ aSSVisitor visitStringAssertionMessage: self</body></methods><methods><class-id>SmallSuiteGenerator.SStringAssertion class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Core" selector="for:">for: anExecutionContext	^ (anExecutionContext associations		reject: [ :assoc | self isPrimitive: assoc value ])		collect: [ :assoc | self stringAssertionsOf: assoc ]		thenSelect: [ :stringAssertion | stringAssertion isNil not ]</body><body package="SmallSuiteGenerator-Core" selector="stringAssertionsOf:">stringAssertionsOf: assoc	| aValue |	aValue := assoc value.	^ (aValue class allSelectorsBelow: Object)		detect: [ :aSelector | aSelector = #printOn: or: [ aSelector = #asString ] ]		ifFound: [ | fieldValue |			[ fieldValue := aValue printString.			self new				selector: #assert:equals:;				args:					(Array						with:							(SMessage new								receiver: (SVariable nameOrId: assoc key);								selector: #printString;								yourself)						with: (SLiteral new value: fieldValue));				yourself ]				on: Error				do: [ nil ] ]		ifNone: [ nil ]</body></methods><methods><class-id>SmallSuiteGenerator.SReportTypeInfo class</class-id> <category>export</category><body package="SmallSuiteGenerator-Utility" selector="dataCaseStudy:from:">dataCaseStudy: profiler from: projectName	^ Array		with: projectName		with: profiler numberOfClasses		with: profiler numberOfMethods		with:			(profiler allMethods				collect: #selector				thenSelect: [ :selector | selector beginsWith: 'test' ]) size		with:			(((profiler allMethods count: #wasExecuted) / profiler numberOfMethods)				asFloat round: 4) * 100</body><body package="SmallSuiteGenerator-Utility" selector="dataFrequency:from:">dataFrequency: typeInfo from: projectName	^ (Array with: projectName)		, (typeInfo reportFrequencyByFilter associations sort collect: #value)</body><body package="SmallSuiteGenerator-Utility" selector="exportReportsCaseStudyAndFrequency:of:">exportReportsCaseStudyAndFrequency: fileNames of: projectsName	| data |	self		assert: fileNames size = 2		description: 'Set the fileNames correctly'.	data := projectsName		collect: [ :projectName | 			| profiler |			profiler := self profilerProject: projectName.			Array				with: (self dataCaseStudy: profiler from: projectName)				with:					(self						dataFrequency: (STypeInfo asTypeInfo: profiler)						from: projectName) ].	self writeReport: fileNames first ofCaseStudy: (data collect: #first).	self		writeReport: fileNames second		ofFrequency: (data collect: #second)</body><body package="SmallSuiteGenerator-Utility" selector="exportReportsCaseStudyAndFrequencyOf:">exportReportsCaseStudyAndFrequencyOf: projectsName	self		exportReportsCaseStudyAndFrequency: #('CaseStudy' 'Frequency')		of: projectsName</body><body package="SmallSuiteGenerator-Utility" selector="profilerProject:">profilerProject: projectName	^ self aSTypeCollectorClass		profile: [ (SPlatform testCaseClass withAllSubclasses				select: [ :t | t category beginsWith: projectName ])				do: [ :tc | 					[ tc buildSuite run ]						on: Exception						do: [ :e | 							Transcript								show: e printString;								cr ] ]				displayingProgress: 'working' ]		onPackagesMatching: projectName , '*'</body></methods><methods><class-id>SmallSuiteGenerator.SReportTypeInfo class</class-id> <category>export as CSV</category><body package="SmallSuiteGenerator-Utility" selector="exportData:onCSV:">exportData: aTypeInfo onCSV: aString	self exportData: aTypeInfo onCSV: aString usingFilter: #all</body><body package="SmallSuiteGenerator-Utility" selector="exportReportData:">exportReportData: projectName	self exportReportData: projectName withName: projectName</body><body package="SmallSuiteGenerator-Utility" selector="exportReportData:usingFilter:">exportReportData: projectName usingFilter: aSymbol	self		exportReportData: projectName		withName: projectName		usingFilter: aSymbol</body><body package="SmallSuiteGenerator-Utility" selector="exportReportData:withName:">exportReportData: projectName withName: aString	self		exportData: (STypeInfo asTypeInfo: (self profilerProject: projectName))		onCSV: aString</body><body package="SmallSuiteGenerator-Utility" selector="exportReportData:withName:usingFilter:">exportReportData: projectName withName: aString usingFilter: aSymbol	self		exportData: (STypeInfo asTypeInfo: (self profilerProject: projectName))		onCSV: aString		usingFilter: aSymbol</body><body package="SmallSuiteGenerator-Utility" selector="titles">titles	^ #('ClassName' 'MethodName' 'Receivers' 'CommSupcls' 'ArgTypes' 'CommSupcls' 'ReturnTypes' 'CommSupcls')</body></methods><methods><class-id>SmallSuiteGenerator.SReportTypeInfo class</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Utility" selector="fileReference:">fileReference: aString	| filename |	filename := aString , '.csv'.	filename asFileReference ensureDelete.	^ filename asFileReference</body></methods><methods><class-id>SmallSuiteGenerator.SMethodInfoTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-Info" selector="testEquals">testEquals	| studentSymbol sfooSymbol stringSymbol |	studentSymbol := #SStudent fullClassNameSymbol.	sfooSymbol := #SFoo fullClassNameSymbol.	stringSymbol := #ByteString fullClassNameSymbol.	self		assert:			(STypeMethodInfo				type:					#name						-&gt;							(Array								with: studentSymbol								with: stringSymbol								with: #()								with: false))		equals:			(STypeMethodInfo				type:					#name						-&gt;							(Array								with: studentSymbol								with: stringSymbol								with: #()								with: false)).	self		assert:			(STypeMethodInfo				type:					#return:						-&gt;							(Array								with: sfooSymbol								with: stringSymbol								with: (Array with: stringSymbol)								with: false))		equals:			(STypeMethodInfo				type:					#return:						-&gt;							(Array								with: sfooSymbol								with: stringSymbol								with: (Array with: stringSymbol)								with: false))</body><body package="SmallSuiteGenerator-Tests-Info" selector="testType">testType	| methodInfo sfooSymbol floatSymbol stringSymbol collSymbol intSymbol |	sfooSymbol := #SFoo fullClassNameSymbol.	floatSymbol := #SmallFloat64 fullClassNameSymbol.	stringSymbol := #ByteString fullClassNameSymbol.	collSymbol := #OrderedCollection fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	methodInfo := STypeMethodInfo		type:			#returnFloat				-&gt;					(Array						with: sfooSymbol						with: floatSymbol						with: #()						with: false).	self assert: methodInfo receiver type equals: sfooSymbol.	self assert: methodInfo returnType type equals: floatSymbol.	self assert: methodInfo allArgTypes isEmpty.	self deny: methodInfo isQuick.	self deny: methodInfo isDeprecated.	methodInfo := STypeMethodInfo		type:			#returnString				-&gt;					(Array						with: sfooSymbol						with: stringSymbol						with: #()						with: false).	self assert: methodInfo receiver type equals: sfooSymbol.	self assert: methodInfo returnType type equals: stringSymbol.	self assert: methodInfo allArgTypes isEmpty.	self deny: methodInfo isQuick.	methodInfo := STypeMethodInfo		type:			#return:				-&gt;					(Array						with: sfooSymbol						with: collSymbol						with: (Array with: collSymbol)						with: false).	self assert: methodInfo receiver type equals: sfooSymbol.	self assert: methodInfo returnType type equals: collSymbol.	self		assertCollection: methodInfo allArgTypes		hasSameElements: (Array with: collSymbol).	self deny: methodInfo isQuick.	methodInfo := STypeMethodInfo		type:			#score:				-&gt;					(Array						with: sfooSymbol						with: sfooSymbol						with: (Array with: intSymbol)						with: false).	self assert: methodInfo receiver type equals: sfooSymbol.	self assert: methodInfo returnType type equals: sfooSymbol.	self		assertCollection: methodInfo allArgTypes		hasSameElements: (Array with: intSymbol).	self deny: methodInfo isQuick.	methodInfo := STypeMethodInfo		type:			#score				-&gt;					(Array						with: sfooSymbol						with: intSymbol						with: #()						with: true).	self assert: methodInfo receiver type equals: sfooSymbol.	self assert: methodInfo returnType type equals: intSymbol.	self assert: methodInfo argTypes isEmpty.	self assert: methodInfo isQuick</body></methods><methods><class-id>SmallSuiteGenerator.SMultiFitnessFunction</class-id> <category>accessing</category><body package="SmallSuiteGenerator-GA" selector="add:weight:">add: aFitness weight: aFloat	aFitness weight: aFloat.	aFitness profiler: self profiler.	aFitness targetClass: targetClass.	functionList at: aFitness functionName put: aFitness</body><body package="SmallSuiteGenerator-GA" selector="computeFitness">computeFitness	| fitness |	fitness := (functionList		collect: [ :each | each computeFitness first * each weight ]) sum.	^ Array with: fitness</body><body package="SmallSuiteGenerator-GA" selector="computeMultiFitnessOf:">computeMultiFitnessOf: aTestCase	| fitness fitnessByClass |	fitness := (functionList		collect: [ :each | (aTestCase fitnessFor: each functionName) * each weight ])		sum.	fitnessByClass := Dictionary new.	"functionList collect: [ :each | 		fitnessByClass sum: (aTestCase fitnessByClass at: each functionName) * each weight ]."	functionList		do: [ :each | 			fitnessByClass				sum: (aTestCase fitnessByClass at: each functionName) * each weight ].	aTestCase fitnessByClass at: self functionName put: fitnessByClass.	aTestCase fitness at: self functionName put: fitness</body><body package="SmallSuiteGenerator-GA" selector="consideringNSuperclasses:">consideringNSuperclasses: anInteger	functionList do: [ :func | func consideringNSuperclasses: anInteger ]</body><body package="SmallSuiteGenerator-GA" selector="fitnessOf:">fitnessOf: aTestCase	functionList do: [ :func | func fitnessOf: aTestCase ].	self computeMultiFitnessOf: aTestCase</body><body package="SmallSuiteGenerator-GA" selector="functionName">functionName	^ 'multi-coverage'</body><body package="SmallSuiteGenerator-GA" selector="profiler:">profiler: aProfiler	profiler := aProfiler.	self updateFunctionList</body><body package="SmallSuiteGenerator-GA" selector="targetClass:">targetClass: anObject	targetClass := anObject.	self updateFunctionList</body><body package="SmallSuiteGenerator-GA" selector="updateFunctionList">updateFunctionList	functionList		do: [ :func | 			func profiler: profiler.			func targetClass: targetClass ]</body></methods><methods><class-id>SmallSuiteGenerator.SMultiFitnessFunction</class-id> <category>initialization</category><body package="SmallSuiteGenerator-GA" selector="initialize">initialize	super initialize.	functionList := Dictionary new</body></methods><methods><class-id>SmallSuiteGenerator.SMultiFitnessFunction class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-GA" selector="methodAndStatementCoverage">methodAndStatementCoverage	| inst |	inst := self new.	inst add: SMethodCoverage new weight: 0.6.	inst add: SStatementCoverage new weight: 0.4.	^ inst</body></methods><methods><class-id>SmallSuiteGenerator.SLiteral</class-id> <category>evaluating</category><body package="SmallSuiteGenerator-Core" selector="value">value	^ value</body></methods><methods><class-id>SmallSuiteGenerator.SLiteral</class-id> <category>querying</category><body package="SmallSuiteGenerator-Core" selector="containsVariable:">containsVariable: aVariable	^ false</body><body package="SmallSuiteGenerator-Core" selector="referenceTo:">referenceTo: aClassName	^ (value isClass		ifTrue: [ value name ]		ifFalse: [ value className ]) = aClassName asString</body></methods><methods><class-id>SmallSuiteGenerator.SLiteral</class-id> <category>copying</category><body package="SmallSuiteGenerator-Core" selector="copy">copy	| copy |	copy := super copy.	copy value: value copy.	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.SLiteral</class-id> <category>actions</category><body package="SmallSuiteGenerator-Core" selector="changeOn:">changeOn: aTestCase	| copy |	copy := self copy.	copy value: value mutateToChange.	aTestCase addAssignment: copy</body><body package="SmallSuiteGenerator-Core" selector="insertOn:">insertOn: aTestCase	^ aTestCase addLiteral: self returnType</body></methods><methods><class-id>SmallSuiteGenerator.SLiteral</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Core" selector="value:">value: anObject	value := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SLiteral</class-id> <category>visitor</category><body package="SmallSuiteGenerator-Core" selector="accept:">accept: aSSVisitor	^ aSSVisitor visitLiteral: self</body></methods><methods><class-id>SmallSuiteGenerator.SLiteral</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Core" selector="=">= other	^ super = other		and: [ value isLiteral				ifTrue: [ value = other value ]				ifFalse: [ value isClass						ifTrue: [ value name = other value name ]						ifFalse: [ value className = other value className ] ] ]</body><body package="SmallSuiteGenerator-Core" selector="hash">hash	^ super hash bitXor: value hash</body></methods><methods><class-id>SmallSuiteGenerator.SLiteral class</class-id> <category>parsing</category><body package="SmallSuiteGenerator-Core" selector="value:">value: aValue	^ self new		value: aValue;		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngineTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-GA" selector="testRunOnClassSStudentManual">testRunOnClassSStudentManual	"| testSuite block utility |	utility := SUtilityTypeInfo new.	block := [ SStudent new		scoreStudent: 34;		scoreStudent;		idStudent ].	testSuite := utility testSuiteSStudentManual.	engine		populationSize: 3;		numberOfStatements: 10;		blockToExecute: block;		endForMaxNumberOfGeneration: 10;		typeInfo: utility typeInfosSStudent first;		initializePopulationWith: testSuite;		fitness: (SStatementCoverage coverageOf: block onClass: SStudent).	engine run"	</body><body package="SmallSuiteGenerator-Tests-GA" selector="testRunOnPackagesMatchingSFoo">testRunOnPackagesMatchingSFoo	| first last functionFitness targetPackageRegex typeInfo targetClass |	targetClass := #SFoo fullClassNameSymbol.	targetPackageRegex := 'SmallSuiteGenerator-Scenario'.	typeInfo := utility typeInfoSFooOnPackage1.	self profilerOf: targetPackageRegex.	functionFitness := SMethodCoverage new profiler: profiler.	functionFitness		targetClass: targetClass;		typeInfo: typeInfo.	engine		targetPackageRegex: targetPackageRegex;		typeInfo: typeInfo;		" STON fromString: utility typeInfoStringSFoo3."			targetClassName: targetClass;		fitness: functionFitness;		populationSize: 5;		numberOfGenerations: 5;		populationSize: 10;		run.	first := engine logs first fittestTestCase fitness		at: functionFitness functionName.	last := engine logs last fittestTestCase fitness		at: functionFitness functionName.	self assert: first &gt; 0.	self assert: first &lt;= last</body><body package="SmallSuiteGenerator-Tests-GA" selector="testRunOnPackagesSSTeacherUsingMethodCoverage">testRunOnPackagesSSTeacherUsingMethodCoverage	| first last functionFitness targetPackageRegex typeInfo targetClass |	targetClass := #SSTeacher fullClassNameSymbol.	targetPackageRegex := 'SmallSuiteGenerator-Scenario'.	typeInfo := utility typeInfoSSTeacherOnPackage1.	self profilerOf: targetPackageRegex.	functionFitness := SMethodCoverage new profiler: profiler.	functionFitness		targetClass: targetClass;		typeInfo: typeInfo.	engine		targetPackageRegex: targetPackageRegex;		typeInfo: typeInfo;		"STON fromString: utility typeInfoStringSSTeacher1."			fitness: functionFitness;		targetClassName: targetClass;		populationSize: 10;		numberOfGenerations: 5;		run.	first := engine logs first fittestTestCase fitness		at: functionFitness functionName.	last := engine logs last fittestTestCase fitness		at: functionFitness functionName.	self assert: first &gt; 0.	"20 = (1/5) * 100"	self assert: first &lt;= last	"80 = (4/5) * 100"</body><body package="SmallSuiteGenerator-Tests-GA" selector="testRunOnPackagesSSTeacherUsingStatementCoverage">testRunOnPackagesSSTeacherUsingStatementCoverage	| first last functionFitness targetPackageRegex typeInfo targetClass |	targetClass := #SSTeacher fullClassNameSymbol.	targetPackageRegex := 'SmallSuiteGenerator-Scenario'.	typeInfo := utility typeInfoSSTeacherOnPackage1.	self profilerOf: targetPackageRegex.	functionFitness := SStatementCoverage new profiler: profiler.	functionFitness		targetClass: targetClass;		typeInfo: typeInfo.	engine		targetPackageRegex: targetPackageRegex;		typeInfo: typeInfo;		fitness: functionFitness;		targetClassName: targetClass;		populationSize: 10;		numberOfGenerations: 5;		run.	first := engine logs first fittestTestCase fitness		at: functionFitness functionName.	last := engine logs last fittestTestCase fitness		at: functionFitness functionName.	self assert: first &gt; 0.	"37.5 = (3/8) * 100"	self assert: first &lt;= last	"87.5 = (7/8) * 100"</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngineTest</class-id> <category>running</category><body package="SmallSuiteGenerator-Tests-GA" selector="setUp">setUp	super setUp.	engine := SGAEngine new.	profiler := self aSLProfilerCoverage new.	utility := SUtilityTypeInfo new</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfoTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-Info" selector="testAccesssMessagesFrom">testAccesssMessagesFrom	| typeInfo sfooSymbol stringSymbol intSymbol |	sfooSymbol := #SFoo fullClassNameSymbol.	stringSymbol := #ByteString fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	typeInfo := STypeInfo new		type:			sfooSymbol				-&gt;					(Array						with:							(Array								with:									#returnString										-&gt;											(Array												with: sfooSymbol												with: stringSymbol												with: #()												with: false)								with:									#score										-&gt;											(Array												with: sfooSymbol												with: intSymbol												with: #()												with: true))						with: #()).	self		assertCollection: ((typeInfo accessMessagesFrom: sfooSymbol) collect: #selector)		hasSameElements: #(#score)</body><body package="SmallSuiteGenerator-Tests-Info" selector="testAsTypeInfoScalars">testAsTypeInfoScalars	| typeInfo a b |	typeInfo := STypeInfo		asTypeInfo:			(self aSTypeCollectorClass				profile: [ SConference price: 95 ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario').	self		assertCollection:			(typeInfo scalars values				flatCollect: [ :val | 					(val isKindOf: SConference)						ifTrue: [ ^ #SConference ]						ifFalse: [ ^ val ] ])		hasSameElements:			(Array				with: 95				with: 0				with: 100				with: nil				with: (SConference price: 95)).	typeInfo := STypeInfo		asTypeInfo:			(self aSTypeCollectorClass				profile: [ SFoo new						returnCollection;						returnFloat;						returnNum;						returnString ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario').	self		assertCollection: typeInfo scalars associations		hasSameElements:			(Array				with:					SUndefinedObject basicNew class nameAsSymbol						-&gt; (OrderedCollection with: nil)				with: SmallInteger nameAsSymbol -&gt; (OrderedCollection newFrom: #(0 4))				with:					OrderedCollection nameAsSymbol						-&gt; (OrderedCollection with: OrderedCollection new)				with: ByteString nameAsSymbol -&gt; (OrderedCollection newFrom: #('' 'Hello'))				with: 2.3 class nameAsSymbol -&gt; (OrderedCollection newFrom: #(2.3))				with: SFoo nameAsSymbol -&gt; (OrderedCollection newFrom: SFoo new))</body><body package="SmallSuiteGenerator-Tests-Info" selector="testAsTypeInfoSConferenceOnPackagesMatching">testAsTypeInfoSConferenceOnPackagesMatching	| typeInfo messages |	typeInfo := STypeInfo		asTypeInfo:			(self aSTypeCollectorClass				profile: [ SConference price: 95 ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario').	messages := typeInfo messagesFrom: SConference nameAsSymbol.	self		assertCollection: (messages collect: #selector)		hasSameElements: #(#initialize #price: #price).	self		assert:			((messages flatCollect: [ :aMessage | aMessage receiver types ])				allSatisfy:					[ :aType | aType = SConference nameAsSymbol or: [ aType = SEvent nameAsSymbol ] ]).	self		assertCollection: ((typeInfo messagesFrom: SEvent nameAsSymbol) collect: #selector)		hasSameElements: #(#initialize #price: #price).	self		assertCollection: ((typeInfo messagesFrom: SParty nameAsSymbol) collect: #selector)		hasSameElements: #(#initialize #price: #price).	messages := typeInfo factoryMessagesFrom: SConference nameAsSymbol.	self		assertCollection: (messages collect: #selector)		hasSameElements: #(#price:)</body><body package="SmallSuiteGenerator-Tests-Info" selector="testAsTypeInfoSEventOnPackagesMatching">testAsTypeInfoSEventOnPackagesMatching	| typeInfo messages methodInfo classNameSEvent classNameSConference classNameSParty classNameByteString classNameSmallInteger classNameSStudent elementArray classNameBoolean classNameUndefined |	classNameSEvent := SEvent nameAsSymbol.	classNameSConference := SConference nameAsSymbol.	classNameSParty := SParty nameAsSymbol.	classNameBoolean := false class nameAsSymbol.	classNameByteString := ByteString nameAsSymbol.	classNameSmallInteger := SmallInteger nameAsSymbol.	classNameSStudent := SStudent nameAsSymbol.	classNameUndefined := SUndefinedObject nameAsSymbol.	typeInfo := STypeInfo		asTypeInfo:			(self aSTypeCollectorClass				profile: [ | aConference aPerson |					aConference := SConference new offerPrice: 95.					aPerson := SStudent new name: 'Mary'.					aConference canRegister: aPerson ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario').	self		assert: (typeInfo types at: classNameSEvent) methodTypes size		equals: 4.	self		assert: (typeInfo types at: classNameSEvent) classMethodTypes isEmpty.	self		assert: (typeInfo types at: classNameSConference) methodTypes size		equals: 5.	self		assert: (typeInfo types at: classNameSConference) classMethodTypes isEmpty.	self		assert:			((typeInfo types at: classNameSParty) methodTypes allSatisfy: #isUnary).	self		assert: (typeInfo types at: classNameSParty) classMethodTypes isEmpty.	messages := typeInfo messagesFrom: classNameSConference.	self		assertCollection: (messages collect: #selector)		hasSameElements: #(#initialize #offerPrice: #canRegister: #price).	self		assert:			((messages flatCollect: [ :aMessage | aMessage receiver types ])				allSatisfy:					[ :aType | aType = classNameSConference or: [ aType = classNameSEvent ] ]).	methodInfo := messages		detect: [ :aMessage | aMessage selector = #canRegister: ].	self		assertCollection: methodInfo returnType types		hasSameElements: (Array with: false class nameAsSymbol).	self		assertCollection: methodInfo allArgTypes		hasSameElements: (Array with: classNameSStudent).	self		assertCollection: methodInfo allReceivers		hasSameElements: (Array with: classNameSConference).	elementArray := OrderedCollection new		add: classNameSmallInteger;		add: 2.3 class nameAsSymbol;		add: classNameSStudent;		add: classNameByteString;		add: classNameBoolean;		add: classNameUndefined;		yourself.	self		assertCollection: typeInfo scalars keys		hasSameElements: elementArray</body><body package="SmallSuiteGenerator-Tests-Info" selector="testAsTypeInfoSFooOnClass">testAsTypeInfoSFooOnClass	| profile typeInfo methodInfo classNameSFoo |	classNameSFoo := SFoo nameAsSymbol.	profile := self aSTypeCollectorClass		profile: [ SFoo new return: OrderedCollection ]		forClassNamed: classNameSFoo.	typeInfo := STypeInfo asTypeInfo: profile.	self		assert: (typeInfo types at: classNameSFoo) methodTypes size		equals: 7.	self		assert: (typeInfo types at: classNameSFoo) classMethodTypes isEmpty.	self		assert: (typeInfo methodType: #initialize from: classNameSFoo) returnType type		equals: classNameSFoo.	methodInfo := typeInfo methodType: #return: from: classNameSFoo.	self		assertCollection: methodInfo returnType types		hasSameElements: (Array with: OrderedCollection class nameAsSymbol).	self		assertCollection: methodInfo allArgTypes		hasSameElements: (Array with: OrderedCollection class nameAsSymbol).	self		assertCollection: ((typeInfo messagesFrom: classNameSFoo) collect: #selector)		hasSameElements:			#(#returnFloat #returnCollection #initialize #returnNum #returnString #return:)</body><body package="SmallSuiteGenerator-Tests-Info" selector="testAsTypeInfoSFooWithNil">testAsTypeInfoSFooWithNil	| profile typeInfo methodInfo classNameSFoo |	classNameSFoo := SFoo nameAsSymbol.	profile := self aSTypeCollectorClass		profile: [ SFoo new return: nil ]		forClassNamed: classNameSFoo.	typeInfo := STypeInfo asTypeInfo: profile.	self		assert: (typeInfo types at: classNameSFoo) methodTypes size		equals: 7.	self		assert: (typeInfo types at: classNameSFoo) classMethodTypes isEmpty.	self		assert: (typeInfo methodType: #initialize from: classNameSFoo) returnType type		equals: classNameSFoo.	methodInfo := typeInfo methodType: #return: from: classNameSFoo.	self		assertCollection: methodInfo returnType types		hasSameElements: (Array with: UndefinedObject nameAsSymbol).	self		assertCollection: methodInfo allArgTypes		hasSameElements: (Array with: UndefinedObject nameAsSymbol).	self		assertCollection: ((typeInfo messagesFrom: classNameSFoo) collect: #selector)		hasSameElements:			#(#returnFloat #returnCollection #initialize #returnNum #returnString #return:)</body><body package="SmallSuiteGenerator-Tests-Info" selector="testAsTypeInfoSTeacherOnClass">testAsTypeInfoSTeacherOnClass	| typeInfo classNameSTeacher |	classNameSTeacher := SSTeacher nameAsSymbol.	typeInfo := STypeInfo		asTypeInfo:			(self aSTypeCollectorClass				profile: [ (SSTeacher name: 'Ann' with: 34)						name;						nickname;						yearsWorkExperience;						idTeacher;						id ]				forClassNamed: classNameSTeacher).	self		assertCollection:			((typeInfo types at: classNameSTeacher) methodTypes values				collect: #selector)		hasSameElements: #(#idTeacher #initialize #nickname #yearsWorkExperience).	self		assert: (typeInfo types at: classNameSTeacher) classMethodTypes isEmpty.	self		assertCollection: ((typeInfo messagesFrom: classNameSTeacher) collect: #selector)		hasSameElements: #(#initialize #nickname).	self		assertCollection: ((typeInfo accessMessagesFrom: classNameSTeacher) collect: #selector)		hasSameElements: #(#idTeacher #yearsWorkExperience)</body><body package="SmallSuiteGenerator-Tests-Info" selector="testAsTypeInfoSTeacherOnPackagesMatching">testAsTypeInfoSTeacherOnPackagesMatching	| typeInfo |	typeInfo := STypeInfo		asTypeInfo:			(self aSTypeCollectorClass				profile: [ (SSTeacher name: 'Ann' with: 34)						name;						nickname;						yearsWorkExperience;						idTeacher;						id ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario').	self		assertCollection:			((typeInfo types at: SSTeacher nameAsSymbol) methodTypes values				collect: #selector)		hasSameElements: #(#idTeacher #initialize #nickname #yearsWorkExperience).	self		assertCollection:			((typeInfo factoryMessagesFrom: SSTeacher nameAsSymbol)				collect: #selector)		hasSameElements: #(#name:with:).	self		assertCollection: ((typeInfo messagesFrom: SSTeacher nameAsSymbol) collect: #selector)		hasSameElements:			#(#initialize #nickname #identifier #fullIdentifier #id: #nickname: #name:).	self		assertCollection:			((typeInfo accessMessagesFrom: SSTeacher nameAsSymbol)				collect: #selector)		hasSameElements: #(#idTeacher #yearsWorkExperience #name #id)</body><body package="SmallSuiteGenerator-Tests-Info" selector="testClassMethodTypeFrom">testClassMethodTypeFrom	| typeInfo sfooSymbol |	sfooSymbol := #SFoo fullClassNameSymbol.	typeInfo := STypeInfo new		type: sfooSymbol -&gt; (Array with: #() with: #()).	self		should: [ typeInfo classMethodType: #new from: sfooSymbol ]		raise: SError.	typeInfo := STypeInfo new		type:			sfooSymbol				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: sfooSymbol												with: sfooSymbol												with: #()												with: false))						with: #()).	self		shouldnt: [ typeInfo classMethodType: #new from: sfooSymbol ]		raise: SError</body><body package="SmallSuiteGenerator-Tests-Info" selector="testEquals">testEquals	| sfooSymbol studentSymbol stringSymbol intSymbol |	sfooSymbol := #SFoo fullClassNameSymbol.	studentSymbol := #SStudent fullClassNameSymbol.	stringSymbol := #ByteString fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	self		assert: (STypeInfo new type: sfooSymbol -&gt; #(#() #()))		equals: (STypeInfo new type: sfooSymbol -&gt; #(#() #())).	self		assert:			(STypeInfo new				type:					studentSymbol						-&gt;							(Array								with:									(Array										with:											#name												-&gt;													(Array														with: studentSymbol														with: stringSymbol														with: #()														with: false))								with: #());				scalar: stringSymbol with: #('Abi'))		equals:			(STypeInfo new				type:					studentSymbol						-&gt;							(Array								with:									(Array										with:											#name												-&gt;													(Array														with: studentSymbol														with: stringSymbol														with: #()														with: false))								with: #());				scalar: stringSymbol with: #('Abi')).	self		assert:			(STypeInfo new				type:					sfooSymbol						-&gt;							(Array								with:									(Array										with:											#return:												-&gt;													(Array														with: sfooSymbol														with: studentSymbol														with: (Array with: studentSymbol)														with: false))								with:									(Array										with:											#score:												-&gt;													(Array														with: sfooSymbol														with: sfooSymbol														with: (Array with: intSymbol)														with: false)));				scalar: intSymbol with: #(1 3 4);				scalar: studentSymbol					with: (Array with: (SStudent name: 'Nilson')))		equals:			(STypeInfo new				type:					sfooSymbol						-&gt;							(Array								with:									(Array										with:											#return:												-&gt;													(Array														with: sfooSymbol														with: studentSymbol														with: (Array with: studentSymbol)														with: false))								with:									(Array										with:											#score:												-&gt;													(Array														with: sfooSymbol														with: sfooSymbol														with: (Array with: intSymbol)														with: false)));				scalar: intSymbol with: #(1 3 4);				scalar: studentSymbol					with: (Array with: (SStudent name: 'Nilson')))</body><body package="SmallSuiteGenerator-Tests-Info" selector="testFactoryMessages">testFactoryMessages	| typeInfo classNameStudent studentSymbol confSymbol |	classNameStudent := SStudent nameAsSymbol.	studentSymbol := #SStudent fullClassNameSymbol.	confSymbol := #SConference fullClassNameSymbol.	typeInfo := STypeInfo		asTypeInfo:			(self aSTypeCollectorClass				profile: [ SStudent name: 'Mary' ]				forClassNamed: classNameStudent).	self assert: (typeInfo factoryMessagesFrom: studentSymbol) isEmpty.	typeInfo := STypeInfo		asTypeInfo:			(self aSTypeCollectorClass				profile: [ SStudent name: 'Mary' ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario').	self		assertCollection: ((typeInfo factoryMessagesFrom: studentSymbol) collect: #selector)		hasSameElements: #(#name:).	typeInfo := STypeInfo		asTypeInfo:			(self aSTypeCollectorClass				profile: [ SConference price: 95 ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario').	self		assertCollection: ((typeInfo factoryMessagesFrom: confSymbol) collect: #selector)		hasSameElements: #(#price:)</body><body package="SmallSuiteGenerator-Tests-Info" selector="testFactoryMessagesFrom">testFactoryMessagesFrom	"self halt"	</body><body package="SmallSuiteGenerator-Tests-Info" selector="testIsAbstracClass">testIsAbstracClass	| typeInfo personSymbol stringSymbol intSymbol |	personSymbol := #SSPerson fullClassNameSymbol.	stringSymbol := #ByteString fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	typeInfo := STypeInfo new		type:			personSymbol				-&gt;					(Array						with:							(Array								with:									#name										-&gt;											(Array												with: personSymbol												with: stringSymbol												with: #()												with: true)								with:									#id										-&gt;											(Array												with: personSymbol												with: intSymbol												with: #()												with: false))						with:							(Array								with:									#name:with:										-&gt;											(Array												with: personSymbol												with: personSymbol												with: (Array with: stringSymbol with: intSymbol)												with: false)));		scalar: intSymbol with: #(50);		scalar: stringSymbol with: #('Ann').	self assert: (typeInfo isAbstractClass: personSymbol)</body><body package="SmallSuiteGenerator-Tests-Info" selector="testJoinWith">testJoinWith	| typeInfo methodInfo otherTypeInfo sfooSymbol collSymbol intSymbol stringSymbol floatSymbol stackSymbol |	sfooSymbol := #SFoo fullClassNameSymbol.	collSymbol := #OrderedCollection fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	stringSymbol := #ByteString fullClassNameSymbol.	floatSymbol := #SmallFloat64 fullClassNameSymbol.	stackSymbol := #SStack fullClassNameSymbol.	typeInfo := STypeInfo new		type:			sfooSymbol				-&gt;					(Array						with:							(Array								with:									#return:										-&gt;											(Array												with: sfooSymbol												with: collSymbol												with: (Array with: collSymbol)												with: false)								with:									#score:										-&gt;											(Array												with: sfooSymbol												with: sfooSymbol												with: (Array with: intSymbol)												with: false)								with:									#score										-&gt;											(Array												with: sfooSymbol												with: intSymbol												with: #()												with: false))						with:							(Array								with:									#score:										-&gt;											(Array												with: sfooSymbol												with: sfooSymbol												with: (Array with: intSymbol)												with: false))).	otherTypeInfo := STypeInfo new		type:			sfooSymbol				-&gt;					(Array						with:							(Array								with:									#returnFloat										-&gt;											(Array												with: sfooSymbol												with: floatSymbol												with: #()												with: false)								with:									#returnString										-&gt;											(Array												with: sfooSymbol												with: stringSymbol												with: #()												with: false)								with:									#return:										-&gt;											(Array												with: sfooSymbol												with: stackSymbol												with: (Array with: stackSymbol)												with: false))						with: #()).	typeInfo joinWith: otherTypeInfo.	self		assert: (typeInfo types at: sfooSymbol) methodTypes size		equals: 5.	self		assert: (typeInfo types at: sfooSymbol) classMethodTypes size		equals: 1.	methodInfo := typeInfo methodType: #return: from: sfooSymbol.	self assert: methodInfo receiver type equals: sfooSymbol.	self		assertCollection: (Array with: collSymbol with: stackSymbol)		hasSameElements: methodInfo returnType types.	self		assertCollection: (Array with: collSymbol with: stackSymbol)		hasSameElements: (methodInfo argTypes flatCollect: [ :argType | argType types ]).	self		assert: (typeInfo methodType: #returnFloat from: sfooSymbol) returnType type		equals: floatSymbol.	self		assert: (typeInfo methodType: #returnString from: sfooSymbol) returnType type		equals: stringSymbol.	self		assert: (typeInfo methodType: #score from: sfooSymbol) returnType type		equals: intSymbol.	methodInfo := typeInfo methodType: #score: from: sfooSymbol.	self assert: methodInfo receiver type equals: sfooSymbol.	self assert: methodInfo returnType type equals: sfooSymbol.	self		assertCollection: (methodInfo argTypes flatCollect: [ :argType | argType types ])		hasSameElements: (Array with: intSymbol).	self		assert: (typeInfo classMethodType: #score: from: sfooSymbol) returnType type		equals: sfooSymbol</body><body package="SmallSuiteGenerator-Tests-Info" selector="testMessagesFrom">testMessagesFrom	| typeInfo sfooSymbol intSymbol stringSymbol floatSymbol |	sfooSymbol := #SFoo fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	stringSymbol := #ByteString fullClassNameSymbol.	floatSymbol := #SmallFloat64 fullClassNameSymbol.	typeInfo := STypeInfo new		type:			sfooSymbol				-&gt;					(Array						with:							(Array								with:									#returnFloat										-&gt;											(Array												with: sfooSymbol												with: floatSymbol												with: #()												with: false)								with:									#returnString										-&gt;											(Array												with: sfooSymbol												with: stringSymbol												with: #()												with: false)								with:									#score										-&gt;											(Array												with: sfooSymbol												with: intSymbol												with: #()												with: true))						with:							(Array								with:									#score:										-&gt;											(Array												with: sfooSymbol												with: sfooSymbol												with: (Array with: intSymbol)												with: false))).	self		assertCollection: ((typeInfo messagesFrom: sfooSymbol) collect: #selector)		hasSameElements: #(#returnFloat #returnString)	"self assertCollection: ((typeInfo accessMessagesFrom: #SFoo) collect: #selector) hasSameElements: #(#score)."</body><body package="SmallSuiteGenerator-Tests-Info" selector="testNoneAbstractClasses">testNoneAbstractClasses	| typeInfo personSymbol studentSymbol intSymbol stringSymbol abstractSymbol |	personSymbol := #SSPerson fullClassNameSymbol.	studentSymbol := #SStudent fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	stringSymbol := #ByteString fullClassNameSymbol.	abstractSymbol := #SAbstractClass fullClassNameSymbol.	typeInfo := STypeInfo new		type:			personSymbol				-&gt;					(Array						with:							(Array								with:									#name										-&gt;											(Array												with: personSymbol												with: stringSymbol												with: #()												with: true)								with:									#id										-&gt;											(Array												with: personSymbol												with: intSymbol												with: #()												with: false))						with:							(Array								with:									#name:with:										-&gt;											(Array												with: personSymbol												with: personSymbol												with: (Array with: stringSymbol with: intSymbol)												with: false)));		type:			abstractSymbol				-&gt;					(Array						with:							(Array								with:									#id										-&gt;											(Array												with: abstractSymbol												with: intSymbol												with: #()												with: true))						with: #());		type:			studentSymbol				-&gt;					(Array						with:							(Array								with:									#scoreStudent										-&gt;											(Array												with: studentSymbol												with: intSymbol												with: #()												with: true))						with: #());		scalar: intSymbol with: #(50 1);		scalar: stringSymbol with: #('Ann').	self		assertCollection: (typeInfo noneAbstractClasses collect: #nameAsSymbol) asArray		hasSameElements: (Array with: studentSymbol)</body><body package="SmallSuiteGenerator-Tests-Info" selector="testScalar">testScalar	| typeInfo |	typeInfo := STypeInfo new		scalar: #SmallInteger with: #(1 5 6);		scalar: #ByteString with: #('hello' 'world');		scalar: #Dictionary			with:			(Array				with: Dictionary new				with:					(Dictionary new						at: 2 put: 3;						yourself)).	self		assertCollection: typeInfo scalars keys		hasSameElements: #(#Dictionary #ByteString #SmallInteger).	self		assertCollection: (typeInfo scalars at: #ByteString)		hasSameElements: #('hello' 'world').	self		assertCollection: (typeInfo scalars at: #SmallInteger)		hasSameElements: #(1 5 6).	self		assertCollection: ((typeInfo scalars at: #Dictionary) collect: #className)		hasSameElements: #('Dictionary' 'Dictionary')</body><body package="SmallSuiteGenerator-Tests-Info" selector="testType">testType	| typeInfo methodInfo sfooSymbol collSymbol intSymbol stringSymbol floatSymbol |	sfooSymbol := #SFoo fullClassNameSymbol.	collSymbol := #OrderedCollection fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	stringSymbol := #ByteString fullClassNameSymbol.	floatSymbol := #SmallFloat64 fullClassNameSymbol.	typeInfo := STypeInfo new		type:			sfooSymbol				-&gt;					(Array						with:							(Array								with:									#returnFloat										-&gt;											(Array												with: sfooSymbol												with: floatSymbol												with: #()												with: false)								with:									#returnString										-&gt;											(Array												with: sfooSymbol												with: stringSymbol												with: #()												with: false)								with:									#return:										-&gt;											(Array												with: sfooSymbol												with: collSymbol												with: (Array with: collSymbol)												with: false)								with:									#score:										-&gt;											(Array												with: sfooSymbol												with: sfooSymbol												with: (Array with: intSymbol)												with: false)								with:									#score										-&gt;											(Array												with: sfooSymbol												with: intSymbol												with: #()												with: false))						with:							(Array								with:									#score:										-&gt;											(Array												with: sfooSymbol												with: sfooSymbol												with: (Array with: intSymbol)												with: false))).	self		assert: (typeInfo types at: sfooSymbol) methodTypes size		equals: 5.	self		assert: (typeInfo types at: sfooSymbol) classMethodTypes size		equals: 1.	methodInfo := typeInfo methodType: #return: from: sfooSymbol.	self assert: methodInfo receiver type equals: sfooSymbol.	self assert: methodInfo returnType type equals: collSymbol.	self		assertCollection: methodInfo allArgTypes		hasSameElements: (Array with: collSymbol).	self		assert: (typeInfo methodType: #returnFloat from: sfooSymbol) returnType type		equals: floatSymbol.	self		assert: (typeInfo methodType: #returnString from: sfooSymbol) returnType type		equals: stringSymbol.	self		assert: (typeInfo methodType: #score from: sfooSymbol) returnType type		equals: intSymbol.	methodInfo := typeInfo methodType: #score: from: sfooSymbol.	self assert: methodInfo receiver type equals: sfooSymbol.	self assert: methodInfo returnType type equals: sfooSymbol.	self		assertCollection: methodInfo allArgTypes		hasSameElements: (Array with: intSymbol).	self		assert: (typeInfo classMethodType: #score: from: sfooSymbol) returnType type		equals: sfooSymbol</body></methods><methods><class-id>SmallSuiteGenerator.SSVisitorTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-AST" selector="testDictionaryBasedPrinting">testDictionaryBasedPrinting	| test result |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var0 := 1.					 _var1 := 1.					 _var2 := Point x: _var0 y: _var1.					 _var3 := Point x: _var1 y: _var0.					 _var4 := _var2 x.					 _var5 := _var2 closeTo: _var3.').	result := String		streamContents: [ :stream | test accept: (SSDictionaryBasedPrinter on: stream) ].	self		assert: result		equals:			'	var at: 1 put: (1 ).	var at: 2 put: (1 ).	var at: 3 put: (Point x: ( var at: 1 ) y: ( var at: 2 )  ).	var at: 4 put: (Point x: ( var at: 2 ) y: ( var at: 1 )  ).	var at: 5 put: (( var at: 3 ) x ).	var at: 6 put: (( var at: 3 ) closeTo: ( var at: 4 )  ).'</body><body package="SmallSuiteGenerator-Tests-AST" selector="testRename">testRename	| test |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var99 := 1.					 _var23 := 1.					 _var2 := Point x: _var99 y: _var23.					 _var33 := Point x: _var23 y: _var99.					 _var4 := _var2 x.					 _var5 := _var2 equals: _var33.').	SSVariableNameSwapper repairNamesOf: test.	self		assert: test printString		equals:			'	_var0 := 1.	_var1 := 1.	_var2 := Point x: _var0 y: _var1 .	_var3 := Point x: _var1 y: _var0 .	_var4 := _var2 x.	_var5 := _var2 equals: _var3 .'</body><body package="SmallSuiteGenerator-Tests-AST" selector="testRunWithoutAsssertions">testRunWithoutAsssertions	| test result |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var0 := 1.					 _var1 := 0.					 _var2 := Point x: _var0 y: _var1.					 _var3 := Point x: _var1 y: _var0.					 _var4 := _var2 x.					 _var5 := _var2 &gt; _var3.').	result := test runWithoutAssertions.	self assert: (result at: '_var0') equals: 1.	self assert: (result at: '_var1') equals: 0.	self assert: (result at: '_var2') equals: 1 @ 0.	self assert: (result at: '_var3') equals: 0 @ 1.	self assert: (result at: '_var4') equals: 1.	self assert: (result at: '_var5') equals: false</body><body package="SmallSuiteGenerator-Tests-AST" selector="testStandardPrinting">testStandardPrinting	| test result |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var0 := 1.					 _var1 := 1.					 _var2 := Point x: _var0 y: _var1.					 _var3 := Point x: _var1 y: _var0.					 _var4 := _var2 x.					 _var5 := _var2 equals: _var3.').	result := String		streamContents: [ :stream | test accept: (SSStandardPrinter on: stream) ].	self		assert: result		equals:			'	_var0 := 1.	_var1 := 1.	_var2 := Point x: _var0 y: _var1 .	_var3 := Point x: _var1 y: _var0 .	_var4 := _var2 x.	_var5 := _var2 equals: _var3 .'</body></methods><methods><class-id>SmallSuiteGenerator.SAssignment</class-id> <category>evaluating</category><body package="SmallSuiteGenerator-Core" selector="value">value	^ value</body></methods><methods><class-id>SmallSuiteGenerator.SAssignment</class-id> <category>querying</category><body package="SmallSuiteGenerator-Core" selector="containsVariable:">containsVariable: aVariable	^ self value containsVariable: aVariable</body><body package="SmallSuiteGenerator-Core" selector="isThereEnoughArgumentsToBuild:">isThereEnoughArgumentsToBuild: aTestCase	^ self value isThereEnoughArgumentsToBuild: aTestCase</body><body package="SmallSuiteGenerator-Core" selector="reference">reference	^ variable</body><body package="SmallSuiteGenerator-Core" selector="referenceTo:">referenceTo: aClassName	^ value referenceTo: aClassName</body></methods><methods><class-id>SmallSuiteGenerator.SAssignment</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Core" selector="initialize">initialize	super initialize</body></methods><methods><class-id>SmallSuiteGenerator.SAssignment</class-id> <category>copying</category><body package="SmallSuiteGenerator-Core" selector="copy">copy	| copy |	copy := super copy.	copy		variable: variable copy;		value: value copy.	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.SAssignment</class-id> <category>actions</category><body package="SmallSuiteGenerator-Core" selector="changeOn:">changeOn: aTestCase	^ self value changeOn: aTestCase</body><body package="SmallSuiteGenerator-Core" selector="fixWith:in:">fixWith: anObject in: aTestCase	value fixWith: anObject in: aTestCase.	returnType := value returnType.	variable returnType: value returnType</body><body package="SmallSuiteGenerator-Core" selector="insertOn:">insertOn: aTestCase	^ value insertOn: aTestCase</body></methods><methods><class-id>SmallSuiteGenerator.SAssignment</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Core" selector="id">id	^ variable id</body><body package="SmallSuiteGenerator-Core" selector="value:">value: anObject	value := anObject</body><body package="SmallSuiteGenerator-Core" selector="variable">variable	^ variable</body><body package="SmallSuiteGenerator-Core" selector="variable:">variable: anObject	variable := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SAssignment</class-id> <category>visitor</category><body package="SmallSuiteGenerator-Core" selector="accept:">accept: aSSVisitor	^ aSSVisitor visitAssignment: self</body></methods><methods><class-id>SmallSuiteGenerator.SAssignment</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Core" selector="=">= other	^ super = other		and: [ variable = other variable and: [ value = other value ] ]</body><body package="SmallSuiteGenerator-Core" selector="hash">hash	^ super hash bitXor: (variable hash bitXor: value hash)</body></methods><methods><class-id>SmallSuiteGenerator.SAssignment class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Core" selector="name:value:">name: aVariable value: anExpression	^ self new		variable: aVariable;		value: anExpression;		returnType: anExpression returnType;		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SSStandardPrinter</class-id> <category>visiting-core</category><body package="SmallSuiteGenerator-Strategies" selector="visitAbstractMessage:">visitAbstractMessage: aMessage	| selector |	"this only propagate the visit"	selector := aMessage selector.	aMessage receiver accept: self.	stream space.	(selector isKeyword or: [ selector isBinary ])		ifTrue: [ selector keywords				with: aMessage args				do: [ :key :arg | 					stream						nextPutAll: key;						space.					arg accept: self.					stream space ] ]		ifFalse: [ stream nextPutAll: selector ]</body><body package="SmallSuiteGenerator-Strategies" selector="visitAssignment:">visitAssignment: anAssignmnet	anAssignmnet variable accept: self.	stream nextPutAll: ' := '.	anAssignmnet value accept: self</body><body package="SmallSuiteGenerator-Strategies" selector="visitCascade:">visitCascade: aCascade	stream nextPut: $(.	aCascade messages first receiver accept: self.	stream		nextPut: $);		cr.	aCascade messages		do: [ :msj | 			stream tab.			msj selector isKeyword				ifTrue: [ msj selector keywords						with: msj args						do: [ :key :arg | 							stream								nextPutAll: key;								space.							arg accept: self.							stream space ] ]				ifFalse: [ stream nextPutAll: msj selector ] ]		separatedBy: [ stream				nextPut: $;;				cr ]</body><body package="SmallSuiteGenerator-Strategies" selector="visitLiteral:">visitLiteral: aLiteral	| val |	val := aLiteral value.	(val isNumber or: [ val isBlock ])		ifTrue: [ val printOn: stream ]		ifFalse: [ SPlatform initLevelToPrint.			val storeOn: stream ]</body><body package="SmallSuiteGenerator-Strategies" selector="visitSelf:">visitSelf: aSelf	stream nextPutAll: 'self'</body><body package="SmallSuiteGenerator-Strategies" selector="visitSequenceNode:">visitSequenceNode: aSequenceNode	self visitStatements: aSequenceNode statements</body><body package="SmallSuiteGenerator-Strategies" selector="visitStatements:">visitStatements: expresions	expresions		do: [ :exp | 			stream tab.			exp accept: self.			stream				nextPut: $.;				cr ]</body><body package="SmallSuiteGenerator-Strategies" selector="visitVariable:">visitVariable: aVariable	stream nextPutAll: aVariable varName.	"when the id is nil, it meas that is a class, no the best solution I know"	aVariable id ifNotNil: [ aVariable id printOn: stream ]</body></methods><methods><class-id>SmallSuiteGenerator.SSStandardPrinter</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Strategies" selector="contents">contents	^ stream contents</body><body package="SmallSuiteGenerator-Strategies" selector="stream">stream	^ stream</body><body package="SmallSuiteGenerator-Strategies" selector="stream:">stream: anObject	stream := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SSStandardPrinter class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Strategies" selector="on:">on: aStream	^ self new		stream: aStream;		yourself</body><body package="SmallSuiteGenerator-Strategies" selector="printTempVariables:on:">printTempVariables: aTestCase on: aStream	aStream		tab;		nextPut: $|;		space.	aTestCase assignedIds		do: [ :id | 			aStream				nextPutAll: '_var';				nextPutAll: id asString;				space ].	aTestCase lastTemporaries		do: [ :tmp | 			aStream				nextPutAll: tmp fullName asString;				space ].	aStream		space;		nextPut: $|;		cr</body></methods><methods><class-id>SmallSuiteGenerator.SSStandardPrinter class</class-id> <category>testing</category><body package="SmallSuiteGenerator-Strategies" selector="hasLimit">hasLimit	^ true</body><body package="SmallSuiteGenerator-Strategies" selector="isDictionary">isDictionary	^ false</body></methods><methods><class-id>SmallSuiteGenerator.SSDictionaryBasedPrinter</class-id> <category>intialization</category><body package="SmallSuiteGenerator-Strategies" selector="initialize">initialize	super initialize.	dictionaryName := 'var'</body></methods><methods><class-id>SmallSuiteGenerator.SSDictionaryBasedPrinter</class-id> <category>visiting-core</category><body package="SmallSuiteGenerator-Strategies" selector="visitAssignment:">visitAssignment: anAssignmnet	stream nextPutAll: dictionaryName.	stream nextPutAll: ' at: '.	anAssignmnet variable id + 1 printOn: stream.	stream nextPutAll: ' put: ('.	anAssignmnet value accept: self.	stream nextPutAll: ' )'</body><body package="SmallSuiteGenerator-Strategies" selector="visitVariable:">visitVariable: aVariable	aVariable id		ifNil: [ stream nextPutAll: aVariable varName ]		ifNotNil: [ stream nextPutAll: '( '.			stream nextPutAll: dictionaryName.			stream nextPutAll: ' at: '.			aVariable id + 1 printOn: stream.			stream nextPutAll: ' )' ]</body></methods><methods><class-id>SmallSuiteGenerator.SSDictionaryBasedPrinter</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Strategies" selector="dictionaryName">dictionaryName	^ dictionaryName</body><body package="SmallSuiteGenerator-Strategies" selector="dictionaryName:">dictionaryName: anObject	dictionaryName := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SSDictionaryBasedPrinter class</class-id> <category>testing</category><body package="SmallSuiteGenerator-Strategies" selector="hasLimit">hasLimit	^ false</body><body package="SmallSuiteGenerator-Strategies" selector="isDictionary">isDictionary	^ true</body></methods><methods><class-id>SmallSuiteGenerator.SSDictionaryBasedPrinter class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Strategies" selector="printTempVariables:on:">printTempVariables: aTestCase on: aStream	aStream		tab;		nextPut: $|;		space.	aStream nextPutAll: 'var'.	aStream		space;		nextPut: $|;		cr.	aStream		tab;		nextPutAll: 'var := Dictionary new.';		cr</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>building-actions</category><body package="SmallSuiteGenerator-Core" selector="addAssignment:">addAssignment: anExpression	| assignment |	assignment := self newAssignment: anExpression.	self addStatement: assignment.	^ assignment</body><body package="SmallSuiteGenerator-Core" selector="addFactoryMessage">addFactoryMessage	| variables |	variables := self objectVariables.	variables		ifNotEmpty: [ ^ self addFactoryMessage: variables pickAny returnType ].	^ typeInfo noneAbstractClasses		safelyPickAny: [ :class | self addFactoryMessage: class name fullClassNameSymbol ]		ifNone: [ self serror: 'Cannot create a factoryMessage.' ]</body><body package="SmallSuiteGenerator-Core" selector="addFactoryMessage:">addFactoryMessage: symbol	^ self addAssignment: (self newFactoryMessage: symbol)</body><body package="SmallSuiteGenerator-Core" selector="addFactoryMessage:usingSelector:">addFactoryMessage: aClassName usingSelector: aSelector	| method |	method := typeInfo classMethodType: aSelector from: aClassName.	^ [ self		addAssignment: (self newFactoryMessage: method from: aClassName) ]		on: SError		do: [ self addFactoryMessage: aClassName ]</body><body package="SmallSuiteGenerator-Core" selector="addFieldAccessMessage">addFieldAccessMessage	| receiver method |	receiver := self pickAnObjectVariable.	method := self pickAccessorsOf: receiver returnType.	method		ifEmpty: [ self serror: 'Cannot create a field access message.' ].	^ self		addFieldAccessMessage: (self selectMethod: method)		withReceiver: receiver</body><body package="SmallSuiteGenerator-Core" selector="addFieldAccessMessage:from:">addFieldAccessMessage: selector from: returnType	| receiver accessors accessor |	accessors := self pickAccessorsOf: returnType.	accessor := accessors		detect: [ :acc | acc selector = selector ]		ifNone: [ self				serror:					'None field access message of selector: ' , selector asString						, ' matches with: ' , returnType asString ].	receiver := self pickOrCreateObjectVariableOf: returnType.	^ self addFieldAccessMessage: accessor withReceiver: receiver</body><body package="SmallSuiteGenerator-Core" selector="addFieldAccessMessage:withReceiver:">addFieldAccessMessage: method withReceiver: receiver	| result |	result := self		addAssignment: (SFieldAccessMessage newFromReceiver: receiver copy andMethod: method).	^ result</body><body package="SmallSuiteGenerator-Core" selector="addLiteral">addLiteral	^ self addLiteral: self randomLiteralClassName</body><body package="SmallSuiteGenerator-Core" selector="addLiteral:">addLiteral: aClassName	^ self addAssignment: (self newLiteral: aClassName)</body><body package="SmallSuiteGenerator-Core" selector="addMessage">addMessage	| receiver methods |	receiver := self pickAnObjectVariable.	methods := self pickMessagesOf: receiver returnType.	methods		ifEmpty: [ self				serror: 'There are no method typeInfos for: ' , receiver returnType , '.' ].	^ self		addMessage: (self selectMethod: methods)		withReceiver: receiver</body><body package="SmallSuiteGenerator-Core" selector="addMessage:from:">addMessage: selector from: receiverType	| receiver method methods |	methods := (self pickMessagesOf: receiverType)		, (typeInfo factoryMessagesFrom: receiverType).	method := methods		detect: [ :aMessage | aMessage selector = selector ]		ifNone: [ self				serror:					'None message of selector: ' , selector asString , ' matches with: '						, receiverType asString ].	receiver := self pickOrCreateObjectVariableOf: receiverType.	^ self addMessage: method withReceiver: receiver</body><body package="SmallSuiteGenerator-Core" selector="addMessage:withReceiver:">addMessage: method withReceiver: receiver	| result |	result := self addAssignment: (self newMessage: method on: receiver).	^ result</body><body package="SmallSuiteGenerator-Core" selector="addStatement:">addStatement: anExpression	self canAddStatement		ifFalse: [ ^ self ].	statements add: anExpression.	self runWithoutAssertionsAndLastStatement</body><body package="SmallSuiteGenerator-Core" selector="addStatements:">addStatements: collStatements	self		assert: statements isEmpty		description: 'statements must be empty'.	collStatements do: [ :stm | self addStatement: stm ]</body><body package="SmallSuiteGenerator-Core" selector="addStatementWithReturnType:">addStatementWithReturnType: aMultiTypeInfo	[ (self typeInfo isScalar: aMultiTypeInfo)		ifTrue: [ self addLiteral: aMultiTypeInfo ]		ifFalse: [ self addFactoryMessage: aMultiTypeInfo ] ]		on: SError		do: [ :e | self serror: 'we could not build the argument needed' ]</body><body package="SmallSuiteGenerator-Core" selector="buildArgs:">buildArgs: argTypes	^ argTypes		collect: [ :type | 			| arg vars validArgs |			validArgs := type cleanTypesIn: self typeInfo.			validArgs				ifEmpty: [ self serror: 'Types required not exist in typeInfo' ].			arg := validArgs pickAny.			vars := self variablesWithReturnType: arg.			(vars isEmpty or: [ self next &lt; 0.3 ])				ifTrue: [ self addStatementWithReturnType: arg.					vars := self variablesWithReturnType: arg ].			vars pickAny ]</body><body package="SmallSuiteGenerator-Core" selector="generateAssertions">generateAssertions	^ self		generateAssertions:			(Array				with: SComparisonAssertion				with: SInspectorAssertion				with: SPrimitiveAssertion				with: SStringAssertion)</body><body package="SmallSuiteGenerator-Core" selector="generateAssertions:">generateAssertions: classAssertions	"	it analyze each kind of assertion an generate a set of assertion based on the test case -- double dispatch	"	| executionContext |	executionContext := self execute: [ :testCase | testCase analyze ].	assertions := classAssertions		flatCollect: [ :assertion | assertion for: executionContext ]</body><body package="SmallSuiteGenerator-Core" selector="generateStatements">generateStatements	| flag counter |	flag := true.	counter := 0.	self		assert: typeInfo types isNotEmpty		description: 'TypeInfo does not contain info at all.'.	[ flag and: [ self length &lt; self maxNumberOfStatements ] ]		whileTrue: [ | array |			array := (OrderedCollection				with: #addMessage				with: #addFieldAccessMessage) randomShuffle.			array				detect: [ :selector | 					[ (self perform: selector) isNotNil ]						on: SError						do: [ :e | false ] ]				ifNone: [ counter := counter + 1.					counter &gt; self maxNumberOfStatements						ifTrue: [ flag := false.							self serror: 'Not able to generate statements' ] ] ]</body><body package="SmallSuiteGenerator-Core" selector="generateStatements:">generateStatements: anInteger	self maxNumberOfStatements: anInteger.	self runWithoutAssertionsAndLastStatement.	self generateStatements</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>action</category><body package="SmallSuiteGenerator-Core" selector="analyze">analyze	" we use a meta interpreter to use smalltalk and interpret our AST"	| context |	context := self runWithoutAssertions.	self hasErrors		ifTrue: [ self serror: 'Execution error' ].	^ context</body><body package="SmallSuiteGenerator-Core" selector="assignId">assignId	| idToAssign |	idToAssign := nextId.	nextId := nextId + 1.	^ idToAssign</body><body package="SmallSuiteGenerator-Core" selector="clean">clean	"|literals unused|	literals := self statements select: [ :e | (e value isKindOf: SLiteral) or: [ e value isKindOf: SFactoryMessage ] ].	unused := literals difference: (literals select: 		[ :e | (self statements collect: 			[:stm | stm pickUpReferences: e]) anySatisfy: [ :x | x isNotEmpty  ]]).	unused do: [ :stm | self removeStatement: stm ]"	</body><body package="SmallSuiteGenerator-Core" selector="execute:">execute: aBlock	^ self methodsClass on: self execute: aBlock</body><body package="SmallSuiteGenerator-Core" selector="hasErrors:">hasErrors: aBoolean	hasErrors := aBoolean</body><body package="SmallSuiteGenerator-Core" selector="repairIds">repairIds	SSVariableNameSwapper repairNamesOf: self</body><body package="SmallSuiteGenerator-Core" selector="run">run	^ self		execute:			[ :testCase | testCase runStatements: testCase statements	", testCase assertions." ]</body><body package="SmallSuiteGenerator-Core" selector="runStatements:">runStatements: aStatementCollection	" we use a meta interpreter to use smalltalk and interpret our AST"	| interpreter semaphore timeOut process result |	interpreter := self interpreterClass new.	hasErrors := true.	semaphore := Semaphore new.	process := [ [ interpreter		setUp;		visitStatements: aStatementCollection;		waitThread;		tearDown;		clean.	hasErrors := false.	result := interpreter context.	semaphore signal ]		on: Error		do: [ :e | 			result := Dictionary new.			semaphore signal ] ] fork.	timeOut := semaphore waitTimeoutMSecs: 1000.	timeOut		ifTrue: [ process terminate.			result := Dictionary new			"self halt." ].	^ result</body><body package="SmallSuiteGenerator-Core" selector="runWithoutAssertions">runWithoutAssertions	^ self		execute:			[ :testCase | testCase runStatements: testCase statements , testCase lastStatements ]</body><body package="SmallSuiteGenerator-Core" selector="runWithoutAssertionsAndLastStatement">runWithoutAssertionsAndLastStatement	^ self		execute: [ :testCase | testCase runStatements: testCase statements ]</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>mutation-change</category><body package="SmallSuiteGenerator-Core" selector="addAlternativeArgsFor:">addAlternativeArgsFor: aMessageStatement	| copy newArgs |	copy := aMessageStatement copy.	newArgs := OrderedCollection new.	copy args		do: [ :arg | 			| alternatives |			alternatives := self alternativeOfVariables: arg.			alternatives isEmpty				ifTrue: [ newArgs add: arg ]				ifFalse: [ newArgs add: alternatives pickAny ] ].	copy args: newArgs.	self addAssignment: copy</body><body package="SmallSuiteGenerator-Core" selector="addAlternativeFactoryMessage:">addAlternativeFactoryMessage: aFactoryMessage	| returnType receiverType |	returnType := aFactoryMessage returnType.	receiverType := aFactoryMessage receiver returnType.	^ (typeInfo factoryMessagesFrom: receiverType)		detect: [ :meth | 			meth returnType = returnType				and: [ meth selector ~= aFactoryMessage selector ] ]		ifFound:			[ :meth | self addFactoryMessage: receiverType usingSelector: meth selector ]		ifNone: [ self serror: 'there is not alternative factory method' ]</body><body package="SmallSuiteGenerator-Core" selector="addAlternativeFieldAccessMessage:">addAlternativeFieldAccessMessage: aFieldAccessMessage	| returnType receiver |	receiver := aFieldAccessMessage receiver.	returnType := aFieldAccessMessage returnType.	(self pickAccessorsOf: receiver returnType)		detect: [ :meth | 			meth returnType = returnType				and: [ meth selector ~= aFieldAccessMessage selector ] ]		ifFound:			[ :meth | self addFieldAccessMessage: meth selector from: receiver returnType ]		ifNone: [ self				serror:					'There is no alternative for fieldAccessMessage of selector: '						, aFieldAccessMessage selector ]</body><body package="SmallSuiteGenerator-Core" selector="addAlternativeReceiverFor:">addAlternativeReceiverFor: aMessageStatement	| alternatives copy |	alternatives := self		alternativeOfVariables: aMessageStatement receiver.	alternatives		ifEmpty: [ self serror: 'there is not alternatives for the receiver' ].	copy := aMessageStatement copy.	copy receiver: alternatives pickAny.	self addAssignment: copy</body><body package="SmallSuiteGenerator-Core" selector="addAlternativeSelectorFor:">addAlternativeSelectorFor: aMessageStatement	| returnType receiverType |	receiverType := aMessageStatement receiver returnType.	returnType := aMessageStatement returnType.	^ (self pickMessagesOf: receiverType)		detect: [ :meth | 			(meth returnType types includes: returnType)				and: [ meth selector ~= aMessageStatement selector ] ]		ifFound: [ :meth | self addMessage: meth selector from: receiverType ]		ifNone: [ self serror: 'there is not alternative message' ]</body><body package="SmallSuiteGenerator-Core" selector="changeStatement">changeStatement	^ (1 to: self length) asOrderedCollection		safelyPickAny: [ :index | self changeStatementAt: index ]		ifNone: [ self				serror:					'There is not an statement that could be created with the current arguments' ]</body><body package="SmallSuiteGenerator-Core" selector="changeStatementAt:">changeStatementAt: index	"only for testing"	| copy chgStm |	copy := self emptyCopy.	1 to: index - 1 do: [ :i | 		| stm |		stm := self statements at: i.		copy addStatement: stm copy.		copy assignId ].	"if I add args i make sure they have unique names"	copy nextId: self nextId + 1.	chgStm := self statements at: index.	chgStm changeOn: copy.	"make sure that the last statement has the same id than the changed statement, i suppose to have the same type result, or trigger an error"	copy statements last variable id: chgStm variable id.	index + 1 to: self length do: [ :i | 		| stm |		stm := self statements at: i.		copy addStatement: stm copy.		copy assignId ].	copy repairIds.	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Core" selector="newAssignment:">newAssignment: anExpression	^ SAssignment		name:			(SVariable new				varName: '_var';				id: self assignId;				returnType: anExpression returnType;				yourself)		value: anExpression copy</body><body package="SmallSuiteGenerator-Core" selector="newFactoryMessage:">newFactoryMessage: aClassName	| methods |	(typeInfo		classAt: aClassName		ifNone: [ self				serror:					'Error to create factoryMessage of: ' , aClassName						, ' because it is not found in typeInfo.' ]) isAbstract		ifTrue: [ self				serror:					'Error to create factoryMessage of: ' , aClassName						, ' because it is abstract.' ].	methods := typeInfo factoryMessagesFrom: aClassName.	methods		ifNotEmpty: [ [ ^ self newFactoryMessage: methods pickAny from: aClassName ]				on: SError				do: [ :e | nil ] ].	^ SFactoryMessage default: aClassName</body><body package="SmallSuiteGenerator-Core" selector="newFactoryMessage:from:">newFactoryMessage: method from: aClassName	^ SFactoryMessage new		receiver:			(SVariable new				varName: aClassName;				returnType: aClassName;				yourself);		selector: method selector;		args: (self buildArgs: method argTypes);		returnType: aClassName;		yourself</body><body package="SmallSuiteGenerator-Core" selector="newLiteral:">newLiteral: aClassName	typeInfo scalars		at: aClassName		ifPresent: [ :values | 			values				ifEmpty: [ self serror: 'Scalar of type: ' , aClassName , ' is empty.' ].			^ SLiteral new				returnType: aClassName;				value: (self random selectAtRandom: values asOrderedCollection) copy ].	self serror: 'Scalars dont include: ' , aClassName</body><body package="SmallSuiteGenerator-Core" selector="newMessage:on:">newMessage: method on: receiver	^ SMessage new		receiver: receiver;		selector: method selector;		args: (self buildArgs: method argTypes);		returnType: method returnType types first</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Core" selector="assertions">assertions	^ assertions</body><body package="SmallSuiteGenerator-Core" selector="hasErrors">hasErrors	^ hasErrors</body><body package="SmallSuiteGenerator-Core" selector="interpreterClass">interpreterClass	"return the default interpreter"	^ self class defaultInterpreterClass</body><body package="SmallSuiteGenerator-Core" selector="lastMessage">lastMessage	^ lastMessage</body><body package="SmallSuiteGenerator-Core" selector="lastMessage:">lastMessage: anObject	lastMessage := anObject</body><body package="SmallSuiteGenerator-Core" selector="lastStatements">lastStatements	lastMessage ifNil: [ ^ #() ].	^ lastMessage isSequence		ifTrue: [ lastMessage messages ]		ifFalse: [ Array with: lastMessage ]</body><body package="SmallSuiteGenerator-Core" selector="lastTemporaries">lastTemporaries	^ lastMessage isSequence		ifTrue: [ lastMessage temporaries ]		ifFalse: [ #() ]</body><body package="SmallSuiteGenerator-Core" selector="length">length	^ statements size</body><body package="SmallSuiteGenerator-Core" selector="maxNumberOfStatements">maxNumberOfStatements	^ maxNumberOfStatements</body><body package="SmallSuiteGenerator-Core" selector="maxNumberOfStatements:">maxNumberOfStatements: anObject	maxNumberOfStatements := anObject</body><body package="SmallSuiteGenerator-Core" selector="methodsClass">methodsClass	^ self class defaultMethodsClass</body><body package="SmallSuiteGenerator-Core" selector="nextId">nextId	^ nextId</body><body package="SmallSuiteGenerator-Core" selector="nextId:">nextId: newId	nextId := newId</body><body package="SmallSuiteGenerator-Core" selector="notEmpty">notEmpty	^ self length &gt; 0</body><body package="SmallSuiteGenerator-Core" selector="numMaxStatements">numMaxStatements	^ maxNumberOfStatements</body><body package="SmallSuiteGenerator-Core" selector="numMaxStatements:">numMaxStatements: anObject	maxNumberOfStatements := anObject</body><body package="SmallSuiteGenerator-Core" selector="statementAt:">statementAt: statement	statements		detect: [ :stm | stm = statement ]		ifFound: [ :stm | ^ stm ].	self		serror: 'Statement: ' , statement printString , ' is not found in testCase.'</body><body package="SmallSuiteGenerator-Core" selector="statementOfVarName:">statementOfVarName: aString	statements		detect: [ :stm | stm reference printString = aString ]		ifFound: [ :stm | ^ stm ].	self serror: 'Statement of varName: ' , aString , 'is not found.'</body><body package="SmallSuiteGenerator-Core" selector="statements">statements	^ statements</body><body package="SmallSuiteGenerator-Core" selector="targetClassesName">targetClassesName	^ targetClassName</body><body package="SmallSuiteGenerator-Core" selector="targetClassName:">targetClassName: aSymbol	typeInfo types		at: aSymbol		ifAbsent: [ self serror: 'Class name: ' , aSymbol , ' is not found in typeInfo' ].	targetClassName := aSymbol</body><body package="SmallSuiteGenerator-Core" selector="typeInfo">typeInfo	^ typeInfo</body><body package="SmallSuiteGenerator-Core" selector="typeInfo:">typeInfo: anObject	typeInfo := anObject</body><body package="SmallSuiteGenerator-Core" selector="waitThreadStatement">waitThreadStatement	^ [ Array		with:			(SSGParser				parseFrom: (SPlatform rbParserClass parseExpression: 'self waitThread')) ]		on: Error		do: [ #() ]</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>querying</category><body package="SmallSuiteGenerator-Core" selector="allVarNames">allVarNames	^ statements collect: [ :stm | stm reference printString ]</body><body package="SmallSuiteGenerator-Core" selector="alternativeOfVariables:">alternativeOfVariables: aVariable	^ self statements		select: [ :stm | 			stm returnType = aVariable returnType				and: [ (stm variable containsVariable: aVariable) not ] ]		thenCollect: [ :stm | stm variable ]</body><body package="SmallSuiteGenerator-Core" selector="assignedIds">assignedIds	^ statements collect: #id</body><body package="SmallSuiteGenerator-Core" selector="containsVariable:">containsVariable: aVariable	^ self statements anySatisfy: [ :stm | stm variable = aVariable ]</body><body package="SmallSuiteGenerator-Core" selector="containsVariableWithReturnType:">containsVariableWithReturnType: aClassName	^ self statements anySatisfy: [ :stm | stm returnType = aClassName ]</body><body package="SmallSuiteGenerator-Core" selector="noTargetClassIndexs">noTargetClassIndexs	| indexs |	indexs := OrderedCollection new.	self statements		doWithIndex: [ :stm :index | 			(stm value isFactoryMessage				and: [ stm returnType ~= self targetClassesName ])				ifTrue: [ indexs add: index ] ].	^ indexs</body><body package="SmallSuiteGenerator-Core" selector="objectVariables">objectVariables	^ statements		select:			[ :stm | (self typeInfo classAt: stm returnType ifNone: [ nil ]) isNil not ]		thenCollect: [ :stm | stm variable ]</body><body package="SmallSuiteGenerator-Core" selector="pickAccessorsOf:">pickAccessorsOf: aType	^ typeInfo accessMessagesFrom: aType</body><body package="SmallSuiteGenerator-Core" selector="pickAnObjectVariable">pickAnObjectVariable	| variables |	variables := self objectVariables.	variables		ifEmpty: [ self addFactoryMessage.			variables := self objectVariables ].	^ variables pickAny</body><body package="SmallSuiteGenerator-Core" selector="pickMessagesOf:">pickMessagesOf: aType	^ typeInfo messagesFrom: aType</body><body package="SmallSuiteGenerator-Core" selector="pickOrCreateObjectVariableOf:">pickOrCreateObjectVariableOf: aClassName	| variables |	variables := self objectVariables		select: [ :var | var returnType = aClassName ].	variables		ifEmpty: [ self addFactoryMessage: aClassName.			variables := self objectVariables				select: [ :var | var returnType = aClassName ] ].	^ variables pickAny</body><body package="SmallSuiteGenerator-Core" selector="randomLiteralClassName">randomLiteralClassName	| scalars |	scalars := typeInfo scalars keys.	scalars		ifEmpty: [ self				serror: 'TypeInfo does not have scalars. Set scalars on typeInfo.' ].	^ scalars asArray pickAny</body><body package="SmallSuiteGenerator-Core" selector="targetClassArgumentIndexs">targetClassArgumentIndexs	| indexs |	indexs := OrderedCollection new.	self statements		doWithIndex: [ :stm :index | 			(stm value isMessage				and: [ stm value receiver returnType = self targetClassesName ])				ifTrue: [ 1 to: index - 1 do: [ :i | 						| stmAnt |						stmAnt := self statements at: i.						((self typeInfo isScalar: stmAnt returnType) not							and: [ stm value containsVariable: stmAnt variable ])							ifTrue: [ indexs									add:										((Array new: 2)											at: 1 put: i;											at: 2 put: index;											yourself) ] ] ] ].	^ indexs</body><body package="SmallSuiteGenerator-Core" selector="targetClassIndexs">targetClassIndexs	| indexs |	indexs := OrderedCollection new.	self statements		doWithIndex: [ :stm :index | 			(stm value isFactoryMessage				and: [ stm returnType = self targetClassesName ])				ifTrue: [ indexs add: index ] ].	^ indexs</body><body package="SmallSuiteGenerator-Core" selector="variablesWithReturnType:">variablesWithReturnType: type	^ self statements		select: [ :stm | stm returnType = type ]		thenCollect: [ :stm | stm variable ]</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>printing</category><body package="SmallSuiteGenerator-Core" selector="printerClass">printerClass	^ self class defaultPrinterClass</body><body package="SmallSuiteGenerator-Core" selector="printFunctionByClassName:on:">printFunctionByClassName: dict on: stream	(dict associations select: [ :assoc | assoc value &gt; 0 ])		do: [ :assoc | 			stream				nextPutAll: assoc key;				nextPut: $:;				nextPutAll: assoc value printString;				nextPut: $%;				nextPutAll: (String with: Character cr) ]</body><body package="SmallSuiteGenerator-Core" selector="printStatements">printStatements	^ statements collect: #printString</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>initalize</category><body package="SmallSuiteGenerator-Core" selector="initialize">initialize	super initialize.	statements := OrderedCollection new.	assertions := OrderedCollection new.	nextId := 0.	maxNumberOfStatements := 10</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>mutation-insert</category><body package="SmallSuiteGenerator-Core" selector="copyWithANewMethodCallToAnArgumentOfTheTargetClass">copyWithANewMethodCallToAnArgumentOfTheTargetClass	| copy indexs pair insertionIndex argumentFactoryIndex messageIndex receiver methods |	copy := self emptyCopy.	indexs := self targetClassArgumentIndexs.	indexs ifEmpty: [ self serror: 'there is object arguments' ].	"we can not do it"	pair := indexs pickAny.	argumentFactoryIndex := pair first.	messageIndex := pair second.	"we can insert the call any index after the target class object was created"	insertionIndex := self random		nextIntBetween: argumentFactoryIndex		and: messageIndex.	"copy the first statements"	1 to: insertionIndex do: [ :i | 		| statement |		statement := self statements at: i.		copy addStatement: statement copy ].	"assigning ids that do not exists in previous test, then there will be no collitions when at the last part of the statements"	copy nextId: self nextId.	"add the new method call"	receiver := (self statements at: argumentFactoryIndex) variable copy.	methods := self pickMessagesOf: receiver returnType.	methods		ifEmpty: [ self				serror: 'There are no method typeInfos for: ' , receiver returnType , '.' ].	copy addMessage: methods pickAny withReceiver: receiver.	"adding the rest of statements"	insertionIndex + 1 to: self length do: [ :i | 		| statement |		statement := self statements at: i.		copy addStatement: statement copy.		copy assignId ].	"no we got un ordered ids... because we put bigger ides in the middel to avoid collision, so we will fix the ides"	^ copy</body><body package="SmallSuiteGenerator-Core" selector="copyWithANewMethodCallToAnyValue">copyWithANewMethodCallToAnyValue	| copy indexs insertionIndex factoryIndex receiver methods |	copy := self emptyCopy.	indexs := self noTargetClassIndexs.	indexs		ifEmpty: [ self serror: 'there is not object besides target class' ].	"we can not do it"	factoryIndex := indexs pickAny.	"we can insert the call any index after the target class object was created"	insertionIndex := self random		nextIntBetween: factoryIndex		and: self length.	"copy the first statements"	1 to: insertionIndex do: [ :i | 		| statement |		statement := self statements at: i.		copy addStatement: statement copy ].	"assigning ids that do not exists in previous test, then there will be no collitions when at the last part of the statements"	copy nextId: self nextId.	"add the new method call"	receiver := (self statements at: factoryIndex) variable copy.	methods := self pickMessagesOf: receiver returnType.	methods		ifEmpty: [ self				serror: 'There are no method typeInfos for: ' , receiver returnType , '.' ].	copy addMessage: methods pickAny withReceiver: receiver.	"adding the rest of statements"	insertionIndex + 1 to: self length do: [ :i | 		| statement |		statement := self statements at: i.		copy addStatement: statement copy.		copy assignId ].	^ copy</body><body package="SmallSuiteGenerator-Core" selector="copyWithANewMethodCallToTargetClass">copyWithANewMethodCallToTargetClass	| copy indexs insertionIndex factoryIndex receiver methods |	copy := self emptyCopy.	indexs := self targetClassIndexs.	indexs ifEmpty: [ self serror: 'No target class object has found' ].	"we can not do it"	factoryIndex := indexs pickAny.	"we can insert the call any index after the target class object was created"	insertionIndex := self random		nextIntBetween: factoryIndex		and: self length.	"copy the first statements"	1 to: insertionIndex do: [ :i | 		| statement |		statement := self statements at: i.		copy addStatement: statement copy ].	"assigning ids that do not exists in previous test, then there will be no collitions when at the last part of the statements"	copy nextId: self nextId.	"add the new method call"	receiver := (self statements at: factoryIndex) variable copy.	methods := self pickMessagesOf: receiver returnType.	methods		ifEmpty: [ self				serror: 'There are no method typeInfos for: ' , receiver returnType , '.' ].	copy addMessage: methods pickAny withReceiver: receiver.	"adding the rest of statements"	insertionIndex + 1 to: self length do: [ :i | 		| statement |		statement := self statements at: i.		copy addStatement: statement copy.		copy assignId ].	^ copy</body><body package="SmallSuiteGenerator-Core" selector="copyWithARandomStatement">copyWithARandomStatement	| val |	val := self random next.	val &lt;= 0.3		ifTrue: [ ^ self copyWithANewMethodCallToTargetClass ].	val &lt;= 0.6		ifTrue: [ ^ self copyWithANewMethodCallToAnyValue ].	val &lt;= 1		ifTrue: [ ^ self copyWithANewMethodCallToAnArgumentOfTheTargetClass ].	^ self serror: 'We could not insert any statement'</body><body package="SmallSuiteGenerator-Core" selector="insertStatement">insertStatement	| alpha count testCase |	testCase := self.	count := 1.	alpha := 0.5.	[ self length &lt; self maxNumberOfStatements		and: [ self next &lt;= (alpha raisedTo: count) ] ]		whileTrue: [ testCase := testCase copyWithARandomStatement.			count := count + 1 ].	^ testCase</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>util</category><body package="SmallSuiteGenerator-Core" selector="invariant">invariant	self typeInfo		ifNil:			[ self error: 'TypeInfo is nil. Set the testCase with a typeInfo' ]</body><body package="SmallSuiteGenerator-Core" selector="updateNextId">updateNextId	nextId = 0		ifTrue: [ nextId := statements size ]</body><body package="SmallSuiteGenerator-Core" selector="validReferences">validReferences	| references |	references := Set new.	^ statements		detect: [ :stm | 			| variables |			variables := (SSVariablesWithIdCollector new visit: stm)				variablesWithId asSet.			references add: stm reference.			(references includesAll: variables)				ifFalse: [ true ]				ifTrue: [ references addAll: variables.					false ] ]		ifFound: [ false ]		ifNone: [ true ]</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>mutation-remove</category><body package="SmallSuiteGenerator-Core" selector="removeStatement">removeStatement	^ self removeStatementAt: (self random nextInt: self length)</body><body package="SmallSuiteGenerator-Core" selector="removeStatementAt:">removeStatementAt: index	| deletedVariables copy |	self length = 0		ifTrue: [ self serror: 'there is not statements to delete' ].	copy := self emptyCopy.	deletedVariables := OrderedCollection new.	"to give different names to variables"	copy nextId: self nextId.	"lo borramos"	deletedVariables add: (self statements at: index) variable.	"copy the first half"	1 to: index - 1 do: [ :i | 		| stm |		stm := self statements at: i.		copy addStatement: stm copy ].	"carrefully copy the other half"	index + 1 to: self length do: [ :i | 		| stm |		stm := self statements at: i.		(deletedVariables			anySatisfy: [ :delVar | stm containsVariable: delVar ])			ifTrue: [ (stm isThereEnoughArgumentsToBuild: copy)					ifTrue:						[ "if this insert new argument then the argumetns and the same statement will have different names"						stm insertOn: copy.						"make sure that the last statement has the same id, because the rest of statement may depende of him"						copy statements last variable id: stm variable id ]					ifFalse: [ deletedVariables add: stm variable ] ]			ifFalse: [ copy addStatement: stm copy ] ].	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>copying</category><body package="SmallSuiteGenerator-Core" selector="emptyCopy">emptyCopy	| copy |	copy := self class with: typeInfo copy.	copy targetClassName: targetClassName.	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter class</class-id> <category>settings</category><body package="SmallSuiteGenerator-Core" selector="defaultInterpreterClass">defaultInterpreterClass	^ SSMetaInterpreter</body><body package="SmallSuiteGenerator-Core" selector="defaultMethodsClass">defaultMethodsClass	^ SConfigGenerationTestCase</body><body package="SmallSuiteGenerator-Core" selector="defaultPrinterClass">defaultPrinterClass	^ SSStandardPrinter</body><body package="SmallSuiteGenerator-Core" selector="limitToWait">limitToWait	^ 1000</body><body package="SmallSuiteGenerator-Core" selector="resetToDefaults">resetToDefaults	((Array new: 3)		at: 1 put: #defaultInterpreterClass -&gt; SSMetaInterpreter;		at: 2 put: #defaultPrinterClass -&gt; SSStandardPrinter;		at: 3 put: #limitToWait -&gt; 1000;		yourself)		do: [ :val | 			self class				compile: val key asString , String cr , '	^ ' , val value printString ]</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCase</class-id> <category>printing</category><body package="SmallSuiteGenerator-Core" selector="printDescriptiveComment">printDescriptiveComment	^ self printSummaryFitness , (String with: Character cr)		, self printSummaryFitnessByClass</body><body package="SmallSuiteGenerator-Core" selector="printOn:">printOn: aStream	self accept: (self printerClass on: aStream)</body><body package="SmallSuiteGenerator-Core" selector="printString">printString	^ String streamContents: [ :stream | self printOn: stream ]</body><body package="SmallSuiteGenerator-Core" selector="printStringWithAssertions">printStringWithAssertions	^ String		streamContents: [ :stream | 			self printerClass printTempVariables: self on: stream.			(self printerClass on: stream)				visitStatements:					self statements , self waitThreadStatement , self lastStatements						, self assertions ]</body><body package="SmallSuiteGenerator-Core" selector="printSummaryFitness">printSummaryFitness	^ String		streamContents: [ :stream | 			stream				nextPutAll: '"Fitness: ';				nextPut: Character cr.			fitness				associationsDo: [ :assoc | 					stream						nextPutAll: assoc key;						nextPutAll: ': ';						nextPutAll: assoc value printString;						nextPut: Character cr ].			stream nextPutAll: '"' ]</body><body package="SmallSuiteGenerator-Core" selector="printSummaryFitnessByClass">printSummaryFitnessByClass	^ String		streamContents: [ :stream | 			stream				nextPutAll: '"This test covers: ';				nextPut: Character cr.			fitnessByClass				associationsDo: [ :assoc | 					stream						nextPutAll: assoc key;						nextPutAll: (String with: Character cr).					self printFunctionByClassName: assoc value on: stream ].			stream				nextPutAll: '"';				nextPutAll: (String with: Character cr) ]</body><body package="SmallSuiteGenerator-Core" selector="storeOn:">storeOn: aStream	</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCase</class-id> <category>util</category><body package="SmallSuiteGenerator-Core" selector="isBetterThan:using:">isBetterThan: testCase2 using: fitnessStrategy	| fitness1 fitness2 |	fitness1 := self fitness at: fitnessStrategy.	fitness2 := testCase2 fitness at: fitnessStrategy.	fitness1 &gt; fitness2		ifTrue: [ ^ true ].	(self hasErrors		and: [ testCase2 hasErrors not and: [ self next &lt; 0.5 ] ])		ifTrue: [ ^ false ].	(fitness1 = fitness2 and: [ self length &lt; testCase2 length ])		ifTrue: [ ^ true ].	(fitness1 = fitness2		and: [ self length = testCase2 length				and: [ self idPopulation &gt; testCase2 idPopulation ] ])		ifTrue: [ ^ true ].	^ false</body><body package="SmallSuiteGenerator-Core" selector="selectMethod:">selectMethod: aCollection	selectionStrategy ifNil: [ ^ aCollection pickAny ].	^ selectionStrategy		selectJustOneOf: aCollection		with: (aCollection collect: #executions)</body><body package="SmallSuiteGenerator-Core" selector="updateWith:">updateWith: anotherTestCase	self generationNumber: anotherTestCase generationNumber.	self idPopulation: anotherTestCase idPopulation.	anotherTestCase parents		do: [ :parent | 			parent removeChild: anotherTestCase.			self addParent: parent ]</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCase</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Core" selector="addChild:">addChild: aTestCase	children add: aTestCase</body><body package="SmallSuiteGenerator-Core" selector="addParent:">addParent: aTestCase	parents add: aTestCase.	aTestCase addChild: self</body><body package="SmallSuiteGenerator-Core" selector="addParents:">addParents: aCollection	aCollection do: [ :e | self addParent: e ]</body><body package="SmallSuiteGenerator-Core" selector="allChildren">allChildren	^ (Set newFrom: children)		addAll: (children flatCollect: [ :tC | tC allChildren ]);		yourself</body><body package="SmallSuiteGenerator-Core" selector="allParents">allParents	| list |	list := OrderedCollection new.	self allParents: self on: list using: Set new.	^ list</body><body package="SmallSuiteGenerator-Core" selector="allParents:on:using:">allParents: testCase on: collection using: associationSet	testCase parents		reject:			[ :tC | associationSet includes: tC generationNumber -&gt; tC idPopulation ]		thenDo: [ :tC | 			associationSet add: tC generationNumber -&gt; tC idPopulation.			collection add: tC.			self allParents: tC on: collection using: associationSet ]</body><body package="SmallSuiteGenerator-Core" selector="children">children	^ children</body><body package="SmallSuiteGenerator-Core" selector="fitness">fitness	^ fitness</body><body package="SmallSuiteGenerator-Core" selector="fitnessByClass">fitnessByClass	^ fitnessByClass</body><body package="SmallSuiteGenerator-Core" selector="generationNumber">generationNumber	^ generationNumber</body><body package="SmallSuiteGenerator-Core" selector="generationNumber:">generationNumber: anObject	generationNumber := anObject</body><body package="SmallSuiteGenerator-Core" selector="idPopulation">idPopulation	^ idPopulation</body><body package="SmallSuiteGenerator-Core" selector="idPopulation:">idPopulation: anObject	idPopulation := anObject</body><body package="SmallSuiteGenerator-Core" selector="parents">parents	^ parents</body><body package="SmallSuiteGenerator-Core" selector="properties">properties	^ self</body><body package="SmallSuiteGenerator-Core" selector="removeChild:">removeChild: testCase	| index |	index := 0.	children		detect: [ :tC | 			index := index + 1.			tC generationNumber == testCase generationNumber				and: [ tC idPopulation == testCase idPopulation ] ]		ifFound: [ :tC | children removeAt: index ]</body><body package="SmallSuiteGenerator-Core" selector="selectionStrategy:">selectionStrategy: selectStrategy	selectionStrategy := selectStrategy</body><body package="SmallSuiteGenerator-Core" selector="setFitness:">setFitness: aDictionary	fitness := aDictionary copy</body><body package="SmallSuiteGenerator-Core" selector="setFitnessByClass:">setFitnessByClass: aDictionary	fitnessByClass := aDictionary copy</body><body package="SmallSuiteGenerator-Core" selector="summaryExecutionMethods">summaryExecutionMethods	^ summaryExecutionMethods</body><body package="SmallSuiteGenerator-Core" selector="summaryExecutionMethods:">summaryExecutionMethods: summaryExecutionMethod	summaryExecutionMethods := summaryExecutionMethod</body><body package="SmallSuiteGenerator-Core" selector="summaryTargetClass">summaryTargetClass	^ summaryTargetClass</body><body package="SmallSuiteGenerator-Core" selector="summaryTargetClass:">summaryTargetClass: anObject	summaryTargetClass := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCase</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Core" selector="initialize">initialize	super initialize.	generationNumber := 1.	idPopulation := 1.	parents := OrderedCollection new.	children := OrderedCollection new.	summaryExecutionMethods := OrderedCollection new.	hasErrors := false.	fitness := Dictionary new.	fitnessByClass := Dictionary new.	selectionStrategy := SGARouletteSelection new.	properties := Dictionary new</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCase</class-id> <category>copying</category><body package="SmallSuiteGenerator-Core" selector="copy">copy	| copy |	copy := self class with: typeInfo copy.	copy targetClassName: targetClassName.	statements do: [ :stm | copy addStatement: stm copy ].	copy updateNextId.	^ copy</body><body package="SmallSuiteGenerator-Core" selector="deepCopy">deepCopy	| copy |	copy := self copy.	copy setFitness: self fitness.	copy setFitnessByClass: self fitnessByClass.	copy generationNumber: self generationNumber.	copy summaryExecutionMethods: self summaryExecutionMethods.	copy hasErrors: self hasErrors.	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCase</class-id> <category>actions</category><body package="SmallSuiteGenerator-Core" selector="fitnessFor:">fitnessFor: functionName	^ self fitness at: functionName</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCase</class-id> <category>visitor</category><body package="SmallSuiteGenerator-Core" selector="accept:">accept: aVisitor	aVisitor visitStatements: self statements</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCase</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Core" selector="=">= another	^ self class = another class		and: [ statements = another statements				and: [ fitness = another fitness						and: [ parents = another parents								and: [ generationNumber = another generationNumber										and: [ idPopulation = another idPopulation ] ] ] ] ]</body><body package="SmallSuiteGenerator-Core" selector="hash">hash	^ super hash bitXor: self statements hash	"(self number hash bitXor:"	")"</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCase class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Core" selector="with:">with: aTypeInfo	| testCase |	testCase := self new.	testCase typeInfo: aTypeInfo.	^ testCase</body></methods><methods><class-id>SmallSuiteGenerator.SGARouletteSelection</class-id> <category>selection</category><body package="SmallSuiteGenerator-GA" selector="selectJustOneOf:with:">selectJustOneOf: aCollection with: probabilities	| roulette random |	roulette := self createRouletteWith: probabilities.	random := self next.	roulette		doWithIndex: [ :probability :index | 			random &lt; probability				ifTrue: [ ^ aCollection at: index ] ].	^ nil</body><body package="SmallSuiteGenerator-GA" selector="selectOf:">selectOf: aCollection	^ self		selectOf: aCollection		with: (aCollection collect: [ :testCase | self fitnessFor: testCase ])</body><body package="SmallSuiteGenerator-GA" selector="selectOf:with:">selectOf: collection with: probability	| roulette random newCollection collectionSize indexes index |	roulette := self createRouletteWith: probability.	newCollection := OrderedCollection new.	collectionSize := collection size.	indexes := OrderedCollection new.	[ newCollection size &lt; collectionSize ]		whileTrue: [ random := self next.			index := 0.			roulette				detect: [ :rv | 					index := index + 1.					random &lt; rv and: [ (indexes includes: index) not ] ]				ifFound: [ newCollection add: (collection at: index).					indexes add: index ] ].	^ newCollection</body></methods><methods><class-id>SmallSuiteGenerator.SGARouletteSelection</class-id> <category>creating</category><body package="SmallSuiteGenerator-GA" selector="createRouletteWith:">createRouletteWith: probability	| sum roulette |	sum := probability sum.	roulette := probability		collect: [ :e | 			[ e / sum ]				on: Error				do: [ 0 ] ].	2 to: probability size do:		[ :i | roulette at: i put: (roulette at: i - 1) + (roulette at: i) ].	^ roulette</body></methods><methods><class-id>SmallSuiteGenerator.SPrimitiveAssertion</class-id> <category>visitor</category><body package="SmallSuiteGenerator-Core" selector="accept:">accept: aSSVisitor	^ aSSVisitor visitPrimitiveAssertionMessage: self</body></methods><methods><class-id>SmallSuiteGenerator.SPrimitiveAssertion class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Core" selector="for:">for: anExecutionContext	^ anExecutionContext associations		select: [ :assoc | self isPrimitive: assoc value ]		thenCollect: [ :assoc | 			self new				selector: #assert:equals:;				args:					(Array						with: (SVariable nameOrId: assoc key)						with: (SLiteral new value: assoc value));				yourself ]</body></methods><methods><class-id>SmallSuiteGenerator.SUtilityTypeInfo</class-id> <category>examples</category><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoOnPackage1">typeInfoOnPackage1	"the first typeInfo is about a class has as argument other class from other package"	| eventSymbol confSymbol falseSymbol studentSymbol intSymbol |	eventSymbol := #SEvent fullClassNameSymbol.	confSymbol := #SConference fullClassNameSymbol.	falseSymbol := #False fullClassNameSymbol.	studentSymbol := #SStudent fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	^ STypeInfo new		type:			eventSymbol				-&gt;					(Array						with:							(Array								with:									#canRegister:										-&gt;											(Array												with: confSymbol												with: falseSymbol												with: (Array with: studentSymbol)												with: false)								with:									#price										-&gt;											(Array												with: confSymbol												with: intSymbol												with: #()												with: false))						with: #());		type:			confSymbol				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: confSymbol												with: confSymbol												with: #()												with: false)								with:									#offerPrice										-&gt;											(Array												with: confSymbol												with: intSymbol												with: #()												with: true)								with:									#offerPrice:										-&gt;											(Array												with: confSymbol												with: confSymbol												with: (Array with: intSymbol)												with: false)								with:									#discount										-&gt;											(Array												with: confSymbol												with: intSymbol												with: #()												with: true))						with: #());		scalar: intSymbol with: #(95 100);		scalar: falseSymbol with: #(false);		scalar: studentSymbol			with: (Array with: (SStudent new name: 'Mary'))</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoOnPackage2">typeInfoOnPackage2	"the first typeInfo is about a class has as argument other class from other package"	| eventSymbol confSymbol intSymbol |	eventSymbol := #SEvent fullClassNameSymbol.	confSymbol := #SConference fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	^ STypeInfo new		type:			eventSymbol				-&gt;					(Array						with:							(Array								with:									#price:										-&gt;											(Array												with: confSymbol												with: confSymbol												with: (Array with: intSymbol)												with: false))						with:							(Array								with:									#price:										-&gt;											(Array												with: confSymbol												with: confSymbol												with: (Array with: intSymbol)												with: false)));		type:			confSymbol				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: confSymbol												with: confSymbol												with: #()												with: false))						with: #());		scalar: intSymbol with: #(95)</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoOnPackage3">typeInfoOnPackage3	"the first typeInfo is about a class has as argument other class from other package"	"review and modify"	| teacherSymbol confSymbol falseSymbol studentSymbol intSymbol stringSymbol |	teacherSymbol := #SSTeacher fullClassNameSymbol.	confSymbol := #SConference fullClassNameSymbol.	falseSymbol := #False fullClassNameSymbol.	studentSymbol := #SStudent fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	stringSymbol := #ByteString fullClassNameSymbol.	^ STypeInfo new		type:			teacherSymbol				-&gt;					(Array						with:							(OrderedCollection new								add:									#name:										-&gt;											(Array												with: teacherSymbol												with: teacherSymbol												with: (Array with: stringSymbol)												with: false);								add:									#id:										-&gt;											(Array												with: teacherSymbol												with: teacherSymbol												with: (Array with: intSymbol)												with: false);								add:									#nickname:										-&gt;											(Array												with: teacherSymbol												with: teacherSymbol												with: (Array with: stringSymbol)												with: false);								add:									#initialize										-&gt;											(Array												with: teacherSymbol												with: teacherSymbol												with: #()												with: false);								add:									#nickname										-&gt;											(Array												with: teacherSymbol												with: stringSymbol												with: #()												with: false);								add:									#name										-&gt;											(Array												with: teacherSymbol												with: stringSymbol												with: #()												with: true);								add:									#id										-&gt;											(Array												with: teacherSymbol												with: intSymbol												with: #()												with: true);								add:									#yearsWorkExperience										-&gt;											(Array												with: teacherSymbol												with: intSymbol												with: #()												with: true);								add:									#idTeacher										-&gt;											(Array												with: teacherSymbol												with: intSymbol												with: #()												with: true);								yourself)						with:							(Array								with:									#name:with:										-&gt;											(Array												with: teacherSymbol												with: teacherSymbol												with: (Array with: stringSymbol with: intSymbol)												with: false)));		type:			confSymbol				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: confSymbol												with: confSymbol												with: #()												with: false)								with:									#offerPrice										-&gt;											(Array												with: confSymbol												with: intSymbol												with: #()												with: true)								with:									#offerPrice:										-&gt;											(Array												with: confSymbol												with: confSymbol												with: (Array with: intSymbol)												with: false)								with:									#discount										-&gt;											(Array												with: confSymbol												with: intSymbol												with: #()												with: true))						with: #());		scalar: intSymbol with: #(95);		scalar: falseSymbol with: #(false);		scalar: studentSymbol			with: (Array with: (SStudent new name: 'Mary'));		scalar: stringSymbol with: #('Mary')</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoOnPackage4">typeInfoOnPackage4	"the first typeInfo is about a class has as argument other class from other package"	"review and modify"	| eventSymbol confSymbol intSymbol |	eventSymbol := #SEvent fullClassNameSymbol.	confSymbol := #SConference fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	^ STypeInfo new		type:			eventSymbol				-&gt;					(Array						with:							(Array								with:									#price:										-&gt;											(Array												with: confSymbol												with: confSymbol												with: (Array with: intSymbol)												with: false))						with:							(Array								with:									#price:										-&gt;											(Array												with: confSymbol												with: confSymbol												with: (Array with: intSymbol)												with: false)));		type:			confSymbol				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: confSymbol												with: confSymbol												with: #()												with: false))						with: #());		type: #SParty fullClassNameSymbol -&gt; #(#() #());		scalar: intSymbol with: #(95)</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoSAbstractClass">typeInfoSAbstractClass	| abstractSymbol intSymbol |	abstractSymbol := #SAbstractClass fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	^ STypeInfo new		type:			abstractSymbol				-&gt;					(Array						with:							(Array								with:									#id										-&gt;											(Array												with: abstractSymbol												with: intSymbol												with: #()												with: false))						with: #());		scalar: intSymbol with: #(1)</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoSEvent1">typeInfoSEvent1	| eventSymbol intSymbol |	eventSymbol := #SEvent fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	^ STypeInfo new		type:			eventSymbol				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: eventSymbol												with: eventSymbol												with: #()												with: false)								with:									#discount										-&gt;											(Array												with: eventSymbol												with: intSymbol												with: #()												with: true)								with:									#discount:										-&gt;											(Array												with: eventSymbol												with: eventSymbol												with: (Array with: intSymbol)												with: false)								with:									#price										-&gt;											(Array												with: eventSymbol												with: intSymbol												with: #()												with: true)								with:									#price:										-&gt;											(Array												with: eventSymbol												with: eventSymbol												with: (Array with: intSymbol)												with: false))						with:							(Array								with:									#price:										-&gt;											(Array												with: eventSymbol												with: eventSymbol												with: (Array with: intSymbol)												with: false)));		scalar: intSymbol with: #(8)</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoSEvent2">typeInfoSEvent2	| eventSymbol intSymbol |	eventSymbol := #SEvent fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	^ STypeInfo new		type:			eventSymbol				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: eventSymbol												with: eventSymbol												with: #()												with: false)								with:									#discount										-&gt;											(Array												with: eventSymbol												with: intSymbol												with: #()												with: true)								with:									#price										-&gt;											(Array												with: eventSymbol												with: intSymbol												with: #()												with: true))						with:							(Array								with:									#price:										-&gt;											(Array												with: eventSymbol												with: eventSymbol												with: (Array with: intSymbol)												with: false)));		scalar: intSymbol with: #(0 15)</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoSEventOnPackage1">typeInfoSEventOnPackage1	| eventSymbol intSymbol |	eventSymbol := #SEvent fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	^ STypeInfo new		type:			eventSymbol				-&gt;					(Array						with:							(Array								with:									#price										-&gt;											(Array												with: eventSymbol												with: intSymbol												with: #()												with: false)								with:									#discount										-&gt;											(Array												with: eventSymbol												with: intSymbol												with: #()												with: true)								with:									#initialize										-&gt;											(Array												with: eventSymbol												with: eventSymbol												with: #()												with: false)								with:									#price:										-&gt;											(Array												with: eventSymbol												with: eventSymbol												with: (Array with: intSymbol)												with: false))						with:							(Array								with:									#price:										-&gt;											(Array												with: eventSymbol												with: eventSymbol												with: (Array with: intSymbol)												with: false)));		type: #SSTeacher fullClassNameSymbol -&gt; #(#() #());		type: #SSPerson fullClassNameSymbol -&gt; #(#() #());		type: #SStack fullClassNameSymbol -&gt; #(#() #());		type: #SConference fullClassNameSymbol -&gt; #(#() #());		type: #SFoo fullClassNameSymbol -&gt; #(#() #());		type: #SParty fullClassNameSymbol -&gt; #(#() #());		type: eventSymbol -&gt; #(#() #());		scalar: intSymbol with: #(15 0)</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoSFoo2">typeInfoSFoo2	| sfooSymbol |	sfooSymbol := #SFoo fullClassNameSymbol.	^ STypeInfo new		type:			sfooSymbol				-&gt;					(Array						with:							(Array								with:									#return:										-&gt;											(Array												with: sfooSymbol												with: sfooSymbol												with: (Array with: sfooSymbol)												with: false))						with: #())</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoSFoo4">typeInfoSFoo4	| sfooSymbol studentSymbol intSymbol |	sfooSymbol := #SFoo fullClassNameSymbol.	studentSymbol := #SStudent fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	^ STypeInfo new		type:			sfooSymbol				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: sfooSymbol												with: sfooSymbol												with: #()												with: false)								with:									#return:										-&gt;											(Array												with: sfooSymbol												with: studentSymbol												with: (Array with: studentSymbol)												with: false))						with: #());		type:			studentSymbol				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: studentSymbol												with: studentSymbol												with: #()												with: false)								with:									#idStudent										-&gt;											(Array												with: studentSymbol												with: intSymbol												with: #()												with: true)								with:									#scoreStudent										-&gt;											(Array												with: studentSymbol												with: intSymbol												with: #()												with: true)								with:									#scoreStudent:										-&gt;											(Array												with: studentSymbol												with: intSymbol												with: (Array with: intSymbol)												with: false))						with: #());		scalar: 1 class name fullClassNameSymbol			with:			((Array new: 2)				at: 1 put: 1;				at: 2 put: 2;				yourself);		yourself</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoSFoo5">typeInfoSFoo5	| sfooSymbol collSymbol |	sfooSymbol := #SFoo fullClassNameSymbol.	collSymbol := #OrderedCollection fullClassNameSymbol.	^ STypeInfo new		type:			sfooSymbol				-&gt;					(Array						with:							(Array								with:									#return:										-&gt;											(Array												with: sfooSymbol												with: collSymbol												with: (Array with: collSymbol)												with: false))						with: #());		scalar: collSymbol			with:			(Array				with:					(OrderedCollection new						addAll: #(1 4 5);						yourself))</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoSFooEmpty">typeInfoSFooEmpty	^ STypeInfo new		type: #SFoo fullClassNameSymbol -&gt; (Array with: #() with: #())</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoSFooOnPackage1">typeInfoSFooOnPackage1	| sfooSymbol stringSymbol intSymbol studentSymbol collSymbol |	sfooSymbol := #SFoo fullClassNameSymbol.	stringSymbol := #ByteString fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	studentSymbol := #SStudent fullClassNameSymbol.	collSymbol := #OrderedCollection fullClassNameSymbol.	^ STypeInfo new		type:			sfooSymbol				-&gt;					(Array						with:							(Array								with:									#returnCollection										-&gt;											(Array												with: sfooSymbol												with: collSymbol												with: #()												with: false)								with:									#returnString										-&gt;											(Array												with: sfooSymbol												with: stringSymbol												with: #()												with: false)								with:									#score										-&gt;											(Array												with: sfooSymbol												with: intSymbol												with: #()												with: true)								with:									#score:										-&gt;											(Array												with: sfooSymbol												with: sfooSymbol												with: (Array with: intSymbol)												with: false)								with:									#return:										-&gt;											(Array												with: sfooSymbol												with: studentSymbol												with: (Array with: studentSymbol)												with: false))						with:							(Array								with:									#score:										-&gt;											(Array												with: sfooSymbol												with: sfooSymbol												with: (Array with: intSymbol)												with: false)));		type:			#SSPerson fullClassNameSymbol				-&gt;					(Array						with:							(Array								with:									#id:										-&gt;											(Array												with: studentSymbol												with: studentSymbol												with: (Array with: intSymbol)												with: false)								with:									#nickname:										-&gt;											(Array												with: studentSymbol												with: studentSymbol												with: (Array with: stringSymbol)												with: false)								with:									#name:										-&gt;											(Array												with: studentSymbol												with: studentSymbol												with: (Array with: stringSymbol)												with: false))						with:							(Array								with:									#name:										-&gt;											(Array												with: studentSymbol												with: studentSymbol												with: (Array with: stringSymbol)												with: false)));		type: #SStack fullClassNameSymbol -&gt; #(#() #());		type: #SConference fullClassNameSymbol -&gt; #(#() #());		type: #SEvent fullClassNameSymbol -&gt; #(#() #());		type: #SSTeacher fullClassNameSymbol -&gt; #(#() #());		type: #SParty fullClassNameSymbol -&gt; #(#() #());		type: #SEventTest fullClassNameSymbol -&gt; #(#() #());		scalar: intSymbol with: #(5 1 4);		scalar: stringSymbol with: #('Emily' 'Hello');		scalar: collSymbol with: (Array with: OrderedCollection new);		scalar: studentSymbol			with:			(Array				with:					((SStudent name: 'Emily')						nickname;						scoreStudent;						yourself))</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoSFooOnPackage3">typeInfoSFooOnPackage3	| personSymbol intSymbol studentSymbol stringSymbol sfooSymbol dictSymbol stackSymbol |	personSymbol := #SSPerson fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	studentSymbol := #SStudent fullClassNameSymbol.	stringSymbol := #ByteString fullClassNameSymbol.	sfooSymbol := #SFoo fullClassNameSymbol.	dictSymbol := #Dictionary fullClassNameSymbol.	stackSymbol := #SStack fullClassNameSymbol.	^ STypeInfo new		type:			personSymbol				-&gt;					(Array						with:							(Array								with:									#id:										-&gt;											(Array												with: studentSymbol												with: studentSymbol												with: (Array with: intSymbol)												with: false)								with:									#nickname:										-&gt;											(Array												with: studentSymbol												with: studentSymbol												with: (Array with: stringSymbol)												with: false)								with:									#name:										-&gt;											(Array												with: studentSymbol												with: studentSymbol												with: (Array with: stringSymbol)												with: false))						with:							(Array								with:									#name:with:										-&gt;											(Array												with: studentSymbol												with: studentSymbol												with: (Array with: stringSymbol with: intSymbol)												with: false)));		type:			sfooSymbol				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: sfooSymbol												with: sfooSymbol												with: #()												with: false)								with:									#return:										-&gt;											(Array												with: sfooSymbol												with: dictSymbol												with: (Array with: dictSymbol)												with: false))						with: #());		type:			stackSymbol				-&gt;					(Array						with:							(Array								with:									#push:										-&gt;											(Array												with: stackSymbol												with: studentSymbol												with: (Array with: studentSymbol)												with: false))						with: #());		type: #SConference fullClassNameSymbol -&gt; #(#() #());		type: #SEvent fullClassNameSymbol -&gt; #(#() #());		type: #SParty fullClassNameSymbol -&gt; #(#() #());		type: #SSTeacher fullClassNameSymbol -&gt; #(#() #());		type: #SEventTest fullClassNameSymbol -&gt; #(#() #());		scalar: studentSymbol			with:			(Array				with: (SStudent name: 'Mery' with: 5)				with: (SStudent name: 'Josh' with: 2)				with: (SStudent name: 'Lian'));		scalar: dictSymbol			with:			(Array				with:					(Dictionary new						at: 1							put:							(SStack new								push: (SStudent name: 'Josh' with: 2);								push: (SStudent name: 'Lian');								yourself);						at: 2							put:							(OrderedCollection new								add: (SStudent name: 'Mery' with: 5);								yourself);						yourself));		scalar: intSymbol with: #(5 1 2);		scalar: stringSymbol with: #('Josh' 'Lian' 'Mery')</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoSSPerson1">typeInfoSSPerson1	| personSymbol intSymbol stringSymbol |	personSymbol := #SSPerson fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	stringSymbol := #ByteString fullClassNameSymbol.	^ STypeInfo new		type:			personSymbol				-&gt;					(Array						with:							(Array								with:									#name										-&gt;											(Array												with: personSymbol												with: stringSymbol												with: #()												with: true)								with:									#id										-&gt;											(Array												with: personSymbol												with: intSymbol												with: #()												with: false))						with:							(Array								with:									#name:with:										-&gt;											(Array												with: personSymbol												with: personSymbol												with: (Array with: stringSymbol with: intSymbol)												with: false)));		scalar: intSymbol with: #(50);		scalar: stringSymbol with: #('Ann')</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfosSStudent">typeInfosSStudent	| studentSymbol intSymbol stringSymbol |	studentSymbol := #SStudent fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	stringSymbol := #ByteString fullClassNameSymbol.	^ OrderedCollection new		add:			(STypeInfo new				type:					studentSymbol						-&gt;							(Array								with:									(Array										with:											#initialize												-&gt;													(Array														with: studentSymbol														with: studentSymbol														with: #()														with: false)										with:											#scoreStudent												-&gt;													(Array														with: studentSymbol														with: intSymbol														with: #()														with: true)										with:											#scoreStudent:												-&gt;													(Array														with: studentSymbol														with: studentSymbol														with: (Array with: intSymbol)														with: false)										with:											#idStudent												-&gt;													(Array														with: studentSymbol														with: intSymbol														with: #()														with: true))								with: #());				scalar: intSymbol with: #(1);				scalar: stringSymbol with: #('student_Jane'));		add:			(STypeInfo new				type:					studentSymbol						-&gt;							(Array								with:									(Array										with:											#scoreStudent:												-&gt;													(Array														with: studentSymbol														with: studentSymbol														with: (Array with: intSymbol)														with: false)										with:											#nickname												-&gt;													(Array														with: studentSymbol														with: stringSymbol														with: #()														with: false))								with: #());				scalar: intSymbol with: #(1 6 8);				scalar: stringSymbol with: #('Jane' 'Ann' 'Peter'));		yourself</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoSStack1">typeInfoSStack1	| stackSymbol intSymbol arraySymbol |	stackSymbol := #SStack fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	arraySymbol := #Array fullClassNameSymbol.	^ STypeInfo new		type:			stackSymbol				-&gt;					(Array						with:							(Array								with:									#firstLinkStack										-&gt;											(Array												with: stackSymbol												with: intSymbol												with: #()												with: true)								with:									#pop										-&gt;											(Array												with: stackSymbol												with: intSymbol												with: #()												with: false)								with:									#push:										-&gt;											(Array												with: stackSymbol												with: intSymbol												with: (Array with: intSymbol)												with: false))						with:							(Array								with:									#newStackWith:										-&gt;											(Array												with: stackSymbol												with: stackSymbol												with: (Array with: arraySymbol)												with: false)));		scalar: arraySymbol with: #(#(2 4 6 1));		scalar: intSymbol with: #(1 2 4 6 8)</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoSStack2">typeInfoSStack2	| stackSymbol intSymbol arraySymbol |	stackSymbol := #SStack fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	arraySymbol := #Array fullClassNameSymbol.	^ STypeInfo new		type:			stackSymbol				-&gt;					(Array						with:							(Array								with:									#lastLinkStack										-&gt;											(Array												with: stackSymbol												with: intSymbol												with: #()												with: true)								with:									#pop										-&gt;											(Array												with: stackSymbol												with: intSymbol												with: #()												with: false)								with:									#top										-&gt;											(Array												with: stackSymbol												with: intSymbol												with: #()												with: false))						with:							(Array								with:									#newStack										-&gt;											(Array												with: stackSymbol												with: stackSymbol												with: #()												with: false)								with:									#newStackWith:										-&gt;											(Array												with: stackSymbol												with: stackSymbol												with: (Array with: arraySymbol)												with: false)));		scalar: arraySymbol with: #(#(2 4 6 1) #(5 7 9 0));		scalar: intSymbol with: #(1 2 5 8 9)</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoSStack3">typeInfoSStack3	| stackSymbol intSymbol arraySymbol |	stackSymbol := #SStack fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	arraySymbol := #Array fullClassNameSymbol.	^ STypeInfo new		type:			stackSymbol				-&gt;					(Array						with:							(Array								with:									#pop										-&gt;											(Array												with: stackSymbol												with: intSymbol												with: #()												with: false)								with:									#push:										-&gt;											(Array												with: stackSymbol												with: intSymbol												with: (Array with: intSymbol)												with: false)								with:									#top										-&gt;											(Array												with: stackSymbol												with: intSymbol												with: #()												with: false))						with:							(Array								with:									#newStackWith:										-&gt;											(Array												with: stackSymbol												with: stackSymbol												with: (Array with: arraySymbol)												with: false)));		scalar: arraySymbol with: (Array with: #(2 4 6 1));		scalar: intSymbol with: #(7 5 9 1)</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoSStack4">typeInfoSStack4	| stackSymbol intSymbol arraySymbol |	stackSymbol := #SStack fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	arraySymbol := #Array fullClassNameSymbol.	^ STypeInfo new		type:			stackSymbol				-&gt;					(Array						with:							(Array								with:									#firstLinkStack										-&gt;											(Array												with: stackSymbol												with: intSymbol												with: #()												with: true)								with:									#lastLinkStack										-&gt;											(Array												with: stackSymbol												with: intSymbol												with: #()												with: true)								with:									#pop										-&gt;											(Array												with: stackSymbol												with: intSymbol												with: #()												with: false)								with:									#push:										-&gt;											(Array												with: stackSymbol												with: intSymbol												with: (Array with: intSymbol)												with: false)								with:									#top										-&gt;											(Array												with: stackSymbol												with: intSymbol												with: #()												with: false))						with:							(Array								with:									#newStack										-&gt;											(Array												with: stackSymbol												with: stackSymbol												with: #()												with: false)								with:									#newStackWith:										-&gt;											(Array												with: stackSymbol												with: stackSymbol												with: (Array with: arraySymbol)												with: false)));		scalar: intSymbol with: #(5);		scalar: arraySymbol with: #(#(1 4 5))</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoSStackOnPackage1">typeInfoSStackOnPackage1	| stackSymbol intSymbol arraySymbol |	stackSymbol := #SStack fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	arraySymbol := #Array fullClassNameSymbol.	^ STypeInfo new		type:			stackSymbol				-&gt;					(Array						with:							(Array								with:									#pop										-&gt;											(Array												with: stackSymbol												with: intSymbol												with: #()												with: false)								with:									#push:										-&gt;											(Array												with: stackSymbol												with: intSymbol												with: (Array with: intSymbol)												with: false)								with:									#top										-&gt;											(Array												with: stackSymbol												with: intSymbol												with: #()												with: false))						with:							(Array								with:									#newStackWith:										-&gt;											(Array												with: stackSymbol												with: stackSymbol												with: (Array with: arraySymbol)												with: false)));		type: #SSPerson fullClassNameSymbol -&gt; #(#() #());		type: #SSTeacher fullClassNameSymbol -&gt; #(#() #());		type: #SConference fullClassNameSymbol -&gt; #(#() #());		type: #SEvent fullClassNameSymbol -&gt; #(#() #());		type: #SFoo fullClassNameSymbol -&gt; #(#() #());		type: #SParty fullClassNameSymbol -&gt; #(#() #());		type: #SEventTest fullClassNameSymbol -&gt; #(#() #());		scalar: intSymbol with: #(1 2 4 6 8);		scalar: arraySymbol with: #(#(2 4 6 1))</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoSStackOnPackage2">typeInfoSStackOnPackage2	^ STypeInfo new		type:			#SSPerson				-&gt;					(Array						with:							(Array								with: #id: -&gt; #(#SStudent #SStudent #(#SmallInteger) false)								with: #nickname: -&gt; #(#SStudent #SStudent #(#ByteString) false)								with: #name: -&gt; #(#SStudent #SStudent #(#ByteString) false))						with:							(Array								with:									#name:with:										-&gt; #(#SStudent #SStudent #(#ByteString #SMallInteger) false)));		type:			#SStack				-&gt;					(Array						with:							(Array								with: #push: -&gt; #(#SStack #OrderedCollection #(#OrderedCollection) false))						with: #());		type: #SFoo -&gt; #(#() #());		type: #SConference -&gt; #(#() #());		type: #SEvent -&gt; #(#() #());		type: #SParty -&gt; #(#() #());		type: #SSTeacher -&gt; #(#() #());		type: #SEventTest -&gt; #(#() #());		scalar: #SStudent			with:			(Array				with: (SStudent name: 'Josh' with: 2)				with: (SStudent name: 'Mery' with: 5)				with: (SStudent name: 'Lian'));		scalar: #OrderedCollection			with:			(Array				with:					(OrderedCollection new						add: (SStudent name: 'Mery' with: 5);						yourself)				with:					(OrderedCollection new						add: (SStudent name: 'Lian');						add: (SStudent name: 'Josh' with: 2);						yourself));		scalar: #SmallInteger with: #(5 1 2);		scalar: #ByteString with: #('Josh' 'Lian' 'Mery')</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoSSTeacher1">typeInfoSSTeacher1	| teacherSymbol intSymbol stringSymbol |	teacherSymbol := #SSTeacher fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	stringSymbol := #ByteString fullClassNameSymbol.	^ STypeInfo new		type:			teacherSymbol				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: teacherSymbol												with: teacherSymbol												with: #()												with: false)								with:									#yearsWorkExperience										-&gt;											(Array												with: teacherSymbol												with: intSymbol												with: #()												with: true)								with:									#yearsWorkExperience:										-&gt;											(Array												with: teacherSymbol												with: teacherSymbol												with: (Array with: intSymbol)												with: false))						with: #());		scalar: intSymbol with: #(0 100);		scalar: stringSymbol with: #('teacher_Ann')</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoSSTeacher2">typeInfoSSTeacher2	| teacherSymbol intSymbol stringSymbol |	teacherSymbol := #SSTeacher fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	stringSymbol := #ByteString fullClassNameSymbol.	^ STypeInfo new		type:			teacherSymbol				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: teacherSymbol												with: teacherSymbol												with: #()												with: false)								with:									#idTeacher										-&gt;											(Array												with: teacherSymbol												with: intSymbol												with: #()												with: true)								with:									#yearsWorkExperience:										-&gt;											(Array												with: teacherSymbol												with: teacherSymbol												with: (Array with: intSymbol)												with: false)								with:									#nickname										-&gt;											(Array												with: teacherSymbol												with: stringSymbol												with: #()												with: false))						with: #());		scalar: intSymbol with: #(1 29 -7 9);		scalar: stringSymbol with: #('teacher_Amy' 'teacher_Mark')</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoSSTeacher3">typeInfoSSTeacher3	| teacherSymbol intSymbol stringSymbol |	teacherSymbol := #SSTeacher fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	stringSymbol := #ByteString fullClassNameSymbol.	^ STypeInfo new		type:			teacherSymbol				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: teacherSymbol												with: teacherSymbol												with: #()												with: false)								with:									#yearsWorkExperience										-&gt;											(Array												with: teacherSymbol												with: intSymbol												with: #()												with: false)								with:									#nickname										-&gt;											(Array												with: teacherSymbol												with: stringSymbol												with: #()												with: false))						with: #());		scalar: intSymbol with: #(1 10);		scalar: stringSymbol with: #('teacher_Amy' 'teacher_Mark')</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoSSTeacher4">typeInfoSSTeacher4	| teacherSymbol intSymbol stringSymbol |	teacherSymbol := #SSTeacher fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	stringSymbol := #ByteString fullClassNameSymbol.	^ STypeInfo new		type:			teacherSymbol				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: teacherSymbol												with: teacherSymbol												with: #()												with: false)								with:									#idTeacher										-&gt;											(Array												with: teacherSymbol												with: intSymbol												with: #()												with: true)								with:									#yearsWorkExperience										-&gt;											(Array												with: teacherSymbol												with: teacherSymbol												with: #()												with: true))						with: #());		scalar: intSymbol with: #(1 29 9);		scalar: stringSymbol with: #('teacher_Amy' 'teacher_Mark')</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoSSTeacherOnPackage1">typeInfoSSTeacherOnPackage1	| teacherSymbol intSymbol stringSymbol personSymbol |	teacherSymbol := #SSTeacher fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	stringSymbol := #ByteString fullClassNameSymbol.	personSymbol := #SSPerson fullClassNameSymbol.	^ STypeInfo new		type:			personSymbol				-&gt;					(Array						with:							(Array								with:									#id:										-&gt;											(Array												with: teacherSymbol												with: teacherSymbol												with: (Array with: intSymbol)												with: false)								with:									#nickname:										-&gt;											(Array												with: teacherSymbol												with: teacherSymbol												with: (Array with: stringSymbol)												with: false)								with:									#name										-&gt;											(Array												with: teacherSymbol												with: stringSymbol												with: #()												with: true)								with:									#id										-&gt;											(Array												with: teacherSymbol												with: stringSymbol												with: #()												with: true)								with:									#name:										-&gt;											(Array												with: teacherSymbol												with: teacherSymbol												with: (Array with: stringSymbol)												with: false))						with:							(Array								with:									#name:with:										-&gt;											(Array												with: teacherSymbol												with: teacherSymbol												with: (Array with: stringSymbol with: intSymbol)												with: false)));		type:			teacherSymbol				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: teacherSymbol												with: teacherSymbol												with: #()												with: false)								with:									#idTeacher										-&gt;											(Array												with: teacherSymbol												with: intSymbol												with: #()												with: true)								with:									#yearsWorkExperience:										-&gt;											(Array												with: teacherSymbol												with: teacherSymbol												with: (Array with: intSymbol)												with: false)								with:									#nickname										-&gt;											(Array												with: teacherSymbol												with: stringSymbol												with: #()												with: false))						with: #());		type: #SStack fullClassNameSymbol -&gt; #(#() #());		type: #SConference fullClassNameSymbol -&gt; #(#() #());		type: #SEvent fullClassNameSymbol -&gt; #(#() #());		type: #SFoo fullClassNameSymbol -&gt; #(#() #());		type: #SParty fullClassNameSymbol -&gt; #(#() #());		type: #SEventTest fullClassNameSymbol -&gt; #(#() #());		scalar: intSymbol with: #(0 100 34);		scalar: stringSymbol with: #('Ann' 'teacher_Ann')</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoSSTeacherOnPackage2">typeInfoSSTeacherOnPackage2	| teacherSymbol intSymbol stringSymbol |	teacherSymbol := #SSTeacher fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	stringSymbol := #ByteString fullClassNameSymbol.	^ STypeInfo new		type:			teacherSymbol				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: teacherSymbol												with: teacherSymbol												with: #()												with: false)								with:									#nickname										-&gt;											(Array												with: teacherSymbol												with: teacherSymbol												with: #()												with: false)								with:									#yearsWorkExperience										-&gt;											(Array												with: teacherSymbol												with: intSymbol												with: #()												with: true))						with: #());		type: #SSPerson fullClassNameSymbol -&gt; #(#() #());		type: #SStack fullClassNameSymbol -&gt; #(#() #());		type: #SConference fullClassNameSymbol -&gt; #(#() #());		type: #SEvent fullClassNameSymbol -&gt; #(#() #());		type: #SFoo fullClassNameSymbol -&gt; #(#() #());		type: #SParty fullClassNameSymbol -&gt; #(#() #());		type: #SEventTest fullClassNameSymbol -&gt; #(#() #());		scalar: intSymbol with: #(0);		scalar: stringSymbol with: #('teacher_1')</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoSStudentOnPackage1">typeInfoSStudentOnPackage1	| studentSymbol intSymbol |	studentSymbol := #SStudent fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	^ STypeInfo new		type:			studentSymbol				-&gt;					(Array						with:							(Array								with:									#initialize										-&gt;											(Array												with: studentSymbol												with: studentSymbol												with: #()												with: false)								with:									#idStudent										-&gt;											(Array												with: studentSymbol												with: intSymbol												with: #()												with: true)								with:									#scoreStudent										-&gt;											(Array												with: studentSymbol												with: intSymbol												with: #()												with: true)								with:									#scoreStudent:										-&gt;											(Array												with: studentSymbol												with: intSymbol												with: (Array with: intSymbol)												with: false))						with: #());		type: #SAbstractClass fullClassNameSymbol -&gt; #(#() #());		scalar: intSymbol with: #(10 1)</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoStringSEvent">typeInfoStringSEvent	"(SSTypeCollector				profile: [ (SEvent price: 15)						price;						discount ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario')"	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : { },			#classMethodTypes : { }		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : { },			#classMethodTypes : { }		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : {				#price : STypeMethodInfo {					#selector : #price,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SEvent ]				},				#discount : STypeMethodInfo {					#selector : #discount,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SEvent ]				},				#initialize : STypeMethodInfo {					#selector : #initialize,					#returnType : SMultiTypeInfo [ #SEvent ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SEvent ]				},				#''price:'' : STypeMethodInfo {					#selector : #''price:'',					#returnType : SMultiTypeInfo [ #SEvent ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SEvent ]				}			},			#classMethodTypes : {				#''price:'' : STypeMethodInfo {					#selector : #''price:'',					#returnType : SMultiTypeInfo [ #SEvent ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SEvent ]				}			}		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : { },			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : { },			#classMethodTypes : { }		}	},	#scalars : {		#SmallInteger : [			15,			0		]	}}'</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoStringSFoo2">typeInfoStringSFoo2	"SSTypeCollector				profile: [ (SFoo score: 15)						returnCollection;						returnFloat;						score;						return: #(1 5 6) ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario'"	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : { },			#classMethodTypes : { }		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : { },			#classMethodTypes : { }		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : { },			#classMethodTypes : { }		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : { },			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : {				#returnFloat : STypeMethodInfo {					#selector : #returnFloat,					#returnType : SMultiTypeInfo [ #SmallFloat64 ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#''score:'' : STypeMethodInfo {					#selector : #''score:'',					#returnType : SMultiTypeInfo [ #SFoo ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#initialize : STypeMethodInfo {					#selector : #initialize,					#returnType : SMultiTypeInfo [ #SFoo ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#returnCollection : STypeMethodInfo {					#selector : #returnCollection,					#returnType : SMultiTypeInfo [ #OrderedCollection ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#''return:'' : STypeMethodInfo {					#selector : #''return:'',					#returnType : SMultiTypeInfo [ #Array ],					#argTypes : [						SMultiTypeInfo [ #Array ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#score : STypeMethodInfo {					#selector : #score,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				}			},			#classMethodTypes : {				#''score:'' : STypeMethodInfo {					#selector : #''score:'',					#returnType : SMultiTypeInfo [ #SFoo ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				}			}		}	},	#scalars : {		#OrderedCollection : [			OrderedCollection [ ]		],		#Array : [			[				1,				5,				6			]		],		#SmallInteger : [			15		],		#SmallFloat64 : [			2.3		]	}}'</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoStringSFoo3">typeInfoStringSFoo3	"SSTypeCollector profile:[ (SFoo score: 4)				score;				returnCollection;				returnString;				score: 5;				return:					((SStudent name: 'Emily')						nickname;						scoreStudent;						yourself) ] onPackagesMatching: 'SmallSuiteGenerator-Scenario'."	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : { },			#classMethodTypes : { }		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : {				#''id:'' : STypeMethodInfo {					#selector : #''id:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#''nickname:'' : STypeMethodInfo {					#selector : #''nickname:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#''name:'' : STypeMethodInfo {					#selector : #''name:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				}			},			#classMethodTypes : {				#''name:'' : STypeMethodInfo {					#selector : #''name:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				}			}		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : { },			#classMethodTypes : { }		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : { },			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : {				#''score:'' : STypeMethodInfo {					#selector : #''score:'',					#returnType : SMultiTypeInfo [ #SFoo ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#initialize : STypeMethodInfo {					#selector : #initialize,					#returnType : SMultiTypeInfo [ #SFoo ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#returnCollection : STypeMethodInfo {					#selector : #returnCollection,					#returnType : SMultiTypeInfo [ #OrderedCollection ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#returnString : STypeMethodInfo {					#selector : #returnString,					#returnType : SMultiTypeInfo [ #ByteString ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#''return:'' : STypeMethodInfo {					#selector : #''return:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #SStudent ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#score : STypeMethodInfo {					#selector : #score,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				}			},			#classMethodTypes : {				#''score:'' : STypeMethodInfo {					#selector : #''score:'',					#returnType : SMultiTypeInfo [ #SFoo ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				}			}		}	},	#scalars : {		#OrderedCollection : [			OrderedCollection [ ]		],		#SmallInteger : [			5,			1,			4		],		#ByteString : [			''Emily'',			''Hello''		],		#SStudent : [			SStudent {				#name : ''Emily'',				#id : 1,				#nickname : ''Emily'',				#scoreStudent : 1			}		]	}}'</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoStringSFoo6">typeInfoStringSFoo6	"SSTypeCollector profile: [ SFoo new return: (Dictionary new at: 1 put: (SStack new push: (SStudent  name: 'Lian' with: 1); push: (SStudent name: 'Josh' with: 2); yourself ); at: 2 put: (OrderedCollection new add: (SStudent name: 'Mery' with: 5); yourself); yourself ) ] onPackagesMatching: 'SmallSuiteGenerator-Scenario'."	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : {				#''push:'' : STypeMethodInfo {					#selector : #''push:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #SStudent ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStack ]				}			},			#classMethodTypes : { }		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : {				#''id:'' : STypeMethodInfo {					#selector : #''id:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#''nickname:'' : STypeMethodInfo {					#selector : #''nickname:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#''name:'' : STypeMethodInfo {					#selector : #''name:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				}			},			#classMethodTypes : {				#''name:with:'' : STypeMethodInfo {					#selector : #''name:with:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ],						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				}			}		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : { },			#classMethodTypes : { }		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : { },			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : {				#initialize : STypeMethodInfo {					#selector : #initialize,					#returnType : SMultiTypeInfo [ #SFoo ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#''return:'' : STypeMethodInfo {					#selector : #''return:'',					#returnType : SMultiTypeInfo [ #Dictionary ],					#argTypes : [						SMultiTypeInfo [ #Dictionary ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				}			},			#classMethodTypes : { }		}	},	#scalars : {		#Dictionary : [			{				1 : SStack [					SStudent {						#name : ''Josh'',						#id : 2,						#nickname : ''Josh'',						#scoreStudent : 1,						#idStudent : 1					},					SStudent {						#name : ''Lian'',						#id : 1,						#nickname : ''Lian'',						#scoreStudent : 1,						#idStudent : 1					}				],				2 : OrderedCollection [					SStudent {						#name : ''Mery'',						#id : 5,						#nickname : ''Mery'',						#scoreStudent : 1,						#idStudent : 1					}				]			}		],		#ByteString : [			''Josh'',			''Lian'',			''Mery''		],		#SmallInteger : [			5,			1,			2		],		#SStudent : [			@65,			@68,			@66		]	}}'</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoStringSStack1">typeInfoStringSStack1	"SSTypeCollector profile: [ SStack new push: (OrderedCollection new add: (SStudent  name: 'Lian' with: 1); add: (SStudent name: 'Josh' with: 2); yourself); push: (OrderedCollection new add: (SStudent name: 'Mery' with: 5); yourself); yourself ] onPackagesMatching: 'SmallSuiteGenerator-Scenario'."	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : {				#''push:'' : STypeMethodInfo {					#selector : #''push:'',					#returnType : SMultiTypeInfo [ #OrderedCollection ],					#argTypes : [						SMultiTypeInfo [ #OrderedCollection ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStack ]				}			},			#classMethodTypes : { }		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : {				#''id:'' : STypeMethodInfo {					#selector : #''id:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#''nickname:'' : STypeMethodInfo {					#selector : #''nickname:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#''name:'' : STypeMethodInfo {					#selector : #''name:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				}			},			#classMethodTypes : {				#''name:with:'' : STypeMethodInfo {					#selector : #''name:with:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ],						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				}			}		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : { },			#classMethodTypes : { }		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : { },			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : { },			#classMethodTypes : { }		}	},	#scalars : {		#OrderedCollection : [			OrderedCollection [				SStudent {					#name : ''Mery'',					#id : 5,					#nickname : ''Mery'',					#scoreStudent : 1,					#idStudent : 1				}			],			OrderedCollection [				SStudent {					#name : ''Lian'',					#id : 1,					#nickname : ''Lian'',					#scoreStudent : 1,					#idStudent : 1				},				SStudent {					#name : ''Josh'',					#id : 2,					#nickname : ''Josh'',					#scoreStudent : 1,					#idStudent : 1				}			]		],		#ByteString : [			''Josh'',			''Lian'',			''Mery''		],		#SmallInteger : [			5,			1,			2		],		#SStudent : [			@56,			@59,			@58		]	}}'</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoStringSStack2">typeInfoStringSStack2	"SSTypeCollector				profile: [ (SStack newStackWith: #(2 4 6 1))						push: 8;						pop;						top ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario'"	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : {				#''push:'' : STypeMethodInfo {					#selector : #''push:'',					#returnType : SMultiTypeInfo [ #SmallInteger ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStack ]				},				#pop : STypeMethodInfo {					#selector : #pop,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStack ]				},				#top : STypeMethodInfo {					#selector : #top,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStack ]				}			},			#classMethodTypes : {				#''newStackWith:'' : STypeMethodInfo {					#selector : #''newStackWith:'',					#returnType : SMultiTypeInfo [ #SStack ],					#argTypes : [						SMultiTypeInfo [ #Array ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStack ]				}			}		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : { },			#classMethodTypes : { }		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : { },			#classMethodTypes : { }		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : { },			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : { },			#classMethodTypes : { }		}	},	#scalars : {		#Array : [			[				2,				4,				6,				1			]		],		#SmallInteger : [			1,			2,			4,			6,			8		]	}}'</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoStringSSTeacher1">typeInfoStringSSTeacher1	"SSTypeCollector		profile: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario'."	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : { },			#classMethodTypes : { }		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : {				#''id:'' : STypeMethodInfo {					#selector : #''id:'',					#returnType : SMultiTypeInfo [ #SSTeacher ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#''nickname:'' : STypeMethodInfo {					#selector : #''nickname:'',					#returnType : SMultiTypeInfo [ #SSTeacher ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#name : STypeMethodInfo {					#selector : #name,					#returnType : SMultiTypeInfo [ #ByteString ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#id : STypeMethodInfo {					#selector : #id,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#''name:'' : STypeMethodInfo {					#selector : #''name:'',					#returnType : SMultiTypeInfo [ #SSTeacher ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				}			},			#classMethodTypes : {				#''name:with:'' : STypeMethodInfo {					#selector : #''name:with:'',					#returnType : SMultiTypeInfo [ #SSTeacher ],					#argTypes : [						SMultiTypeInfo [ #ByteString ],						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				}			}		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : { },			#classMethodTypes : { }		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : {				#yearsWorkExperience : STypeMethodInfo {					#selector : #yearsWorkExperience,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#initialize : STypeMethodInfo {					#selector : #initialize,					#returnType : SMultiTypeInfo [ #SSTeacher ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#idTeacher : STypeMethodInfo {					#selector : #idTeacher,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#nickname : STypeMethodInfo {					#selector : #nickname,					#returnType : SMultiTypeInfo [ #ByteString ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				}			},			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : { },			#classMethodTypes : { }		}	},	#scalars : {		#ByteString : [			''Ann'',			''teacher_Ann''		],		#SmallInteger : [			0,			100,			34		]	}}'</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoStringSSTeacher2">typeInfoStringSSTeacher2	"SSTypeCollector				profile: [ SSTeacher new						nickname;						yearsWorkExperience ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario'"	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : { },			#classMethodTypes : { }		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : { },			#classMethodTypes : { }		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : { },			#classMethodTypes : { }		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : {				#yearsWorkExperience : STypeMethodInfo {					#selector : #yearsWorkExperience,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#initialize : STypeMethodInfo {					#selector : #initialize,					#returnType : SMultiTypeInfo [ #SSTeacher ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#nickname : STypeMethodInfo {					#selector : #nickname,					#returnType : SMultiTypeInfo [ #ByteString ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				}			},			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : { },			#classMethodTypes : { }		}	},	#scalars : {		#ByteString : [			''teacher_1''		],		#SmallInteger : [			0		]	}}'</body><body package="SmallSuiteGenerator-Tests-Utility" selector="typeInfoStringSStudent1">typeInfoStringSStudent1	"SSTypeCollector				profile: [ SStudent new						idStudent;						scoreStudent: 10;						scoreStudent ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario2'"	^ 'STypeInfo {	#types : {		#SAbstractClass : STypeClassInfo {			#typeName : #SAbstractClass,			#methodTypes : { },			#classMethodTypes : { }		},		#SStudent : STypeClassInfo {			#typeName : #SStudent,			#methodTypes : {				#initialize : STypeMethodInfo {					#selector : #initialize,					#returnType : SMultiTypeInfo [ #SStudent ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#idStudent : STypeMethodInfo {					#selector : #idStudent,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#scoreStudent : STypeMethodInfo {					#selector : #scoreStudent,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#''scoreStudent:'' : STypeMethodInfo {					#selector : #''scoreStudent:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				}			},			#classMethodTypes : { }		}	},	#scalars : {		#SmallInteger : [			10,			1		]	}}'</body></methods><methods><class-id>SmallSuiteGenerator.SUtilityTypeInfo</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-Utility" selector="testSuiteOf:withTargetClassName:">testSuiteOf: aCollection withTargetClassName: symbol	self		assert: aCollection size &gt;= 2		description: 'list must have at least two or more testCases.'.	^ OrderedCollection new		add:			((SSTestCase with: aCollection first)				targetClassName: symbol;				generateStatements);		add:			((SSTestCase with: aCollection second)				targetClassName: symbol;				generateStatements);		yourself</body><body package="SmallSuiteGenerator-Tests-Utility" selector="testSuiteSStack">testSuiteSStack	^ self		testSuiteOf:			(Array				with: self typeInfoSStack1				with: self typeInfoSStack2				with: self typeInfoSStack3				with: self typeInfoSStack4)		withTargetClassName: #SStack fullClassNameSymbol</body><body package="SmallSuiteGenerator-Tests-Utility" selector="testSuiteSSTeacher">testSuiteSSTeacher	^ self		testSuiteOf:			(Array				with: self typeInfoSSTeacher1				with: self typeInfoSSTeacher2				with: self typeInfoSSTeacher3)		withTargetClassName: #SSTeacher fullClassNameSymbol</body><body package="SmallSuiteGenerator-Tests-Utility" selector="testSuiteSStudent">testSuiteSStudent	^ self		testSuiteOf: self typeInfosSStudent		withTargetClassName: #SStudent fullClassNameSymbol</body><body package="SmallSuiteGenerator-Tests-Utility" selector="testSuiteSStudentManual">testSuiteSStudentManual	| studentSymbol intSymbol stringSymbol |	studentSymbol := #SStudent fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.	stringSymbol := #ByteString fullClassNameSymbol.	^ OrderedCollection new		add:			((SSTestCase with: self typeInfosSStudent first)				targetClassName: studentSymbol;				addFactoryMessage: studentSymbol usingSelector: #new;				addLiteral: stringSymbol;				addFieldAccessMessage: #idStudent from: studentSymbol;				addMessage: #scoreStudent: from: studentSymbol;				addFactoryMessage: studentSymbol usingSelector: #new;				addFieldAccessMessage: #scoreStudent from: studentSymbol;				yourself);		add:			((SSTestCase with: self typeInfosSStudent first)				targetClassName: studentSymbol;				addLiteral: intSymbol;				addFactoryMessage: studentSymbol usingSelector: #new;				addMessage: #scoreStudent: from: studentSymbol;				addFactoryMessage: studentSymbol usingSelector: #new;				addFieldAccessMessage: #idStudent from: studentSymbol;				yourself);		add:			((SSTestCase with: self typeInfosSStudent first)				targetClassName: studentSymbol;				addFactoryMessage: studentSymbol usingSelector: #new;				addLiteral: intSymbol;				addMessage: #scoreStudent: from: studentSymbol;				addLiteral: intSymbol;				addFactoryMessage: studentSymbol usingSelector: #new;				yourself);		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SReportSTestCaseFactory</class-id> <category>actions</category><body package="SmallSuiteGenerator-Utility" selector="engine">engine	^ factoryTestCase engine</body><body package="SmallSuiteGenerator-Utility" selector="evolutionTypeInfo">evolutionTypeInfo	| typeInfos evolution |	typeInfos := Array		with: factoryTestCase typeInfoSeed		withAll: (self engine logs collect: #typeInfoGeneration).	evolution := Dictionary new.	2 to: typeInfos size do: [ :index | 		| partialResult |		partialResult := (typeInfos at: index - 1)			difference: (typeInfos at: index).		(partialResult notNil and: [ partialResult notEmpty ])			ifTrue: [ evolution					at: ('{1} -&gt; {2}' format: (Array with: index - 2 with: index - 1))					put: partialResult ] ].	^ evolution</body><body package="SmallSuiteGenerator-Utility" selector="generateReportForAllMethodsOf:">generateReportForAllMethodsOf: aLog	self generateReportOf: aLog usingFilter: #all</body><body package="SmallSuiteGenerator-Utility" selector="generateReportForAllMethodsOfAllLogs">generateReportForAllMethodsOfAllLogs	self engine logs		do: [ :aLog | self generateReportForAllMethodsOf: aLog ]</body><body package="SmallSuiteGenerator-Utility" selector="generateReportForUnexecutedMethodsOf:">generateReportForUnexecutedMethodsOf: anIndex	self generateReportOf: anIndex usingFilter: #notAllBlocksExecuted</body><body package="SmallSuiteGenerator-Utility" selector="generateReportForUnexecutedMethodsOfAllLogs">generateReportForUnexecutedMethodsOfAllLogs	self engine logs		do: [ :aLog | self generateReportForUnexecutedMethodsOf: aLog ]</body><body package="SmallSuiteGenerator-Utility" selector="generateReportOf:usingFilter:">generateReportOf: aLog usingFilter: aSymbol	SReportSGALog		exportData: aLog		onCSV:			'Report_' , aLog generationNumber asString , '_'				, aSymbol asString capitalized				, factoryTestCase targetClassName asString		usingFilter: aSymbol</body><body package="SmallSuiteGenerator-Utility" selector="generateReportOfAllMethods">generateReportOfAllMethods	self generateReportForAllMethodsOf: self engine logs last</body><body package="SmallSuiteGenerator-Utility" selector="generateResumeDifferenceOfGeneration">generateResumeDifferenceOfGeneration	SReportSGALog		generateReportForDifferencesBtwGenerationsOf: self engine</body><body package="SmallSuiteGenerator-Utility" selector="generateResumeReportOfLogs">generateResumeReportOfLogs	SReportSGALog		exportResumeOf: self engine logs		onCSV: 'Report_Resume_' , factoryTestCase targetClassName asString</body></methods><methods><class-id>SmallSuiteGenerator.SReportSTestCaseFactory</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Utility" selector="factoryTestCase:">factoryTestCase: anObject	factoryTestCase := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SReportSTestCaseFactory class</class-id> <category>class-factory</category><body package="SmallSuiteGenerator-Utility" selector="on:">on: anObject	^ self new factoryTestCase: anObject</body></methods><methods><class-id>SmallSuiteGenerator.SSimpleFitnessFunction</class-id> <category>actions</category><body package="SmallSuiteGenerator-GA" selector="computeCoverageWith:">computeCoverageWith: assoc	| sum |	sum := [ assoc at: targetClass ]		on: Error		do: [ 0 ].	sum := superclasses		inject: sum		into: [ :v :e | 			| val |			val := [ assoc at: e ]				on: Error				do: [ 0 ].			v + val ].	^ sum / (n + 1)</body><body package="SmallSuiteGenerator-GA" selector="computeFitness">computeFitness	| assoc |	assoc := self fitnessByClass.	^ Array with: (self computeCoverageWith: assoc) with: assoc</body><body package="SmallSuiteGenerator-GA" selector="fitnessByClass">fitnessByClass	self subclassResponsibility</body><body package="SmallSuiteGenerator-GA" selector="fitnessOf:">fitnessOf: testCase	| fitness |	fitness := self computeFitness.	testCase fitness at: self functionName put: fitness first.	testCase fitnessByClass at: self functionName put: fitness second</body><body package="SmallSuiteGenerator-GA" selector="run:">run: testCaseCollection	testCaseCollection		do: [ :testCase | 			testCase length &gt; 0				ifTrue: [ profiler cleanBlocksOfMethods.					testCase runWithoutAssertionsAndLastStatement.					SGAEngine logClass						summaryExecutionMethodsOf: testCase						with: profiler.					self fitnessOf: testCase ]				ifFalse: [ testCase fitness at: self functionName put: 0 ] ]</body></methods><methods><class-id>SmallSuiteGenerator.SSimpleFitnessFunction</class-id> <category>initialization</category><body package="SmallSuiteGenerator-GA" selector="initialize">initialize	super initialize.	weight := 1.0.	n := 0.	superclasses := #()</body></methods><methods><class-id>SmallSuiteGenerator.SSimpleFitnessFunction</class-id> <category>accessing</category><body package="SmallSuiteGenerator-GA" selector="consideringNSuperclasses:">consideringNSuperclasses: anInteger	n := anInteger.	self updateSuperclasses</body><body package="SmallSuiteGenerator-GA" selector="updateSuperclasses">updateSuperclasses	superclasses := self aClass allSuperclasses collect: [ :e | e name ].	n := n min: superclasses size - 2.	"avoid add Object and ProtoObject in superclasses"	superclasses := superclasses first: n</body></methods><methods><class-id>SmallSuiteGenerator.SSimpleFitnessFunction</class-id> <category>accesing</category><body package="SmallSuiteGenerator-GA" selector="weight">weight	^ weight</body><body package="SmallSuiteGenerator-GA" selector="weight:">weight: aFloat	weight := aFloat</body></methods><methods><class-id>SmallSuiteGenerator.SMethodCoverage</class-id> <category>accesing</category><body package="SmallSuiteGenerator-GA" selector="functionName">functionName	^ 'method-coverage'</body></methods><methods><class-id>SmallSuiteGenerator.SMethodCoverage</class-id> <category>actions</category><body package="SmallSuiteGenerator-GA" selector="fitnessByClass">fitnessByClass	^ profiler methodCoverage1</body></methods><methods><class-id>SmallSuiteGenerator.SStatementCoverage</class-id> <category>accesing</category><body package="SmallSuiteGenerator-GA" selector="functionName">functionName	^ 'block-coverage'</body></methods><methods><class-id>SmallSuiteGenerator.SStatementCoverage</class-id> <category>actions</category><body package="SmallSuiteGenerator-GA" selector="fitnessByClass">fitnessByClass	^ profiler statementCoverage1</body></methods><methods><class-id>SmallSuiteGenerator.SVariable</class-id> <category>querying</category><body package="SmallSuiteGenerator-Core" selector="containsVariable:">containsVariable: aVariable	self id ifNil: [ ^ self varName = aVariable varName ].	^ self id = aVariable id</body><body package="SmallSuiteGenerator-Core" selector="referenceTo:">referenceTo: aClassName	^ self returnType = aClassName</body></methods><methods><class-id>SmallSuiteGenerator.SVariable</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Core" selector="initialize">initialize	super initialize.	varName := '_var'</body></methods><methods><class-id>SmallSuiteGenerator.SVariable</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Core" selector="fullName">fullName	self id ifNil: [ ^ self varName ].	^ self varName , self id asString</body><body package="SmallSuiteGenerator-Core" selector="key">key	self printerClass isDictionary		ifTrue: [ ^ id + 1 ]		ifFalse: [ ^ self printString asSymbol ]</body><body package="SmallSuiteGenerator-Core" selector="printerClass">printerClass	^ SSTestCase defaultPrinterClass</body><body package="SmallSuiteGenerator-Core" selector="varName">varName	^ varName</body><body package="SmallSuiteGenerator-Core" selector="varName:">varName: anObject	varName := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SVariable</class-id> <category>copying</category><body package="SmallSuiteGenerator-Core" selector="copy">copy	| copy |	copy := super copy.	copy varName: varName copy.	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.SVariable</class-id> <category>actions</category><body package="SmallSuiteGenerator-Core" selector="changeOn:">changeOn: aTestCase	"nothing to change"	</body></methods><methods><class-id>SmallSuiteGenerator.SVariable</class-id> <category>visitor</category><body package="SmallSuiteGenerator-Core" selector="accept:">accept: aSSVisitor	^ aSSVisitor visitVariable: self</body></methods><methods><class-id>SmallSuiteGenerator.SVariable</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Core" selector="=">= other	^ self containsVariable: other</body><body package="SmallSuiteGenerator-Core" selector="hash">hash	^ super hash bitXor: varName hash</body></methods><methods><class-id>SmallSuiteGenerator.SVariable class</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Core" selector="name:">name: aString	| variable |	variable := self new.	variable varName: aString.	^ variable</body><body package="SmallSuiteGenerator-Core" selector="nameOrId:">nameOrId: anObject	^ self new		varName: (self variableName: anObject);		id: (self variableId: anObject);		yourself</body><body package="SmallSuiteGenerator-Core" selector="variableId:">variableId: aString	^ ('_var*' match: aString)		ifTrue: [ (aString copyFrom: 5 to: aString size) asInteger ]		ifFalse: [ nil ]</body><body package="SmallSuiteGenerator-Core" selector="variableName:">variableName: aString	^ ('_var*' match: aString)		ifTrue: [ '_var' ]		ifFalse: [ aString ]</body></methods><methods><class-id>SmallSuiteGenerator.SSelf</class-id> <category>querying</category><body package="SmallSuiteGenerator-Core" selector="containsVariable:">containsVariable: aVariable	^ false</body></methods><methods><class-id>SmallSuiteGenerator.SSelf</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Core" selector="initialize">initialize	super initialize.	varName := 'self'</body></methods><methods><class-id>SmallSuiteGenerator.SSelf</class-id> <category>visitor</category><body package="SmallSuiteGenerator-Core" selector="accept:">accept: aSSVisitor	^ aSSVisitor visitSelf: self</body></methods><methods><class-id>SmallSuiteGenerator.SSPerson</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Scenario" selector="age:">age: aNumber	^ aNumber</body><body package="SmallSuiteGenerator-Scenario" selector="fullIdentifier">fullIdentifier	^ name , '_' , nickname , '_' , id printString</body><body package="SmallSuiteGenerator-Scenario" selector="id">id	^ id</body><body package="SmallSuiteGenerator-Scenario" selector="id:">id: anObject	id := anObject</body><body package="SmallSuiteGenerator-Scenario" selector="identifier">identifier	^ name , id printString</body><body package="SmallSuiteGenerator-Scenario" selector="name">name	^ name</body><body package="SmallSuiteGenerator-Scenario" selector="name:">name: anObject	name := anObject</body><body package="SmallSuiteGenerator-Scenario" selector="nickname">nickname	self subclassResponsibility</body><body package="SmallSuiteGenerator-Scenario" selector="nickname:">nickname: anObject	nickname := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SSPerson</class-id> <category>testing</category><body package="SmallSuiteGenerator-Scenario" selector="canRegister:">canRegister: aConference	^ aConference price - aConference offerPrice		&gt; (aConference price * 0.05)</body></methods><methods><class-id>SmallSuiteGenerator.SSPerson class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Scenario" selector="name:">name: aString	| inst |	inst := self new		name: aString;		id: 1;		nickname: aString.	^ inst</body><body package="SmallSuiteGenerator-Scenario" selector="name:with:">name: aString with: aNumber	| inst |	inst := self new		name: aString;		id: aNumber;		nickname: aString.	^ inst</body></methods><methods><class-id>SmallSuiteGenerator.SPrototypeClass</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Scenario2" selector="a">a	^ a</body><body package="SmallSuiteGenerator-Scenario2" selector="a:">a: anInteger	a := anInteger</body><body package="SmallSuiteGenerator-Scenario2" selector="b">b	^ b ifNil: [ b := 7 ]</body><body package="SmallSuiteGenerator-Scenario2" selector="b:">b: anInteger	b := anInteger</body><body package="SmallSuiteGenerator-Scenario2" selector="c">c	^ c</body><body package="SmallSuiteGenerator-Scenario2" selector="c:">c: aString	c := aString</body><body package="SmallSuiteGenerator-Scenario2" selector="initialize">initialize	super initialize.	a := 3.	b := 4</body><body package="SmallSuiteGenerator-Scenario2" selector="methWithArguments:">methWithArguments: aList	| selectedNumbers |	selectedNumbers := OrderedCollection new.	aList		detect: [ :aNum | aNum odd ]		ifFound: [ :aNum | 			aNum &gt; 10				ifTrue: [ selectedNumbers add: aNum ]				ifFalse: [ selectedNumbers add: aNum * 3 ] ]		ifNone: [  ].	^ selectedNumbers</body><body package="SmallSuiteGenerator-Scenario2" selector="methWithComposeBlocks:">methWithComposeBlocks: list	| selectedNumbers |	selectedNumbers := OrderedCollection new.	list		select: [ :aNum | aNum odd ]		thenDo: [ :aNum | 			aNum &gt; 10				ifTrue: [ selectedNumbers add: aNum ] ].	^ selectedNumbers</body><body package="SmallSuiteGenerator-Scenario2" selector="methWithCondition">methWithCondition	^ a &lt; b		ifTrue: [ a + 3 ]		ifFalse: [ b + 3 ]</body><body package="SmallSuiteGenerator-Scenario2" selector="methWithDoubleCondition">methWithDoubleCondition	^ a odd		ifTrue: [ a &lt; 10				ifTrue: [ true ] ]		ifFalse: [ false ]</body><body package="SmallSuiteGenerator-Scenario2" selector="methWithDoubleCondition:">methWithDoubleCondition: aNumber	aNumber odd		ifTrue: [ aNumber &lt; 10				ifTrue: [ true ] ]		ifFalse: [ false ]</body><body package="SmallSuiteGenerator-Scenario2" selector="returnStringWithSeparetors:">returnStringWithSeparetors: aSeparatorColl	c ifNotNil: [ ^ c substrings: aSeparatorColl ].	^ #()</body></methods><methods><class-id>SmallSuiteGenerator.SPrototypeClass</class-id> <category>actions</category><body package="SmallSuiteGenerator-Scenario2" selector="doSomething">doSomething	</body><body package="SmallSuiteGenerator-Scenario2" selector="returnMessage">returnMessage	| a |	a := 3.	^ a</body><body package="SmallSuiteGenerator-Scenario2" selector="voidMessage">voidMessage	self doSomething</body></methods><methods><class-id>SmallSuiteGenerator.SSVariablesWithIdCollector</class-id> <category>visiting</category><body package="SmallSuiteGenerator-Core" selector="visit:">visit: sNode	sNode accept: self</body></methods><methods><class-id>SmallSuiteGenerator.SSVariablesWithIdCollector</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Core" selector="initialize">initialize	super initialize.	variablesWithId := OrderedCollection new</body></methods><methods><class-id>SmallSuiteGenerator.SSVariablesWithIdCollector</class-id> <category>visiting-core</category><body package="SmallSuiteGenerator-Core" selector="visitVariable:">visitVariable: aVariable	aVariable id ifNotNil: [ variablesWithId add: aVariable ]</body></methods><methods><class-id>SmallSuiteGenerator.SSVariablesWithIdCollector</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Core" selector="variablesWithId">variablesWithId	^ variablesWithId</body></methods><methods><class-id>SmallSuiteGenerator.SConference</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Scenario" selector="date">date	^ date</body><body package="SmallSuiteGenerator-Scenario" selector="date:">date: anObject	date := anObject</body><body package="SmallSuiteGenerator-Scenario" selector="offerPrice">offerPrice	^ offerPrice</body><body package="SmallSuiteGenerator-Scenario" selector="offerPrice:">offerPrice: aNumber	offerPrice := aNumber</body><body package="SmallSuiteGenerator-Scenario" selector="speaker">speaker	^ speaker</body><body package="SmallSuiteGenerator-Scenario" selector="speaker:">speaker: anObject	speaker := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SConference</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Scenario" selector="initialize">initialize	price := 100.	discount := 0.	offerPrice := price.	date := Date today</body></methods><methods><class-id>SmallSuiteGenerator.SSequense</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Core" selector="isSequence">isSequence	^ true</body><body package="SmallSuiteGenerator-Core" selector="messages">messages	^ messages</body><body package="SmallSuiteGenerator-Core" selector="messages:">messages: anObject	messages := anObject</body><body package="SmallSuiteGenerator-Core" selector="temporaries">temporaries	^ temporaries</body><body package="SmallSuiteGenerator-Core" selector="temporaries:">temporaries: anObject	temporaries := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SSequense</class-id> <category>adding</category><body package="SmallSuiteGenerator-Core" selector="addMessage:">addMessage: aMessage	messages add: aMessage</body><body package="SmallSuiteGenerator-Core" selector="addTemporarie:">addTemporarie: tmp	temporaries add: tmp</body></methods><methods><class-id>SmallSuiteGenerator.SSequense</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Core" selector="initialize">initialize	super initialize.	messages := OrderedCollection new.	temporaries := OrderedCollection new</body></methods><methods><class-id>SmallSuiteGenerator.SGAMutationOperationTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-GA" selector="testMutation">testMutation	| testCase mutatedTestCase |	testCase := SSTestCase with: utility typeInfoSStack3.	testCase numMaxStatements: 10.	testCase		targetClassName: #SStack fullClassNameSymbol;		generateStatements.	mutatedTestCase := operation mutate: testCase.	mutatedTestCase := operation mutate: mutatedTestCase.	self assert: mutatedTestCase validReferences</body><body package="SmallSuiteGenerator-Tests-GA" selector="testMutationSSteacher">testMutationSSteacher	| typeInfo testCase mutatedTestCase |	typeInfo := utility typeInfoSSTeacher1.	testCase := SSTestCase with: typeInfo.	testCase		targetClassName: #SSTeacher fullClassNameSymbol;		generateStatements.	mutatedTestCase := operation mutate: testCase.	mutatedTestCase := operation mutate: mutatedTestCase.	self assert: mutatedTestCase validReferences</body><body package="SmallSuiteGenerator-Tests-GA" selector="testMutationSStudentManual">testMutationSStudentManual	| testCase mutatedTestCase testSuite |	testSuite := utility testSuiteSStudentManual.	testCase := testSuite first.	"testCase generateStatements."	mutatedTestCase := operation mutate: testCase.	mutatedTestCase := operation mutate: mutatedTestCase.	self assert: mutatedTestCase validReferences.	testCase := testSuite second.	"testCase generateStatements."	mutatedTestCase := operation mutate: testCase.	mutatedTestCase := operation mutate: mutatedTestCase.	self assert: mutatedTestCase validReferences</body><body package="SmallSuiteGenerator-Tests-GA" selector="testMutationSStudentWithValidReferences">testMutationSStudentWithValidReferences	| testCase mutatedTestCase testSuite |	testSuite := utility testSuiteSStudentManual.	testCase := testSuite third.	"testCase generateStatements."	mutatedTestCase := operation mutate: testCase.	mutatedTestCase := operation mutate: mutatedTestCase.	self assert: mutatedTestCase validReferences.	testCase := testSuite third.	"testCase generateStatements."	mutatedTestCase := operation mutate: testCase.	mutatedTestCase := operation mutate: mutatedTestCase.	self assert: mutatedTestCase validReferences</body></methods><methods><class-id>SmallSuiteGenerator.SGAMutationOperationTest</class-id> <category>running</category><body package="SmallSuiteGenerator-Tests-GA" selector="setUp">setUp	super setUp.	SPlatform resetRandomGenerator.	operation := SGAMutationOperation new.	utility := SUtilityTypeInfo new</body></methods><methods><class-id>SmallSuiteGenerator.SSGParser</class-id> <category>parsing</category><body package="SmallSuiteGenerator-Utility" selector="parse:">parse: aNode	^ aNode acceptVisitor: self</body><body package="SmallSuiteGenerator-Utility" selector="variableId:">variableId: aString	^ ('_var*' match: aString)		ifTrue: [ (aString copyFrom: 5 to: aString size) asInteger ]		ifFalse: [ nil ]</body><body package="SmallSuiteGenerator-Utility" selector="variableName:">variableName: aString	^ ('_var*' match: aString)		ifTrue: [ '_var' ]		ifFalse: [ aString ]</body></methods><methods><class-id>SmallSuiteGenerator.SSGParser class</class-id> <category>parsing</category><body package="SmallSuiteGenerator-Utility" selector="parseFrom:">parseFrom: aRBNode	^ self new parse: aRBNode</body></methods><methods><class-id>SmallSuiteGenerator.SCoverageTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-GA" selector="computeFitnessOf:">computeFitnessOf: testCase	fitness compute: (Array with: testCase).	^ self fitnessOf: testCase</body><body package="SmallSuiteGenerator-Tests-GA" selector="fitnessOf:">fitnessOf: aTestCase	^ aTestCase fitness at: fitness functionName</body><body package="SmallSuiteGenerator-Tests-GA" selector="testCase:withNumStatements:andTargetClassName:">testCase: typeInfo withNumStatements: aNumber andTargetClassName: symbol	^ (SSTestCase with: typeInfo)		numMaxStatements: aNumber;		targetClassName: symbol;		addFactoryMessage: symbol;		generateStatements</body></methods><methods><class-id>SmallSuiteGenerator.SCoverageTest</class-id> <category>running</category><body package="SmallSuiteGenerator-Tests-GA" selector="fitnessClass">fitnessClass	^ self subclassResponsibility</body><body package="SmallSuiteGenerator-Tests-GA" selector="installOn:">installOn: aPackageName	profiler := self aSLProfilerCoverage		profilerForPackagesMatching: aPackageName.	fitness profiler: profiler.	profiler uninstall.	profiler beforeProfiling</body><body package="SmallSuiteGenerator-Tests-GA" selector="setUp">setUp	utility := SUtilityTypeInfo new.	fitness := self fitnessClass new.	profiler := self aSLProfilerCoverage new</body><body package="SmallSuiteGenerator-Tests-GA" selector="tearDown">tearDown	</body><body package="SmallSuiteGenerator-Tests-GA" selector="uninstall">uninstall	profiler uninstall</body></methods><methods><class-id>SmallSuiteGenerator.SStatementCoverageTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-GA" selector="fitnessClass">fitnessClass	^ SStatementCoverage</body><body package="SmallSuiteGenerator-Tests-GA" selector="testCoverageClassSEvent">testCoverageClassSEvent	| testCase valueFitness targetClass |	targetClass := #SEvent fullClassNameSymbol.	testCase := self		testCase: utility typeInfoSEvent2		withNumStatements: 20		andTargetClassName: targetClass.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: targetClass.	valueFitness := self computeFitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 75.0 ]).	"75.0 = (6/8) * 100 round: 2"	self uninstall</body><body package="SmallSuiteGenerator-Tests-GA" selector="testCoverageClassSFoo">testCoverageClassSFoo	| testCase valueFitness targetClass |	targetClass := #SFoo fullClassNameSymbol.	testCase := self		testCase: utility typeInfoSFoo4		withNumStatements: 20		andTargetClassName: targetClass.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: targetClass.	valueFitness := self computeFitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 71.43 ]).	"71.43 = (10/14) * 100 round: 2"	self uninstall</body><body package="SmallSuiteGenerator-Tests-GA" selector="testCoverageOnClassSStack">testCoverageOnClassSStack	| testCase valueFitness targetClass |	targetClass := #SStack fullClassNameSymbol.	testCase := self		testCase: utility typeInfoSStack3		withNumStatements: 20		andTargetClassName: targetClass.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: targetClass.	valueFitness := self computeFitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 80.0 ]).	"73.68 = (14/19) * 100 round: 2"	self uninstall</body><body package="SmallSuiteGenerator-Tests-GA" selector="testCoverageOnClassSSTeacher">testCoverageOnClassSSTeacher	| testCase valueFitness targetClass |	targetClass := #SFoo fullClassNameSymbol.	testCase := self		testCase: utility typeInfoSFoo4		withNumStatements: 20		andTargetClassName: targetClass.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: targetClass.	valueFitness := self computeFitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 75.0 ]).	"75.0 = (6/8) * 100 round: 2"	self uninstall</body><body package="SmallSuiteGenerator-Tests-GA" selector="testCoverageOnClassSStudent">testCoverageOnClassSStudent	| testCase valueFitness targetClass |	targetClass := #SStudent fullClassNameSymbol.	testCase := self		testCase: utility typeInfosSStudent first		withNumStatements: 20		andTargetClassName: targetClass.	self installOn: 'SmallSuiteGenerator-Scenario2'.	fitness targetClass: targetClass.	valueFitness := self computeFitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 75.0 ]).	"75.0 = (6/8) * 100 round: 2"	self uninstall</body><body package="SmallSuiteGenerator-Tests-GA" selector="testCoverageOnPackagesSEvent">testCoverageOnPackagesSEvent	| testCase valueFitness targetClass |	targetClass := #SEvent fullClassNameSymbol.	testCase := self		testCase: utility typeInfoSEventOnPackage1		withNumStatements: 20		andTargetClassName: targetClass.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: targetClass.	valueFitness := self computeFitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 75.0 ]).	self uninstall</body><body package="SmallSuiteGenerator-Tests-GA" selector="testCoverageOnPackagesSFoo">testCoverageOnPackagesSFoo	| testCase valueFitness targetClass |	targetClass := #SFoo fullClassNameSymbol.	testCase := self		testCase: utility typeInfoSFooOnPackage2		withNumStatements: 20		andTargetClassName: targetClass.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: targetClass.	valueFitness := self computeFitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 71.43 ]).	"71.43 = (10/14) * 100 round: 2"	self uninstall</body><body package="SmallSuiteGenerator-Tests-GA" selector="testCoverageOnPackagesSStack">testCoverageOnPackagesSStack	| testCase valueFitness targetClass |	targetClass := #SStack fullClassNameSymbol.	testCase := self		testCase: utility typeInfoSStackOnPackage1		withNumStatements: 20		andTargetClassName: targetClass.	"testCase inspect."	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: targetClass.	valueFitness := self computeFitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 73.68 ]).	"73.68 = (14/19) * 100 round: 2"	self uninstall</body><body package="SmallSuiteGenerator-Tests-GA" selector="testCoverageOnPackagesSSTeacher">testCoverageOnPackagesSSTeacher	| testCase targetClass valueFitness |	targetClass := #SSTeacher fullClassNameSymbol.	testCase := self		testCase: utility typeInfoSSTeacherOnPackage2		withNumStatements: 20		andTargetClassName: targetClass.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: targetClass.	valueFitness := self computeFitnessOf: testCase.	self uninstall.	self assert: valueFitness &lt;= 75.0</body><body package="SmallSuiteGenerator-Tests-GA" selector="testCoverageOnPackagesSStudent">testCoverageOnPackagesSStudent	| testCase valueFitness targetClass |	targetClass := #SStudent fullClassNameSymbol.	testCase := self		testCase: utility typeInfoSStudentOnPackage1		withNumStatements: 20		andTargetClassName: targetClass.	self installOn: 'SmallSuiteGenerator-Scenario2'.	fitness targetClass: targetClass.	valueFitness := self computeFitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 75.0 ]).	self uninstall</body></methods><methods><class-id>SmallSuiteGenerator.SMultiCoverageTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-GA" selector="fitnessOf:withMethodCov:andStmCov:">fitnessOf: testCase withMethodCov: aFloat1 andStmCov: aFloat2	fitness add: SMethodCoverage new weight: aFloat1.	fitness add: SStatementCoverage new weight: aFloat2.	^ self computeFitnessOf: testCase</body><body package="SmallSuiteGenerator-Tests-GA" selector="testCoverageClassSEvent">testCoverageClassSEvent	| testCase valueFitness targetClass |	targetClass := #SEvent fullClassNameSymbol.	testCase := self		testCase: utility typeInfoSEvent2		withNumStatements: 20		andTargetClassName: targetClass.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: targetClass.	valueFitness := self		fitnessOf: testCase		withMethodCov: 0.6		andStmCov: 0.4.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 75.0 ]).	"block-coverage-66.67, method-coverage-71.43 = 69.52"	valueFitness := self		fitnessOf: testCase		withMethodCov: 0.4		andStmCov: 0.6.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 75.0 ]).	"block-coverage-66.67, method-coverage-71.43 = 68.57"	self uninstall</body><body package="SmallSuiteGenerator-Tests-GA" selector="testCoverageClassSFoo">testCoverageClassSFoo	| testCase valueFitness targetClass |	targetClass := #SFoo fullClassNameSymbol.	testCase := self		testCase: utility typeInfoSFoo4		withNumStatements: 20		andTargetClassName: targetClass.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: targetClass.	valueFitness := self		fitnessOf: testCase		withMethodCov: 0.6		andStmCov: 0.4.	"block-coverage-14.28, method-coverage-22.22 = 19.05"	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 71.43 ]).	valueFitness := self		fitnessOf: testCase		withMethodCov: 0.4		andStmCov: 0.6.	"block-coverage-14.28, method-coverage-22.22 = 17.46"	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 71.43 ]).	self uninstall</body><body package="SmallSuiteGenerator-Tests-GA" selector="testCoverageOnClassSStack">testCoverageOnClassSStack	| testCase valueFitness targetClass |	targetClass := #SStack fullClassNameSymbol.	testCase := self		testCase: utility typeInfoSStack3		withNumStatements: 20		andTargetClassName: targetClass.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: targetClass.	valueFitness := self		fitnessOf: testCase		withMethodCov: 0.6		andStmCov: 0.4.	"block-coverage-73.33, method-coverage-71.42 = 72.42"	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 73.68 ]).	valueFitness := self		fitnessOf: testCase		withMethodCov: 0.6		andStmCov: 0.4.	"block-coverage-73.33, method-coverage-71.42 = 72.19"	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 73.68 ]).	self uninstall</body></methods><methods><class-id>SmallSuiteGenerator.SMultiCoverageTest</class-id> <category>running</category><body package="SmallSuiteGenerator-Tests-GA" selector="fitnessClass">fitnessClass	^ SMultiFitnessFunction</body></methods><methods><class-id>SmallSuiteGenerator.SMethodCoverageTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-GA" selector="testCoverageClassSEvent">testCoverageClassSEvent	| testCase valueFitness targetClass |	targetClass := #SEvent fullClassNameSymbol.	testCase := self		testCase: utility typeInfoSEvent2		withNumStatements: 20		andTargetClassName: targetClass.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: targetClass.	valueFitness := self computeFitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 83.33 ]).	"83.33 = (5/6) * 100 round: 2"	self uninstall</body><body package="SmallSuiteGenerator-Tests-GA" selector="testCoverageClassSFoo">testCoverageClassSFoo	| testCase valueFitness targetClass |	targetClass := #SFoo fullClassNameSymbol.	testCase := self		testCase: utility typeInfoSFoo4		withNumStatements: 20		andTargetClassName: targetClass.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: targetClass.	valueFitness := self computeFitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 77.78 ]).	"77.78 = (7/9) * 100 round: 2"	self uninstall</body><body package="SmallSuiteGenerator-Tests-GA" selector="testCoverageOnClassSStack">testCoverageOnClassSStack	| testCase valueFitness targetClass |	targetClass := #SStack fullClassNameSymbol.	testCase := self		testCase: utility typeInfoSStack3		withNumStatements: 20		andTargetClassName: targetClass.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: targetClass.	valueFitness := self computeFitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 71.429 ]).	"57.14 = (4/7) * 100 round: 2"	self uninstall</body><body package="SmallSuiteGenerator-Tests-GA" selector="testCoverageOnClassSSTeacher">testCoverageOnClassSSTeacher	| testCase valueFitness targetClass |	targetClass := #SSTeacher fullClassNameSymbol.	testCase := self		testCase: utility typeInfoSSTeacher3		withNumStatements: 20		andTargetClassName: targetClass.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: targetClass.	valueFitness := self computeFitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 60.0 ]).	"60.0 = (3/5) * 100 round: 2"	self uninstall</body><body package="SmallSuiteGenerator-Tests-GA" selector="testCoverageOnClassSStudent">testCoverageOnClassSStudent	| testCase valueFitness targetClass |	targetClass := #SStudent fullClassNameSymbol.	testCase := self		testCase: utility typeInfosSStudent first		withNumStatements: 20		andTargetClassName: targetClass.	self installOn: 'SmallSuiteGenerator-Scenario2'.	fitness targetClass: targetClass.	valueFitness := self computeFitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 80.0 ]).	"80.0 = (4/5) * 100 round: 2"	self uninstall</body><body package="SmallSuiteGenerator-Tests-GA" selector="testCoverageOnPackagesSEvent">testCoverageOnPackagesSEvent	| testCase valueFitness targetClass |	targetClass := #SEvent fullClassNameSymbol.	testCase := self		testCase: utility typeInfoSEventOnPackage1		withNumStatements: 20		andTargetClassName: targetClass.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: targetClass.	valueFitness := self computeFitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 83.33 ]).	self uninstall</body><body package="SmallSuiteGenerator-Tests-GA" selector="testCoverageOnPackagesSFoo">testCoverageOnPackagesSFoo	| testCase valueFitness targetClass |	targetClass := #SFoo fullClassNameSymbol.	testCase := self		testCase: utility typeInfoSFooOnPackage2		withNumStatements: 20		andTargetClassName: targetClass.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: targetClass.	valueFitness := self computeFitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 77.78 ]).	"77.78 = (7/9) * 100 round: 2"	self uninstall</body><body package="SmallSuiteGenerator-Tests-GA" selector="testCoverageOnPackagesSStack">testCoverageOnPackagesSStack	| testCase valueFitness targetClass |	targetClass := #SStack fullClassNameSymbol.	testCase := self		testCase: utility typeInfoSStackOnPackage1		withNumStatements: 20		andTargetClassName: targetClass.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: targetClass.	valueFitness := self computeFitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 71.429 ]).	"57.14 = (4/7) * 100 round: 2"	self uninstall</body><body package="SmallSuiteGenerator-Tests-GA" selector="testCoverageOnPackagesSSTeacher">testCoverageOnPackagesSSTeacher	| testCase valueFitness targetClass |	targetClass := #SSTeacher fullClassNameSymbol.	testCase := self		testCase: utility typeInfoSSTeacherOnPackage2		withNumStatements: 20		andTargetClassName: targetClass.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness targetClass: targetClass.	valueFitness := self computeFitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 77.78 ]).	"77.78 = (7/9) * 100 round: 2"	self uninstall</body><body package="SmallSuiteGenerator-Tests-GA" selector="testCoverageOnPackagesSStudent">testCoverageOnPackagesSStudent	| testCase valueFitness targetClass |	targetClass := #SStudent fullClassNameSymbol.	testCase := self		testCase: utility typeInfoSStudentOnPackage1		withNumStatements: 20		andTargetClassName: targetClass.	self installOn: 'SmallSuiteGenerator-Scenario2'.	fitness targetClass: targetClass.	valueFitness := self computeFitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 80.0 ]).	self uninstall</body></methods><methods><class-id>SmallSuiteGenerator.SMethodCoverageTest</class-id> <category>running</category><body package="SmallSuiteGenerator-Tests-GA" selector="fitnessClass">fitnessClass	^ SMethodCoverage</body></methods><methods><class-id>SmallSuiteGenerator.SSTeacher</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Scenario" selector="initialize">initialize	idTeacher := 100 + (id ifNil: [ 0 ]).	yearsWorkExperience := 0</body></methods><methods><class-id>SmallSuiteGenerator.SSTeacher</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Scenario" selector="idTeacher">idTeacher	^ idTeacher</body><body package="SmallSuiteGenerator-Scenario" selector="nickname">nickname	^ 'teacher_' , (nickname ifNil: [ '1' ])</body><body package="SmallSuiteGenerator-Scenario" selector="yearsWorkExperience">yearsWorkExperience	^ yearsWorkExperience</body><body package="SmallSuiteGenerator-Scenario" selector="yearsWorkExperience:">yearsWorkExperience: anObject	yearsWorkExperience := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SStudent</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Scenario2" selector="initialize">initialize	id := 1.	scoreStudent := 1.	idStudent := id</body></methods><methods><class-id>SmallSuiteGenerator.SStudent</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Scenario2" selector="idStudent">idStudent	^ idStudent</body><body package="SmallSuiteGenerator-Scenario2" selector="nickname">nickname	^ 'student_' , (nickname ifNil: [ '1' ])</body><body package="SmallSuiteGenerator-Scenario2" selector="scoreStudent">scoreStudent	^ scoreStudent</body><body package="SmallSuiteGenerator-Scenario2" selector="scoreStudent:">scoreStudent: aNumber	scoreStudent := aNumber</body></methods><methods><class-id>SmallSuiteGenerator.SConfigGenerationTestCase</class-id> <category>actions</category><body package="SmallSuiteGenerator-Core" selector="executeBlock:">executeBlock: aBlock	executionBlock := aBlock</body><body package="SmallSuiteGenerator-Core" selector="executedCase:">executedCase: aTestCase	executedCase := aTestCase</body><body package="SmallSuiteGenerator-Core" selector="runContext">runContext	| context |	self setUp.	context := executionBlock value: executedCase.	self waitThread.	self tearDown.	^ context</body></methods><methods><class-id>SmallSuiteGenerator.SConfigGenerationTestCase</class-id> <category>running</category><body package="SmallSuiteGenerator-Core" selector="waitThread">waitThread	</body></methods><methods><class-id>SmallSuiteGenerator.SConfigGenerationTestCase class</class-id> <category>settings</category><body package="SmallSuiteGenerator-Core" selector="aClass">aClass	self subclassResponsibility</body><body package="SmallSuiteGenerator-Core" selector="addTypeInfo:withKey:">addTypeInfo: aTypeInfo withKey: aString	^ self typeInfos at: aString put: aTypeInfo</body><body package="SmallSuiteGenerator-Core" selector="asDict">asDict	^ false</body><body package="SmallSuiteGenerator-Core" selector="blackList">blackList	^ #()</body><body package="SmallSuiteGenerator-Core" selector="compileMethod:withReturn:">compileMethod: aSymbol withReturn: aString	self class		compile: aSymbol asString , String cr , '	^ ' , aString		classified: 'settings'</body><body package="SmallSuiteGenerator-Core" selector="compilePrinterClass">compilePrinterClass	| aClass |	aClass := self asDict		ifTrue: [ SSDictionaryBasedPrinter ]		ifFalse: [ SSStandardPrinter ].	SSTestShifter class		compile: 'defaultPrinterClass' , String cr , '	^ ' , aClass printString</body><body package="SmallSuiteGenerator-Core" selector="crossoverOperator">crossoverOperator	^ SGACrossoverOperation new</body><body package="SmallSuiteGenerator-Core" selector="crossoverStrategy">crossoverStrategy	^ SGACrossoverRate new</body><body package="SmallSuiteGenerator-Core" selector="decodeBlackList">decodeBlackList	| result |	result := OrderedCollection new.	self blackList		do: [ :e | 			| class |			[ class := (e at: 1) asClass.			(e at: 3)				ifTrue: [ class := class class ].			result add: (class compiledMethodAt: (e at: 2)) ]				on: Error				do: [ nil ] ].	^ result</body><body package="SmallSuiteGenerator-Core" selector="defaultTypeInfo">defaultTypeInfo	defaultTypeInfo		ifNil: [ defaultTypeInfo := STypeInfo				asTypeInfo:					(Spy1.SSTypeCollector						profile: [  ]						inPackagesMatching: self targetPackageRegex) ].	^ defaultTypeInfo</body><body package="SmallSuiteGenerator-Core" selector="elitismRate">elitismRate	^ 0.1</body><body package="SmallSuiteGenerator-Core" selector="encodeBlackList:">encodeBlackList: aColl	^ aColl		collect: [ :compM | 			Array				with: compM origin instanceSide name				with: compM selector				with: compM origin isMeta ]</body><body package="SmallSuiteGenerator-Core" selector="factory">factory	^ STestCaseFactoryPharo from: self</body><body package="SmallSuiteGenerator-Core" selector="fitness">fitness	^ #statement</body><body package="SmallSuiteGenerator-Core" selector="fitnessValue">fitnessValue	"returns the fitness value given a keyword"	^ (self fitnessDictionary		at: self fitness		ifAbsent: [ self fitnessDictionary at: #statement ]) value</body><body package="SmallSuiteGenerator-Core" selector="generateTests">generateTests	^ self factory		createTestCases;		yourself</body><body package="SmallSuiteGenerator-Core" selector="lastMessage">lastMessage	^ ''</body><body package="SmallSuiteGenerator-Core" selector="limitToWait">limitToWait	^ 1000</body><body package="SmallSuiteGenerator-Core" selector="logClass">logClass	^ SGANullLog</body><body package="SmallSuiteGenerator-Core" selector="logs">logs	^ false</body><body package="SmallSuiteGenerator-Core" selector="nsuperclasses">nsuperclasses	^ 0</body><body package="SmallSuiteGenerator-Core" selector="numberOfGenerations">numberOfGenerations	^ 5</body><body package="SmallSuiteGenerator-Core" selector="numberOfStatements">numberOfStatements	^ 30</body><body package="SmallSuiteGenerator-Core" selector="outputPackageName">outputPackageName	^ 'GeneratedTests'</body><body package="SmallSuiteGenerator-Core" selector="populationSize">populationSize	^ 30</body><body package="SmallSuiteGenerator-Core" selector="printerClass">printerClass	^ SSDictionaryBasedPrinter</body><body package="SmallSuiteGenerator-Core" selector="selectionStrategy">selectionStrategy	^ SGARandomSelection</body><body package="SmallSuiteGenerator-Core" selector="selectionStrategyTestCase">selectionStrategyTestCase	^ SGARouletteSelection</body><body package="SmallSuiteGenerator-Core" selector="stopIterations">stopIterations	^ 10</body><body package="SmallSuiteGenerator-Core" selector="targetPackageRegex">targetPackageRegex	self subclassResponsibility</body><body package="SmallSuiteGenerator-Core" selector="typeInfo">typeInfo	^ 'Default'</body><body package="SmallSuiteGenerator-Core" selector="typeInfos">typeInfos	typeInfos ifNotNil: [ ^ typeInfos ].	typeInfos := Dictionary new		at: 'Default' put: nil;		yourself.	^ typeInfos</body><body package="SmallSuiteGenerator-Core" selector="typeInfoValue">typeInfoValue	[ | value |	value := SConfigGenerationTestCase typeInfos at: self typeInfo.	value ifNil: [ SError signal: 'Default typeInfo' ].	^ value ]		on: Error		do: [ ^ self defaultTypeInfo ]</body><body package="SmallSuiteGenerator-Core" selector="vizClass">vizClass	^ SGANullViz</body></methods><methods><class-id>SmallSuiteGenerator.SConfigGenerationTestCase class</class-id> <category>setter</category><body package="SmallSuiteGenerator-Core" selector="aClass:">aClass: aClass	self compileMethod: #aClass withReturn: aClass printString</body><body package="SmallSuiteGenerator-Core" selector="asDict:">asDict: aBoolean	self compileMethod: #asDict withReturn: aBoolean asString.	self compilePrinterClass</body><body package="SmallSuiteGenerator-Core" selector="blackList:">blackList: aColl	self		compileMethod: #blackList		withReturn: (self encodeBlackList: aColl) storeString</body><body package="SmallSuiteGenerator-Core" selector="crossoverOperator:">crossoverOperator: aClass	self compileMethod: #crossoverOperator withReturn: aClass storeString</body><body package="SmallSuiteGenerator-Core" selector="crossoverStrategy:">crossoverStrategy: aClass	self compileMethod: #crossoverStrategy withReturn: aClass storeString</body><body package="SmallSuiteGenerator-Core" selector="elitismRate:">elitismRate: aNumber	self compileMethod: #elitismRate withReturn: aNumber storeString</body><body package="SmallSuiteGenerator-Core" selector="fitness:">fitness: aSymbol	self compileMethod: #fitness withReturn: aSymbol printString</body><body package="SmallSuiteGenerator-Core" selector="lastMessage:">lastMessage: aString	self compileMethod: #lastMessage withReturn: aString storeString</body><body package="SmallSuiteGenerator-Core" selector="limitToWait:">limitToWait: aNumber	self compileMethod: #limitToWait withReturn: aNumber asString</body><body package="SmallSuiteGenerator-Core" selector="logClass:">logClass: aClass	self compileMethod: #logClass withReturn: aClass printString</body><body package="SmallSuiteGenerator-Core" selector="logs:">logs: aBoolean	self compileMethod: #logs withReturn: aBoolean printString</body><body package="SmallSuiteGenerator-Core" selector="nsuperclasses:">nsuperclasses: aNumber	self compileMethod: #nsuperclasses withReturn: aNumber printString</body><body package="SmallSuiteGenerator-Core" selector="numberOfGenerations:">numberOfGenerations: aNumber	self		compileMethod: #numberOfGenerations		withReturn: aNumber printString</body><body package="SmallSuiteGenerator-Core" selector="numberOfStatements:">numberOfStatements: aNumber	self		compileMethod: #numberOfStatements		withReturn: aNumber printString</body><body package="SmallSuiteGenerator-Core" selector="outputPackageName:">outputPackageName: aString	self category: aString.	self		compileMethod: #outputPackageName		withReturn: aString storeString</body><body package="SmallSuiteGenerator-Core" selector="populationSize:">populationSize: aNumber	self compileMethod: #populationSize withReturn: aNumber printString</body><body package="SmallSuiteGenerator-Core" selector="printerClass:">printerClass: aClass	self compileMethod: #printerClass withReturn: aClass printString</body><body package="SmallSuiteGenerator-Core" selector="selectionStrategy:">selectionStrategy: aClass	self compileMethod: #selectionStrategy withReturn: aClass printString</body><body package="SmallSuiteGenerator-Core" selector="selectionStrategyTestCase:">selectionStrategyTestCase: aClass	self		compileMethod: #selectionStrategyTestCase		withReturn: aClass printString</body><body package="SmallSuiteGenerator-Core" selector="stopIterations:">stopIterations: aNumber	self compileMethod: #stopIterations withReturn: aNumber storeString</body><body package="SmallSuiteGenerator-Core" selector="targetPackageRegex:">targetPackageRegex: aString	self		compileMethod: #targetPackageRegex		withReturn: aString storeString</body><body package="SmallSuiteGenerator-Core" selector="typeInfo:">typeInfo: aString	self compileMethod: #typeInfo withReturn: aString storeString</body><body package="SmallSuiteGenerator-Core" selector="vizClass:">vizClass: aClass	self compileMethod: #vizClass withReturn: aClass printString</body></methods><methods><class-id>SmallSuiteGenerator.SConfigGenerationTestCase class</class-id> <category>execution</category><body package="SmallSuiteGenerator-Core" selector="on:execute:">on: aTestCase execute: aBlock	^ self new		executedCase: aTestCase;		executeBlock: aBlock;		runContext</body></methods><methods><class-id>SmallSuiteGenerator.SComparisonAssertion</class-id> <category>visitor</category><body package="SmallSuiteGenerator-Core" selector="accept:">accept: aSSVisitor	^ aSSVisitor visitComparisonAssertionMessage: self</body></methods><methods><class-id>SmallSuiteGenerator.SComparisonAssertion class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Core" selector="comparisonAssertion:with:">comparisonAssertion: anExecutionContext with: array	| varName1 varName2 val1 val2 |	varName1 := array first.	varName2 := array second.	val1 := anExecutionContext at: varName1.	val2 := anExecutionContext at: varName2.	val1 class = val2 class		ifTrue: [ (val1 class allSelectorsBelow: Object)				detect: [ :selector | selector = #= ]				ifFound: [ | selector |					selector := val1 = val2						ifTrue: [ #assert:equals: ]						ifFalse: [ #deny:equals: ].					^ self new						selector: selector;						args:							(Array								with: (SVariable nameOrId: varName1)								with: (SVariable nameOrId: varName2));						yourself ] ].	^ nil</body><body package="SmallSuiteGenerator-Core" selector="for:">for: anExecutionContext	| assertions |	assertions := OrderedCollection new.	anExecutionContext keys asOrderedCollection		combinations: 2		atATimeDo: [ :comb | 			| compareAssert |			compareAssert := self				comparisonAssertion: anExecutionContext				with: comb.			compareAssert ifNotNil: [ assertions add: compareAssert ] ].	^ assertions</body></methods><methods><class-id>SmallSuiteGenerator.SInsertTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-Core" selector="setUp">setUp	super setUp.	SPlatform fileLogger: 'SInsertTestLogger.log'</body></methods><methods><class-id>SmallSuiteGenerator.SInsertTest</class-id> <category>mutation-insert</category><body package="SmallSuiteGenerator-Tests-Core" selector="testCopyWithANewMethodCallToTargetClass">testCopyWithANewMethodCallToTargetClass	| testCase targetClass studentClass newTestCase |	targetClass := 'SFoo' fullClassNameSymbol.	studentClass := 'SStudent' fullClassNameSymbol.	testCase := SSTestCase with: utility typeInfoSFoo4.	testCase		targetClassName: targetClass;		addFactoryMessage: targetClass;		addMessage: #return: from: targetClass.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			((Array new: 3)				at: 1 put: '_var0 := ' , targetClass asString , ' new';				at: 2 put: '_var1 := ' , studentClass asString , ' new';				at: 3 put: '_var2 := _var0 return: _var1 ';				yourself).	newTestCase := testCase copyWithANewMethodCallToTargetClass.	newTestCase repairIds.	self		assertCollection: (newTestCase statements collect: #printString)		hasSameElements:			((Array new: 5)				at: 1 put: '_var0 := ' , targetClass asString , ' new';				at: 2 put: '_var1 := ' , studentClass asString , ' new';				at: 3 put: '_var2 := _var0 return: _var1 ';				at: 4 put: '_var3 := ' , studentClass asString , ' new';				at: 5 put: '_var4 := _var0 return: _var3 ';				yourself)</body></methods><methods><class-id>SmallSuiteGenerator.STypeObjectInfo</class-id> <category>actions</category><body package="SmallSuiteGenerator-Info" selector="joinWith:">joinWith: otherObject	self subclassResponsibility</body></methods><methods><class-id>SmallSuiteGenerator.STypeObjectInfo class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Info" selector="instance">instance	^ self new</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Info" selector="=">= other	^ self class = other class		and: [ selector = other selector				and: [ receiver = other receiver						and: [ returnType = other returnType								and: [ argTypes = other argTypes										and:											[ isQuick = other isQuick and: [ hasProfiler = other hasProfiler ] ] ] ] ] ]</body><body package="SmallSuiteGenerator-Info" selector="hash">hash	^ selector hash		bitXor:			(receiver hash				bitXor: (returnType hash bitXor: (argTypes hash bitXor: isQuick hash)))</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Info" selector="allArgTypes">allArgTypes	argTypes ifNil: [ ^ #() ].	^ argTypes flatCollect: [ :arg | arg types ]</body><body package="SmallSuiteGenerator-Info" selector="allReceivers">allReceivers	^ receiver types</body><body package="SmallSuiteGenerator-Info" selector="argTypes">argTypes	^ argTypes</body><body package="SmallSuiteGenerator-Info" selector="argTypes:">argTypes: anObject	argTypes := anObject</body><body package="SmallSuiteGenerator-Info" selector="dataCSV">dataCSV	^ Array		with: selector		withAll:			(OrderedCollection new				add: receiver types asArray;				add: receiver commonSuperclass;				add:					(argTypes						ifNil: [ #() ]						ifNotNil: [ (argTypes collect: [ :argType | argType types asArray ]) asArray ]);				add:					(argTypes						ifNil: [ '' ]						ifNotNil: [ argTypes collect: [ :argType | argType commonSuperclass ] ]);				add: returnType types asArray;				add: returnType commonSuperclass;				yourself)</body><body package="SmallSuiteGenerator-Info" selector="hasProfiler">hasProfiler	^ hasProfiler</body><body package="SmallSuiteGenerator-Info" selector="hasProfiler:">hasProfiler: aBoolean	hasProfiler := aBoolean</body><body package="SmallSuiteGenerator-Info" selector="isAbstract">isAbstract	^ abstract</body><body package="SmallSuiteGenerator-Info" selector="isAbstract:">isAbstract: aBoolean	abstract := aBoolean</body><body package="SmallSuiteGenerator-Info" selector="isDeprecated">isDeprecated	^ isDeprecated</body><body package="SmallSuiteGenerator-Info" selector="isDeprecated:">isDeprecated: anObject	isDeprecated := anObject</body><body package="SmallSuiteGenerator-Info" selector="isQuick">isQuick	^ isQuick</body><body package="SmallSuiteGenerator-Info" selector="isQuick:">isQuick: aBoolean	isQuick := aBoolean</body><body package="SmallSuiteGenerator-Info" selector="isUnary">isUnary	^ selector isUnary</body><body package="SmallSuiteGenerator-Info" selector="receiver">receiver	^ receiver</body><body package="SmallSuiteGenerator-Info" selector="receiver:">receiver: anObject	receiver := anObject</body><body package="SmallSuiteGenerator-Info" selector="returnType">returnType	^ returnType</body><body package="SmallSuiteGenerator-Info" selector="returnType:">returnType: anObject	returnType := anObject</body><body package="SmallSuiteGenerator-Info" selector="scalars">scalars	^ scalars</body><body package="SmallSuiteGenerator-Info" selector="selector">selector	^ selector</body><body package="SmallSuiteGenerator-Info" selector="selector:">selector: anObject	selector := anObject</body><body package="SmallSuiteGenerator-Info" selector="transform:">transform: aSet	| multiType |	multiType := SMultiTypeInfo new.	aSet do: [ :anObject | multiType type: anObject ].	^ multiType</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id> <category>actions</category><body package="SmallSuiteGenerator-Info" selector="copyValuesOf:">copyValuesOf: otherTypeMethod	(otherTypeMethod hasProfiler		and: [ otherTypeMethod returnType types isNotEmpty ])		ifFalse: [ ^ self ].	returnType := otherTypeMethod returnType.	argTypes := otherTypeMethod argTypes.	receiver := otherTypeMethod receiver.	hasProfiler := otherTypeMethod hasProfiler</body><body package="SmallSuiteGenerator-Info" selector="joinWith:">joinWith: otherTypeMethod	hasProfiler		ifFalse: [ self copyValuesOf: otherTypeMethod ]		ifTrue: [ argTypes				ifNotNil: [ argTypes						with: otherTypeMethod argTypes						do: [ :argType :otherArgType | argType joinWith: otherArgType ] ].			returnType joinWith: otherTypeMethod returnType ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id> <category>adding</category><body package="SmallSuiteGenerator-Info" selector="addType:">addType: aType	argTypes do: [ :arg | arg type: aType ].	returnType type: aType</body><body package="SmallSuiteGenerator-Info" selector="scalars:">scalars: aDictionary	scalars := aDictionary</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id> <category>metrics</category><body package="SmallSuiteGenerator-Info" selector="isSimpleTyped">isSimpleTyped	"	- one type of receiver only one type for each argument	"	^ (Array		with: receiver hasOnlyOneType		with: returnType hasOnlyOneType		with: (argTypes isNil or: [ argTypes allSatisfy: #hasOnlyOneType ]))		allSatisfy: #yourself</body><body package="SmallSuiteGenerator-Info" selector="isSimpleTyped10">isSimpleTyped10	"		"	^ (Array		with: receiver hasOnlyOneType		with:			(returnType hasOnlyOneType not				and: [ returnType commonSuperclass = 'Object' ])		with:			(argTypes notNil				and: [ argTypes anySatisfy: [ :t | t hasOnlyOneType not ] ])		with:			(argTypes notNil				and: [ argTypes						allSatisfy: [ :t | 							t hasOnlyOneType								or: [ t isBlockSymbol not and: [ t commonSuperclass = 'Object' ] ] ] ]))		allSatisfy: #yourself</body><body package="SmallSuiteGenerator-Info" selector="isSimpleTyped11">isSimpleTyped11	"		"	^ (Array		with: receiver hasOnlyOneType not		with: returnType hasOnlyOneType not		with: (argTypes isNil or: [ argTypes allSatisfy: #hasOnlyOneType ])		with: (receiver equals: returnType) not) allSatisfy: #yourself</body><body package="SmallSuiteGenerator-Info" selector="isSimpleTyped12">isSimpleTyped12	"		"	^ (Array		with:			(receiver hasOnlyOneType not				and: [ receiver commonSuperclass ~= 'Object' ])		with: returnType hasOnlyOneType not		with:			(argTypes notNil				and: [ argTypes anySatisfy: [ :t | t hasOnlyOneType not ] ])		with:			(argTypes notNil				and: [ argTypes						allSatisfy: [ :t | 							t hasOnlyOneType								or: [ t isBlockSymbol not and: [ t commonSuperclass = 'Object' ] ] ] ]))		allSatisfy: #yourself</body><body package="SmallSuiteGenerator-Info" selector="isSimpleTyped2">isSimpleTyped2	"	- this guy return the type that he receive 	"	^ (Array		with: receiver hasOnlyOneType not		with: returnType hasOnlyOneType not		with: (receiver equals: returnType)		with: (argTypes isNil or: [ argTypes allSatisfy: #hasOnlyOneType ]))		allSatisfy: #yourself</body><body package="SmallSuiteGenerator-Info" selector="isSimpleTyped3">isSimpleTyped3	"	- this guy return the type that he receive 	"	^ (Array		with: receiver hasOnlyOneType not		with: receiver commonSuperclass ~= 'Object'		with: returnType hasOnlyOneType		with: (argTypes isNil or: [ argTypes allSatisfy: #hasOnlyOneType ]))		allSatisfy: #yourself</body><body package="SmallSuiteGenerator-Info" selector="isSimpleTyped4">isSimpleTyped4	"		"	^ (Array		with: receiver hasOnlyOneType		with: returnType hasOnlyOneType		with:			(argTypes notNil				and: [ argTypes anySatisfy: [ :t | t hasOnlyOneType not ] ])		with:			(argTypes notNil				and: [ argTypes						allSatisfy: [ :t | t hasOnlyOneType or: [ t isBlockSymbol ] ] ]))		allSatisfy: #yourself</body><body package="SmallSuiteGenerator-Info" selector="isSimpleTyped5">isSimpleTyped5	"		"	^ (Array		with: receiver hasOnlyOneType		with: returnType hasOnlyOneType		with:			(argTypes notNil				and: [ argTypes anySatisfy: [ :t | t hasOnlyOneType not ] ])		with:			(argTypes notNil				and: [ argTypes						allSatisfy: [ :t | 							t hasOnlyOneType								or: [ t isBlockSymbol not and: [ t commonSuperclass = 'Object' ] ] ] ]))		allSatisfy: #yourself</body><body package="SmallSuiteGenerator-Info" selector="isSimpleTyped6">isSimpleTyped6	"		"	^ (Array		with: receiver hasOnlyOneType		with: returnType hasOnlyOneType		with:			(argTypes notNil				and: [ argTypes anySatisfy: [ :t | t hasOnlyOneType not ] ])		with:			(argTypes notNil				and: [ argTypes						allSatisfy: [ :t | t hasOnlyOneType or: [ t commonSuperclass ~= 'Object' ] ] ]))		allSatisfy: #yourself</body><body package="SmallSuiteGenerator-Info" selector="isSimpleTyped7">isSimpleTyped7	"		"	^ (Array		with: receiver hasOnlyOneType		with:			(returnType hasOnlyOneType not				and: [ returnType commonSuperclass = 'Object' ])		with: (argTypes isNil or: [ argTypes allSatisfy: #hasOnlyOneType ]))		allSatisfy: #yourself</body><body package="SmallSuiteGenerator-Info" selector="isSimpleTyped8">isSimpleTyped8	"		"	^ (Array		with: receiver hasOnlyOneType		with:			(returnType hasOnlyOneType not				and: [ returnType commonSuperclass ~= 'Object' ])		with: (argTypes isNil or: [ argTypes allSatisfy: #hasOnlyOneType ]))		allSatisfy: #yourself</body><body package="SmallSuiteGenerator-Info" selector="isSimpleTyped9">isSimpleTyped9	"		"	^ (Array		with:			(receiver hasOnlyOneType not				and: [ receiver commonSuperclass ~= 'Object' ])		with:			(returnType hasOnlyOneType not				and: [ returnType commonSuperclass ~= 'Object' ])		with:			(argTypes notNil				and: [ argTypes anySatisfy: [ :t | t hasOnlyOneType not ] ])		with:			(argTypes notNil				and: [ argTypes						allSatisfy: [ :t | t hasOnlyOneType or: [ t commonSuperclass ~= 'Object' ] ] ]))		allSatisfy: #yourself</body><body package="SmallSuiteGenerator-Info" selector="returnTypeFor:">returnTypeFor: aReceiver	^ self isSimpleTyped2		ifTrue: [ "it is the same than his father" aReceiver returnType ]		ifFalse: [ "it return one random" self returnType type ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id> <category>converting</category><body package="SmallSuiteGenerator-Info" selector="asMethodInfo:">asMethodInfo: typeCollMethod	self		selector: typeCollMethod selector;		receiver: (self transform: typeCollMethod receiverType);		returnType: (self transform: typeCollMethod returnType);		argTypes: (self transformArgs: typeCollMethod argTypes);		isQuick: typeCollMethod isQuick;		isAbstract: typeCollMethod isAbstract;		scalars: typeCollMethod dictLiterals;		isDeprecated: typeCollMethod isDeprecated;		executions: typeCollMethod numberOfExecutions;		hasProfiler: typeCollMethod wasExecuted</body><body package="SmallSuiteGenerator-Info" selector="transformArgs:">transformArgs: allArgs	^ allArgs collect: [ :args | self transform: args ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Info" selector="initialize">initialize	argTypes := #().	isQuick := false.	returnType := SMultiTypeInfo new.	receiver := SMultiTypeInfo new.	isDeprecated := false.	scalars := Dictionary new.	hasProfiler := true.	abstract := false</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id> <category>testing</category><body package="SmallSuiteGenerator-Info" selector="isFromReceiver:">isFromReceiver: aClassName	^ receiver types includes: aClassName</body><body package="SmallSuiteGenerator-Info" selector="isWithReturnType:">isWithReturnType: aClassName	^ returnType types includes: aClassName</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id> <category>copying</category><body package="SmallSuiteGenerator-Info" selector="copy">copy	| copy |	copy := self class instance.	copy		selector: selector;		isQuick: isQuick;		isDeprecated: isDeprecated;		isAbstract: abstract;		returnType: returnType copy;		argTypes: argTypes copy;		scalars: scalars copy;		executions: executions;		receiver: receiver copy.	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id> <category>acccessing</category><body package="SmallSuiteGenerator-Info" selector="executions">executions	^ executions</body><body package="SmallSuiteGenerator-Info" selector="executions:">executions: anObject	executions := anObject</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo class</class-id> <category>converting</category><body package="SmallSuiteGenerator-Info" selector="asMethodInfo:">asMethodInfo: aSpyMethod	^ self new asMethodInfo: aSpyMethod</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo class</class-id> <category>accessing structure variables</category><body package="SmallSuiteGenerator-Info" selector="type:">type: aAssoc	| aValue |	aValue := aAssoc value.	^ self new		selector: aAssoc key;		receiver: (SMultiTypeInfo new: aValue first);		returnType: (SMultiTypeInfo new: aValue second);		argTypes: (aValue third collect: [ :aType | SMultiTypeInfo new: aType ]);		isQuick: aValue fourth	";		isDeprecated: aValue fifth"</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo class</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Info" selector="selectorsFilter">selectorsFilter	^ self selectors		select: [ :aSelector | aSelector beginsWith: 'isSimpleTyped' ]</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>actions</category><body package="SmallSuiteGenerator-Info" selector="joinWith:">joinWith: otherTypeReturn	| hasOneType |	hasOneType := self hasOnlyOneType.	(otherTypeReturn types difference: self types)		do: [ :aType | 			self type: aType.			self resetTypes ].	types size &gt; 1		ifTrue: [ types remove: #SUndefinedObject ifAbsent: [  ] ].	mustBeFixed := hasOneType and: [ types size &gt; 1 ]</body><body package="SmallSuiteGenerator-Info" selector="resetTypes">resetTypes	self cleanTypes: nil</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Info" selector="cleanTypes:">cleanTypes: anObject	cleanTypes := anObject</body><body package="SmallSuiteGenerator-Info" selector="cleanTypesIn:">cleanTypesIn: aTypeInfo	cleanTypes ifNotNil: [ ^ cleanTypes ].	cleanTypes := aTypeInfo intersect: self types.	^ cleanTypes</body><body package="SmallSuiteGenerator-Info" selector="commonSuperclass">commonSuperclass	| commonSuperclass |	types ifEmpty: [ ^ '' ].	commonSuperclass := SPlatform lookUpClass: types anyOne.	commonSuperclass ifNil: [ ^ '' ].	types		do: [ :aType | 			| otherClass |			otherClass := SPlatform lookUpClass: aType.			otherClass ifNil: [ ^ '' ].			(commonSuperclass isClass and: [ commonSuperclass name = #Object ])				ifTrue: [ ^ #Object ].			commonSuperclass := commonSuperclass				commonSuperclassWith: otherClass ].	^ commonSuperclass name</body><body package="SmallSuiteGenerator-Info" selector="mustBeFixed">mustBeFixed	^ mustBeFixed</body><body package="SmallSuiteGenerator-Info" selector="removeType:">removeType: aType	types remove: aType ifAbsent: [  ]</body><body package="SmallSuiteGenerator-Info" selector="type">type	^ types		ifEmpty: [ nil ]		ifNotEmpty: [ self random selectAtRandom: self types ]</body><body package="SmallSuiteGenerator-Info" selector="types">types	^ types asArray</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Info" selector="initialize">initialize	types := Set new.	mustBeFixed := false</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>accessing structure variables</category><body package="SmallSuiteGenerator-Info" selector="type:">type: aClassName	aClassName ~= #nil		ifTrue: [ types add: aClassName ]</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>metrics</category><body package="SmallSuiteGenerator-Info" selector="hasOnlyOneType">hasOnlyOneType	^ types size &lt;= 1</body><body package="SmallSuiteGenerator-Info" selector="isBlockSymbol">isBlockSymbol	^ types size = 2		and: [ (types anySatisfy: [ :aType | aType = #BlockClosure ])				and: [ types anySatisfy: [ :aType | aType = #ByteSymbol ] ] ]</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>copying</category><body package="SmallSuiteGenerator-Info" selector="copy">copy	| copy |	copy := self class instance.	types do: [ :aType | copy type: aType ].	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>ston persistence</category><body package="SmallSuiteGenerator-Info" selector="stonOn:">stonOn: stonWriter	stonWriter		writeObject: self		streamShortList: [ :array | self types do: [ :type | array add: type ] ]</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>testing</category><body package="SmallSuiteGenerator-Info" selector="includes:">includes: aType	^ self types includes: aType</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Info" selector="fromSton:">fromSton: stonReader	stonReader parseListDo: [ :each :index | self type: each ]</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Info" selector="=">= other	^ self class = other class and: [ self types = other types ]</body><body package="SmallSuiteGenerator-Info" selector="equals:">equals: other	self types size = other types size		ifFalse: [ ^ false ].	self types asOrderedCollection		with: other types asOrderedCollection		do: [ :a :b | 			a = b				ifFalse: [ ^ false ] ].	^ true</body><body package="SmallSuiteGenerator-Info" selector="hash">hash	^ self types hash</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Info" selector="new:">new: aType	^ self new type: aType</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>adding</category><body package="SmallSuiteGenerator-Info" selector="addClassMethod:">addClassMethod: methodTypeInfo	classMethodTypes		at: methodTypeInfo selector		ifPresent: [ :methInfo | methInfo joinWith: methodTypeInfo ]		ifAbsentPut: methodTypeInfo.	self addScalars: methodTypeInfo scalars</body><body package="SmallSuiteGenerator-Info" selector="addClassMethods:">addClassMethods: methodTypeInfos	methodTypeInfos		do: [ :aMethodType | self addClassMethod: aMethodType ]</body><body package="SmallSuiteGenerator-Info" selector="addMethod:">addMethod: methodTypeInfo	"methodTypeInfo typeInfo: typeInfo."	methodTypes		at: methodTypeInfo selector		ifPresent: [ :methInfo | methInfo joinWith: methodTypeInfo ]		ifAbsentPut: [ methodTypeInfo ].	self addScalars: methodTypeInfo scalars</body><body package="SmallSuiteGenerator-Info" selector="addMethods:">addMethods: methodTypeInfos	methodTypeInfos do: [ :aMethodType | self addMethod: aMethodType ]</body><body package="SmallSuiteGenerator-Info" selector="addScalars:">addScalars: aDictionary	aDictionary associations		do: [ :assoc | 			scalars				at: assoc key				ifPresent:					[ :values | scalars at: assoc key put: (values union: assoc value) asArray ]				ifAbsentPut: [ assoc value asArray ] ]</body><body package="SmallSuiteGenerator-Info" selector="difference:">difference: anotherClassInfo	^ (OrderedCollection		withAll: (self differenceWith: anotherClassInfo usingSelector: #methodTypes))		addAll:			(self				differenceWith: anotherClassInfo				usingSelector: #classMethodTypes);		yourself</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>converting</category><body package="SmallSuiteGenerator-Info" selector="asClassInfo:">asClassInfo: aSpyClass	| aTypeClass instanceMethods classMethods |	aTypeClass := self class newFrom: aSpyClass typeName.	instanceMethods := self instanceMethodsFor: aSpyClass.	classMethods := self classMethodsFor: aSpyClass.	aTypeClass		addMethods:			(instanceMethods				collect: [ :instMeth | STypeMethodInfo asMethodInfo: instMeth ]);		addClassMethods:			(classMethods				collect: [ :instMeth | STypeMethodInfo asMethodInfo: instMeth ]).	^ aTypeClass</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>private</category><body package="SmallSuiteGenerator-Info" selector="accessMessages">accessMessages	^ self messagesAndAccessMessages select: #isQuick</body><body package="SmallSuiteGenerator-Info" selector="factoryMessages">factoryMessages	^ classMethodTypes values		reject: [ :method | method selector = #basicNew ]</body><body package="SmallSuiteGenerator-Info" selector="factoryMessagesFrom:">factoryMessagesFrom: aClassName	^ self factoryMessages		select: [ :factMessage | 			(factMessage isFromReceiver: aClassName)				and: [ factMessage isWithReturnType: aClassName ] ]</body><body package="SmallSuiteGenerator-Info" selector="messages">messages	^ self messagesAndAccessMessages reject: #isQuick</body><body package="SmallSuiteGenerator-Info" selector="messagesAndAccessMessages">messagesAndAccessMessages	^ methodTypes values		select: [ :methType | 			methType isDeprecated not				and: [ methType isAbstract not and: [ methType returnType isNil not ] ] ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Info" selector="classMethodTypes">classMethodTypes	^ classMethodTypes</body><body package="SmallSuiteGenerator-Info" selector="filteredMethodsBy:">filteredMethodsBy: aSymbol	^ (STypeMethodInfo selectorsFilter includes: aSymbol)		ifTrue: [ self allMethods select: aSymbol ]		ifFalse: [ self remainingOrAllMethods: aSymbol ]</body><body package="SmallSuiteGenerator-Info" selector="methodTypes">methodTypes	^ methodTypes</body><body package="SmallSuiteGenerator-Info" selector="remainingOrAllMethods:">remainingOrAllMethods: aSymbol	^ aSymbol = #others		ifTrue: [ | methods |			methods := self allMethods.			STypeMethodInfo selectorsFilter				do: [ :key | methods := methods reject: key ].			methods ]		ifFalse: [ self allMethods ]</body><body package="SmallSuiteGenerator-Info" selector="scalars">scalars	^ scalars</body><body package="SmallSuiteGenerator-Info" selector="typeName">typeName	^ typeName</body><body package="SmallSuiteGenerator-Info" selector="typeName:">typeName: anObject	typeName := anObject</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>accessing - read only</category><body package="SmallSuiteGenerator-Info" selector="allMethods">allMethods	^ methodTypes values , classMethodTypes values</body><body package="SmallSuiteGenerator-Info" selector="classMethodOf:">classMethodOf: aSelector	^ classMethodTypes at: aSelector</body><body package="SmallSuiteGenerator-Info" selector="methodOf:">methodOf: aSelector	^ methodTypes at: aSelector</body><body package="SmallSuiteGenerator-Info" selector="reportFrequencyByFilter:">reportFrequencyByFilter: aSelector	^ (self filteredMethodsBy: aSelector) size</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Info" selector="initialize">initialize	methodTypes := Dictionary new.	classMethodTypes := Dictionary new.	scalars := Dictionary new</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>copying</category><body package="SmallSuiteGenerator-Info" selector="copy">copy	| copy |	copy := self class instance.	methodTypes do: [ :methodType | copy addMethod: methodType copy ].	classMethodTypes		do: [ :classMethodType | copy addClassMethod: classMethodType copy ].	copy typeName: typeName.	copy abstract: self isAbstract.	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>writing</category><body package="SmallSuiteGenerator-Info" selector="writeDataCSV:using:">writeDataCSV: neoCSVWriter using: methods	methods		do: [ :aMethod | 			neoCSVWriter				nextPut: (Array with: typeName printString) , aMethod dataCSV ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>accesing</category><body package="SmallSuiteGenerator-Info" selector="abstract:">abstract: aBoolean	abstract := aBoolean</body><body package="SmallSuiteGenerator-Info" selector="instanceMethodsFor:">instanceMethodsFor: aSpyClass	| instanceMethods |	instanceMethods := OrderedCollection new.	(aSpyClass typeName endsWith: ' class')		ifFalse: [ instanceMethods := (aSpyClass methods reject: #isTest)				select: [ :instMeth | instMeth wasExecuted or: [ instMeth isUnary ] ].			instanceMethods				do: [ :instMeth | 					instMeth wasExecuted						ifFalse: [ instMeth numberOfExecutions: 0.5.							instMeth returnValue: SUndefinedObject basicNew.							instMeth saveReceiver: instMeth originalMethod origin ] ] ].	^ instanceMethods</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>actions</category><body package="SmallSuiteGenerator-Info" selector="exportDataCSV:withFilter:">exportDataCSV: neoCSVWriter withFilter: aSymbol	self		writeDataCSV: neoCSVWriter		using: (self filteredMethodsBy: aSymbol)</body><body package="SmallSuiteGenerator-Info" selector="joinWith:">joinWith: otherTypeClass	otherTypeClass methodTypes do: [ :aMethod | self addMethod: aMethod ].	otherTypeClass classMethodTypes		do: [ :aMethod | self addClassMethod: aMethod ]</body><body package="SmallSuiteGenerator-Info" selector="typeClassMethod:">typeClassMethod: aAssoc	self addClassMethod: (STypeMethodInfo type: aAssoc)</body><body package="SmallSuiteGenerator-Info" selector="typeMethod:">typeMethod: aAssoc	self addMethod: (STypeMethodInfo type: aAssoc)</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Info" selector="=">= other	^ self class = other class		and: [ typeName = other typeName				and: [ methodTypes = other methodTypes						and: [ classMethodTypes = other classMethodTypes ] ] ]</body><body package="SmallSuiteGenerator-Info" selector="hash">hash	^ typeName hash		bitXor: (methodTypes hash bitXor: classMethodTypes hash)</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>acccessing</category><body package="SmallSuiteGenerator-Info" selector="classMethodsFor:">classMethodsFor: aSpyClass	| classMethods |	classMethods := OrderedCollection new.	(aSpyClass metaclassSpy typeName endsWith: ' class')		ifTrue: [ classMethods := (aSpyClass metaclassSpy methods reject: #isTest)				select:					[ :clsMethod | clsMethod wasExecuted and: [ clsMethod isValidReturnTypeWithReceiver ] ] ].	^ classMethods</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo class</class-id> <category>converting</category><body package="SmallSuiteGenerator-Info" selector="asClassInfo:">asClassInfo: aSpyClass	^ self new asClassInfo: aSpyClass</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo class</class-id> <category>accessing structure variables</category><body package="SmallSuiteGenerator-Info" selector="type:">type: aAssoc	| dataOfAllMethods inst dataMethods dataClassMethods |	inst := self new typeName: aAssoc key.	dataOfAllMethods := aAssoc value.	dataMethods := dataOfAllMethods first.	dataClassMethods := dataOfAllMethods second.	dataMethods do: [ :data | inst typeMethod: data ].	dataClassMethods do: [ :data | inst typeClassMethod: data ].	inst methodTypes do: [ :meth | meth executions: 1 ].	^ inst</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Info" selector="newFrom:">newFrom: aClassName	^ self new typeName: aClassName</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>LinkedList</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>firstLink lastLink </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>RBProgramNodeVisitor</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><class><name>MinimumStandardRandom</name><environment>Core</environment><super>Core.Random</super><private>false</private><indexed-type>none</indexed-type><inst-vars>a m q r </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>