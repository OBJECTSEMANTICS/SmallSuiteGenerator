<?xml version="1.0"?><st-source><!-- Name: SpyLiteBundleName: SpyLiteBundleStructure: a Store.BundleForParcelParcel: #('SpyLite' )ParcelName: SpyLitePrerequisiteParcels: #(#('Method Wrapper Base' '' ) )Date: 9:34:47 am June 5, 2020 --><time-stamp>From VisualWorksÂ®, 7.4 of December 5, 2005 on June 5, 2020 at 9:34:47 am</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Spy1</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>Spy1</category><attributes><package>SpyLite</package></attributes></name-space><class><name>SpyWrapper</name><environment>Spy1</environment><super>Refactory.Wrappers.MethodWrapper</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>count methodSpy previousMethod v originalMethod receiver listOfArguments </inst-vars><class-inst-vars>currentTestCase currentTestMethod </class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>SpyLite</package></attributes></class><comment><class-id>Spy1.SpyWrapper</class-id><body>Missing comment</body></comment><class><name>SLProfilerCoverageTest</name><environment>Spy1</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Tests</category><attributes><package>SpyLite</package></attributes></class><comment><class-id>Spy1.SLProfilerCoverageTest</class-id><body>Missing comment</body></comment><class><name>SLBlock</name><environment>Spy1</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id executed numberOfStatements start stop code </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite</package></attributes></class><class><name>SLCodeProbe</name><environment>Spy1</environment><super>CraftedSmalltalk.CodeProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SpyLite</package></attributes></class><class><name>SSTypeCollectorMethodTest</name><environment>Spy1</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeCollectorMethod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Tests</category><attributes><package>SpyLite</package></attributes></class><comment><class-id>Spy1.SSTypeCollectorMethodTest</class-id><body>Missing comment</body></comment><class><name>SLCounter</name><environment>Spy1</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Scenario</category><attributes><package>SpyLite</package></attributes></class><class><name>SLInstrumentor</name><environment>Spy1</environment><super>Refactory.Browser.RBProgramNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blocks currentId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite</package></attributes></class><class><name>SLCollectorLiteral</name><environment>Spy1</environment><super>Refactory.Browser.RBProgramNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>literals </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite</package></attributes></class><comment><class-id>Spy1.SLCollectorLiteral</class-id><body>Missing comment</body></comment><class><name>SpyLite</name><environment>Spy1</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>currentTestCase currentTestMethod </class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>SpyLite</package></attributes></class><comment><class-id>Spy1.SpyLite</class-id><body>Missing comment</body></comment><class><name>SLClass</name><environment>Spy1</environment><super>Spy1.SpyLite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methods className allSubclassesCache packageSpy metaclassSpy originalClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>SpyLite</package></attributes></class><comment><class-id>Spy1.SLClass</class-id><body>Missing comment</body></comment><class><name>SLClassCoverage</name><environment>Spy1</environment><super>Spy1.SLClass</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite</package></attributes></class><class><name>SLProfiler</name><environment>Spy1</environment><super>Spy1.SpyLite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packages allClassesAsDictionaryCache allMethodsCache afterBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>SpyLite</package></attributes></class><comment><class-id>Spy1.SLProfiler</class-id><body>Missing comment</body></comment><class><name>SLProfilerCoverage</name><environment>Spy1</environment><super>Spy1.SLProfiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeInfo </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite</package></attributes></class><class><name>SLSummaryExecutionMethod</name><environment>Smalltalk</environment><super>Spy1.SpyLite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>executorClass selector executed code summaryStatements isClassSide hasProfiler returnType argsTypes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Utility</category><attributes><package>SpyLite</package></attributes></class><class><name>SSTypeCollector</name><environment>Spy1</environment><super>Spy1.SLProfiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scalars </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-TypeCollector</category><attributes><package>SpyLite</package></attributes></class><comment><class-id>Spy1.SSTypeCollector</class-id><body>Missing comment</body></comment><class><name>SLMethod</name><environment>Spy1</environment><super>Spy1.SpyLite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instrumentedMethod originalMethod selector classSpy spywrapper </inst-vars><class-inst-vars>inMeta </class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>SpyLite</package></attributes></class><comment><class-id>Spy1.SLMethod</class-id><body>Missing comment</body></comment><class><name>SLMethodCoverage</name><environment>Spy1</environment><super>Spy1.SLMethod</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blocks probedMethod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite</package></attributes></class><class><name>SSTypeCollectorMethod</name><environment>Spy1</environment><super>Spy1.SLMethod</super><private>false</private><indexed-type>none</indexed-type><inst-vars>returnType argTypes receiverType executed literals numberOfExecutions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-TypeCollector</category><attributes><package>SpyLite</package></attributes></class><comment><class-id>Spy1.SSTypeCollectorMethod</class-id><body>Missing comment</body></comment><class><name>SLSummaryStatement</name><environment>Smalltalk</environment><super>Spy1.SpyLite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>code executed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Utility</category><attributes><package>SpyLite</package></attributes></class><class><name>SSTypeCollectorClass</name><environment>Spy1</environment><super>Spy1.SLClass</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-TypeCollector</category><attributes><package>SpyLite</package></attributes></class><comment><class-id>Spy1.SSTypeCollectorClass</class-id><body>Missing comment</body></comment><class><name>SLPackage</name><environment>Spy1</environment><super>Spy1.SpyLite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packageName classes profiler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>SpyLite</package></attributes></class><comment><class-id>Spy1.SLPackage</class-id><body>Missing comment</body></comment><class><name>SLPackageCoverage</name><environment>Spy1</environment><super>Spy1.SLPackage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite</package></attributes></class><class><name>SSTypeCollectorPackage</name><environment>Spy1</environment><super>Spy1.SLPackage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-TypeCollector</category><attributes><package>SpyLite</package></attributes></class><comment><class-id>Spy1.SSTypeCollectorPackage</class-id><body>Missing comment</body></comment><shared-variable><name>Registry</name><environment>Spy1.SLProfiler</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>SpyLite</package></attributes></shared-variable><shared-variable><name>STypeInfo</name><environment>Spy1.SSTypeCollector</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>SpyLite</package></attributes></shared-variable><shared-variable><name>CurrentMethod</name><environment>Spy1.SpyWrapper</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>SpyLite</package></attributes></shared-variable><methods><class-id>Spy1.SpyLite</class-id> <category>visualization</category><body package="SpyLite" selector="fullNameOfClass:">fullNameOfClass: aString	| classes |	classes := Root allClasses select: [:each | aString  = each fullName or: [ (('*.', aString) match: each fullName) ]].	classes ifNotEmpty: [ ^ classes collect: [:cls | cls fullName asSymbol ] ]		ifEmpty: [ self error: 'I cant find the namespace for: ' , aString. ]</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>util</category><body package="SpyLite" selector="addEvaluatedMethod:fromTally:atLevel:">addEvaluatedMethod: t1 fromTally: t2 atLevel: t3 	t3 = 2		ifTrue: [t1 addAll: t2 receivers]		ifFalse: [t2 receivers size &gt; 0 ifTrue: [self					addEvaluatedMethod: t1					fromTally: (t2 receivers asOrderedCollection at: 1)					atLevel: t3 + 1]].</body><body package="SpyLite" selector="addExecutedMethod:fromTally:">addExecutedMethod: t1 fromTally: t2 	(t2 receivers size &gt; 0 and: [t2 tally / t2 root tally &gt; 0.2])		ifTrue: [t2 receivers				do: 					[:t3 | 					t1 add: t3.					self addExecutedMethod: t1 fromTally: t3]].</body><body package="SpyLite" selector="selectProfiledClassesFrom:">selectProfiledClassesFrom: t1	| t2 t3 |	t3 := self allClasses collect: [:t4 | t4 originalClass].	^t2 := t1 select: [:t5 | t5 method mclass class class isMeta					ifTrue: [t3 includes: t5 method mclass instanceBehavior]					ifFalse: [t3 includes: t5 method mclass]]</body><body package="SpyLite" selector="setTimeInfoFromTally:">setTimeInfoFromTally: t1 	self setTimeInfoFromTally: t1 parents: (Array with: t1)</body><body package="SpyLite" selector="setTimeInfoFromTally:parents:">setTimeInfoFromTally: t1 parents: t2 	| t3 t4 t5 t6 t7 t8 t9 |	(t8 := self classAt: t1 method methodClass name ifNone: [nil]) ifNotNil: [(t3 := t8 localMethodAt: t1 method selector ifAbsent: [nil])			ifNotNilDo: 				[:t10 | 				t3 useTime: t1 parents: t2.				t4 := t2 last.				(t6 := self classAt: t4 method methodClass name ifNone: [nil]) ifNotNil: [(t5 := t6 localMethodAt: t4 method selector ifAbsent: [nil])						ifNotNil: 							[t5 addOutgoingCalls: t3.							t3 addIncomingCalls: t5.							self assert: [t5 outgoingCalls includes: t3]]]]].	t7 := t1 receivers.	t9 := t2 , (Array with: t1).	t7 do: [:t11 | self setTimeInfoFromTally: t11 parents: t9]</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>public-profiling</category><body package="SpyLite" selector="profile:inClassCategories:">profile: t1 inClassCategories: t2	^self		profile: t1		inClassCategories: t2		inNamespace: Smalltalk</body><body package="SpyLite" selector="profile:inClassCategories:inNamespace:">profile: t1 inClassCategories: t2 inNamespace: t3 	Transcript show: 'profiling...'; cr.		[self beforeProfiling.	self gatherForClassCategories: t2 inNamespace: t3.	self install.	t1 value.	self afterProfiling]		ensure: [self class removeFromClassCategories: t2 inNamespace: t3].	Transcript show: 'ended...'; cr.	self setIfNecessaryTimeProfiler: t1.	self setIfNecessaryTimeAndCallGraphFrom: t1.	self setIfNecessaryStateChanges.	self checkInvariant.</body><body package="SpyLite" selector="profile:inClassCategoriesMatching:">profile: t1 inClassCategoriesMatching: t2 	^self		profile: t1		inClassCategoriesMatching: t2		inNamespace: Smalltalk</body><body package="SpyLite" selector="profile:inClassCategoriesMatching:inNamespace:">profile: t1 inClassCategoriesMatching: t2 inNamespace: t3 	| t4 |	t4 := (t4 := t3 organization categories select: [:t5 | t2 match: t5]) collect: [:t6 | t6 asString].	^self		profile: t1		inClassCategories: t4		inNamespace: t3</body><body package="SpyLite" selector="profile:inClassCategory:">profile: t1 inClassCategory: t2 	^self		profile: t1		inClassCategories: (Array with: t2)		inNamespace: Smalltalk</body><body package="SpyLite" selector="profile:inPackage:">profile: t1 inPackage: t2 	^self profile: t1 inPackages: (Array with: (Store.Registry packageNamed: t2))</body><body package="SpyLite" selector="profile:inPackages:">profile: t1 inPackages: t2	Transcript show: 'profiling...'; cr.		[self beforeProfiling.	self gatherForPackages: t2.	self install.	self beforeProfiling.	t1 value.	self afterProfiling]		ensure: [self class removeFromPackages: t2].	Transcript show: 'ended...'; cr.	self setIfNecessaryTimeProfiler: t1.	self setIfNecessaryTimeAndCallGraphFrom: t1.	self setIfNecessaryStateChanges.	self checkInvariant</body><body package="SpyLite" selector="profile:inPackagesMatching:">profile: t1 inPackagesMatching: t2 	| t3 |	t3 := Store.Registry allPackages select: [:t4 | t2 match: t4 name asString].	^self profile: t1 inPackages: t3</body><body package="SpyLite" selector="profile:inPackagesNames:">profile: t1 inPackagesNames: t2	| t3 |	t3 := Store.Registry allPackages select: [:t4 | t2 includes: t4 name asString].	^self profile: t1 inPackages: t3</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>hooks</category><body package="SpyLite" selector="afterProfiling">afterProfiling	^self</body><body package="SpyLite" selector="beforeProfiling">beforeProfiling	SLMethod setInNonMeta</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>gathering</category><body package="SpyLite" selector="gather">gather	^self gatherForClasses: self class nonDangerousClasses</body><body package="SpyLite" selector="gatherForClassCategory:">gatherForClassCategory: t1	| t2 t3 t4 t5 t6 |	(t2 := self packageForClassCategory: t1) packageName: t1.	self addPackage: t2</body><body package="SpyLite" selector="gatherForClasses:">gatherForClasses: t1	| t2 t3 t4 |	(t3 := self class spyClassForPackage new) packageName: 'Global profiling'.	t1		do: 			[:t5 | 			(t2 := self spyForClass: t5) packageSpy: t3.			t3 classAt: t5 name put: t2].	self addPackage: t3.	^t3</body><body package="SpyLite" selector="spyForClass:">spyForClass: t1	| t2 |	(t2 := self class spyClassForClass new initialize) className: (self nameOf: t1).	t2 originalClass: t1.	t2 metaclassSpy initialize.	self fillClassType: t2 with: t1 methodDictionary.	self fillClassType: t2 metaclassSpy with: t1 class methodDictionary.	^t2</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>accessing - read only</category><body package="SpyLite" selector="&gt;&gt;">&gt;&gt; t1 	(t1 includes: $ )		ifTrue: [^(self &gt;&gt; t1 asString sunitSubStrings first asSymbol) metaclassSpy].	^self classAt: t1 </body><body package="SpyLite" selector="allClasses">allClasses	| t1 |	t1 := OrderedCollection new.	self packages do: [:t2 | t1 addAll: t2 classes].	^t1</body><body package="SpyLite" selector="allClassesAsDictionary">allClassesAsDictionary	| t1 |	allClassesAsDictionaryCache ifNotNil: [^allClassesAsDictionaryCache].	t1 := Dictionary new.	self packages do: [:t2 | t2 classes do: [:t3 | t1 at: t3 className put: t3]].	^allClassesAsDictionaryCache := t1</body><body package="SpyLite" selector="allClassesSuchThat:">allClassesSuchThat: t1 	^self allClasses select: t1</body><body package="SpyLite" selector="allNonMetaClasses">allNonMetaClasses	^self allClasses reject: #isMeta</body><body package="SpyLite" selector="classAt:">classAt: t1 	^self allClassesAsDictionary at: t1 ifAbsent: [self error: 'Class ' , t1 , ' not found']</body><body package="SpyLite" selector="classAt:ifNone:">classAt: t1 ifNone: t2 	^self allClassesAsDictionary at: t1 ifAbsent: t2</body><body package="SpyLite" selector="includesClassNamed:">includesClassNamed: t1	self classAt: t1 asSymbol ifNone: [^false].	^true</body><body package="SpyLite" selector="numberOfClasses">numberOfClasses	^self allClasses size</body><body package="SpyLite" selector="numberOfMethods">numberOfMethods	^self allMethods size</body><body package="SpyLite" selector="numberOfNonAbstractMethods">numberOfNonAbstractMethods	^self allNonAbstractMethods size</body><body package="SpyLite" selector="numberOfPackages">numberOfPackages	^self packages size</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>private-profiling</category><body package="SpyLite" selector="profile:forClassNamed:">profile: t1 forClassNamed: t2	| t3 t4 t5 |	t5 := Smalltalk at: t2.	Transcript show: 'profiling...'; cr.		[self beforeProfiling.	t4 := self spyForClass: t5.	(t3 := self class spyClassForPackage new initialize) classAt: t2 put: t4.	self addPackage: t3.	self install.	t1 value.	self afterProfiling]		ensure: [self class removeFromClass: t5].	Transcript show: 'ended...'; cr.	self setIfNecessaryTimeProfiler: t1.	self setIfNecessaryTimeAndCallGraphFrom: t1</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>initialize-release</category><body package="SpyLite" selector="initialize">initialize	packages := nil</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>visualization-util</category><body package="SpyLite" selector="nameAsString">nameAsString	^'Profiler'</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>installing</category><body package="SpyLite" selector="install">install	self allMethods asSet do: [:t1 | t1 install]</body><body package="SpyLite" selector="uninstall">uninstall	self allMethods do: #uninstall</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>visualization</category><body package="SpyLite" selector="addFindClassMenuOn:">addFindClassMenuOn: t1	t1 addMenu: 'Find a Class...'		callBack: 			[:t2 | 			| t3 t4 t5 t6 t7 t8 |			t5 := SortedCollection sortBlock: [:t9 :t10 | t9 key printString &lt; t9 key printString].			t6 := OrderedCollection new.			t7 := OrderedCollection new.			self allClasses do: [:t11 | t5 add: t11 originalClass -&gt; t11].			t5				do: 					[:t12 | 					t6 add: t12 key.					t7 add: t12 value].			(t8 := Refactory.Browser.BrowserApplicationModel new						choose: 'Find a class'						fromList: t6						values: t7						lines: 20						cancel: [nil]) isNil not				ifTrue: 					[| t13 |					t13 := nil.					t3 := nil.					t1 raw elementsDo: [:t14 | t13 isNil							ifTrue: 								[(t13 := t1 nestedLookup: t8 in: t14) isNil ifFalse: [t13 elementsDo: [:t15 | t3 isNil											ifTrue: [t3 := t1 nestedLookup: t8 in: t15]											ifFalse: [nil]]].								t4 := t14]							ifFalse: [nil]].					t3 isNil						ifTrue: [nil]						ifFalse: [self findElementStack: t2 element: t3]]]</body><body package="SpyLite" selector="addFindMethodMenuOn:">addFindMethodMenuOn: t1 	t1 addMenu: 'Find a Method...'		callBack: 			[:t2 | 			| t3 t4 t5 t6 t7 t8 |			t5 := SortedCollection sortBlock: [:t9 :t10 | t9 &lt; t9].			t6 := OrderedCollection new.			t7 := OrderedCollection new.			self allMethods do: [:t11 | t5 add: t11 printString -&gt; t11].			t5				do: 					[:t12 | 					t6 add: t12 key.					t7 add: t12 value].			(t8 := Refactory.Browser.BrowserApplicationModel new						choose: 'Find a class'						fromList: t6						values: t7						lines: 20						cancel: [nil]) isNil not				ifTrue: 					[t3 := nil.					t1 raw elementsDo: [:t13 | t3 isNil							ifTrue: 								[t3 := t1 nestedLookup: t8 in: t13.								t4 := t13]							ifFalse: [nil]].					t3 isNil						ifTrue: [nil]						ifFalse: [self findElementStack: t2 element: t3]]				ifFalse: [nil]].</body><body package="SpyLite" selector="deleteCache">deleteCache	allClassesAsDictionaryCache := nil.	allMethodsCache := nil.</body><body package="SpyLite" selector="legendSeparationOn:">legendSeparationOn: t1 	(t1 interaction) noPopup; forwarder.	t1 shape label.	t1 node: '---------------------------------------------------------------------------------------------------' forIt: [t1 verticalLineLayout].	</body><body package="SpyLite" selector="setInteractionForMethodSpyOn:">setInteractionForMethodSpyOn: t1 </body><body package="SpyLite" selector="visualizeWithoutNonExecutedClasses">visualizeWithoutNonExecutedClasses</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>accessing</category><body package="SpyLite" selector="packages">packages	^packages ifNil: [packages := OrderedCollection new]</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>time and call graph</category><body package="SpyLite" selector="setIfNecessaryStateChanges">setIfNecessaryStateChanges	| t1 |	self getTimeAndCallGraph ifTrue: [self allMethods do: [:t2 | (t2 numberOfInvocations &gt; 0 and: [t2 performLocalSideEffect])				ifTrue: [(t1 := t2 withAllIncomingCalls asSet) do: [:t3 | t3 performLocalSideEffect: true]]				ifFalse: [nil]]]</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>actions</category><body package="SpyLite" selector="remove">remove	^self class remove</body><body package="SpyLite" selector="removeFromRegistry">removeFromRegistry	self class registry removeKey: (self class registry keyAtValue: self)</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>adding</category><body package="SpyLite" selector="addPackage:">addPackage: t1 	self assert: [t1 class == self class spyClassForPackage].	self packages add: t1.	t1 profiler: self</body><body package="SpyLite" selector="afterBlock:">afterBlock: aBlock	afterBlock := aBlock</body></methods><methods><class-id>Spy1.SLProfiler class</class-id> <category>public - installing removing</category><body package="SpyLite" selector="forClass:">forClass: t1	| t2 t3 t4 |	self installOnClass: t1.	t3 := (t2 := self new) spyForClass: t1.	(t4 := self spyClassForPackage new) classAt: t1 name put: t3.	t3 packageSpy: t4.	t4 packageName: 'Smalltalk'.	t2 addPackage: t4.	^t2</body></methods><methods><class-id>Spy1.SLProfiler class</class-id> <category>gathering</category><body package="SpyLite" selector="allSpysForPackagesMatching:">allSpysForPackagesMatching: t1 	| t2 t3 |	t2 := self classesForPackagesMatching: t1.	t3 := OrderedCollection new.	t2 do: [:t4 | t3 addAll: (t4 methods select: #isSpy)].	^t3</body><body package="SpyLite" selector="classesForPackages:">classesForPackages: t1 	| t2 t3 |	^t3 := (t2 := Store.Registry allPackages select: [:t4 | t1 includes: t4]) inject: #( ) into: [:t5 :t6 | t5 , t6 allClasses]</body><body package="SpyLite" selector="classesForPackagesMatching:">classesForPackagesMatching: t1 	| t2 t3 |	^t3 := ((t2 := Store.Registry allPackages select: [:t4 | t1 match: t4 name asString]) inject: #( ) into: [:t5 :t6 | t5 , t6 allClasses])				collect: [:t7 | t7 myClass]</body><body package="SpyLite" selector="gather">gather	^self new gather</body><body package="SpyLite" selector="gatherForClassCategory:">gatherForClassCategory: t1 	^self new gatherForClassCategory: t1</body><body package="SpyLite" selector="gatherForPackageNamed:">gatherForPackageNamed: t1 	^self new gatherForPackageNamed: t1</body><body package="SpyLite" selector="gatherForPackagesMatching:">gatherForPackagesMatching: t1	^self new gatherForPackagesMatching: t1</body></methods><methods><class-id>Spy1.SLProfiler class</class-id> <category>public - profiling</category><body package="SpyLite" selector="profile:inClassCategories:">profile: t1 inClassCategories: t2	^self		profile: t1		inClassCategories: t2		inNamespace: Smalltalk</body><body package="SpyLite" selector="profile:inClassCategories:inNamespace:">profile: t1 inClassCategories: t2 inNamespace: t3	| t4 |	Transcript show: 'profiling using instrumentation...'; cr.	t4 := self new.		[t4 beforeProfiling.	t4 gatherForClassCategories: t2 inNamespace: t3.	t4 install.	t1 value.	t4 afterProfiling]		ensure: [t4 uninstall].	t4 setIfNecessaryTimeProfiler: t1.	t4 setIfNecessaryTimeAndCallGraphFrom: t1.	t4 setIfNecessaryStateChanges.	t4 checkInvariant.	Transcript show: 'ended!'; cr.	^t4</body><body package="SpyLite" selector="profile:inClassCategoriesMatching:">profile: t1 inClassCategoriesMatching: t2	^self		profile: t1		inClassCategoriesMatching: t2		inNamespace: Smalltalk</body><body package="SpyLite" selector="profile:inClassCategoriesMatching:inNamespace:">profile: t1 inClassCategoriesMatching: t2 inNamespace: t3	| t4 |	t4 := (t4 := t3 organization categories select: [:t5 | t2 match: t5]) collect: [:t6 | t6 asString].	^self		profile: t1		inClassCategories: t4		inNamespace: t3</body><body package="SpyLite" selector="profile:inClassCategory:">profile: t1 inClassCategory: t2 	^self		profile: t1		inClassCategories: (Array with: t2)		inNamespace: Smalltalk</body><body package="SpyLite" selector="profile:inPackage:">profile: t1 inPackage: t2	^self profile: t1 inPackages: (Array with: (Store.Registry packageNamed: t2))</body><body package="SpyLite" selector="profile:inPackages:">profile: t1 inPackages: t2 	| t3 |	Transcript show: 'profiling...'; cr.	t3 := self new.		[t3 beforeProfiling.	t3 gatherForPackages: t2.	t3 install.	t3 beforeProfiling.	t1 value.	t3 afterProfiling]		ensure: [t3 uninstall].	Transcript show: 'ended...'; cr.	t3 setIfNecessaryTimeProfiler: t1.	t3 setIfNecessaryTimeAndCallGraphFrom: t1.	t3 setIfNecessaryStateChanges.	t3 checkInvariant.	^t3</body><body package="SpyLite" selector="profile:inPackagesMatching:">profile: t1 inPackagesMatching: t2	| t3 |	t3 := Store.Registry allPackages select: [:t4 | t2 match: t4 name asString].	^self profile: t1 inPackages: t3</body><body package="SpyLite" selector="profile:inPackagesNames:">profile: t1 inPackagesNames: t2	| t3 |	t3 := Store.Registry allPackages select: [:t4 | t2 includes: t4 name asString].	^self profile: t1 inPackages: t3</body></methods><methods><class-id>Spy1.SLProfiler class</class-id> <category>util</category><body package="SpyLite" selector="classesInCategory:">classesInCategory: t1 	^self classesInCategory: t1 inNamespace: Smalltalk</body><body package="SpyLite" selector="classesInCategory:inNamespace:">classesInCategory: t1 inNamespace: t2	^((t2 organization listAtCategoryNamed: t1 asSymbol)		collect: [:t3 | t2 at: t3])		select: [:t4 | t4 isBehavior]</body><body package="SpyLite" selector="isDangerous:">isDangerous: t1 	| t2 |	(t1 name beginsWith: 'ConfigurationOf')		ifTrue: [^true].	(t1 category beginsWith: 'Spy-ScenarioExample')		ifTrue: [^false].	(#('Spy-Core' 'Announcements' 'Balloon' 'Collections' 'CollectionsTests' 'Compiler' 'CompilerTests' 'Compression' 'DeprecatedPreferences' 'Exceptions' 'Files' 'FixUnderscores' 'FreeType' 'FreeTypeSubPixelAntiAliasing' 'FreeTypeTests' 'Gofer' 'Graphics' 'GraphicsTests' 'HostMenus' 'Kernel' 'KernelTests' 'MCDirtyPackage' 'MenuRegistration' 'Monticello' 'MonticelloConfigurations' 'MonticelloGUI' 'MonticelloMocks' 'Morphic' 'MorphicTests' 'Multilingual' 'MultilingualTests' 'ObjectMetaTools' 'PackageInfo' 'PinesoftEnhancementsForFreetype' 'Polymorph' 'PreferenceBrowser' 'ST80' 'SUnit' 'SUnitGUI' 'ScriptLoader' 'ScriptLoader11' 'Settings' 'System' 'Tests' 'ToolBuilder' 'Tools' 'ToolsTest' 'Traits' 'TrueType' 'VB' ) anySatisfy: [:t3 | t1 category beginsWith: t3])		ifTrue: [^true].	^false</body><body package="SpyLite" selector="isNotDangerous:">isNotDangerous: t1	^(self isDangerous: t1) not</body><body package="SpyLite" selector="log:">log: t1	^self</body><body package="SpyLite" selector="nonDangerousClasses">nonDangerousClasses	^Smalltalk allClasses select: [:t1 | SLProfiler isNotDangerous: t1]</body><body package="SpyLite" selector="nullObject">nullObject	^self new</body><body package="SpyLite" selector="shouldInstallOnClass:">shouldInstallOnClass: t1	| t2 |	self assert: [t1 theNonMetaClass == t1]		description: 'Can only be called on non meta class'.	^self isNotDangerous: t1</body><body package="SpyLite" selector="shouldInstallOnCompiledMethod:">shouldInstallOnCompiledMethod: t1 	^(t1 pragmaAt: #nospy) isNil</body></methods><methods><class-id>Spy1.SLProfiler class</class-id> <category>hooks</category><body package="SpyLite" selector="defaultRun">defaultRun	^#package</body><body package="SpyLite" selector="spyClassForClass">spyClassForClass	^self spyClassForPackage spyClassForClass</body><body package="SpyLite" selector="spyClassForMethod">spyClassForMethod	^self spyClassForPackage spyClassForClass spyClassForMethod</body><body package="SpyLite" selector="spyClassForPackage">spyClassForPackage	^SLPackage</body><body package="SpyLite" selector="testMethodsToIgnore">testMethodsToIgnore	^#(#testNestingOfFormBuilder #testNestedCycle )</body></methods><methods><class-id>Spy1.SLProfiler class</class-id> <category>private - installing</category><body package="SpyLite" selector="install">install	self installOnClasses: Smalltalk allClasses.</body><body package="SpyLite" selector="installOnClass:">installOnClass: t1 	(self isDangerous: t1)		ifTrue: [^self].	^self new spyForClass: t1</body><body package="SpyLite" selector="installOnClassCategory:">installOnClassCategory: t1 	| t2 t3 |	t3 := (t2 := Smalltalk organization listAtCategoryNamed: t1 asSymbol) collect: [:t4 | Smalltalk at: t4].	self installOnClasses: t3</body><body package="SpyLite" selector="installOnClassCategoryMatching:">installOnClassCategoryMatching: t1 	| t2 |	t2 := Smalltalk organization categories select: [:t3 | t3 match: t1].	self removeFromClassCategories: t2.	t2 do: [:t4 | self installOnClassCategory: t4].	</body><body package="SpyLite" selector="installOnClasses:">installOnClasses: t1 	t1 do: [:t2 | self installOnClass: t2].</body><body package="SpyLite" selector="installOnPackagesMatching:">installOnPackagesMatching: t1	| t2 |	(t2 := self classesForPackagesMatching: t1) do: [:t3 | self installOnClass: t3].	</body><body package="SpyLite" selector="installOnPackagesNamed:">installOnPackagesNamed: t1 	| t2 |	self assert: [t1 isString not]		description: 'A collection of String must be passed to #installOnPackagesNamed:'.	self assert: [t1 allSatisfy: #isString]		description: 'A collection of String must be passed to #installOnPackagesNamed:'.	t1 do: [:t3 | (t2 := Smalltalk organization listAtCategoryNamed: t3 classes) do: [:t4 | self installOnClass: t4 theNonMetaClass]]</body><body package="SpyLite" selector="profilerForClass:">profilerForClass: t1 	| t2 t3 t4 t5 |	t4 := Smalltalk at: t1.	t2 := self new.	self installOnClass: t4.	t5 := t2 spyForClass: t4.	(t3 := self spyClassForPackage new) classAt: t1 put: t5.	t2 addPackage: t3.	t5 packageSpy: t3.	^t2</body><body package="SpyLite" selector="remove">remove	self removeFromClasses: Smalltalk allClasses</body><body package="SpyLite" selector="removeFrom:">removeFrom: t1	t1 flushVMmethodCache.	t1 rebindAllMethods</body><body package="SpyLite" selector="removeFromClass:">removeFromClass: t1	SLProfiler class == t1 ifTrue: [^self].	^self removeFrom: t1</body><body package="SpyLite" selector="removeFromClassCategories:">removeFromClassCategories: t1 		| t2 |	t1		do: 			[:t3 | 			t2 := self classesInCategory: t3.			self removeFromClasses: t2 , (t2 collect: [:t4 | t4 class])]</body><body package="SpyLite" selector="removeFromClassCategories:inNamespace:">removeFromClassCategories: t1 inNamespace: t2 	| t3 |	t1		do: 			[:t4 | 			t3 := self classesInCategory: t4 inNamespace: t2.			self removeFromClasses: t3 , (t3 collect: [:t5 | t5 class])]</body><body package="SpyLite" selector="removeFromClassCategoriesMatching:">removeFromClassCategoriesMatching: t1	| t2 |	t2 := Smalltalk organization categories select: [:t3 | t3 match: t1].	self removeFromClassCategories: t2</body><body package="SpyLite" selector="removeFromClassCategoriesMatching:inNamespace:">removeFromClassCategoriesMatching: t1 inNamespace: t2	| t3 |	t3 := t2 organization categories select: [:t4 | t1 match: t4].	self removeFromClassCategories: t3 inNamespace: t2</body><body package="SpyLite" selector="removeFromClassCategory:">removeFromClassCategory: t1	| t2 |	(t2 := OrderedCollection new) add: t1.	self removeFromClassCategories: (Array with: t1)</body><body package="SpyLite" selector="removeFromClasses:">removeFromClasses: t1	^t1 do: [:t2 | self removeFromClass: t2; removeFromClass: t2 class]</body><body package="SpyLite" selector="removeFromPackages:">removeFromPackages: t1	| t2 |	(t2 := self classesForPackages: t1)		do: 			[:t3 | 			t3 myClass flushVMmethodCache.			t3 myClass rebindAllMethods]</body><body package="SpyLite" selector="removeFromPackagesMatching:">removeFromPackagesMatching: t1	| t2 |	(t2 := self classesForPackagesMatching: t1)		do: 			[:t3 | 			t3 flushVMmethodCache.			t3 rebindAllMethods]</body></methods><methods><class-id>Spy1.SLProfiler class</class-id> <category>private - profiling</category><body package="SpyLite" selector="profile:forClassNamed:">profile: t1 forClassNamed: t2 	| t3 t4 t5 t6 |	t6 := Smalltalk at: t2.	t5 := self new.	Transcript show: 'profiling...'; cr.		[t5 beforeProfiling.	t4 := t5 spyForClass: t6.	(t3 := self spyClassForPackage new initialize) classAt: t2 put: t4.	t5 addPackage: t3.	t5 install.	t1 value.	t5 afterProfiling]		ensure: [t5 uninstall].	t5 setIfNecessaryTimeProfiler: t1.	t5 setIfNecessaryTimeAndCallGraphFrom: t1.	Transcript show: 'ended...'; cr.	^t5</body></methods><methods><class-id>Spy1.SLProfilerCoverage</class-id> <category>as yet unclassified</category><body package="SpyLite" selector="calculateExecutedStatementsOf:">calculateExecutedStatementsOf: t1 	"	***This is decompiled code.*** 	No source was available"	| t2 t3 |	t3 := (t2 := (self classAt: t1) allMethods) ifEmpty: [0]				ifNotEmpty: [(t2 collect: #numberOfAllStatements) sum].	^Array with: t3 with: (t2 inject: 0 into: [:t4 :t5 | t4 + t5 numberOfExecutedStatements])</body><body package="SpyLite" selector="statementCoverage">statementCoverageself halt.	self numberOfAllStatements == 0 ifTrue: [^0].	^(100 * self numberOfExecutedStatements / self numberOfAllStatements) asFloat round: 3</body><body package="SpyLite" selector="statementCoverage1">statementCoverage1	^(self calculateExecutedStatementsByClass associations collect: 		[:t1 | 		| t2 |		(t2 := t1 value) first &gt; 0			ifTrue: [t1 key -&gt; ((100 * t2 second / t2 first) asFloat round: 3)]			ifFalse: [t1 key -&gt; 0]]) asDictionary</body><body package="SpyLite" selector="statementCoverageFor:">statementCoverageFor: t1 	"	***This is decompiled code.*** 	No source was available"		[| coverage |	coverage := self calculateExecutedStatementsOf: t1.	^ ((coverage second / coverage first) * 100 asFloat) round: 3]		on: Error do: [^0]</body><body package="SpyLite" selector="updateClass:">updateClass: t1	self packages do: [:t2 | t2 classes at: t1 className			ifPresent: 				[:t3 | 				t1 localMethods do: [:t4 | t4 classSpy: t3].				t1 metaclassSpy localMethods do: [:t5 | t5 classSpy: t3 metaclassSpy].				t3 methods: t1 localMethods.				t3 metaclassSpy methods: t1 metaclassSpy localMethods.				t2 classes at: t1 className put: t3]].	^self</body></methods><methods><class-id>Spy1.SSTypeCollector</class-id> <category>initialization</category><body package="SpyLite" selector="addScalar:">addScalar: t1 	| t2 |	(t2 := scalars at: (self nameOf: t1 class)				ifAbsentPut: [Set new]) add: t1.	t1 isCollection ifTrue: [[t2 add: t1 class new]			on: Error do: [nil]] </body><body package="SpyLite" selector="afterProfiling">afterProfiling	afterBlock value.</body><body package="SpyLite" selector="initialize">initialize	super initialize.	afterBlock := [].	scalars := Dictionary new</body><body package="SpyLite" selector="isScalar:">isScalar: t1 	((self nameOf: t1 class)		includesAll: 'BlockClosure')		ifTrue: [^true].	self allClassesAsDictionary at: (self nameOf: t1 class) asSymbol ifAbsent: [^true].	^false</body><body package="SpyLite" selector="scalars">scalars	^scalars</body></methods><methods><class-id>Spy1.SSTypeCollector class</class-id> <category>hooks</category><body package="SpyLite" selector="profile:inPackages:withAfterBlockProfiling:">profile: t1 inPackages: t2 withAfterBlockProfiling: aBlock	| t3 |	Transcript show: 'profiling...'; cr.	t3 := self new.	t3 afterBlock: aBlock.		[t3 beforeProfiling.	t3 gatherForPackages: t2.	t3 install.	t3 beforeProfiling.	t1 value.	t3 afterProfiling]		ensure: [t3 uninstall].	Transcript show: 'ended...'; cr.	t3 setIfNecessaryTimeProfiler: t1.	t3 setIfNecessaryTimeAndCallGraphFrom: t1.	t3 setIfNecessaryStateChanges.	t3 checkInvariant.	^t3</body><body package="SpyLite" selector="profile:inPackagesMatching:withAfterBlockProfiling:">profile: t1 inPackagesMatching: t2 withAfterBlockProfiling: aBlock 	| t3 |	t3 := Store.Registry allPackages select: [:t4 | t2 match: t4 name asString].	^self profile: t1 inPackages: t3 withAfterBlockProfiling: aBlock </body><body package="SpyLite" selector="profile:onPackagesMatching:">profile: t1 onPackagesMatching: t2 	^self profile: t1 inPackagesMatching: t2</body><body package="SpyLite" selector="spyClassForPackage">spyClassForPackage	^SSTypeCollectorPackage</body><body package="SpyLite" selector="typeNameOf:">typeNameOf: t1 	^t1 name</body></methods><methods><class-id>Spy1.SSTypeCollectorMethod</class-id> <category>hooks</category><body package="SpyLite" selector="returnValue:">returnValue: t1	returnType add: (self nameOf: t1 class).	self checkIfArgIsScalar: t1</body><body package="SpyLite" selector="saveArguments:">saveArguments: t1	t1		doWithIndex: 			[:t2 :t3 | 			[self argTypes at: t3]				on: SubscriptOutOfBoundsError do: [:t4 | self argTypes add: Set new].			(self argTypes at: t3)				add: (self nameOf: t2 class)]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>MethodWrapper</name><environment>Refactory.Wrappers</environment><super>Kernel.CompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>clientMethod selector </inst-vars><class-inst-vars>methods </class-inst-vars><imports></imports><category>Refactory-Method Wrappers</category><attributes><package>Method Wrapper Base</package></attributes></class><class><name>CodeProbe</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.AbstractCodeProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testMethod testSource variables labelString permanent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><class><name>RBProgramNodeVisitor</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class></st-source>