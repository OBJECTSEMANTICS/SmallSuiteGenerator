<?xml version="1.0"?><st-source><!-- Name: SpyLiteBundleName: SpyLiteBundleStructure: a Store.BundleForParcelParcel: #('SpyLite' )ParcelName: SpyLitePrerequisiteParcels: #(#('Method Wrapper Base' '' ) )Date: 4:38:58 am June 8, 2020 --><time-stamp>From VisualWorksÂ®, 7.4 of December 5, 2005 on June 8, 2020 at 4:38:58 am</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Spy1</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>Spy1</category><attributes><package>SpyLite</package></attributes></name-space><class><name>SLProfilerCoverageTest</name><environment>Spy1</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Tests</category><attributes><package>SpyLite</package></attributes></class><comment><class-id>Spy1.SLProfilerCoverageTest</class-id><body>Missing comment</body></comment><class><name>SLCollectorLiteral</name><environment>Spy1</environment><super>Refactory.Browser.RBProgramNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>literals </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite</package></attributes></class><comment><class-id>Spy1.SLCollectorLiteral</class-id><body>Missing comment</body></comment><class><name>SLInstrumentor</name><environment>Spy1</environment><super>Refactory.Browser.RBProgramNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blocks currentId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite</package></attributes></class><class><name>SpyLite</name><environment>Spy1</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>currentTestCase currentTestMethod </class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>SpyLite</package></attributes></class><comment><class-id>Spy1.SpyLite</class-id><body>Missing comment</body></comment><class><name>SLClass</name><environment>Spy1</environment><super>Spy1.SpyLite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methods className allSubclassesCache packageSpy metaclassSpy originalClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>SpyLite</package></attributes></class><comment><class-id>Spy1.SLClass</class-id><body>Missing comment</body></comment><class><name>SLSummaryStatement</name><environment>Smalltalk</environment><super>Spy1.SpyLite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>code executed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Utility</category><attributes><package>SpyLite</package></attributes></class><class><name>SLSummaryExecutionMethod</name><environment>Smalltalk</environment><super>Spy1.SpyLite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>executorClass selector executed code summaryStatements isClassSide hasProfiler returnType argsTypes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Utility</category><attributes><package>SpyLite</package></attributes></class><class><name>SLMethod</name><environment>Spy1</environment><super>Spy1.SpyLite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instrumentedMethod originalMethod selector classSpy spywrapper </inst-vars><class-inst-vars>inMeta </class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>SpyLite</package></attributes></class><comment><class-id>Spy1.SLMethod</class-id><body>Missing comment</body></comment><class><name>SSTypeCollectorClass</name><environment>Spy1</environment><super>Spy1.SLClass</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-TypeCollector</category><attributes><package>SpyLite</package></attributes></class><comment><class-id>Spy1.SSTypeCollectorClass</class-id><body>Missing comment</body></comment><class><name>SLClassCoverage</name><environment>Spy1</environment><super>Spy1.SLClass</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite</package></attributes></class><class><name>SLBlock</name><environment>Spy1</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id executed numberOfStatements start stop code </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite</package></attributes></class><class><name>SLCounter</name><environment>Spy1</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Scenario</category><attributes><package>SpyLite</package></attributes></class><class><name>SSTypeCollectorMethod</name><environment>Spy1</environment><super>Spy1.SLMethod</super><private>false</private><indexed-type>none</indexed-type><inst-vars>returnType argTypes receiverType executed literals numberOfExecutions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-TypeCollector</category><attributes><package>SpyLite</package></attributes></class><comment><class-id>Spy1.SSTypeCollectorMethod</class-id><body>Missing comment</body></comment><class><name>SpyWrapper</name><environment>Spy1</environment><super>Refactory.Wrappers.MethodWrapper</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>count methodSpy previousMethod v originalMethod receiver listOfArguments </inst-vars><class-inst-vars>currentTestCase currentTestMethod </class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>SpyLite</package></attributes></class><comment><class-id>Spy1.SpyWrapper</class-id><body>Missing comment</body></comment><class><name>SLCodeProbe</name><environment>Spy1</environment><super>CraftedSmalltalk.CodeProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SpyLite</package></attributes></class><class><name>SSTypeCollectorMethodTest</name><environment>Spy1</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeCollectorMethod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Tests</category><attributes><package>SpyLite</package></attributes></class><comment><class-id>Spy1.SSTypeCollectorMethodTest</class-id><body>Missing comment</body></comment><class><name>SLMethodCoverage</name><environment>Spy1</environment><super>Spy1.SLMethod</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blocks probedMethod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite</package></attributes></class><class><name>SLProfiler</name><environment>Spy1</environment><super>Spy1.SpyLite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packages allClassesAsDictionaryCache allMethodsCache afterBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>SpyLite</package></attributes></class><comment><class-id>Spy1.SLProfiler</class-id><body>Missing comment</body></comment><class><name>SSTypeCollector</name><environment>Spy1</environment><super>Spy1.SLProfiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scalars </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-TypeCollector</category><attributes><package>SpyLite</package></attributes></class><comment><class-id>Spy1.SSTypeCollector</class-id><body>Missing comment</body></comment><class><name>SLProfilerCoverage</name><environment>Spy1</environment><super>Spy1.SLProfiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeInfo </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite</package></attributes></class><class><name>SLPackage</name><environment>Spy1</environment><super>Spy1.SpyLite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packageName classes profiler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>SpyLite</package></attributes></class><comment><class-id>Spy1.SLPackage</class-id><body>Missing comment</body></comment><class><name>SSTypeCollectorPackage</name><environment>Spy1</environment><super>Spy1.SLPackage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-TypeCollector</category><attributes><package>SpyLite</package></attributes></class><comment><class-id>Spy1.SSTypeCollectorPackage</class-id><body>Missing comment</body></comment><class><name>SLPackageCoverage</name><environment>Spy1</environment><super>Spy1.SLPackage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite</package></attributes></class><shared-variable><name>STypeInfo</name><environment>Spy1.SSTypeCollector</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>SpyLite</package></attributes></shared-variable><shared-variable><name>Registry</name><environment>Spy1.SLProfiler</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>SpyLite</package></attributes></shared-variable><shared-variable><name>CurrentMethod</name><environment>Spy1.SpyWrapper</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>SpyLite</package></attributes></shared-variable><methods><class-id>Spy1.SLProfilerCoverageTest</class-id> <category>as yet unclassified</category><body package="SpyLite" selector="assertStatementCoverageOf:on:equals:">assertStatementCoverageOf: t1 on: t2 equals: t3 	| t4 |	t4 := t1 statementCoverage1.	self assert: (t4 at: t2)		equals: t3.</body><body package="SpyLite" selector="nameOf:">nameOf: t1 	^t1 fullName asSymbol</body></methods><methods><class-id>Spy1.SLProfilerCoverageTest</class-id> <category>running</category><body package="SpyLite" selector="tearDown">tearDown	super tearDown.</body></methods><methods><class-id>Spy1.SLProfilerCoverageTest</class-id> <category>api</category><body package="SpyLite" selector="clean:">clean: t1 	t1 uninstall.</body></methods><methods><class-id>Spy1.SLProfilerCoverageTest</class-id> <category>asserting</category><body package="SpyLite" selector="assert:class:">assert: t1 class: t2 	self assert: t1 class name equals: t2 name.</body><body package="SpyLite" selector="assertNoExecutedMethods:equals:">assertNoExecutedMethods: t1 equals: t2 	self assert: t1 numberOfExecutedMethods equals: t2.</body><body package="SpyLite" selector="assertNumExecutedMethodsOf:on:equals:">assertNumExecutedMethodsOf: t1 on: t2 equals: t3 	| t4 |	t4 := t1 calculateExecutedMethodsByClass.	self assert: (t4 at: t2)		equals: t3.</body><body package="SpyLite" selector="assertNumExecutedStatementsOf:on:equals:">assertNumExecutedStatementsOf: t1 on: t2 equals: t3	| t4 |	t4 := t1 calculateExecutedStatementsByClass.	self assert: (t4 at: t2)		equals: t3.</body></methods><methods><class-id>Spy1.SLProfilerCoverageTest</class-id> <category>tests</category><body package="SpyLite" selector="testMethodCoverage">testMethodCoverage	| t1 t2 |	t1 := SLProfilerCoverage profile: [SLCounter new]				inPackagesMatching: 'SpyLite-Scen*'.	t2 := self nameOf: SLCounter.	self		assertNumExecutedMethodsOf: t1		on: t2		equals: 0.	self		assertMethodCoverageOf: t1		on: t2		equals: 0.	self clean: t1.	t1 := SLProfilerCoverage profile: [SLCounter new one]				inPackagesMatching: 'SpyLite-Scen*'.	self		assertNumExecutedMethodsOf: t1		on: t2		equals: 1.	self		assertMethodCoverageOf: t1		on: t2		equals: ((1 / 7) asFloat * 100 round: 3).	self clean: t1.	t1 := SLProfilerCoverage profile: [SLCounter new anAssignment]				inPackagesMatching: 'SpyLite-Scen*'.	self		assertNumExecutedMethodsOf: t1		on: t2		equals: 1.	self		assertMethodCoverageOf: t1		on: t2		equals: ((1 / 7) asFloat * 100 round: 3).	self clean: t1.	t1 := SLProfilerCoverage profile: [SLCounter new main]				inPackagesMatching: 'SpyLite-Scen*'.	self		assertNumExecutedMethodsOf: t1		on: t2		equals: 2.	self		assertMethodCoverageOf: t1		on: t2		equals: ((2 / 7) asFloat * 100 round: 3).	self clean: t1.	t1 := SLProfilerCoverage profile: [SLCounter new methWithCondition]				inPackagesMatching: 'SpyLite-Scen*'.	self		assertNumExecutedMethodsOf: t1		on: t2		equals: 1.	self		assertMethodCoverageOf: t1		on: t2		equals: ((1 / 7) asFloat * 100 round: 3).	self clean: t1.	t1 := SLProfilerCoverage profile: [SLCounter new methMix]				inPackagesMatching: 'SpyLite-Scen*'.	self		assertNumExecutedMethodsOf: t1		on: t2		equals: 1.	self		assertMethodCoverageOf: t1		on: t2		equals: ((1 / 7) asFloat * 100 round: 3).	self clean: t1.	t1 := SLProfilerCoverage profile: [SLCounter new methWithComposeBlocks]				inPackagesMatching: 'SpyLite-Scen*'.	self		assertNumExecutedMethodsOf: t1		on: t2		equals: 1.	self		assertMethodCoverageOf: t1		on: t2		equals: ((1 / 7) asFloat * 100 round: 3).	self clean: t1.	t1 := SLProfilerCoverage profile: [SLCounter new methWithArguments: #(2 6 8 13 5 9 11 13 )]				inPackagesMatching: 'SpyLite-Scen*'.	self		assertNumExecutedMethodsOf: t1		on: t2		equals: 1.	self		assertMethodCoverageOf: t1		on: t2		equals: ((1 / 7) asFloat * 100 round: 3).	self clean: t1.</body><body package="SpyLite" selector="testProfileOnPackagesMatching">testProfileOnPackagesMatching	| t1 |	t1 := SLProfilerCoverage profile: [SLCounter new]				inPackagesMatching: 'SpyLite-Scen*'.	self assert: t1 class: SLProfilerCoverage.	self		assertMethodCoverageOf: t1		on: (self nameOf: SLCounter)		equals: 0.	self assert: t1 statementCoverage1 isEmpty.	self clean: t1.</body><body package="SpyLite" selector="testStatementCoverage">testStatementCoverage	| t1 t2 |	t1 := SLProfilerCoverage profile: [SLCounter new]				inPackagesMatching: 'SpyLite-Scen*'.	t2 := self nameOf: SLCounter.	self assert: t1 numberOfAllStatements equals: 27.	self assert: t1 statementCoverage1 isEmpty.	self clean: t1.	t1 := SLProfilerCoverage profile: [SLCounter new one]				inPackagesMatching: 'SpyLite-Scen*'.	self		assertNumExecutedStatementsOf: t1		on: t2		equals: 1.	self		assertStatementCoverageOf: t1		on: t2		equals: ((1 / 27) asFloat * 100 round: 3).	self clean: t1.	t1 := SLProfilerCoverage profile: [SLCounter new anAssignment]				inPackagesMatching: 'SpyLite-Scen*'.	self		assertNumExecutedStatementsOf: t1		on: t2		equals: 2.	self		assertStatementCoverageOf: t1		on: t2		equals: ((2 / 27) asFloat * 100 round: 3).	self clean: t1.	t1 := SLProfilerCoverage profile: [SLCounter new main]				inPackagesMatching: 'SpyLite-Scen*'.	self		assertNumExecutedStatementsOf: t1		on: t2		equals: 2.	self		assertStatementCoverageOf: t1		on: t2		equals: ((2 / 27) asFloat * 100 round: 3).	self clean: t1.	t1 := SLProfilerCoverage profile: [SLCounter new methWithCondition]				inPackagesMatching: 'SpyLite-Scen*'.	self		assertNumExecutedStatementsOf: t1		on: t2		equals: 2.	self		assertStatementCoverageOf: t1		on: t2		equals: ((2 / 27) asFloat * 100 round: 3).	self clean: t1.	t1 := SLProfilerCoverage profile: [SLCounter new methMix]				inPackagesMatching: 'SpyLite-Scen*'.	self		assertNumExecutedStatementsOf: t1		on: t2		equals: 5.	self		assertStatementCoverageOf: t1		on: t2		equals: ((5 / 27) asFloat * 100 round: 3).	self clean: t1.	t1 := SLProfilerCoverage profile: [SLCounter new methWithComposeBlocks]				inPackagesMatching: 'SpyLite-Scen*'.	self assert: t1 numberOfExecutedStatements equals: 7.	self		assertStatementCoverageOf: t1		on: t2		equals: ((7 / 27) asFloat * 100 round: 3).	self clean: t1.	t1 := SLProfilerCoverage profile: [SLCounter new methWithArguments: #(2 6 8 13 5 9 11 13 )]				inPackagesMatching: 'SpyLite-Scen*'.	self		assertNumExecutedStatementsOf: t1		on: t2		equals: 6.	self		assertStatementCoverageOf: t1		on: t2		equals: ((6 / 27) asFloat * 100 round: 3).	self clean: t1.	t1 := SLProfilerCoverage profile: [SLCounter new methWithArguments: #(1 4 6 7 )]				inPackagesMatching: 'SpyLite-Scen*'.	self		assertNumExecutedStatementsOf: t1		on: t2		equals: 6.	self		assertStatementCoverageOf: t1		on: t2		equals: ((6 / 27) asFloat * 100 round: 3).	self clean: t1.	t1 := SLProfilerCoverage profile: [SLCounter new methWithArguments: #(4 6 12 )]				inPackagesMatching: 'SpyLite-Scen*'.	self		assertNumExecutedStatementsOf: t1		on: t2		equals: 4.	self		assertStatementCoverageOf: t1		on: t2		equals: ((4 / 27) asFloat * 100 round: 3).	self clean: t1.	^self</body></methods><methods><class-id>Spy1.SLCollectorLiteral</class-id> <category>initialization</category><body package="SpyLite" selector="initialize">initialize	literals := Dictionary new.</body></methods><methods><class-id>Spy1.SLCollectorLiteral</class-id> <category>accessing</category><body package="SpyLite" selector="literals">literals	^literals</body></methods><methods><class-id>Spy1.SLInstrumentor</class-id> <category>initialization</category><body package="SpyLite" selector="initialize">initialize	super initialize.	blocks := OrderedCollection new.</body></methods><methods><class-id>Spy1.SLInstrumentor</class-id> <category>accessing</category><body package="SpyLite" selector="blocks">blocks	^blocks</body></methods><methods><class-id>Spy1.SLInstrumentor</class-id> <category>visiting</category><body package="SpyLite" selector="addBlock:">addBlock: t1 	blocks add: (self buildSBBlock: t1)</body><body package="SpyLite" selector="buildGhostNode:">buildGhostNode: t1 	^Refactory.Browser.RBParser parseExpression: '#metaObject count: ' , t1 asString , '.nil.'</body><body package="SpyLite" selector="instrumentBlock:">instrumentBlock: t1 	self addBlock: t1.	t1 body addNodeFirst: (self buildGhostNode: currentId).</body><body package="SpyLite" selector="nextId">nextId	^currentId := blocks size + 1</body></methods><methods><class-id>Spy1.SpyLite</class-id> <category>visualization</category><body package="SpyLite" selector="fullNameOfClass:">fullNameOfClass: aString	| classes |	classes := Root allClasses select: [:each | aString  = each fullName or: [ (('*.', aString) match: each fullName) ]].	classes ifNotEmpty: [ ^ classes collect: [:cls | cls fullName asSymbol ] ]		ifEmpty: [ self error: 'I cant find the namespace for: ' , aString. ]</body><body package="SpyLite" selector="nameAsString">nameAsString	^'Spy'</body></methods><methods><class-id>Spy1.SpyLite</class-id> <category>initialize-release</category><body package="SpyLite" selector="initialize">initialize</body></methods><methods><class-id>Spy1.SpyLite class</class-id> <category>instance creation</category><body package="SpyLite" selector="new">new	^super new initialize</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>hooks</category><body package="SpyLite" selector="afterEachExecution:On:with:">afterEachExecution: t1 On: t2 with: t3 	^self</body><body package="SpyLite" selector="beforeEachExecution:On:with:">beforeEachExecution: t1 On: t2 with: t3 	^self</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>testing</category><body package="SpyLite" selector="hasMethodNamed:">hasMethodNamed: t1 	^self localMethods includesKey: t1</body><body package="SpyLite" selector="isMeta">isMeta	self halt.	^self className includes: $ </body><body package="SpyLite" selector="isSubclassOf:">isSubclassOf: t1 	self == t1 ifTrue: [^true].	self superclass ifNil: [^false].	^self superclass isSubclassOf: t1</body><body package="SpyLite" selector="understandMethodNamed:">understandMethodNamed: t1	(self hasMethodNamed: t1)		ifTrue: [^true].	self superclass ifNil: [^false].	^self superclass understandMethodNamed: t1</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>printing</category><body package="SpyLite" selector="printOn:">printOn: t1 	t1 nextPut: $&lt;.	t1 nextPutAll: self className printString.	t1 nextPut: $&gt;.</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>accessing-computed</category><body package="SpyLite" selector="&gt;&gt;">&gt;&gt; t1 	^self localMethodAt: t1</body><body package="SpyLite" selector="allMethods">allMethods	^self methods , self metaclassSpy methods</body><body package="SpyLite" selector="allSubclasses">allSubclasses	allSubclassesCache ifNotNil: [^allSubclassesCache].	^allSubclassesCache := self subclasses inject: #( ) into: [:t1 :t2 | t1 , (Array with: t2) , t2 allSubclasses]</body><body package="SpyLite" selector="downwardLookupMethodsNamed:">downwardLookupMethodsNamed: t1 	^(self allSubclasses select: [:t2 | t2 hasMethodNamed: t1])		collect: [:t3 | t3 localMethodAt: t1]</body><body package="SpyLite" selector="localMethodAt:">localMethodAt: t1 	^self localMethods at: t1</body><body package="SpyLite" selector="localMethodAt:ifAbsent:">localMethodAt: t1 ifAbsent: t2 	^self localMethods at: t1 ifAbsent: t2</body><body package="SpyLite" selector="localMethodAt:put:">localMethodAt: t1 put: t2 	^self localMethods at: t1 put: t2</body><body package="SpyLite" selector="lookupMethodNamed:">lookupMethodNamed: t1 	(self hasMethodNamed: t1)		ifTrue: [^self localMethodAt: t1].	^self superclass lookupMethodNamed: t1</body><body package="SpyLite" selector="methods">methods	^methods values</body><body package="SpyLite" selector="methods:">methods: t1 	methods := t1.	^self</body><body package="SpyLite" selector="nonMetaClassName">nonMetaClassName	self halt.	^(self isMeta		ifTrue: [self className copyFrom: 1 to: (self className indexOf: $ )					- 1]		ifFalse: [self className]) asSymbol</body><body package="SpyLite" selector="numberOfAllMethods">numberOfAllMethods	^self allMethods size</body><body package="SpyLite" selector="numberOfMethods">numberOfMethods	^self methods size</body><body package="SpyLite" selector="profiler">profiler	^self package profiler</body><body package="SpyLite" selector="subclasses">subclasses	^self profiler allClassesSuchThat: [:t1 | t1 superclass == self]</body><body package="SpyLite" selector="theNonMetaClass">theNonMetaClass	self isMeta ifFalse: [^self].	^self packageSpy &gt;&gt; self nonMetaClassName</body><body package="SpyLite" selector="withAllSubclasses">withAllSubclasses	^(Array with: self)		, self allSubclasses</body></methods><methods><class-id>Spy1.SLClass class</class-id> <category>hooks</category><body package="SpyLite" selector="spyClassForMethod">spyClassForMethod	^SLMethod</body></methods><methods><class-id>Spy1.SLClass class</class-id> <category>accessing</category><body package="SpyLite" selector="nullObject">nullObject	^self new</body></methods><methods><class-id>SLSummaryStatement</class-id> <category>As yet unclassified</category><body package="SpyLite" selector="=">= t1 	self class = t1 class ifTrue: [^self executed = t1 executed].	^false</body><body package="SpyLite" selector="hash">hash	^executed hash</body><body package="SpyLite" selector="initialize">initialize	code := ''.	executed := false.</body></methods><methods><class-id>SLSummaryStatement</class-id> <category>accessing</category><body package="SpyLite" selector="code">code	^code</body><body package="SpyLite" selector="code:">code: t1 	code := t1.</body><body package="SpyLite" selector="executed">executed	^executed</body><body package="SpyLite" selector="executed:">executed: t1 	executed := t1</body></methods><methods><class-id>SLSummaryStatement class</class-id> <category>As yet unclassified</category><body package="SpyLite" selector="with:and:">with: t1 and: t2 	^(self new) code: t1; executed: t2</body></methods><methods><class-id>SLSummaryExecutionMethod</class-id> <category>As yet unclassified</category><body package="SpyLite" selector="=">= t1 	self class = t1 class		ifTrue: 			[selector = t1 selector				ifTrue: 					[executed = t1 executed						ifTrue: 							[self executorClass = t1 executorClass ifTrue: [^summaryStatements = t1 summaryStatements].							^false].					^false].			^false].	^false</body><body package="SpyLite" selector="allBlocksExecuted">allBlocksExecuted	executed ifTrue: [^summaryStatements allSatisfy: #executed].	^false</body><body package="SpyLite" selector="argsTypes">argsTypes	^argsTypes</body><body package="SpyLite" selector="argsTypes:">argsTypes: t1 	argsTypes := t1.</body><body package="SpyLite" selector="executedBlocks">executedBlocks	^summaryStatements select: #executed</body><body package="SpyLite" selector="hash">hash	^summaryStatements hash</body><body package="SpyLite" selector="initialize">initialize	code := ''.	executed := false.	summaryStatements := OrderedCollection new</body><body package="SpyLite" selector="notAllBlocksExecuted">notAllBlocksExecuted	^self allBlocksExecuted not</body><body package="SpyLite" selector="summaryAsColl">summaryAsColl	^(OrderedCollection new) add: executorClass; add: selector; add: isClassSide; add: executed; add: hasProfiler; add: code; add: (argsTypes ifNil: [#( )]			ifNotNil: [(argsTypes collect: [:t1 | t1 types asArray]) asArray]); add: returnType types asArray; add: (self executedBlocks collect: #code) asArray; add: (self unexecutedBlocks collect: #code) asArray; yourself</body></methods><methods><class-id>SLSummaryExecutionMethod</class-id> <category>accessing</category><body package="SpyLite" selector="code">code	^code</body><body package="SpyLite" selector="code:">code: t1 	code := t1.</body><body package="SpyLite" selector="executed">executed	^executed</body><body package="SpyLite" selector="executed:">executed: t1 	executed := t1.</body><body package="SpyLite" selector="executorClass">executorClass	^executorClass</body><body package="SpyLite" selector="executorClass:">executorClass: t1 	executorClass := t1.	</body><body package="SpyLite" selector="hasProfiler">hasProfiler	^hasProfiler</body><body package="SpyLite" selector="hasProfiler:">hasProfiler: t1 	hasProfiler := t1</body><body package="SpyLite" selector="isClassSide">isClassSide	^isClassSide</body><body package="SpyLite" selector="isClassSide:">isClassSide: t1 	isClassSide := t1</body><body package="SpyLite" selector="returnType">returnType	^returnType</body><body package="SpyLite" selector="returnType:">returnType: t1 	returnType := t1.</body><body package="SpyLite" selector="selector">selector	^selector</body><body package="SpyLite" selector="selector:">selector: t1 	selector := t1.</body><body package="SpyLite" selector="summaryStatements">summaryStatements	^summaryStatements</body><body package="SpyLite" selector="summaryStatements:">summaryStatements: t1 	summaryStatements := t1.</body><body package="SpyLite" selector="unexecuted">unexecuted	^self executed not</body><body package="SpyLite" selector="unexecutedBlocks">unexecutedBlocks	^summaryStatements select: [:t1 | t1 executed not]</body><body package="SpyLite" selector="updateTypeInfoWith:">updateTypeInfoWith: t1 	hasProfiler := t1 hasProfiler.	returnType := t1 returnType.	argsTypes := t1 argTypes.</body><body package="SpyLite" selector="writeDataCSV:withIndex:">writeDataCSV: t1 withIndex: t2 	t1 nextPut: (Array with: t2 withAll: self summaryAsColl)</body></methods><methods><class-id>SLSummaryExecutionMethod class</class-id> <category>As yet unclassified</category><body package="SpyLite" selector="on:">on: t1 	^self</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>testing</category><body package="SpyLite" selector="hasClassSpy">hasClassSpy	^self classSpy notNil</body><body package="SpyLite" selector="hasLiteral:">hasLiteral: t1 	^self originalMethod hasLiteral: t1</body><body package="SpyLite" selector="hasNoIncomingCalls">hasNoIncomingCalls	^self hasIncomingCalls not</body><body package="SpyLite" selector="isClassSide">isClassSide	^self classSpy className endsWith: 'class'</body><body package="SpyLite" selector="isMethodNotExisting">isMethodNotExisting	^self isMethodExisting not</body><body package="SpyLite" selector="isNotAMethodExtension">isNotAMethodExtension	^self originalMethod category first = $*</body><body package="SpyLite" selector="isNotMethodExtension">isNotMethodExtension	^self originalMethod isExtension not</body><body package="SpyLite" selector="isRequired">isRequired	^self originalMethod isRequired</body><body package="SpyLite" selector="isRequired:">isRequired: t1 	^self originalMethod isRequired: t1</body><body package="SpyLite" selector="isSpy">isSpy	^true</body><body package="SpyLite" selector="isUnary">isUnary	^self selector isUnary</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>printing</category><body package="SpyLite" selector="printOn:">printOn: t1 	t1 nextPut: $&lt;.	self classSpy ifNotNil: [t1 nextPutAll: self theClass name asString].	t1 nextPutAll: '&gt;&gt;'.	self selector ifNotNil: [t1 nextPutAll: self selector asString].	t1 nextPut: $&gt;.</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>hooks</category><body package="SpyLite" selector="afterRun:with:in:">afterRun: t1 with: t2 in: t3 	^self</body><body package="SpyLite" selector="beforeRun:with:in:">beforeRun: t1 with: t2 in: t3 	^self</body><body package="SpyLite" selector="flushCache">flushCache	^self</body><body package="SpyLite" selector="returnValue:">returnValue: t1 	^self</body><body package="SpyLite" selector="selector:">selector: t1 	selector := t1.	</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>accessing</category><body package="SpyLite" selector="classSpy">classSpy	^classSpy</body><body package="SpyLite" selector="classSpy:">classSpy: t1 	classSpy := t1.	^self</body><body package="SpyLite" selector="compiledMethod">compiledMethod	^self originalMethod</body><body package="SpyLite" selector="instrumentedMethod">instrumentedMethod	^instrumentedMethod</body><body package="SpyLite" selector="instrumentedMethod:">instrumentedMethod: t1 	instrumentedMethod := t1.</body><body package="SpyLite" selector="selector">selector	^selector</body><body package="SpyLite" selector="spyWrapper">spyWrapper	^spywrapper</body><body package="SpyLite" selector="spyWrapper:">spyWrapper: t1 	spywrapper := t1.</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>accessing-computed</category><body package="SpyLite" selector="package">package	^self classSpy packageSpy</body><body package="SpyLite" selector="profiler">profiler	self package ifNil: [^nil].	^self package profiler</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>delegation</category><body package="SpyLite" selector="=">= t1 	| t2 |	(t1 isKindOf: SLMethod)		ifTrue: [t2 := t1 originalMethod]		ifFalse: [t2 := t1].	^self originalMethod == t2</body><body package="SpyLite" selector="at:">at: t1 	^originalMethod at: t1</body><body package="SpyLite" selector="endPC">endPC	^originalMethod endPC</body><body package="SpyLite" selector="getSourceFor:in:">getSourceFor: t1 in: t2 	^originalMethod getSourceFor: t1 in: t2</body><body package="SpyLite" selector="hasLiteralSuchThat:">hasLiteralSuchThat: t1 	^originalMethod hasLiteralSuchThat: t1</body><body package="SpyLite" selector="initialPC">initialPC	^originalMethod initialPC</body><body package="SpyLite" selector="isConflict">isConflict	^originalMethod isConflict</body><body package="SpyLite" selector="last">last	^originalMethod last</body><body package="SpyLite" selector="literalAt:">literalAt: t1 	^originalMethod literalAt: t1</body><body package="SpyLite" selector="literals">literals	^originalMethod literals</body><body package="SpyLite" selector="methodClass">methodClass	^originalMethod methodClass</body><body package="SpyLite" selector="objectForDataStream:">objectForDataStream: t1 	^originalMethod objectForDataStream: t1</body><body package="SpyLite" selector="pragmas">pragmas	^originalMethod pragmas</body><body package="SpyLite" selector="readDataFrom:size:">readDataFrom: t1 size: t2 	^originalMethod readDataFrom: t1 size: t2</body><body package="SpyLite" selector="refersToLiteral:">refersToLiteral: t1 	^originalMethod refersToLiteral: t1</body><body package="SpyLite" selector="sourcePointer">sourcePointer	^originalMethod sourcePointer</body><body package="SpyLite" selector="storeDataOn:">storeDataOn: t1 	^originalMethod storeDataOn: t1</body><body package="SpyLite" selector="storeOn:">storeOn: t1 	^originalMethod storeOn: t1</body><body package="SpyLite" selector="veryDeepCopyWith:">veryDeepCopyWith: t1 	^originalMethod veryDeepCopyWith: t1</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>contract</category><body package="SpyLite" selector="checkInvariant">checkInvariant	self assert: [selector notNil].	self assert: [selector isKindOf: Symbol].	self assert: [originalMethod isKindOf: CompiledMethod].	self assert: [self profiler notNil].	self assert: [self classSpy notNil].	self assert: [self classSpy profiler == self profiler].	self assert: [self classSpy profiler notNil].	self assert: [self classSpy profiler isKindOf: SLProfiler].</body></methods><methods><class-id>Spy1.SLMethod class</class-id> <category>public</category><body package="SpyLite" selector="isInMeta">isInMeta	^inMeta</body><body package="SpyLite" selector="setInMeta">setInMeta	inMeta := true.</body><body package="SpyLite" selector="setInNonMeta">setInNonMeta	inMeta := false.</body></methods><methods><class-id>Spy1.SLMethod class</class-id> <category>hooks</category><body package="SpyLite" selector="spyClassForMethod">spyClassForMethod	^self</body></methods><methods><class-id>Spy1.SSTypeCollectorClass</class-id> <category>defaults</category><body package="SpyLite" selector="typeName">typeName	^self className</body></methods><methods><class-id>Spy1.SSTypeCollectorClass class</class-id> <category>hooks</category><body package="SpyLite" selector="spyClassForMethod">spyClassForMethod	^SSTypeCollectorMethod</body></methods><methods><class-id>Spy1.SLClassCoverage class</class-id> <category>hooks</category><body package="SpyLite" selector="spyClassForMethod">spyClassForMethod	^SLMethodCoverage</body></methods><methods><class-id>Spy1.SLBlock</class-id> <category>as yet unclassified</category><body package="SpyLite" selector="noExecuted">noExecuted	executed := false.</body></methods><methods><class-id>Spy1.SLBlock</class-id> <category>initialization</category><body package="SpyLite" selector="initialize">initialize	executed := false.	numberOfStatements := 0.	code := ''.</body></methods><methods><class-id>Spy1.SLBlock</class-id> <category>accessing</category><body package="SpyLite" selector="code">code	^code</body><body package="SpyLite" selector="code:">code: t1 	code := t1.</body><body package="SpyLite" selector="id">id	^id</body><body package="SpyLite" selector="id:">id: t1 	id := t1.</body><body package="SpyLite" selector="numberOfStatements">numberOfStatements	^numberOfStatements</body><body package="SpyLite" selector="numberOfStatements:">numberOfStatements: t1 	numberOfStatements := t1</body><body package="SpyLite" selector="start">start	^start</body><body package="SpyLite" selector="start:">start: t1 	start := t1.</body><body package="SpyLite" selector="stop">stop	^stop</body><body package="SpyLite" selector="stop:">stop: t1 	stop := t1.</body><body package="SpyLite" selector="wasExecuted">wasExecuted	^executed</body></methods><methods><class-id>Spy1.SLBlock class</class-id> <category>instance creation</category><body package="SpyLite" selector="new">new	^super new initialize</body></methods><methods><class-id>Spy1.SLCounter</class-id> <category>as yet unclassified</category><body package="SpyLite" selector="anAssignment">anAssignment	| t1 |	^t1 := 3</body><body package="SpyLite" selector="methMix">methMix	| t1 t2 |	(t1 := 2 == 3)		ifTrue: [t2 := 3]		ifFalse: [t2 := 5].	^t2 := t2 + 1</body><body package="SpyLite" selector="methWithArguments:">methWithArguments: t1 	| t2 |	t2 := OrderedCollection new.	t1		detect: [:t3 | t3 odd]		ifFound: [:t4 | t4 &gt; 10				ifTrue: [t2 add: t4]				ifFalse: [t2 add: t4 * 3]]		ifNone: [nil].	^t2</body><body package="SpyLite" selector="methWithComposeBlocks">methWithComposeBlocks	| t1 t2 |	t2 := OrderedCollection new.	(t1 := (Array new: 8)				at: 1 put: 1;				at: 2 put: 4;				at: 3 put: 6;				at: 4 put: 7;				at: 5 put: 8;				at: 6 put: 15;				at: 7 put: 17;				at: 8 put: 16; yourself) select: [:t3 | t3 odd]		thenDo: [:t4 | t4 &gt; 10				ifTrue: [t2 add: t4]				ifFalse: [nil]].	^t2</body><body package="SpyLite" selector="methWithCondition">methWithCondition	2 = 1 ifTrue: [^3].	^4</body></methods><methods><class-id>Spy1.SLCounter</class-id> <category>accessing structure variables</category><body package="SpyLite" selector="one">one	^1</body></methods><methods><class-id>Spy1.SLCounter</class-id> <category>accessing</category><body package="SpyLite" selector="main">main	^self one</body></methods><methods><class-id>Spy1.SSTypeCollectorMethod</class-id> <category>hooks</category><body package="SpyLite" selector="checkIfArgIsScalar:">checkIfArgIsScalar: t1 	(self profiler isScalar: t1)		ifTrue: [self profiler addScalar: t1].</body><body package="SpyLite" selector="initialize">initialize	super initialize.	returnType := Set new.	receiverType := Set new.	argTypes := OrderedCollection new.	executed := false.	literals := Dictionary new.	numberOfExecutions := 0.</body><body package="SpyLite" selector="returnValue:">returnValue: t1	returnType add: (self nameOf: t1 class).	self checkIfArgIsScalar: t1 </body><body package="SpyLite" selector="saveArguments:">saveArguments: t1	t1		doWithIndex: 			[:t2 :t3 | 			[self argTypes at: t3]				on: SubscriptOutOfBoundsError do: [:t4 | self argTypes add: Set new].			(self argTypes at: t3)				add: (self nameOf: t2 class)] </body><body package="SpyLite" selector="saveReceiver:">saveReceiver: t1 	receiverType add: (self nameOf: t1).</body><body package="SpyLite" selector="selectLiteralsOf:">selectLiteralsOf: t1 	| t2 t3 |	t2 := Refactory.Browser.RBParser parseMethod: t1.	t3 := SLCollectorLiteral new.	t2 acceptVisitor: t3.	literals := t3 literals.</body><body package="SpyLite" selector="wasExecuted">wasExecuted	^executed</body></methods><methods><class-id>Spy1.SSTypeCollectorMethod</class-id> <category>testing</category><body package="SpyLite" selector="isDeprecated">isDeprecated	^originalMethod isDeprecated</body><body package="SpyLite" selector="isValidReturnTypeWithReceiver">isValidReturnTypeWithReceiver	^self receiverType = self returnType</body></methods><methods><class-id>Spy1.SSTypeCollectorMethod</class-id> <category>accessing</category><body package="SpyLite" selector="argTypes">argTypes	^argTypes</body><body package="SpyLite" selector="argTypes:">argTypes: t1 	argTypes := t1.</body><body package="SpyLite" selector="dictLiterals">dictLiterals	^literals</body><body package="SpyLite" selector="numberOfExecutions">numberOfExecutions	^numberOfExecutions</body><body package="SpyLite" selector="numberOfExecutions:">numberOfExecutions: t1 	numberOfExecutions := t1.</body><body package="SpyLite" selector="receiverType">receiverType	^receiverType</body><body package="SpyLite" selector="returnType">returnType	^returnType</body></methods><methods><class-id>Spy1.SpyWrapper</class-id> <category>evaluating</category><body package="SpyLite" selector="valueWithReceiver:arguments:">valueWithReceiver: t1 arguments: t2 	| t3 |	^t3 := self methodSpy				run: self selector				with: t2				in: t1</body></methods><methods><class-id>Spy1.SpyWrapper</class-id> <category>initialize-release</category><body package="SpyLite" selector="class:selector:">class: t1 selector: t2 	^super class: t1 selector: t2</body></methods><methods><class-id>Spy1.SpyWrapper</class-id> <category>accessing</category><body package="SpyLite" selector="clientMethod">clientMethod	^clientMethod</body><body package="SpyLite" selector="currentMethod">currentMethod	^self class currentMethod</body><body package="SpyLite" selector="currentMethod:">currentMethod: t1 	self class currentMethod: t1.</body><body package="SpyLite" selector="methodSpy">methodSpy	^methodSpy</body><body package="SpyLite" selector="methodSpy:">methodSpy: t1 	methodSpy := t1.</body><body package="SpyLite" selector="originalMethod">originalMethod	^self unwrappedMethod</body></methods><methods><class-id>Spy1.SpyWrapper</class-id> <category>evaluating-before-after</category><body package="SpyLite" selector="beforeMethod">beforeMethod	^self</body></methods><methods><class-id>Spy1.SpyWrapper class</class-id> <category>global info</category><body package="SpyLite" selector="currentTestMethod">currentTestMethod	^currentTestMethod</body><body package="SpyLite" selector="currentTestMethod:">currentTestMethod: t1 	currentTestMethod := t1</body></methods><methods><class-id>Spy1.SLCodeProbe</class-id> <category>accessing</category><body package="SpyLite" selector="block">block	^block</body><body package="SpyLite" selector="block:">block: t1 	block := t1.</body></methods><methods><class-id>Spy1.SLCodeProbe</class-id> <category>initialize-release</category><body package="SpyLite" selector="actOn:">actOn: t1 	block executed.	</body><body package="SpyLite" selector="initialize">initialize	super initialize.</body></methods><methods><class-id>Spy1.SSTypeCollectorMethodTest</class-id> <category>tests</category><body package="SpyLite" selector="nameOf:">nameOf: t1 	^t1 fullName asSymbol</body><body package="SpyLite" selector="testSelectLiteralsOf">testSelectLiteralsOf	| t1 t2 |	t1 := 'test1     ^ 1    '.	typeCollectorMethod selectLiteralsOf: t1.	t2 := typeCollectorMethod dictLiterals.	self assertCollection: t2 keys hasSameElements: (Array with: (self nameOf: SmallInteger)).	self assertCollection: (t2 values flatCollect: [:t3 | t3])		hasSameElements: #(1 ).	t1 := 'test2        |number string|        number := 2.        string := ''hello''.        number = 5 ifTrue: [string := ''world''].'.	typeCollectorMethod selectLiteralsOf: t1.	t2 := typeCollectorMethod dictLiterals.	self assertCollection: t2 keys hasSameElements: (Array with: (self nameOf: SmallInteger)			with: (self nameOf: ByteString)).	self assertCollection: (t2 values flatCollect: [:t4 | t4])		hasSameElements: #(2 5 'hello' 'world' ).	</body><body package="SpyLite" selector="testSelectLiteralsOfMethodsWithoutLiterals">testSelectLiteralsOfMethodsWithoutLiterals	| t1 |	t1 := 'test1 	^ name	'.	typeCollectorMethod selectLiteralsOf: t1.	self assert: typeCollectorMethod dictLiterals associations isEmpty.	t1 := 'test2		name = nickname ifTrue: [id := age].'.	typeCollectorMethod selectLiteralsOf: t1.	self assert: typeCollectorMethod dictLiterals associations isEmpty.</body></methods><methods><class-id>Spy1.SSTypeCollectorMethodTest</class-id> <category>running</category><body package="SpyLite" selector="setUp">setUp	typeCollectorMethod := SSTypeCollectorMethod new.</body></methods><methods><class-id>Spy1.SLMethodCoverage</class-id> <category>as yet unclassified</category><body package="SpyLite" selector="installGhosts">installGhosts	| t1 |	self originalMethod getSource size &gt; 20000		ifTrue: [self uninstall]		ifFalse: [			[self uninstall.			t1 := Refactory.Browser.RBParser parseMethod: self originalMethod getSource.			blocks := (SLInstrumentor new) visitNode: t1; blocks.			(self originalMethod isKindOf: ProbedCompiledMethod)				ifTrue: [self originalMethod revert].			probedMethod := ProbedCompiledMethod from: self originalMethod full: false.			blocks				do: 					[:t2 | 					| t3 |					(t3 := SLCodeProbe new) record: (probedMethod probeRecordFor: (t2 start to: t2 start)).					t3 block: t2.					probedMethod addProbe: t3].			self theClass methodDictionary at: self selector put: probedMethod]				on: Error				do: 					[:t4 | 					self halt.					self uninstall]].	^self</body><body package="SpyLite" selector="updateStateFirstBlock">updateStateFirstBlock	blocks ifNotEmpty: [blocks first executed].</body></methods><methods><class-id>Spy1.SLMethodCoverage</class-id> <category>initialize-release</category><body package="SpyLite" selector="initialize">initialize	super initialize.	blocks := OrderedCollection new.</body></methods><methods><class-id>Spy1.SLMethodCoverage</class-id> <category>enumerating</category><body package="SpyLite" selector="count:">count: t1 	blocks detect: [:t2 | t2 id = t1]		ifFound: 			[:t3 | 			self updateStateFirstBlock.			t3 executed].</body></methods><methods><class-id>Spy1.SLMethodCoverage</class-id> <category>accessing</category><body package="SpyLite" selector="blocks">blocks	^blocks</body></methods><methods><class-id>Spy1.SLMethodCoverage</class-id> <category>public - metrics</category><body package="SpyLite" selector="numberOfAllStatements">numberOfAllStatements	^self blocks inject: 0 into: [:t1 :t2 | t1 + t2 numberOfStatements]</body><body package="SpyLite" selector="numberOfExecutedStatements">numberOfExecutedStatements	^(self blocks select: #wasExecuted)		inject: 0 into: [:t1 :t2 | t1 + t2 numberOfStatements]</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>util</category><body package="SpyLite" selector="addEvaluatedMethod:fromTally:atLevel:">addEvaluatedMethod: t1 fromTally: t2 atLevel: t3 	t3 = 2		ifTrue: [t1 addAll: t2 receivers]		ifFalse: [t2 receivers size &gt; 0 ifTrue: [self					addEvaluatedMethod: t1					fromTally: (t2 receivers asOrderedCollection at: 1)					atLevel: t3 + 1]].</body><body package="SpyLite" selector="addExecutedMethod:fromTally:">addExecutedMethod: t1 fromTally: t2 	(t2 receivers size &gt; 0 and: [t2 tally / t2 root tally &gt; 0.2])		ifTrue: [t2 receivers				do: 					[:t3 | 					t1 add: t3.					self addExecutedMethod: t1 fromTally: t3]].</body><body package="SpyLite" selector="selectProfiledClassesFrom:">selectProfiledClassesFrom: t1	| t2 t3 |	t3 := self allClasses collect: [:t4 | t4 originalClass].	^t2 := t1 select: [:t5 | t5 method mclass class class isMeta					ifTrue: [t3 includes: t5 method mclass instanceBehavior]					ifFalse: [t3 includes: t5 method mclass]]</body><body package="SpyLite" selector="setTimeInfoFromTally:">setTimeInfoFromTally: t1 	self setTimeInfoFromTally: t1 parents: (Array with: t1)</body><body package="SpyLite" selector="setTimeInfoFromTally:parents:">setTimeInfoFromTally: t1 parents: t2 	| t3 t4 t5 t6 t7 t8 t9 |	(t8 := self classAt: t1 method methodClass name ifNone: [nil]) ifNotNil: [(t3 := t8 localMethodAt: t1 method selector ifAbsent: [nil])			ifNotNilDo: 				[:t10 | 				t3 useTime: t1 parents: t2.				t4 := t2 last.				(t6 := self classAt: t4 method methodClass name ifNone: [nil]) ifNotNil: [(t5 := t6 localMethodAt: t4 method selector ifAbsent: [nil])						ifNotNil: 							[t5 addOutgoingCalls: t3.							t3 addIncomingCalls: t5.							self assert: [t5 outgoingCalls includes: t3]]]]].	t7 := t1 receivers.	t9 := t2 , (Array with: t1).	t7 do: [:t11 | self setTimeInfoFromTally: t11 parents: t9]</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>public-profiling</category><body package="SpyLite" selector="profile:inClassCategories:">profile: t1 inClassCategories: t2	^self		profile: t1		inClassCategories: t2		inNamespace: Smalltalk</body><body package="SpyLite" selector="profile:inClassCategories:inNamespace:">profile: t1 inClassCategories: t2 inNamespace: t3 	Transcript show: 'profiling...'; cr.		[self beforeProfiling.	self gatherForClassCategories: t2 inNamespace: t3.	self install.	t1 value.	self afterProfiling]		ensure: [self class removeFromClassCategories: t2 inNamespace: t3].	Transcript show: 'ended...'; cr.	self setIfNecessaryTimeProfiler: t1.	self setIfNecessaryTimeAndCallGraphFrom: t1.	self setIfNecessaryStateChanges.	self checkInvariant.</body><body package="SpyLite" selector="profile:inClassCategoriesMatching:">profile: t1 inClassCategoriesMatching: t2 	^self		profile: t1		inClassCategoriesMatching: t2		inNamespace: Smalltalk</body><body package="SpyLite" selector="profile:inClassCategoriesMatching:inNamespace:">profile: t1 inClassCategoriesMatching: t2 inNamespace: t3 	| t4 |	t4 := (t4 := t3 organization categories select: [:t5 | t2 match: t5]) collect: [:t6 | t6 asString].	^self		profile: t1		inClassCategories: t4		inNamespace: t3</body><body package="SpyLite" selector="profile:inClassCategory:">profile: t1 inClassCategory: t2 	^self		profile: t1		inClassCategories: (Array with: t2)		inNamespace: Smalltalk</body><body package="SpyLite" selector="profile:inPackage:">profile: t1 inPackage: t2 	^self profile: t1 inPackages: (Array with: (Store.Registry packageNamed: t2))</body><body package="SpyLite" selector="profile:inPackages:">profile: t1 inPackages: t2	Transcript show: 'profiling...'; cr.		[self beforeProfiling.	self gatherForPackages: t2.	self install.	self beforeProfiling.	t1 value.	self afterProfiling]		ensure: [self class removeFromPackages: t2].	Transcript show: 'ended...'; cr.	self setIfNecessaryTimeProfiler: t1.	self setIfNecessaryTimeAndCallGraphFrom: t1.	self setIfNecessaryStateChanges.	self checkInvariant</body><body package="SpyLite" selector="profile:inPackagesMatching:">profile: t1 inPackagesMatching: t2 	| t3 |	t3 := Store.Registry allPackages select: [:t4 | t2 match: t4 name asString].	^self profile: t1 inPackages: t3</body><body package="SpyLite" selector="profile:inPackagesNames:">profile: t1 inPackagesNames: t2	| t3 |	t3 := Store.Registry allPackages select: [:t4 | t2 includes: t4 name asString].	^self profile: t1 inPackages: t3</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>hooks</category><body package="SpyLite" selector="afterProfiling">afterProfiling	^self</body><body package="SpyLite" selector="beforeProfiling">beforeProfiling	SLMethod setInNonMeta</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>gathering</category><body package="SpyLite" selector="gather">gather	^self gatherForClasses: self class nonDangerousClasses</body><body package="SpyLite" selector="gatherForClassCategory:">gatherForClassCategory: t1	| t2 t3 t4 t5 t6 |	(t2 := self packageForClassCategory: t1) packageName: t1.	self addPackage: t2</body><body package="SpyLite" selector="gatherForClasses:">gatherForClasses: t1	| t2 t3 t4 |	(t3 := self class spyClassForPackage new) packageName: 'Global profiling'.	t1		do: 			[:t5 | 			(t2 := self spyForClass: t5) packageSpy: t3.			t3 classAt: t5 name put: t2].	self addPackage: t3.	^t3</body><body package="SpyLite" selector="spyForClass:">spyForClass: t1	| t2 |	(t2 := self class spyClassForClass new initialize) className: (self nameOf: t1).	t2 originalClass: t1.	t2 metaclassSpy initialize.	self fillClassType: t2 with: t1 methodDictionary.	self fillClassType: t2 metaclassSpy with: t1 class methodDictionary.	^t2</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>accessing - read only</category><body package="SpyLite" selector="&gt;&gt;">&gt;&gt; t1 	(t1 includes: $ )		ifTrue: [^(self &gt;&gt; t1 asString sunitSubStrings first asSymbol) metaclassSpy].	^self classAt: t1 </body><body package="SpyLite" selector="allClasses">allClasses	| t1 |	t1 := OrderedCollection new.	self packages do: [:t2 | t1 addAll: t2 classes].	^t1</body><body package="SpyLite" selector="allClassesAsDictionary">allClassesAsDictionary	| t1 |	allClassesAsDictionaryCache ifNotNil: [^allClassesAsDictionaryCache].	t1 := Dictionary new.	self packages do: [:t2 | t2 classes do: [:t3 | t1 at: t3 className put: t3]].	^allClassesAsDictionaryCache := t1</body><body package="SpyLite" selector="allClassesSuchThat:">allClassesSuchThat: t1 	^self allClasses select: t1</body><body package="SpyLite" selector="allNonMetaClasses">allNonMetaClasses	^self allClasses reject: #isMeta</body><body package="SpyLite" selector="classAt:">classAt: t1 	^self allClassesAsDictionary at: t1 ifAbsent: [self error: 'Class ' , t1 , ' not found']</body><body package="SpyLite" selector="classAt:ifNone:">classAt: t1 ifNone: t2 	^self allClassesAsDictionary at: t1 ifAbsent: t2</body><body package="SpyLite" selector="includesClassNamed:">includesClassNamed: t1	self classAt: t1 asSymbol ifNone: [^false].	^true</body><body package="SpyLite" selector="numberOfClasses">numberOfClasses	^self allClasses size</body><body package="SpyLite" selector="numberOfMethods">numberOfMethods	^self allMethods size</body><body package="SpyLite" selector="numberOfNonAbstractMethods">numberOfNonAbstractMethods	^self allNonAbstractMethods size</body><body package="SpyLite" selector="numberOfPackages">numberOfPackages	^self packages size</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>private-profiling</category><body package="SpyLite" selector="profile:forClassNamed:">profile: t1 forClassNamed: t2	| t3 t4 t5 |	t5 := Smalltalk at: t2.	Transcript show: 'profiling...'; cr.		[self beforeProfiling.	t4 := self spyForClass: t5.	(t3 := self class spyClassForPackage new initialize) classAt: t2 put: t4.	self addPackage: t3.	self install.	t1 value.	self afterProfiling]		ensure: [self class removeFromClass: t5].	Transcript show: 'ended...'; cr.	self setIfNecessaryTimeProfiler: t1.	self setIfNecessaryTimeAndCallGraphFrom: t1</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>initialize-release</category><body package="SpyLite" selector="initialize">initialize	packages := nil</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>visualization-util</category><body package="SpyLite" selector="nameAsString">nameAsString	^'Profiler'</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>installing</category><body package="SpyLite" selector="install">install	self allMethods asSet do: [:t1 | t1 install]</body><body package="SpyLite" selector="uninstall">uninstall	self allMethods do: #uninstall</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>visualization</category><body package="SpyLite" selector="addFindClassMenuOn:">addFindClassMenuOn: t1	t1 addMenu: 'Find a Class...'		callBack: 			[:t2 | 			| t3 t4 t5 t6 t7 t8 |			t5 := SortedCollection sortBlock: [:t9 :t10 | t9 key printString &lt; t9 key printString].			t6 := OrderedCollection new.			t7 := OrderedCollection new.			self allClasses do: [:t11 | t5 add: t11 originalClass -&gt; t11].			t5				do: 					[:t12 | 					t6 add: t12 key.					t7 add: t12 value].			(t8 := Refactory.Browser.BrowserApplicationModel new						choose: 'Find a class'						fromList: t6						values: t7						lines: 20						cancel: [nil]) isNil not				ifTrue: 					[| t13 |					t13 := nil.					t3 := nil.					t1 raw elementsDo: [:t14 | t13 isNil							ifTrue: 								[(t13 := t1 nestedLookup: t8 in: t14) isNil ifFalse: [t13 elementsDo: [:t15 | t3 isNil											ifTrue: [t3 := t1 nestedLookup: t8 in: t15]											ifFalse: [nil]]].								t4 := t14]							ifFalse: [nil]].					t3 isNil						ifTrue: [nil]						ifFalse: [self findElementStack: t2 element: t3]]]</body><body package="SpyLite" selector="addFindMethodMenuOn:">addFindMethodMenuOn: t1 	t1 addMenu: 'Find a Method...'		callBack: 			[:t2 | 			| t3 t4 t5 t6 t7 t8 |			t5 := SortedCollection sortBlock: [:t9 :t10 | t9 &lt; t9].			t6 := OrderedCollection new.			t7 := OrderedCollection new.			self allMethods do: [:t11 | t5 add: t11 printString -&gt; t11].			t5				do: 					[:t12 | 					t6 add: t12 key.					t7 add: t12 value].			(t8 := Refactory.Browser.BrowserApplicationModel new						choose: 'Find a class'						fromList: t6						values: t7						lines: 20						cancel: [nil]) isNil not				ifTrue: 					[t3 := nil.					t1 raw elementsDo: [:t13 | t3 isNil							ifTrue: 								[t3 := t1 nestedLookup: t8 in: t13.								t4 := t13]							ifFalse: [nil]].					t3 isNil						ifTrue: [nil]						ifFalse: [self findElementStack: t2 element: t3]]				ifFalse: [nil]].</body><body package="SpyLite" selector="deleteCache">deleteCache	allClassesAsDictionaryCache := nil.	allMethodsCache := nil.</body><body package="SpyLite" selector="legendSeparationOn:">legendSeparationOn: t1 	(t1 interaction) noPopup; forwarder.	t1 shape label.	t1 node: '---------------------------------------------------------------------------------------------------' forIt: [t1 verticalLineLayout].	</body><body package="SpyLite" selector="setInteractionForMethodSpyOn:">setInteractionForMethodSpyOn: t1 </body><body package="SpyLite" selector="visualizeWithoutNonExecutedClasses">visualizeWithoutNonExecutedClasses</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>accessing</category><body package="SpyLite" selector="packages">packages	^packages ifNil: [packages := OrderedCollection new]</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>time and call graph</category><body package="SpyLite" selector="setIfNecessaryStateChanges">setIfNecessaryStateChanges	| t1 |	self getTimeAndCallGraph ifTrue: [self allMethods do: [:t2 | (t2 numberOfInvocations &gt; 0 and: [t2 performLocalSideEffect])				ifTrue: [(t1 := t2 withAllIncomingCalls asSet) do: [:t3 | t3 performLocalSideEffect: true]]				ifFalse: [nil]]]</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>actions</category><body package="SpyLite" selector="remove">remove	^self class remove</body><body package="SpyLite" selector="removeFromRegistry">removeFromRegistry	self class registry removeKey: (self class registry keyAtValue: self)</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>adding</category><body package="SpyLite" selector="addPackage:">addPackage: t1 	self assert: [t1 class == self class spyClassForPackage].	self packages add: t1.	t1 profiler: self</body><body package="SpyLite" selector="afterBlock:">afterBlock: aBlock	afterBlock := aBlock</body></methods><methods><class-id>Spy1.SLProfiler class</class-id> <category>public - installing removing</category><body package="SpyLite" selector="forClass:">forClass: t1	| t2 t3 t4 |	self installOnClass: t1.	t3 := (t2 := self new) spyForClass: t1.	(t4 := self spyClassForPackage new) classAt: t1 name put: t3.	t3 packageSpy: t4.	t4 packageName: 'Smalltalk'.	t2 addPackage: t4.	^t2</body></methods><methods><class-id>Spy1.SLProfiler class</class-id> <category>gathering</category><body package="SpyLite" selector="allSpysForPackagesMatching:">allSpysForPackagesMatching: t1 	| t2 t3 |	t2 := self classesForPackagesMatching: t1.	t3 := OrderedCollection new.	t2 do: [:t4 | t3 addAll: (t4 methods select: #isSpy)].	^t3</body><body package="SpyLite" selector="classesForPackages:">classesForPackages: t1 	| t2 t3 |	^t3 := (t2 := Store.Registry allPackages select: [:t4 | t1 includes: t4]) inject: #( ) into: [:t5 :t6 | t5 , t6 allClasses]</body><body package="SpyLite" selector="classesForPackagesMatching:">classesForPackagesMatching: t1 	| t2 t3 |	^t3 := ((t2 := Store.Registry allPackages select: [:t4 | t1 match: t4 name asString]) inject: #( ) into: [:t5 :t6 | t5 , t6 allClasses])				collect: [:t7 | t7 myClass]</body><body package="SpyLite" selector="gather">gather	^self new gather</body><body package="SpyLite" selector="gatherForClassCategory:">gatherForClassCategory: t1 	^self new gatherForClassCategory: t1</body><body package="SpyLite" selector="gatherForPackageNamed:">gatherForPackageNamed: t1 	^self new gatherForPackageNamed: t1</body><body package="SpyLite" selector="gatherForPackagesMatching:">gatherForPackagesMatching: t1	^self new gatherForPackagesMatching: t1</body></methods><methods><class-id>Spy1.SLProfiler class</class-id> <category>public - profiling</category><body package="SpyLite" selector="profile:inClassCategories:">profile: t1 inClassCategories: t2	^self		profile: t1		inClassCategories: t2		inNamespace: Smalltalk</body><body package="SpyLite" selector="profile:inClassCategories:inNamespace:">profile: t1 inClassCategories: t2 inNamespace: t3	| t4 |	Transcript show: 'profiling using instrumentation...'; cr.	t4 := self new.		[t4 beforeProfiling.	t4 gatherForClassCategories: t2 inNamespace: t3.	t4 install.	t1 value.	t4 afterProfiling]		ensure: [t4 uninstall].	t4 setIfNecessaryTimeProfiler: t1.	t4 setIfNecessaryTimeAndCallGraphFrom: t1.	t4 setIfNecessaryStateChanges.	t4 checkInvariant.	Transcript show: 'ended!'; cr.	^t4</body><body package="SpyLite" selector="profile:inClassCategoriesMatching:">profile: t1 inClassCategoriesMatching: t2	^self		profile: t1		inClassCategoriesMatching: t2		inNamespace: Smalltalk</body><body package="SpyLite" selector="profile:inClassCategoriesMatching:inNamespace:">profile: t1 inClassCategoriesMatching: t2 inNamespace: t3	| t4 |	t4 := (t4 := t3 organization categories select: [:t5 | t2 match: t5]) collect: [:t6 | t6 asString].	^self		profile: t1		inClassCategories: t4		inNamespace: t3</body><body package="SpyLite" selector="profile:inClassCategory:">profile: t1 inClassCategory: t2 	^self		profile: t1		inClassCategories: (Array with: t2)		inNamespace: Smalltalk</body><body package="SpyLite" selector="profile:inPackage:">profile: t1 inPackage: t2	^self profile: t1 inPackages: (Array with: (Store.Registry packageNamed: t2))</body><body package="SpyLite" selector="profile:inPackages:">profile: t1 inPackages: t2 	| t3 |	Transcript show: 'profiling...'; cr.	t3 := self new.		[t3 beforeProfiling.	t3 gatherForPackages: t2.	t3 install.	t3 beforeProfiling.	t1 value.	t3 afterProfiling]		ensure: [t3 uninstall].	Transcript show: 'ended...'; cr.	t3 setIfNecessaryTimeProfiler: t1.	t3 setIfNecessaryTimeAndCallGraphFrom: t1.	t3 setIfNecessaryStateChanges.	t3 checkInvariant.	^t3</body><body package="SpyLite" selector="profile:inPackagesMatching:">profile: t1 inPackagesMatching: t2	| t3 |	t3 := Store.Registry allPackages select: [:t4 | t2 match: t4 name asString].	^self profile: t1 inPackages: t3</body><body package="SpyLite" selector="profile:inPackagesNames:">profile: t1 inPackagesNames: t2	| t3 |	t3 := Store.Registry allPackages select: [:t4 | t2 includes: t4 name asString].	^self profile: t1 inPackages: t3</body></methods><methods><class-id>Spy1.SLProfiler class</class-id> <category>util</category><body package="SpyLite" selector="classesInCategory:">classesInCategory: t1 	^self classesInCategory: t1 inNamespace: Smalltalk</body><body package="SpyLite" selector="classesInCategory:inNamespace:">classesInCategory: t1 inNamespace: t2	^((t2 organization listAtCategoryNamed: t1 asSymbol)		collect: [:t3 | t2 at: t3])		select: [:t4 | t4 isBehavior]</body><body package="SpyLite" selector="isDangerous:">isDangerous: t1 	| t2 |	(t1 name beginsWith: 'ConfigurationOf')		ifTrue: [^true].	(t1 category beginsWith: 'Spy-ScenarioExample')		ifTrue: [^false].	(#('Spy-Core' 'Announcements' 'Balloon' 'Collections' 'CollectionsTests' 'Compiler' 'CompilerTests' 'Compression' 'DeprecatedPreferences' 'Exceptions' 'Files' 'FixUnderscores' 'FreeType' 'FreeTypeSubPixelAntiAliasing' 'FreeTypeTests' 'Gofer' 'Graphics' 'GraphicsTests' 'HostMenus' 'Kernel' 'KernelTests' 'MCDirtyPackage' 'MenuRegistration' 'Monticello' 'MonticelloConfigurations' 'MonticelloGUI' 'MonticelloMocks' 'Morphic' 'MorphicTests' 'Multilingual' 'MultilingualTests' 'ObjectMetaTools' 'PackageInfo' 'PinesoftEnhancementsForFreetype' 'Polymorph' 'PreferenceBrowser' 'ST80' 'SUnit' 'SUnitGUI' 'ScriptLoader' 'ScriptLoader11' 'Settings' 'System' 'Tests' 'ToolBuilder' 'Tools' 'ToolsTest' 'Traits' 'TrueType' 'VB' ) anySatisfy: [:t3 | t1 category beginsWith: t3])		ifTrue: [^true].	^false</body><body package="SpyLite" selector="isNotDangerous:">isNotDangerous: t1	^(self isDangerous: t1) not</body><body package="SpyLite" selector="log:">log: t1	^self</body><body package="SpyLite" selector="nonDangerousClasses">nonDangerousClasses	^Smalltalk allClasses select: [:t1 | SLProfiler isNotDangerous: t1]</body><body package="SpyLite" selector="nullObject">nullObject	^self new</body><body package="SpyLite" selector="shouldInstallOnClass:">shouldInstallOnClass: t1	| t2 |	self assert: [t1 theNonMetaClass == t1]		description: 'Can only be called on non meta class'.	^self isNotDangerous: t1</body><body package="SpyLite" selector="shouldInstallOnCompiledMethod:">shouldInstallOnCompiledMethod: t1 	^(t1 pragmaAt: #nospy) isNil</body></methods><methods><class-id>Spy1.SLProfiler class</class-id> <category>hooks</category><body package="SpyLite" selector="defaultRun">defaultRun	^#package</body><body package="SpyLite" selector="spyClassForClass">spyClassForClass	^self spyClassForPackage spyClassForClass</body><body package="SpyLite" selector="spyClassForMethod">spyClassForMethod	^self spyClassForPackage spyClassForClass spyClassForMethod</body><body package="SpyLite" selector="spyClassForPackage">spyClassForPackage	^SLPackage</body><body package="SpyLite" selector="testMethodsToIgnore">testMethodsToIgnore	^#(#testNestingOfFormBuilder #testNestedCycle )</body></methods><methods><class-id>Spy1.SLProfiler class</class-id> <category>private - installing</category><body package="SpyLite" selector="install">install	self installOnClasses: Smalltalk allClasses.</body><body package="SpyLite" selector="installOnBehavior:">installOnBehavior: t1 	| t2 t3 t4 t5 |	t1 flushCache.	t1 isTrait ifTrue: [^self].	(t5 := t1 methodDictionary) keys		do: 			[:t6 | 			t6 flushCache.			(t2 := t5 at: t6) isSpy				ifTrue: [nil]				ifFalse: 					[t3 := (t3 := self templateMethodForNumberOfArguments: t2 numArgs) copyFor: t1.					t4 := (self spyClassForMethod new) originalMethod: t2; selector: t6; instrumentedMethod: t3; yourself.					t3						replaceLiterals: (Array								with: t3 selector -&gt; t6								with: #metaObject -&gt; t4								with: #selector -&gt; t6) dict						at: t6						put: t3]].	^self</body><body package="SpyLite" selector="installOnClass:">installOnClass: t1 	(self isDangerous: t1)		ifTrue: [^self].	^self new spyForClass: t1</body><body package="SpyLite" selector="installOnClassCategory:">installOnClassCategory: t1 	| t2 t3 |	t3 := (t2 := Smalltalk organization listAtCategoryNamed: t1 asSymbol) collect: [:t4 | Smalltalk at: t4].	self installOnClasses: t3</body><body package="SpyLite" selector="installOnClassCategoryMatching:">installOnClassCategoryMatching: t1 	| t2 |	t2 := Smalltalk organization categories select: [:t3 | t3 match: t1].	self removeFromClassCategories: t2.	t2 do: [:t4 | self installOnClassCategory: t4].	</body><body package="SpyLite" selector="installOnClasses:">installOnClasses: t1 	t1 do: [:t2 | self installOnClass: t2].</body><body package="SpyLite" selector="installOnPackagesMatching:">installOnPackagesMatching: t1	| t2 |	(t2 := self classesForPackagesMatching: t1) do: [:t3 | self installOnClass: t3].	</body><body package="SpyLite" selector="installOnPackagesNamed:">installOnPackagesNamed: t1 	| t2 |	self assert: [t1 isString not]		description: 'A collection of String must be passed to #installOnPackagesNamed:'.	self assert: [t1 allSatisfy: #isString]		description: 'A collection of String must be passed to #installOnPackagesNamed:'.	t1 do: [:t3 | (t2 := Smalltalk organization listAtCategoryNamed: t3 classes) do: [:t4 | self installOnClass: t4 theNonMetaClass]]</body><body package="SpyLite" selector="profilerForClass:">profilerForClass: t1 	| t2 t3 t4 t5 |	t4 := Smalltalk at: t1.	t2 := self new.	self installOnClass: t4.	t5 := t2 spyForClass: t4.	(t3 := self spyClassForPackage new) classAt: t1 put: t5.	t2 addPackage: t3.	t5 packageSpy: t3.	^t2</body><body package="SpyLite" selector="remove">remove	self removeFromClasses: Smalltalk allClasses</body><body package="SpyLite" selector="removeFrom:">removeFrom: t1	t1 flushVMmethodCache.	t1 rebindAllMethods</body><body package="SpyLite" selector="removeFromClass:">removeFromClass: t1	SLProfiler class == t1 ifTrue: [^self].	^self removeFrom: t1</body><body package="SpyLite" selector="removeFromClassCategories:">removeFromClassCategories: t1 		| t2 |	t1		do: 			[:t3 | 			t2 := self classesInCategory: t3.			self removeFromClasses: t2 , (t2 collect: [:t4 | t4 class])]</body><body package="SpyLite" selector="removeFromClassCategories:inNamespace:">removeFromClassCategories: t1 inNamespace: t2 	| t3 |	t1		do: 			[:t4 | 			t3 := self classesInCategory: t4 inNamespace: t2.			self removeFromClasses: t3 , (t3 collect: [:t5 | t5 class])]</body><body package="SpyLite" selector="removeFromClassCategoriesMatching:">removeFromClassCategoriesMatching: t1	| t2 |	t2 := Smalltalk organization categories select: [:t3 | t3 match: t1].	self removeFromClassCategories: t2</body><body package="SpyLite" selector="removeFromClassCategoriesMatching:inNamespace:">removeFromClassCategoriesMatching: t1 inNamespace: t2	| t3 |	t3 := t2 organization categories select: [:t4 | t1 match: t4].	self removeFromClassCategories: t3 inNamespace: t2</body><body package="SpyLite" selector="removeFromClassCategory:">removeFromClassCategory: t1	| t2 |	(t2 := OrderedCollection new) add: t1.	self removeFromClassCategories: (Array with: t1)</body><body package="SpyLite" selector="removeFromClasses:">removeFromClasses: t1	^t1 do: [:t2 | self removeFromClass: t2; removeFromClass: t2 class]</body><body package="SpyLite" selector="removeFromPackages:">removeFromPackages: t1	| t2 |	(t2 := self classesForPackages: t1)		do: 			[:t3 | 			t3 myClass flushVMmethodCache.			t3 myClass rebindAllMethods]</body><body package="SpyLite" selector="removeFromPackagesMatching:">removeFromPackagesMatching: t1	| t2 |	(t2 := self classesForPackagesMatching: t1)		do: 			[:t3 | 			t3 flushVMmethodCache.			t3 rebindAllMethods]</body></methods><methods><class-id>Spy1.SLProfiler class</class-id> <category>private - profiling</category><body package="SpyLite" selector="profile:forClassNamed:">profile: t1 forClassNamed: t2 	| t3 t4 t5 t6 |	t6 := Smalltalk at: t2.	t5 := self new.	Transcript show: 'profiling...'; cr.		[t5 beforeProfiling.	t4 := t5 spyForClass: t6.	(t3 := self spyClassForPackage new initialize) classAt: t2 put: t4.	t5 addPackage: t3.	t5 install.	t1 value.	t5 afterProfiling]		ensure: [t5 uninstall].	t5 setIfNecessaryTimeProfiler: t1.	t5 setIfNecessaryTimeAndCallGraphFrom: t1.	Transcript show: 'ended...'; cr.	^t5</body></methods><methods><class-id>Spy1.SSTypeCollector</class-id> <category>initialization</category><body package="SpyLite" selector="addScalar:">addScalar: t1 	| t2 |	(t2 := scalars at: (self nameOf: t1 class)				ifAbsentPut: [Set new]) add: t1.	t1 isCollection ifTrue: [[t2 add: t1 class new]			on: Error do: [nil]] </body><body package="SpyLite" selector="afterProfiling">afterProfiling	afterBlock value.</body><body package="SpyLite" selector="initialize">initialize	super initialize.	afterBlock := [].	scalars := Dictionary new</body><body package="SpyLite" selector="isScalar:">isScalar: t1 	((self nameOf: t1 class)		includesAll: 'BlockClosure')		ifTrue: [^true].	self allClassesAsDictionary at: (self nameOf: t1 class) asSymbol ifAbsent: [^true].	^false</body><body package="SpyLite" selector="scalars">scalars	^scalars</body></methods><methods><class-id>Spy1.SSTypeCollector class</class-id> <category>hooks</category><body package="SpyLite" selector="profile:inPackages:withAfterBlockProfiling:">profile: t1 inPackages: t2 withAfterBlockProfiling: aBlock	| t3 |	Transcript show: 'profiling...'; cr.	t3 := self new.	t3 afterBlock: aBlock.		[t3 beforeProfiling.	t3 gatherForPackages: t2.	t3 install.	t3 beforeProfiling.	t1 value.	t3 afterProfiling]		ensure: [t3 uninstall].	Transcript show: 'ended...'; cr.	t3 setIfNecessaryTimeProfiler: t1.	t3 setIfNecessaryTimeAndCallGraphFrom: t1.	t3 setIfNecessaryStateChanges.	t3 checkInvariant.	^t3</body><body package="SpyLite" selector="profile:inPackagesMatching:withAfterBlockProfiling:">profile: t1 inPackagesMatching: t2 withAfterBlockProfiling: aBlock 	| t3 |	t3 := Store.Registry allPackages select: [:t4 | t2 match: t4 name asString].	^self profile: t1 inPackages: t3 withAfterBlockProfiling: aBlock </body><body package="SpyLite" selector="profile:onPackagesMatching:">profile: t1 onPackagesMatching: t2 	^self profile: t1 inPackagesMatching: t2</body><body package="SpyLite" selector="spyClassForPackage">spyClassForPackage	^SSTypeCollectorPackage</body><body package="SpyLite" selector="typeNameOf:">typeNameOf: t1 	^t1 name</body></methods><methods><class-id>Spy1.SLProfilerCoverage</class-id> <category>hooks</category><body package="SpyLite" selector="beforeProfiling">beforeProfiling	self allMethods select: #isNotMethodExtension thenDo: #installGhosts</body></methods><methods><class-id>Spy1.SLProfilerCoverage</class-id> <category>as yet unclassified</category><body package="SpyLite" selector="calculateExecutedStatementsOf:">calculateExecutedStatementsOf: t1 	| t2 t3 |	t3 := (t2 := (self classAt: t1) allMethods) ifEmpty: [0]				ifNotEmpty: [(t2 collect: #numberOfAllStatements) sum].	^Array with: t3 with: (t2 inject: 0 into: [:t4 :t5 | t4 + t5 numberOfExecutedStatements])</body><body package="SpyLite" selector="cleanBlocksOfMethods">cleanBlocksOfMethods	self allMethods do: [:t1 | t1 blocks do: [:t2 | t2 noExecuted]]</body><body package="SpyLite" selector="methodCoverage">methodCoverage	| t1 |	(t1 := self allMethods) isEmpty ifTrue: [^0].	^(100 * self numberOfExecutedMethods / t1 size) asFloat round: 3</body><body package="SpyLite" selector="methodCoverage1">methodCoverage1	^(self calculateExecutedMethodsByClass associations		collect: 			[:t1 | 			| t2 t3 |			t2 := t1 key.			(t3 := t1 value) first &gt; 0				ifTrue: [t2 -&gt; ((100 * t3 second / t3 first) asFloat round: 3)]				ifFalse: [t2 -&gt; 0]]) asDictionary</body><body package="SpyLite" selector="numberOfAllStatements">numberOfAllStatements	^self allMethods inject: 0 into: [:t1 :t2 | t1 + t2 numberOfAllStatements]</body><body package="SpyLite" selector="numberOfExecutedMethods">numberOfExecutedMethods	^(self selectExecutedMethods: self allMethods) size</body><body package="SpyLite" selector="numberOfExecutedStatements">numberOfExecutedStatements	^self allMethods inject: 0 into: [:t1 :t2 | t1 + t2 numberOfExecutedStatements]</body><body package="SpyLite" selector="selectExecutedMethods:">selectExecutedMethods: t1 	^(t1 select: [:t2 | t2 blocks isNotEmpty])		select: [:t3 | t3 blocks first wasExecuted]</body><body package="SpyLite" selector="statementCoverage">statementCoverageself halt.	self numberOfAllStatements == 0 ifTrue: [^0].	^(100 * self numberOfExecutedStatements / self numberOfAllStatements) asFloat round: 3</body><body package="SpyLite" selector="statementCoverage1">statementCoverage1	^(self calculateExecutedStatementsByClass associations collect: 		[:t1 | 		| t2 |		(t2 := t1 value) first &gt; 0			ifTrue: [t1 key -&gt; ((100 * t2 second / t2 first) asFloat round: 3)]			ifFalse: [t1 key -&gt; 0]]) asDictionary</body><body package="SpyLite" selector="statementCoverageFor:">statementCoverageFor: t1 		[| coverage |	coverage := self calculateExecutedStatementsOf: t1.	^ ((coverage second / coverage first) * 100 asFloat) round: 3]		on: Error do: [^0]</body><body package="SpyLite" selector="summaryExecutedCode">summaryExecutedCode	^((self selectExecutedMethods: self allMethods)		collect: [:t1 | t1 classSpy className -&gt; t1 selector -&gt; (t1 blocks collect: [:t2 | Array with: t2 wasExecuted with: t2 code])]) asDictionary</body><body package="SpyLite" selector="summaryExecutionMethods">summaryExecutionMethods	^self</body><body package="SpyLite" selector="summaryMethodsOf:">summaryMethodsOf: t1 	^self</body><body package="SpyLite" selector="typeInfo">typeInfo	^typeInfo</body><body package="SpyLite" selector="typeInfo:">typeInfo: t1 	typeInfo := t1.</body><body package="SpyLite" selector="updateClass:">updateClass: t1	self packages do: [:t2 | t2 classes at: t1 className			ifPresent: 				[:t3 | 				t1 localMethods do: [:t4 | t4 classSpy: t3].				t1 metaclassSpy localMethods do: [:t5 | t5 classSpy: t3 metaclassSpy].				t3 methods: t1 localMethods.				t3 metaclassSpy methods: t1 metaclassSpy localMethods.				t2 classes at: t1 className put: t3]].</body></methods><methods><class-id>Spy1.SLProfilerCoverage class</class-id> <category>hooks</category><body package="SpyLite" selector="spyClassForPackage">spyClassForPackage	^SLPackageCoverage</body></methods><methods><class-id>Spy1.SLPackage</class-id> <category>testing</category><body package="SpyLite" selector="hasClassNamed:">hasClassNamed: t1 	^self classes includesKey: t1 asSymbol</body></methods><methods><class-id>Spy1.SLPackage</class-id> <category>initialize-release</category><body package="SpyLite" selector="initialize">initialize	super initialize.	classes := Dictionary new.	profiler := SLProfiler nullObject.</body></methods><methods><class-id>Spy1.SLPackage</class-id> <category>printing</category><body package="SpyLite" selector="printOn:">printOn: t1 	t1 nextPutAll: '&lt;&lt;'.	self packageName ifNotNil: [t1 nextPutAll: self packageName asString].	t1 nextPutAll: '&gt;&gt;'.</body></methods><methods><class-id>Spy1.SLPackage</class-id> <category>accessing</category><body package="SpyLite" selector="&gt;&gt;">&gt;&gt; t1 	(t1 includes: $ )		ifTrue: [^(self &gt;&gt; t1 asString sunitSubStrings first asSymbol) metaclassSpy].	^self classAt: t1</body><body package="SpyLite" selector="classAt:">classAt: t1 	^classes at: t1 ifAbsent: [self error: 'Class ' , t1 , ' not found']</body><body package="SpyLite" selector="classAt:ifNone:">classAt: t1 ifNone: t2 	^classes at: t1 ifAbsent: t2</body><body package="SpyLite" selector="classAt:put:">classAt: t1 put: t2 	self assert: [t1 isSymbol].	t2 className: t1.	t2 packageSpy: self.	^classes at: t1 put: t2</body><body package="SpyLite" selector="classes">classes	^classes</body><body package="SpyLite" selector="packageName">packageName	^packageName</body><body package="SpyLite" selector="packageName:">packageName: t1 	packageName := t1.	^self</body><body package="SpyLite" selector="profiler">profiler	^profiler</body><body package="SpyLite" selector="profiler:">profiler: t1 	profiler := t1.</body></methods><methods><class-id>Spy1.SLPackage</class-id> <category>accessing-computed</category><body package="SpyLite" selector="allMethods">allMethods	| t1 |	t1 := OrderedCollection new.	self classes		do: 			[:t2 | 			t1 addAll: t2 methods.			t1 addAll: t2 metaclassSpy methods].	^t1</body></methods><methods><class-id>Spy1.SLPackage</class-id> <category>contract</category><body package="SpyLite" selector="checkInvariant">checkInvariant	self assert: [packageName notNil].	self assert: [packageName isKindOf: ByteString].	self assert: [self profiler notNil].	self assert: [self classes notNil].	self assert: [self classes allSatisfy: [:t1 | t1 isKindOf: self class spyClassForClass]].	self assert: [self classes allSatisfy: [:t2 | t2 package == self]].	self assert: [self classes allSatisfy: [:t3 | t3 profiler == self profiler]].	self classes do: [:t4 | t4 checkInvariant].</body></methods><methods><class-id>Spy1.SLPackage</class-id> <category>enumerating</category><body package="SpyLite" selector="allClassesSuchThat:">allClassesSuchThat: t1 	^self classes select: t1</body><body package="SpyLite" selector="allMethodsSuchThat:">allMethodsSuchThat: t1 	^self allMethods select: t1</body><body package="SpyLite" selector="classesDo:">classesDo: t1 	^self classes do: t1</body></methods><methods><class-id>Spy1.SLPackage class</class-id> <category>hooks</category><body package="SpyLite" selector="nullObject">nullObject	^self new</body><body package="SpyLite" selector="spyClassForClass">spyClassForClass	^SLClass</body></methods><methods><class-id>Spy1.SSTypeCollectorPackage class</class-id> <category>hooks</category><body package="SpyLite" selector="spyClassForClass">spyClassForClass	^SSTypeCollectorClass</body></methods><methods><class-id>Spy1.SLPackageCoverage class</class-id> <category>hooks</category><body package="SpyLite" selector="spyClassForClass">spyClassForClass	^SLClassCoverage</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>CodeProbe</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.AbstractCodeProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testMethod testSource variables labelString permanent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><class><name>MethodWrapper</name><environment>Refactory.Wrappers</environment><super>Kernel.CompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>clientMethod selector </inst-vars><class-inst-vars>methods </class-inst-vars><imports></imports><category>Refactory-Method Wrappers</category><attributes><package>Method Wrapper Base</package></attributes></class><class><name>RBProgramNodeVisitor</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class></st-source>