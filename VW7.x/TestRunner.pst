<?xml version="1.0"?><st-source><!-- Name: TestRunnerDbIdentifier: nilDbTrace: nilPackageName: TestRunnerParcel: #('TestRunner' )ParcelName: TestRunnerPrintStringCache: nilDate: 8:08:55 am July 3, 2020 --><time-stamp>From VisualWorksÂ®, 7.4 of December 5, 2005 on July 3, 2020 at 8:08:55 am</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>VWTestRunner</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			private SUnit.*			</imports><category>TestRunner</category><attributes><package>TestRunner</package></attributes></name-space><class><name>TestRunner</name><environment>VWTestRunner</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classList packageList packageSearchInput testCaseSearchInput defectList testCount defects actionLabel coverageResult packageCoverageInput listPackageCoverage packageSelectionBuilder </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>TestRunner</package></attributes></class><class><name>TestRunnerCoverageView</name><environment>VWTestRunner</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classCoverage listMethodCoverage textEditorMethodCoverage inputFieldSearchMethods </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>TestRunner</package></attributes></class><methods><class-id>VWTestRunner.TestRunner</class-id> <category>actions</category><body package="TestRunner" selector="assignDefectsToList">assignDefectsToList	self defectList list: (defects collect: [:t1 | t1 definition printString]).	^ self</body><body package="TestRunner" selector="disableOrEnableButtons">disableOrEnableButtons	(self sizeOfClassesSelected &gt; 0)		ifTrue: [ 			self enableRunningButtons ]		ifFalse: [ 			self disableRunningButtons ]</body><body package="TestRunner" selector="filterClassesOfSelectedPackages">filterClassesOfSelectedPackages	(self sizeOfPackagesSelected &gt; 0)		ifTrue: [ 			self classesOfSelectedPackages ]		ifFalse: [ 			self classesOfPackages ]</body><body package="TestRunner" selector="removeDefect:">removeDefect: aDefect	"	***This is decompiled code.*** 	No source was available"	defects remove: aDefect ifAbsent: [ nil ].	defects isEmpty ifTrue: [ defects := nil ].	^self</body></methods><methods><class-id>VWTestRunner.TestRunner</class-id> <category>aspects</category><body package="TestRunner" selector="classList">classList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^classList isNil		ifTrue:			[classList := MultiSelectionInList new]		ifFalse:			[classList]</body><body package="TestRunner" selector="defectList">defectList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^defectList isNil		ifTrue:			[defectList := SelectionInList new]		ifFalse:			[defectList]</body><body package="TestRunner" selector="listPackageCoverage">listPackageCoverage	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^listPackageCoverage isNil		ifTrue:			[listPackageCoverage := SelectionInList new]		ifFalse:			[listPackageCoverage]</body><body package="TestRunner" selector="packageCoverageInput">packageCoverageInput	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^packageCoverageInput isNil		ifTrue:			[packageCoverageInput := String new asValue]		ifFalse:			[packageCoverageInput]</body><body package="TestRunner" selector="packageList">packageList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^packageList isNil		ifTrue:			[packageList := MultiSelectionInList new]		ifFalse:			[packageList]</body><body package="TestRunner" selector="packageSearchInput">packageSearchInput	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^packageSearchInput isNil		ifTrue:			[packageSearchInput := String new asValue]		ifFalse:			[packageSearchInput]</body><body package="TestRunner" selector="testCaseSearchInput">testCaseSearchInput	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^testCaseSearchInput isNil		ifTrue:			[testCaseSearchInput := String new asValue]		ifFalse:			[testCaseSearchInput]</body></methods><methods><class-id>VWTestRunner.TestRunner</class-id> <category>initialize-release</category><body package="TestRunner" selector="initialize">initialize	super initialize.	packageList := MultiSelectionInList with: self allPackages.	classList := MultiSelectionInList with: self allClasses</body></methods><methods><class-id>VWTestRunner.TestRunner</class-id> <category>validations</category><body package="TestRunner" selector="defectsExist">defectsExist	defects notNil ifTrue: [^defects notEmpty].	^ false</body><body package="TestRunner" selector="enableCoverage">enableCoverage	^ self listPackageCoverage selection value isNotNil</body><body package="TestRunner" selector="isOnlyOneGeneratedClassSelected">isOnlyOneGeneratedClassSelected	| selectedClass result |	(self sizeOfClassesSelected = 1)		ifTrue: [						selectedClass := self classList selections first.			result := selectedClass superclass name ahsContainsString: 'SConfigGenerationTestCase'.			^ result ]		ifFalse: [ ^ false ].</body></methods><methods><class-id>VWTestRunner.TestRunner</class-id> <category>interface</category><body package="TestRunner" selector="postBuildWith:">postBuildWith: aBuilder	self packageList selectionIndexHolder onChangeSend: #filterClassesOfSelectedPackages to: self.	self classList selectionIndexHolder onChangeSend: #disableOrEnableButtons to: self.	self packageSearchInput onChangeSend: #searchPackages to: self.	self testCaseSearchInput onChangeSend: #searchClasses to: self.</body></methods><methods><class-id>VWTestRunner.TestRunner</class-id> <category>actions-interface</category><body package="TestRunner" selector="deselectAllClasses">deselectAllClasses	self classList clearAll.</body><body package="TestRunner" selector="deselectAllPackages">deselectAllPackages	self packageList clearAll.	self classList refreshList: self allClasses.</body><body package="TestRunner" selector="disableAllButtons">disableAllButtons	builder isNil ifTrue: [^self].	#(RunTestButton DebugButton RunProfiledButton RunCoverageButton RunDefectsButton) do: 		[:each | (self wrapperAt: each) isEnabled: false].</body><body package="TestRunner" selector="disableRunningButtons">disableRunningButtons		#(RunTestButton RunProfiledButton RunCoverageButton) do:		[:each | 				(self wrapperAt: each) isEnabled: false ]</body><body package="TestRunner" selector="enableRunningButtons">enableRunningButtons	#(RunTestButton RunProfiledButton RunCoverageButton) do:		[:each | 				(self wrapperAt: each) isEnabled: true ]</body><body package="TestRunner" selector="openConfigurationWindow">openConfigurationWindow	| class |	class := self classList selections first.	(SConfigClassView on: class) open.</body><body package="TestRunner" selector="openCoverageResultWindow">openCoverageResultWindow		| app win |	app := TestRunnerCoverageView on: coverageResult.	app open.	win := app mainWindow.	win label: (coverageResult methodCoverage asString, '% Code Coverage')</body><body package="TestRunner" selector="openPackageSelectionWindow">openPackageSelectionWindow	| bldr |	(packageSelectionBuilder notNil and: [packageSelectionBuilder window isOpen])		ifTrue: [ packageSelectionBuilder window raise ]		ifFalse: [			self listPackageCoverage refreshList: self defaultPackages.			packageCoverageInput := String new asValue.			packageSelectionBuilder := (bldr := UIBuilder new).			bldr source: self.			bldr add: (self class				interfaceSpecFor: #windowPackagesSpec).			bldr window				application: self;				beSlave.			bldr open. ].</body><body package="TestRunner" selector="selectAllClasses">selectAllClasses	self classList selectAll.</body><body package="TestRunner" selector="selectAllPackages">selectAllPackages	 self packageList selectAll</body><body package="TestRunner" selector="setFailedLabel">setFailedLabel	self setTestLabel: #Failed &lt;&lt; #browser &gt;&gt; 'Failed'.	self updateForFailed.	^self</body><body package="TestRunner" selector="setLabelColor:">setLabelColor: aColor	| label |	self builder isNil ifTrue: [^self].	label := self builder componentAt: #TestResult.	label isNil ifTrue: [^self].	label lookPreferences: (label lookPreferences backgroundColor: aColor).	^self</body><body package="TestRunner" selector="setPassedLabel">setPassedLabel	self setTestLabel: #Passed &lt;&lt; #browser &gt;&gt; 'Passed'.	self updateForPassed.	^self</body><body package="TestRunner" selector="setRunningAttributes">setRunningAttributes	self setLabelColor: ColorValue cyan.	self disableAllButtons.	defects := nil.</body><body package="TestRunner" selector="setRunningDefectsAttributes">setRunningDefectsAttributes	self setLabelColor: ColorValue cyan.	self disableAllButtons.</body><body package="TestRunner" selector="updateButtons">updateButtons	builder isNil ifTrue: [^self].	self updateRunButtons; updateDefectButtons.	^self</body><body package="TestRunner" selector="updateDefectButtons">updateDefectButtons	| enable |	enable := self defectsExist.	#(RunDefectsButton DebugButton) do:		[:each | 	(self wrapperAt: each) isEnabled: enable]</body><body package="TestRunner" selector="updateForFailed">updateForFailed	self setLabelColor: ColorValue red.	self updateButtons.	^self</body><body package="TestRunner" selector="updateForPassed">updateForPassed	self setLabelColor: ColorValue green.	self updateButtons.	defects := nil.	^self</body><body package="TestRunner" selector="updateForRunning">updateForRunning	self setRunningAttributes.	self setTestLabel: 'Running...'.</body><body package="TestRunner" selector="updateForRunningDefects">updateForRunningDefects	self setRunningDefectsAttributes.	self setTestLabel: 'Running...'.</body><body package="TestRunner" selector="updateRunButtons">updateRunButtons	self sizeOfClassesSelected &gt; 0		ifTrue: [			#(RunTestButton RunProfiledButton RunCoverageButton) do:				[:each | 					(self wrapperAt: each) enable]. ]</body></methods><methods><class-id>VWTestRunner.TestRunner</class-id> <category>actions-searching</category><body package="TestRunner" selector="searchClasses">searchClasses	| searchString wordArray classesFiltered allClassesOfPackages |	classesFiltered := OrderedCollection new.	allClassesOfPackages := OrderedCollection new.	searchString := self testCaseSearchInput value.	wordArray := self splitWordsOf: searchString.	self filterClassesOfSelectedPackages.	allClassesOfPackages := self classList list asOrderedCollection.	searchString isEmpty		ifFalse: 			[ wordArray 				do: [:word | 					classesFiltered addAll: 						(allClassesOfPackages 							select: [:package | package name asLowercase ahsContainsString: word asLowercase])].			  self classList refreshList: classesFiltered. ].	^ self</body><body package="TestRunner" selector="searchPackages">searchPackages	| searchString wordArray packagesFiltered classesOfPackagesFiltered |	classesOfPackagesFiltered := OrderedCollection new.	packagesFiltered := OrderedCollection new.	searchString := self packageSearchInput value.	wordArray := self splitWordsOf: searchString.	searchString isEmpty		ifTrue: [			packagesFiltered := self allPackages ]		ifFalse: 			[ wordArray 				do: [:word | 					packagesFiltered addAll: 						(self allPackages 							select: [:package | package name asLowercase ahsContainsString: word asLowercase])] ].	self packageList refreshList: packagesFiltered.	packagesFiltered do: [ :package |		classesOfPackagesFiltered addAll: (package allDefinedClasses select: [ :class | class name endsWith: 'Test' ]) ].	self classList refreshList: classesOfPackagesFiltered.	^ self</body><body package="TestRunner" selector="splitWordsOf:">splitWordsOf: aString	"	***This is decompiled code.*** 	No source was available"	^(aString replaceChar: $| withChar: Character space) subStrings asOrderedCollection</body></methods><methods><class-id>VWTestRunner.TestRunner</class-id> <category>accessing</category><body package="TestRunner" selector="actionLabel">actionLabel	^ actionLabel</body><body package="TestRunner" selector="actionLabel:">actionLabel: aString	actionLabel := aString.	^self</body><body package="TestRunner" selector="allClasses">allClasses	^ Smalltalk allClasses select: [:t1 | t1 name endsWith: 'Test' ]</body><body package="TestRunner" selector="allPackages">allPackages	^ Store.Registry allPackages select: [ :package | package name ahsContainsString: 'Tests' ]</body><body package="TestRunner" selector="classesOfPackage:">classesOfPackage: aPackage	| listOfPackages package |	listOfPackages := self allPackages.	package := listOfPackages select: [ :pack | pack = aPackage ].	self halt.	^ package allClasses</body><body package="TestRunner" selector="classesOfPackages">classesOfPackages	| listOfClasses listOfSelectedPackages |	listOfClasses := OrderedCollection new.	listOfSelectedPackages := self packageList list asOrderedCollection.	listOfSelectedPackages do: [ :package | 		listOfClasses addAll: (package allDefinedClasses select: [ :class | class name endsWith: 'Test' ]) ].	self classList refreshList: listOfClasses.</body><body package="TestRunner" selector="classesOfSelectedPackages">classesOfSelectedPackages	| listOfClasses listOfSelectedPackages |	listOfClasses := OrderedCollection new.	listOfSelectedPackages := self packageList selections asOrderedCollection.	listOfSelectedPackages do: [ :package | 		listOfClasses addAll: (package allDefinedClasses select: [ :class | class name endsWith: 'Test' ]) ].	self classList refreshList: listOfClasses.</body><body package="TestRunner" selector="defaultPackages">defaultPackages	^ Store.Registry allPackages</body><body package="TestRunner" selector="selectedClasses">selectedClasses	^ self classList selections</body><body package="TestRunner" selector="selectedPackages">selectedPackages	^ self packageList selections</body><body package="TestRunner" selector="sizeOfClassesSelected">sizeOfClassesSelected	^ self classList selectionIndexHolder value size</body><body package="TestRunner" selector="sizeOfPackagesSelected">sizeOfPackagesSelected	^ self packageList selectionIndexHolder value size</body><body package="TestRunner" selector="testcaseResult:">testcaseResult: t1	(testCount notNil and: [testCount &gt; 0])		ifTrue: [testCount := testCount - 1].	^self</body><body package="TestRunner" selector="testCasesSelectors">testCasesSelectors	| selectorsList |	selectorsList := OrderedCollection new.	self selectedClasses do: [ :class |		selectorsList addAll: (class allTestSelectors asOrderedCollection collect: [ :selectorName | class selector: selectorName ]) ].	^ selectorsList</body></methods><methods><class-id>VWTestRunner.TestRunner</class-id> <category>actions-running</category><body package="TestRunner" selector="runDefects">runDefects	| suite result |	(defects isNil or: [defects isEmpty])		ifTrue: [^self].		[self subscribeToAnnouncements.	self updateForRunningDefects.	suite := SUnit.TestSuite new.	defects do: [:t3 | suite addTest: t3 asTestCase].	testCount := defects size.	result := [suite run]				ifCurtailed: [self setTestLabel: #Failed &lt;&lt; #browser &gt;&gt; 'Failed'] ]		ensure: [SUnit.TestCase unsubscribe: self].	self setTestLabel: (#x1QPassedORFailed2pRun3pFailed4pErrors &lt;&lt; #browser &gt;&gt; '&lt;1?Passed:Failed&gt;: &lt;2p&gt; run, &lt;3p&gt; failed, &lt;4p&gt; errors'			expandMacrosWith: result allPassed			with: result ranCount			with: result failureCount			with: result errorsCount).	result allPassed		ifTrue: [ self updateForPassed ]		ifFalse: [ 			defects := result defects.			self updateForFailed ].	^self</body><body package="TestRunner" selector="runTests">runTests	| suite result selectors |	[		self subscribeToAnnouncements.		self updateForRunning.		selectors :=  self testCasesSelectors.		suite := SUnit.TestSuite new.		selectors do: [ :test | suite addTest: test ].		testCount := selectors size.		result := [suite run] ifCurtailed:  [self setTestLabel: (#Failed &lt;&lt; #browser &gt;&gt; 'Failed')].	] ensure: [SUnit.TestCase unsubscribe: self].	self 		setTestLabel: (#x1QPassedORFailed2pRun3pFailed4pErrors &lt;&lt; #browser &gt;&gt; '&lt;1?Passed:Failed&gt;: &lt;2p&gt; run, &lt;3p&gt; failed, &lt;4p&gt; errors'				expandMacrosWith: result allPassed				with: result ranCount				with: result failureCount				with: result errorsCount).	result allPassed 		ifTrue: [ 			self updateForPassed.			self defectList refreshList: OrderedCollection new. ]		ifFalse: 			[ defects := result defects.			self assignDefectsToList.			self updateForFailed. ].</body><body package="TestRunner" selector="setSUnitLabel:">setSUnitLabel: aString	"	***This is decompiled code.*** 	No source was available"	| label |	self builder isNil ifTrue: [^self].	label := self builder componentAt: #TestResult.	label isNil ifTrue: [^self].	label widget labelString: (self actionLabel isEmpty			ifTrue: [aString]			ifFalse: [self actionLabel , aString]).	label repairDamage.	^self</body><body package="TestRunner" selector="setTestLabel:">setTestLabel: aString	self actionLabel: ''.	self setSUnitLabel: aString.	^self</body><body package="TestRunner" selector="subscribeToAnnouncements">subscribeToAnnouncements	SUnit.TestCase		unsubscribe: self from: SUnit.Result;		unsubscribe: self from: SUnit.Started;		when: SUnit.Result send: #testcaseResult: to: self</body></methods><methods><class-id>VWTestRunner.TestRunner</class-id> <category>actions-debugging</category><body package="TestRunner" selector="debug:">debug: aTest	"	***This is decompiled code.*** 	No source was available"	SUnit.TestCase		when: SUnit.Failure		do: [:t1 | self debugFailure: t1 exception]		for: self.	SUnit.TestCase		when: SUnit.SomeError		do: [:t2 | self debugError: t2 exception]		for: self.	[aTest debug]		ensure: [SUnit.TestCase unsubscribe: self].	^self</body><body package="TestRunner" selector="debugError:">debugError: t1 	(t1 respondsTo: #pretendDefaultAction)		ifTrue: [t1 pretendDefaultAction].	^Notifier developmentNotifier openOnException: t1</body><body package="TestRunner" selector="debugFailure:">debugFailure: t1 	| t2 t3 t4 t5 |	t3 := (t4 := self searchForFirstTestMachineryContext: t1) sender.	t1 unwindTo: t3.	t5 := Message new setSelector: t4 selector arguments: ((1 to: t4 selector numArgs)					collect: [:t6 | t4 localAt: t6]).	t3 restackMessage: t5 to: t3 receiver.	t2 := DebuggerService basicNew.	t3 jump: (t2 presendPCFor: t3)			- t3 pc.	DebuggerService		openOn: t3		exception: t1		interrupted: true.	^self</body><body package="TestRunner" selector="debugTest:">debugTest: aTest	| test |	self updateForDebuggingDefect.	test := false.	testCount := 1.	[ [	[ self subscribeToAnnouncements.	self debug: aTest asTestCase ]		ensure: [ SUnit.TestCase unsubscribe: self ] ]		on: Error , SUnit.FailedAssertion		do: 			[:t3 | 			test := true.			t3 pass]]		ifCurtailed: [ self setFailedLabel ].	test		ifTrue: [ self setFailedLabel ]		ifFalse: 			[ self removeDefect: aTest.			self setPassedLabel ].	^self</body><body package="TestRunner" selector="debugTests">debugTests	| dialog |	(defects isNil or: [defects isEmpty])		ifTrue: [^self].	(dialog := Dialog				choose: #ChooseATestToDebug &lt;&lt; #browser &gt;&gt; 'Choose A Test To Debug'				fromList: (defects collect: [ :defect | defect definition printString ])				values: defects				lines: 8				cancel: [nil]				for: Dialog defaultParentWindow) ifNotNil: [:test | self debugTest: test].	^self</body><body package="TestRunner" selector="searchForFirstTestMachineryContext:">searchForFirstTestMachineryContext: t1 	| t2 t3 |	t3 := 10.	t2 := t1 topOfContextStack.	[t3 &gt; 0 and: [t2 notNil]]		whileTrue: 			[t2 sender				ifNotNil: 					[:t4 | 					(t4 mclass inheritsFrom: SUnit.TestCase)						ifTrue: [^t2].					nil].			t2 := t2 sender.			t3 := t3 - 1].	^t1 topOfContextStack</body><body package="TestRunner" selector="updateForDebuggingDefect">updateForDebuggingDefect	self setRunningDefectsAttributes.	self setTestLabel: 'Debugging...'.</body></methods><methods><class-id>VWTestRunner.TestRunner</class-id> <category>actions-profiled</category><body package="TestRunner" selector="profileTests">profileTests	| profiler |		(profiler := #{TimeProfiler} valueOrDo: [nil]) isNil 		ifTrue: [ 			^ Dialog warn: #ProfilerNotLoadedLoad &lt;&lt; #browser &gt;&gt; 'Profiler not loaded. Load the "AT Profiling" parcel.' ].	profiler profile: [self runTests].	^self</body></methods><methods><class-id>VWTestRunner.TestRunner</class-id> <category>actions-coverage</category><body package="TestRunner" selector="filterPackageCoverage">filterPackageCoverage	| filteredPackages  filterInput |	filterInput := packageCoverageInput value.	filteredPackages := self defaultPackages.	self listPackageCoverage refreshList: filteredPackages.	filterInput isEmpty		ifFalse: [ 			filteredPackages := (self listPackageCoverage list select: [ :package | (package name asLowercase) ahsContainsString: filterInput asLowercase]) ].	self listPackageCoverage refreshList: filteredPackages.</body><body package="TestRunner" selector="runCoverageOfPackages">runCoverageOfPackages	| packageToCheckCoverage suite |	(self enableCoverage)		ifTrue: [ 			packageToCheckCoverage := self listPackageCoverage selection value.			suite := SUnit.TestSuite new.			self testCasesSelectors do: [ :test | suite addTest: test ].			coverageResult := (Spy1.SLProfilerCoverage profile: [ suite run ]				inPackagesMatching:  packageToCheckCoverage name).			self openCoverageResultWindow ]		ifFalse: [ Dialog wuiError: 'Error: Package not selected, select a package.' for: nil  ]</body></methods><methods><class-id>VWTestRunner.TestRunnerCoverageView</class-id> <category>aspects</category><body package="TestRunner" selector="inputFieldSearchMethods">inputFieldSearchMethods	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^inputFieldSearchMethods isNil		ifTrue:			[inputFieldSearchMethods := String new asValue]		ifFalse:			[inputFieldSearchMethods]</body><body package="TestRunner" selector="listMethodCoverage">listMethodCoverage	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^listMethodCoverage isNil		ifTrue:			[listMethodCoverage := SelectionInList new]		ifFalse:			[listMethodCoverage]</body><body package="TestRunner" selector="textEditorMethodCoverage">textEditorMethodCoverage	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^textEditorMethodCoverage isNil		ifTrue:			[textEditorMethodCoverage := String new asValue]		ifFalse:			[textEditorMethodCoverage]</body></methods><methods><class-id>VWTestRunner.TestRunnerCoverageView</class-id> <category>accessing</category><body package="TestRunner" selector="classCoverage">classCoverage	^ classCoverage</body><body package="TestRunner" selector="classCoverage:">classCoverage: aClass	classCoverage := aClass.	self listMethodCoverage list: aClass allMethods</body></methods><methods><class-id>VWTestRunner.TestRunnerCoverageView</class-id> <category>interface</category><body package="TestRunner" selector="postBuildWith:">postBuildWith: aBuilder	self listMethodCoverage selectionIndexHolder onChangeSend: #changedMethod to: self.	self inputFieldSearchMethods onChangeSend: #searchMethods to: self</body><body package="TestRunner" selector="postOpenWith:">postOpenWith: aBuilder	super postOpenWith: aBuilder.	self listMethodCoverage selectionIndex: 1.</body></methods><methods><class-id>VWTestRunner.TestRunnerCoverageView</class-id> <category>actions</category><body package="TestRunner" selector="addEmphasisToText:withMethod:">addEmphasisToText: aText withMethod: aSpyMethod	| blocksMethod |	blocksMethod := aSpyMethod blocks copy.	blocksMethod first wasExecuted		ifTrue: [			aText addEmphasis: (Array with: #color -&gt; ColorValue.Green) 						removeEmphasis: #() 						allowDuplicates: true 						from: 0 to: (blocksMethod first stop). ]		ifFalse: [			aText addEmphasis: (Array with: #color -&gt; ColorValue.Red) 						removeEmphasis: #() 						allowDuplicates: true 						from: 0 to: (blocksMethod first stop).			^ aText ].		blocksMethod doWithIndex: [ :block :index |			(index = 1)				ifFalse: [					(block wasExecuted)						ifFalse: [							aText addEmphasis: (Array with: #color -&gt; ColorValue.Yellow) 							removeEmphasis: #() 							allowDuplicates: true 							from: (block start) to: (block stop). ] ] ].	^ aText</body><body package="TestRunner" selector="changedMethod">changedMethod	| selectedMethod txt |	selectedMethod := self listMethodCoverage selection.	selectedMethod isNil		ifTrue: [ self textEditorMethodCoverage value: '' ]		ifFalse: [			txt := (selectedMethod blocks at: 1) code asText.			txt := self addEmphasisToText: txt withMethod: (selectedMethod copy).			self textEditorMethodCoverage value: txt. ].</body><body package="TestRunner" selector="searchMethods">searchMethods	| filteredMethods searchValue |	filteredMethods := OrderedCollection new.	searchValue := self inputFieldSearchMethods value.	(searchValue isEmpty)		ifTrue: [  filteredMethods addAll: self classCoverage allMethods. ]		ifFalse: [ 			filteredMethods addAll: (self classCoverage allMethods									select: [ :method | 					 						method printString asLowerCase ahsContainsString: searchValue asString asLowerCase ]) ].	self listMethodCoverage refreshList: filteredMethods.</body></methods><methods><class-id>VWTestRunner.TestRunnerCoverageView</class-id> <category>initialize-release</category><body package="TestRunner" selector="initialize">initialize	classCoverage := nil</body></methods><methods><class-id>VWTestRunner.TestRunnerCoverageView class</class-id> <category>initialize-release</category><body package="TestRunner" selector="on:">on: aClass	^ self new 		classCoverage: aClass;		yourself</body></methods><methods><class-id>VWTestRunner.TestRunner class</class-id> <category>interface specs</category><body package="TestRunner" selector="windowPackagesSpec">windowPackagesSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowPackagesSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Packages' 			#min: #(#{Core.Point} 390 360 ) 			#max: #(#{Core.Point} 390 360 ) 			#bounds: #(#{Graphics.Rectangle} 960 475 1350 835 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #white ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 3522 3522 3522 ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 285 0 40 0 85 25 ) 					#name: #FilterPackagesCoverageButton 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 3522 3522 3522 ) ) 					#model: #filterPackageCoverage 					#tabable: false 					#label: 'Filter' 					#defaultable: true ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 85 0 40 0 180 25 ) 					#name: #PackagesCoverageInput 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 2040 1846 1846 ) ) 					#model: #packageCoverageInput 					#tabable: false ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 20 0 40 0 60 25 ) 					#name: #LabelPackageFilter 					#label: 'Packages:' 					#style: #'Arbor-12' ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 15 0 80 0 360 230 ) 					#name: #ListPackageCoverage 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 2040 1846 1846 ) ) 					#model: #listPackageCoverage 					#tabable: false 					#multipleSelections: false 					#selectionType: #checkMark 					#autoSelect: false ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 20 0 10 0 241 25 ) 					#name: #LabelMessageFilterPackages 					#label: 'Select the packages to run coverage' 					#style: #'Arbor-14-Squeeze' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 151 0 320 0 96 27 ) 					#name: #RunCoverageOfPackages 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 3522 3522 3522 ) ) 					#model: #runCoverageOfPackages 					#tabable: false 					#label: 'Run Coverage' 					#defaultable: true ) ) ) )</body><body package="TestRunner" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 			#label: 'Test Runner' 			#min: #(#{Core.Point} 980 420 ) 			#max: #(#{Core.Point} 980 420 ) 			#bounds: #(#{Graphics.Rectangle} 940 475 1920 895 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #white ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 3522 3522 3522 ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 225 0 370 0 100 30 ) 					#name: #RunProfiledButton 					#flags: 40 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 3522 3522 3522 ) ) 					#model: #profileTests 					#tabable: false 					#label: 'Run Profiled' 					#style: #'Arbor-12' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 25 0 370 0 100 30 ) 					#name: #RunTestButton 					#flags: 40 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 3522 3522 3522 ) ) 					#model: #runTests 					#tabable: false 					#label: 'Run Selected' 					#style: #'Arbor-12' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 630 0 370 0 100 30 ) 					#name: #DebugButton 					#flags: 40 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 3522 3522 3522 ) ) 					#model: #debugTests 					#tabable: false 					#label: 'Debug Defects' 					#style: #'Arbor-12' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 850 0 370 0 100 30 ) 					#name: #RunDefectsButton 					#flags: 40 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 3522 3522 3522 ) ) 					#model: #runDefects 					#tabable: false 					#label: 'Run Defects' 					#style: #'Arbor-12' 					#defaultable: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 20 0 70 0 280 280 ) 					#name: #PackageSelectionList 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 1949 1742 1742 ) ) 					#model: #packageList 					#tabable: false 					#menu: #packageSelectionMenu 					#multipleSelections: true 					#selectionType: #checkMark 					#autoSelect: false ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 340 0 70 0 280 280 ) 					#name: #ClassSelectionList 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 1949 1742 1742 ) ) 					#model: #classList 					#tabable: false 					#menu: #classSelectionMenu 					#multipleSelections: true 					#selectionType: #checkMark 					#autoSelect: false ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 650 0 50 0 300 35 ) 					#name: #TestResult 					#label: 'No Tests' 					#style: #'Arbor-16' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 20 0 35 0 280 25 ) 					#name: #PackageSearchInput 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 1949 1742 1742 ) ) 					#helpText: 'Package #1 | Package #2' 					#model: #packageSearchInput 					#tabable: false 					#style: #'Arbor-14' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 340 0 35 0 280 25 ) 					#name: #TestCaseSearchInput 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 1949 1742 1742 ) ) 					#helpText: 'TestCase #1 | TestCase #2' 					#model: #testCaseSearchInput 					#tabable: false 					#style: #'Arbor-14' ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 320 0 20 0 5 330 ) 					#name: #Divider1 					#orientation: #vertical ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 635 0 20 0 5 330 ) 					#name: #Divider2 					#orientation: #vertical ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 20 0.0 10 0 75 25 ) 					#name: #PackageLabel 					#label: 'Packages' 					#style: #'Arbor-14-Squeeze' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 340 0.0 10 0 60 25 ) 					#name: #ClassesLabel 					#label: 'Classes' 					#style: #'Arbor-14-Squeeze' ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 15 0 362 0 950 50 ) 					#name: #GroupBox1 					#style: #'AnimationOverview-12-TightSqueeze' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 430 0 370 0 100 30 ) 					#name: #RunCoverageButton 					#flags: 40 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 3522 3522 3522 ) ) 					#helpText: '' 					#model: #openPackageSelectionWindow 					#tabable: false 					#label: 'Run Coverage' 					#style: #'Arbor-12' 					#defaultable: true ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 650 0 100 0 305 250 ) 					#name: #DefectList 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 2081 1970 1970 ) ) 					#model: #defectList 					#tabable: false 					#selectionType: #highlight 					#autoSelect: false ) ) ) )</body></methods><methods><class-id>VWTestRunner.TestRunner class</class-id> <category>resources</category><body package="TestRunner" selector="classSelectionMenu">classSelectionMenu	"Tools.MenuEditor new openOnClass: self andSelector: #classSelectionMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Select All' 				#value: #selectAllClasses ) 			#(#{UI.MenuItem} 				#rawLabel: 'Deselect all' 				#value: #deselectAllClasses ) 			#(#{UI.MenuItem} 				#rawLabel: 'Change configuration' 				#enabled: false 				#value: #openConfigurationWindow 				#enablementSelector: #isOnlyOneGeneratedClassSelected ) ) #(2 1 ) nil ) decodeAsLiteralArray</body><body package="TestRunner" selector="packageSelectionMenu">packageSelectionMenu	"Tools.MenuEditor new openOnClass: self andSelector: #packageSelectionMeu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Select All' 				#value: #selectAllPackages ) 			#(#{UI.MenuItem} 				#rawLabel: 'Deselect all' 				#value: #deselectAllPackages ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>VWTestRunner.TestRunnerCoverageView class</class-id> <category>interface specs</category><body package="TestRunner" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 			#label: '' 			#min: #(#{Core.Point} 790 470 ) 			#max: #(#{Core.Point} 790 470 ) 			#bounds: #(#{Graphics.Rectangle} 960 440 1750 910 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #white ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 3522 3522 3522 ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 20 0 100 0 220 350 ) 					#name: #ListMethodCoverage 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 2253 1931 1931 ) ) 					#model: #listMethodCoverage 					#tabable: true 					#selectionType: #highlight 					#autoSelect: true ) 				#(#{UI.TextEditorSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 250 0 50 0 520 400 ) 					#name: #TextEditorMethodCoverage 					#flags: 12 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setBackgroundColor: #(#{Graphics.ColorValue} 2293 2040 2040 ) ) 					#model: #textEditorMethodCoverage 					#tabable: false 					#isReadOnly: true 					#tabRequiresControl: false ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 25 0 13 0 77 32 ) 					#name: #LabelMethodCoverage 					#label: 'Methods' 					#style: #'Arbor-18' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 20 0 50 0 220 30 ) 					#name: #InputFieldSearchMethods 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #white ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 2425 2164 2164 ) ) 					#helpText: 'Introuce a method. Example: foo' 					#model: #inputFieldSearchMethods 					#tabable: false ) ) ) )</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class></st-source>