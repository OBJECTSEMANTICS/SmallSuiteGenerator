<?xml version="1.0"?><st-source><!-- Name: TestRunnerDbIdentifier: nilDbTrace: nilPackageName: TestRunnerParcel: #('TestRunner' )ParcelName: TestRunnerPrintStringCache: nilDate: 8:07:13 am July 28, 2020 --><time-stamp>From VisualWorksÂ®, 7.4 of December 5, 2005 on July 28, 2020 at 8:07:13 am</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>VWTestRunner</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			private SUnit.*			</imports><category>TestRunner</category><attributes><package>TestRunner</package></attributes></name-space><class><name>TestRunnerCodeCoverageView</name><environment>VWTestRunner</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classCoverage textEditorMethodCoverage inputFieldSearchMethods tabControlCoverage listClassMethod listClassCategory listInstanceMethod listInstanceCategory listClassCoverage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>TestRunner</package></attributes></class><class><name>LCodeCoverageSpec</name><environment>VWTestRunner</environment><super>UI.TextEditorSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>language </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LED-UI</category><attributes><package>TestRunner</package></attributes></class><class><name>TestRunnerSelectionPackageView</name><environment>VWTestRunner</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packageCoverageInput listPackageCoverage testSuite coverageResult testCasesSelectors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>TestRunner</package></attributes></class><class><name>TestRunner</name><environment>VWTestRunner</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classList packageList packageSearchInput testCaseSearchInput testCount defects actionLabel packageSelectionBuilder failedTestList errorTestList result </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIApplications-New</category><attributes><package>TestRunner</package></attributes></class><class><name>LCodeCoverageController</name><environment>VWTestRunner</environment><super>UI.ReadOnlyTextEditorController</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blocks </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>LED-UI</category><attributes><package>TestRunner</package></attributes></class><class><name>LCodeCoverageView</name><environment>VWTestRunner</environment><super>UI.TextEditorView</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>style </class-inst-vars><imports></imports><category>LED-UI</category><attributes><package>TestRunner</package></attributes></class><methods><class-id>VWTestRunner.TestRunnerCodeCoverageView</class-id> <category>aspects</category><body package="TestRunner" selector="listClassCategory">listClassCategory	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^listClassCategory isNil		ifTrue:			[listClassCategory := SelectionInList new]		ifFalse:			[listClassCategory]</body><body package="TestRunner" selector="listClassCoverage">listClassCoverage	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^listClassCoverage isNil		ifTrue:			[listClassCoverage := SelectionInList new]		ifFalse:			[listClassCoverage]</body><body package="TestRunner" selector="listClassMethod">listClassMethod	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^listClassMethod isNil		ifTrue:			[listClassMethod := SelectionInList new]		ifFalse:			[listClassMethod]</body><body package="TestRunner" selector="listInstanceCategory">listInstanceCategory	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^listInstanceCategory isNil		ifTrue:			[listInstanceCategory := SelectionInList new]		ifFalse:			[listInstanceCategory]</body><body package="TestRunner" selector="listInstanceMethod">listInstanceMethod	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^listInstanceMethod isNil		ifTrue:			[listInstanceMethod := SelectionInList new]		ifFalse:			[listInstanceMethod]</body><body package="TestRunner" selector="tabControlCoverage">tabControlCoverage	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	tabControlCoverage isNil		ifTrue:			[tabControlCoverage := SelectionInList with: self labelSpec].	^ tabControlCoverage	</body><body package="TestRunner" selector="textEditorMethodCoverage">textEditorMethodCoverage	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^textEditorMethodCoverage isNil		ifTrue:			[textEditorMethodCoverage := String new asValue]		ifFalse:			[textEditorMethodCoverage]</body></methods><methods><class-id>VWTestRunner.TestRunnerCodeCoverageView</class-id> <category>interface</category><body package="TestRunner" selector="postBuildWith:">postBuildWith: aBuilder	self tabControlCoverage selectionIndexHolder onChangeSend: #changedTab to: self.	self assignEventOnClassCoverageList.	self assignEventOnInstanceTab.	self assignEventOnClassTab.</body><body package="TestRunner" selector="postOpenWith:">postOpenWith: aBuilder		super postOpenWith: aBuilder.	self listClassCoverage selectionIndex: 1.	self tabControlCoverage selectionIndex: 1.	self listInstanceMethod selectionIndex: 1.</body></methods><methods><class-id>VWTestRunner.TestRunnerCodeCoverageView</class-id> <category>initialize-release</category><body package="TestRunner" selector="initialize">initialize	classCoverage := nil</body></methods><methods><class-id>VWTestRunner.TestRunnerCodeCoverageView</class-id> <category>actions</category><body package="TestRunner" selector="addBlocksToController:ofBlocks:">addBlocksToController: aController ofBlocks: aBlockList	aController blocks: OrderedCollection new.	(aBlockList at: 1) wasExecuted		ifTrue: [ 			aBlockList doWithIndex: [ :block :index |				index = 1					ifTrue: [						aController addBlock: (Spy1.SLBlock new start: 1; stop: ((aBlockList at: 1)  stop + 1); executed; yourself). ]					ifFalse: [ 						block wasExecuted							ifTrue: [ aController addBlock: (Spy1.SLBlock new start: (block start); stop: (block stop  + 1); executed; yourself) ]							ifFalse: [ aController addBlock: (Spy1.SLBlock new start: (block start); stop: (block stop  + 1); yourself) ] ] ] ]		ifFalse: [ aController addBlock: (Spy1.SLBlock new start: 1; stop: ((aBlockList at: 1)  stop + 1); yourself) ].</body></methods><methods><class-id>VWTestRunner.TestRunnerCodeCoverageView</class-id> <category>events</category><body package="TestRunner" selector="assignEventOnClassCoverageList">assignEventOnClassCoverageList	self listClassCoverage selectionIndexHolder onChangeSend: #changedListOfMethodsAndCategories to: self.</body><body package="TestRunner" selector="assignEventOnClassTab">assignEventOnClassTab	self listClassCategory selectionIndexHolder onChangeSend: #changedListOfClassMethods to: self.	self listClassMethod selectionIndexHolder onChangeSend: #changedClassMethod to: self.</body><body package="TestRunner" selector="assignEventOnInstanceTab">assignEventOnInstanceTab	self listInstanceCategory selectionIndexHolder onChangeSend: #changedListOfInstanceMethods to: self.	self listInstanceMethod selectionIndexHolder onChangeSend: #changedInstanceMethod to: self.</body></methods><methods><class-id>VWTestRunner.TestRunnerCodeCoverageView</class-id> <category>actions-tab</category><body package="TestRunner" selector="changedTab">changedTab	| index |	index := self tabControlCoverage selectionIndex.	(self widgetAt: #TabControlCoverage)		client: self		spec: (self arraySpec at: index).	index = 1		ifTrue: [ 			self listInstanceCategory selectionIndex: 1.			self listInstanceMethod selectionIndex: nil. ]		ifFalse: [ 			self listClassCategory selectionIndex: 1.			self listClassMethod selectionIndex: nil. ]</body></methods><methods><class-id>VWTestRunner.TestRunnerCodeCoverageView</class-id> <category>accessing</category><body package="TestRunner" selector="arraySpec">arraySpec	^ #(#windowInstanceSpec #windowClassSpec)</body><body package="TestRunner" selector="classCoverage">classCoverage	^ classCoverage</body><body package="TestRunner" selector="classCoverage:">classCoverage: aProfiler 	| package |	classCoverage := aProfiler.	package := aProfiler packages at: 1.	self listClassesOfPackage: package</body><body package="TestRunner" selector="labelSpec">labelSpec	^ Array		with: 'Instance'		with: 'Class'</body><body package="TestRunner" selector="nameOfClass:">nameOfClass: aClass	^ (self calculateCoverageOfClass: aClass) asString, '% ', aClass originalClass name</body></methods><methods><class-id>VWTestRunner.TestRunnerCodeCoverageView</class-id> <category>actions-classes</category><body package="TestRunner" selector="calculateCoverageOfClass:">calculateCoverageOfClass: aCoverageClass 	| executedMethods methods |	methods := aCoverageClass allMethods.	executedMethods := self selectExecutedMethods: methods.	^ (100 * executedMethods size / methods size) asFloat round: 2</body><body package="TestRunner" selector="changedListOfMethodsAndCategories">changedListOfMethodsAndCategories	self listClassCoverage selection isNil		ifFalse: [			self assignInstanceMethodsAndCategories.			self assignClassMethodsAndCategories.			self tabControlCoverage selectionIndex: 1.			self listInstanceCategory selectionIndex: 1. ]</body><body package="TestRunner" selector="listClassesOfPackage:">listClassesOfPackage: package 	| classes |	classes := package classes select: [:class | class allMethods size &gt; 0].	self listClassCoverage 		list: (self orderClassesByCoverageOfList: classes asOrderedCollection)</body><body package="TestRunner" selector="orderClassesByCoverageOfList:">orderClassesByCoverageOfList: aList 	| newArray orderedList |	newArray := Array new: aList size.	orderedList := self sortListByCoverage: aList.	orderedList 		doWithIndex: [:aClass :index | newArray at: index put: ((self nameOfClass: aClass) -&gt; aClass)].	^newArray</body><body package="TestRunner" selector="selectExecutedMethods:">selectExecutedMethods: methods 	^(methods select: [:t2 | t2 blocks isNotEmpty]) 		select: [:t3 | t3 blocks first wasExecuted]</body><body package="TestRunner" selector="sortListByCoverage:">sortListByCoverage: aList 	^aList sort: 			[:classA :classB | 			(self calculateCoverageOfClass: classA) 				&gt; (self calculateCoverageOfClass: classB)]</body></methods><methods><class-id>VWTestRunner.TestRunnerCodeCoverageView</class-id> <category>actions-class-tab</category><body package="TestRunner" selector="assignClassMethodsAndCategories">assignClassMethodsAndCategories	| selectedClass categories organization listOfCategories listOfMethods |		selectedClass := self listClassCoverage selection value.	organization := selectedClass originalClass class organization.	categories := organization categories.	listOfCategories := Array new: categories size.	categories 		doWithIndex: [ :aCategory :index |			listOfMethods := selectedClass allMethods 				select: [ :method | 					((organization categoryOfElement: (method selector)) = aCategory)					and: [ (method originalMethod mclass name ahsContainsString: 'class') = true ] ].			listOfCategories at: index put: (aCategory -&gt; listOfMethods) ].	self listClassCategory list: listOfCategories.</body><body package="TestRunner" selector="changedClassMethod">changedClassMethod	| selectedMethod txt controller |	selectedMethod := self listClassMethod selection value.	selectedMethod isNil		ifFalse: [			controller := (self widgetAt: #TextEditorMethodCoverage) controller.			self addBlocksToController: controller ofBlocks: (selectedMethod blocks).			txt := (selectedMethod blocks at: 1) code asText.			self textEditorMethodCoverage value: txt. ].</body><body package="TestRunner" selector="changedListOfClassMethods">changedListOfClassMethods	| selectedCategory methods arrayOfMethods |	selectedCategory := self listClassCategory selection.	selectedCategory isNil		ifFalse: [			methods := selectedCategory value.			arrayOfMethods := Array new: methods size.			methods doWithIndex: [ :aMethod :index |				arrayOfMethods at: index put: (aMethod selector -&gt; aMethod) ] ]		ifTrue: [			methods := OrderedCollection new.			self listClassCategory list do: [ :aCategory | 				methods addAll: aCategory value ].			arrayOfMethods := Array new: methods size.			methods doWithIndex: [ :aMethod :index |				arrayOfMethods at: index put: (aMethod selector -&gt; aMethod) ] ].	self listClassMethod list: arrayOfMethods.</body></methods><methods><class-id>VWTestRunner.TestRunnerCodeCoverageView</class-id> <category>actions-instance-tab</category><body package="TestRunner" selector="assignInstanceMethodsAndCategories">assignInstanceMethodsAndCategories	| selectedClass categories organization listOfCategories listOfMethods |	selectedClass := self listClassCoverage selection value.	organization := selectedClass originalClass organization.	categories := organization categories.	listOfCategories := Array new: categories size.	categories 		doWithIndex: [ :aCategory :index |			listOfMethods := selectedClass allMethods 				select: [ :method | 					((organization categoryOfElement: (method selector)) = aCategory)					and: [ (method originalMethod mclass name ahsContainsString: 'class') = false ] ].				listOfCategories at: index put: (aCategory -&gt; listOfMethods) ].	self listInstanceCategory list: listOfCategories.</body><body package="TestRunner" selector="changedInstanceMethod">changedInstanceMethod	| selectedMethod txt controller |	selectedMethod := self listInstanceMethod selection value.	selectedMethod isNil		ifFalse: [			controller := (self widgetAt: #TextEditorMethodCoverage) controller.			self addBlocksToController: controller ofBlocks: (selectedMethod blocks).			txt := (selectedMethod blocks at: 1) code asText.			self textEditorMethodCoverage value: txt. ].</body><body package="TestRunner" selector="changedListOfInstanceMethods">changedListOfInstanceMethods	| selectedCategory methods arrayOfMethods |	selectedCategory := self listInstanceCategory selection.	selectedCategory isNil		ifFalse: [			methods := selectedCategory value.			arrayOfMethods := Array new: methods size.			methods doWithIndex: [ :aMethod :index |				arrayOfMethods at: index put: (aMethod selector -&gt; aMethod) ] ]		ifTrue: [			methods := OrderedCollection new.			self listInstanceCategory list do: [ :aCategory | 				methods addAll: aCategory value ].			arrayOfMethods := Array new: methods size.			methods doWithIndex: [ :aMethod :index |				arrayOfMethods at: index put: (aMethod selector -&gt; aMethod) ] ].	self listInstanceMethod list: arrayOfMethods.</body></methods><methods><class-id>VWTestRunner.TestRunnerCodeCoverageView class</class-id> <category>initialize-release</category><body package="TestRunner" selector="on:">on: aClass	^ self new 		classCoverage: aClass;		yourself</body></methods><methods><class-id>VWTestRunner.LCodeCoverageSpec</class-id> <category>private</category><body package="TestRunner" selector="dispatchTo:with:">dispatchTo: policy with: builder	"it delegate the building task to the UILookPolicy"	policy ledCoverageView: self into: builder.</body></methods><methods><class-id>VWTestRunner.TestRunnerSelectionPackageView</class-id> <category>actions</category><body package="TestRunner" selector="filterPackageCoverage">filterPackageCoverage	| filteredPackages  filterInput |	filterInput := packageCoverageInput value.	filteredPackages := self defaultPackages.	self listPackageCoverage refreshList: filteredPackages.	filterInput isEmpty		ifFalse: [ 			filteredPackages := (self listPackageCoverage list select: [ :package | (package name asLowercase) ahsContainsString: filterInput asLowercase]) ].	self listPackageCoverage refreshList: filteredPackages.</body><body package="TestRunner" selector="runCoverageOfPackages">runCoverageOfPackages	| packageToCheckCoverage suite |	(self enableCoverage)		ifTrue: [ 			packageToCheckCoverage := self listPackageCoverage selection value.			suite := SUnit.TestSuite new.			self testCasesSelectors do: [ :test | suite addTest: test ].			coverageResult := (Spy1.SLProfilerCoverage profile: [ suite run ]				inPackagesMatching:  packageToCheckCoverage name).			self openCoverageResultWindow ]		ifFalse: [ Dialog wuiError: 'Error: Package not selected, select a package.' for: nil  ]</body></methods><methods><class-id>VWTestRunner.TestRunnerSelectionPackageView</class-id> <category>aspects</category><body package="TestRunner" selector="listPackageCoverage">listPackageCoverage	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^listPackageCoverage isNil		ifTrue:			[listPackageCoverage := SelectionInList new]		ifFalse:			[listPackageCoverage]</body><body package="TestRunner" selector="packageCoverageInput">packageCoverageInput	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^packageCoverageInput isNil		ifTrue:			[packageCoverageInput := String new asValue]		ifFalse:			[packageCoverageInput]</body></methods><methods><class-id>VWTestRunner.TestRunnerSelectionPackageView</class-id> <category>accessing</category><body package="TestRunner" selector="defaultPackages">defaultPackages	^ Store.Registry allPackages</body><body package="TestRunner" selector="testCasesSelectors">testCasesSelectors	^ testCasesSelectors</body><body package="TestRunner" selector="testCasesSelectors:">testCasesSelectors: aList	testCasesSelectors := aList</body><body package="TestRunner" selector="testSuite:">testSuite: aTestSuite	testSuite := aTestSuite</body></methods><methods><class-id>VWTestRunner.TestRunnerSelectionPackageView</class-id> <category>interface </category><body package="TestRunner" selector="postBuildWith:">postBuildWith: aBuilder	self packageCoverageInput onChangeSend: #filterPackageCoverage to: self.</body></methods><methods><class-id>VWTestRunner.TestRunnerSelectionPackageView</class-id> <category>initialize-release</category><body package="TestRunner" selector="initialize">initialize	self listPackageCoverage refreshList: self defaultPackages.	packageCoverageInput := String new asValue.</body></methods><methods><class-id>VWTestRunner.TestRunnerSelectionPackageView</class-id> <category>validations</category><body package="TestRunner" selector="enableCoverage">enableCoverage	^ self listPackageCoverage selection value isNotNil</body></methods><methods><class-id>VWTestRunner.TestRunnerSelectionPackageView</class-id> <category>actions-interface</category><body package="TestRunner" selector="openCoverageResultWindow">openCoverageResultWindow		| app win |	app := TestRunnerCodeCoverageView on: coverageResult.	app open.	win := app mainWindow.	win label: ((coverageResult methodCoverage  round: 2) asString, '% Code Coverage')</body></methods><methods><class-id>VWTestRunner.TestRunnerSelectionPackageView class</class-id> <category>initialize-release</category><body package="TestRunner" selector="on:">on: testCasesSelectors	^ self new		testCasesSelectors: testCasesSelectors;		yourself</body></methods><methods><class-id>VWTestRunner.TestRunner</class-id> <category>actions</category><body package="TestRunner" selector="assignDefectsToList">assignDefectsToList	defects isNil		ifTrue: [ 			self failedTestList list: OrderedCollection new.			self errorTestList list: OrderedCollection new ]		ifFalse: [ 				self failedTestList list: ((defects select: [ :defect | defect isKindOf: SUnit.Failure]) collect: [:t1 | (t1 definition printString) -&gt; t1 ]).			self errorTestList list: ((defects select: [ :defect | defect isKindOf: SUnit.SomeError]) collect: [:t1 | (t1 definition printString) -&gt; t1 ]). ].	^ self</body><body package="TestRunner" selector="disableOrEnableButtons">disableOrEnableButtons	(self sizeOfClassesSelected &gt; 0)		ifTrue: [ 			self enableRunningButtons ]		ifFalse: [ 			self disableRunningButtons ]</body><body package="TestRunner" selector="filterClassesOfSelectedPackages">filterClassesOfSelectedPackages	(self sizeOfPackagesSelected &gt; 0)		ifTrue: [ 			self classesOfSelectedPackages ]		ifFalse: [ 			self classesOfPackages ]</body><body package="TestRunner" selector="removeDefect:">removeDefect: aDefect	"	***This is decompiled code.*** 	No source was available"	defects remove: aDefect ifAbsent: [ nil ].	defects isEmpty ifTrue: [ 		defects := nil ].	^self</body></methods><methods><class-id>VWTestRunner.TestRunner</class-id> <category>aspects</category><body package="TestRunner" selector="classList">classList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^classList isNil		ifTrue:			[classList := MultiSelectionInList new]		ifFalse:			[classList]</body><body package="TestRunner" selector="errorTestList">errorTestList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^errorTestList isNil		ifTrue:			[errorTestList := SelectionInList new]		ifFalse:			[errorTestList]</body><body package="TestRunner" selector="failedTestList">failedTestList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^failedTestList isNil		ifTrue:			[failedTestList := SelectionInList new]		ifFalse:			[failedTestList]</body><body package="TestRunner" selector="packageList">packageList	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^packageList isNil		ifTrue:			[packageList := MultiSelectionInList new]		ifFalse:			[packageList]</body><body package="TestRunner" selector="packageSearchInput">packageSearchInput	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^packageSearchInput isNil		ifTrue:			[packageSearchInput := String new asValue]		ifFalse:			[packageSearchInput]</body><body package="TestRunner" selector="testCaseSearchInput">testCaseSearchInput	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^testCaseSearchInput isNil		ifTrue:			[testCaseSearchInput := String new asValue]		ifFalse:			[testCaseSearchInput]</body></methods><methods><class-id>VWTestRunner.TestRunner</class-id> <category>initialize-release</category><body package="TestRunner" selector="initialize">initialize	super initialize.	packageList := MultiSelectionInList with: self allPackages.	classList := MultiSelectionInList with: self allClasses</body></methods><methods><class-id>VWTestRunner.TestRunner</class-id> <category>validations</category><body package="TestRunner" selector="defectsExist">defectsExist	defects notNil ifTrue: [^defects notEmpty].	^ false</body><body package="TestRunner" selector="packageHasTestCases:">packageHasTestCases: aPackage	| classes |	classes := aPackage allDefinedClasses select: [ :class | class isTestCase ].	^ classes size &gt; 0</body></methods><methods><class-id>VWTestRunner.TestRunner</class-id> <category>interface</category><body package="TestRunner" selector="postBuildWith:">postBuildWith: aBuilder	self packageList selectionIndexHolder onChangeSend: #filterClassesOfSelectedPackages to: self.	self classList selectionIndexHolder onChangeSend: #disableOrEnableButtons to: self.	self packageSearchInput onChangeSend: #searchPackages to: self.	self testCaseSearchInput onChangeSend: #searchClasses to: self.</body></methods><methods><class-id>VWTestRunner.TestRunner</class-id> <category>actions-interface</category><body package="TestRunner" selector="deselectAllClasses">deselectAllClasses	self classList clearAll.</body><body package="TestRunner" selector="deselectAllPackages">deselectAllPackages	self packageList clearAll.	self classList refreshList: self allClasses.</body><body package="TestRunner" selector="disableAllButtons">disableAllButtons	builder isNil ifTrue: [^self].	#(RunTestButton DebugButton RunProfiledButton RunCoverageButton RunDefectsButton) do: 		[:each | (self wrapperAt: each) isEnabled: false].</body><body package="TestRunner" selector="disableRunningButtons">disableRunningButtons		#(RunTestButton RunProfiledButton RunCoverageButton) do:		[:each | 				(self wrapperAt: each) isEnabled: false ]</body><body package="TestRunner" selector="enableRunningButtons">enableRunningButtons	#(RunTestButton RunProfiledButton RunCoverageButton) do:		[:each | 				(self wrapperAt: each) isEnabled: true ]</body><body package="TestRunner" selector="openPackageSelectionWindow">openPackageSelectionWindow	(packageSelectionBuilder notNil and: [packageSelectionBuilder builder window isOpen])		ifTrue: [ 			packageSelectionBuilder testCasesSelectors: self testCasesSelectors. 			packageSelectionBuilder builder window raise ]		ifFalse: [			packageSelectionBuilder := TestRunnerSelectionPackageView on: self testCasesSelectors.			packageSelectionBuilder open. ].</body><body package="TestRunner" selector="selectAllClasses">selectAllClasses	self classList selectAll.</body><body package="TestRunner" selector="selectAllPackages">selectAllPackages	 self packageList selectAll</body><body package="TestRunner" selector="setFailedLabel">setFailedLabel	self updateForFailed.	^self</body><body package="TestRunner" selector="setLabelColor:">setLabelColor: aColor	| label |	self builder isNil ifTrue: [^self].	label := self builder componentAt: #TestResult.	label isNil ifTrue: [^self].	label lookPreferences: (label lookPreferences backgroundColor: aColor).	^self</body><body package="TestRunner" selector="setPassedLabel">setPassedLabel	self updateForPassed.	^self</body><body package="TestRunner" selector="setRunningAttributes">setRunningAttributes	self setLabelColor: ColorValue cyan.	self disableAllButtons.	defects := nil.</body><body package="TestRunner" selector="setRunningDefectsAttributes">setRunningDefectsAttributes	self setLabelColor: ColorValue cyan.	self disableAllButtons.</body><body package="TestRunner" selector="updateButtons">updateButtons	builder isNil ifTrue: [^self].	self updateRunButtons; updateDefectButtons.	^self</body><body package="TestRunner" selector="updateDefectButtons">updateDefectButtons	| enable |	enable := self defectsExist.	#(RunDefectsButton DebugButton) do:		[:each | 	(self wrapperAt: each) isEnabled: enable]</body><body package="TestRunner" selector="updateForFailed">updateForFailed	self setLabelColor: ColorValue salmon.	self updateButtons.	^self</body><body package="TestRunner" selector="updateForPassed">updateForPassed	self setLabelColor: ColorValue springGreen.	self updateButtons.	^self</body><body package="TestRunner" selector="updateForRunning">updateForRunning	self setRunningAttributes.	self setTestLabel: 'Running...'.</body><body package="TestRunner" selector="updateForRunningDefects">updateForRunningDefects	self setRunningDefectsAttributes.	self setTestLabel: 'Running...'.</body><body package="TestRunner" selector="updateRunButtons">updateRunButtons	self sizeOfClassesSelected &gt; 0		ifTrue: [			#(RunTestButton RunProfiledButton RunCoverageButton) do:				[:each | 					(self wrapperAt: each) enable]. ]</body></methods><methods><class-id>VWTestRunner.TestRunner</class-id> <category>actions-searching</category><body package="TestRunner" selector="searchClasses">searchClasses	| searchString wordArray classesFiltered allClassesOfPackages |	classesFiltered := OrderedCollection new.	allClassesOfPackages := OrderedCollection new.	searchString := self testCaseSearchInput value.	wordArray := self splitWordsOf: searchString.	self filterClassesOfSelectedPackages.	allClassesOfPackages := self classList list asOrderedCollection.	searchString isEmpty		ifFalse: 			[ wordArray 				do: [:word | 					classesFiltered addAll: 						(allClassesOfPackages 							select: [ :classes | classes name asLowercase ahsContainsString: word asLowercase])].			  self classList refreshList: classesFiltered. ].	^ self</body><body package="TestRunner" selector="searchPackages">searchPackages	| searchString wordArray packagesFiltered classesOfPackagesFiltered allPackageList |	classesOfPackagesFiltered := OrderedCollection new.	packagesFiltered := OrderedCollection new.	searchString := self packageSearchInput value.	wordArray := self splitWordsOf: searchString.	allPackageList := self allPackages.	searchString isEmpty		ifTrue: [			packagesFiltered := allPackageList ]		ifFalse: 			[ wordArray 				do: [:word | 					packagesFiltered addAll: 						(allPackageList							select: [:package | package name asLowercase ahsContainsString: word asLowercase])] ].	self packageList refreshList: packagesFiltered.	self selectedPackages isEmpty		ifTrue: [ 			packagesFiltered do: [ :package |				classesOfPackagesFiltered addAll: (package allDefinedClasses select: [ :class | class isTestCase ]) ]. ]		ifFalse: [			self selectedPackages do: [ :package |				classesOfPackagesFiltered addAll: (package allDefinedClasses select: [ :class | class isTestCase ]) ] ].	self classList refreshList: classesOfPackagesFiltered.	^ self</body><body package="TestRunner" selector="splitWordsOf:">splitWordsOf: aString	"	***This is decompiled code.*** 	No source was available"	^(aString replaceChar: $| withChar: Character space) subStrings asOrderedCollection</body></methods><methods><class-id>VWTestRunner.TestRunner</class-id> <category>accessing</category><body package="TestRunner" selector="actionLabel">actionLabel	^ actionLabel</body><body package="TestRunner" selector="actionLabel:">actionLabel: aString	actionLabel := aString.	^self</body><body package="TestRunner" selector="allClasses">allClasses	| packages classes |	packages := self allPackages.	classes := OrderedCollection new.	packages do: [ :package | classes addAll: (package allDefinedClasses select: [ :class | class isTestCase ]) ].	^ classes</body><body package="TestRunner" selector="allPackages">allPackages	| packages testPackages |	packages := Store.Registry allPackages.	testPackages := packages select: [ :package | 						package allDefinedClasses 							contains: [ :class | 								class isTestCase ] ].	^ testPackages</body><body package="TestRunner" selector="classesOfPackage:">classesOfPackage: aPackage	| listOfPackages package |	listOfPackages := self allPackages.	package := listOfPackages select: [ :pack | pack = aPackage ].	^ package allClasses</body><body package="TestRunner" selector="classesOfPackages">classesOfPackages	| listOfClasses listOfSelectedPackages |		listOfClasses := OrderedCollection new.	listOfSelectedPackages := self packageList list asOrderedCollection.	listOfSelectedPackages do: [ :package | 		listOfClasses addAll: (package allDefinedClasses select: [ :class | class isTestCase ]) ].	self classList list: listOfClasses.</body><body package="TestRunner" selector="classesOfSelectedPackages">classesOfSelectedPackages	| listOfClasses listOfSelectedPackages |	listOfClasses := OrderedCollection new.	listOfSelectedPackages := self packageList selections asOrderedCollection.	listOfSelectedPackages do: [ :package | 		listOfClasses addAll: (package allDefinedClasses select: [ :class | class isTestCase ]) ].	self classList list: listOfClasses.</body><body package="TestRunner" selector="selectedClasses">selectedClasses	^ self classList selections</body><body package="TestRunner" selector="selectedPackages">selectedPackages	^ self packageList selections</body><body package="TestRunner" selector="sizeOfClassesSelected">sizeOfClassesSelected	^ self classList selectionIndexHolder value size</body><body package="TestRunner" selector="sizeOfPackagesSelected">sizeOfPackagesSelected	^ self packageList selectionIndexHolder value size</body><body package="TestRunner" selector="testcaseResult:">testcaseResult: t1	(testCount notNil and: [testCount &gt; 0])		ifTrue: [testCount := testCount - 1].	^self</body><body package="TestRunner" selector="testCasesSelectors">testCasesSelectors	| selectorsList |	selectorsList := OrderedCollection new.	self selectedClasses do: [ :class |		selectorsList addAll: (class allTestSelectors asOrderedCollection collect: [ :selectorName | class selector: selectorName ]) ].	^ selectorsList</body></methods><methods><class-id>VWTestRunner.TestRunner</class-id> <category>actions-running</category><body package="TestRunner" selector="runDefects">runDefects	| suite |	(defects isNil or: [defects isEmpty])		ifTrue: [^self].		[self subscribeToAnnouncements.	self updateForRunningDefects.	suite := SUnit.TestSuite new.	defects do: [:t3 | suite addTest: t3 asTestCase].	testCount := defects size.	result := [suite run]				ifCurtailed: [self setTestLabel: #Failed &lt;&lt; #browser &gt;&gt; 'Failed'] ]		ensure: [SUnit.TestCase unsubscribe: self].	self setTestLabel: (#x1QPassedORFailed2pRun3pFailed4pErrors &lt;&lt; #browser &gt;&gt; '&lt;1?Passed:Failed&gt;: &lt;2p&gt; run, &lt;3p&gt; failed, &lt;4p&gt; errors'			expandMacrosWith: result allPassed			with: result ranCount			with: result failureCount			with: result errorsCount).	result allPassed		ifTrue: [ 			defects := OrderedCollection new.			self assignDefectsToList.			self updateForPassed ]		ifFalse: [ 			defects := result defects.			self assignDefectsToList.			self updateForFailed ].	^self</body><body package="TestRunner" selector="runTests">runTests	| suite selectors |	[		self subscribeToAnnouncements.		self updateForRunning.		selectors :=  self testCasesSelectors.		suite := SUnit.TestSuite new.		selectors do: [ :test | suite addTest: test ].		testCount := selectors size.		result := [suite run] ifCurtailed:  [self setTestLabel: (#Failed &lt;&lt; #browser &gt;&gt; 'Failed')].	] ensure: [SUnit.TestCase unsubscribe: self].	self 		setTestLabel: (#x1QPassedORFailed2pRun3pFailed4pErrors &lt;&lt; #browser &gt;&gt; '&lt;1?Passed:Failed&gt;: &lt;2p&gt; run, &lt;3p&gt; failed, &lt;4p&gt; errors'				expandMacrosWith: result allPassed				with: result ranCount				with: result failureCount				with: result errorsCount).	result allPassed 		ifTrue: [ 			defects := OrderedCollection new.			self assignDefectsToList.			self updateForPassed. ]		ifFalse: [ 			defects := result defects.			self assignDefectsToList.			self updateForFailed. ].</body><body package="TestRunner" selector="setSUnitLabel:">setSUnitLabel: aString	"	***This is decompiled code.*** 	No source was available"	| label |	self builder isNil ifTrue: [^self].	label := self builder componentAt: #TestResult.	label isNil ifTrue: [^self].	label widget labelString: (self actionLabel isEmpty			ifTrue: [aString]			ifFalse: [self actionLabel , aString]).	label repairDamage.	^self</body><body package="TestRunner" selector="setTestLabel:">setTestLabel: aString	self actionLabel: ''.	self setSUnitLabel: aString.	^self</body><body package="TestRunner" selector="subscribeToAnnouncements">subscribeToAnnouncements	SUnit.TestCase		unsubscribe: self from: SUnit.Result;		unsubscribe: self from: SUnit.Started;		when: SUnit.Result send: #testcaseResult: to: self</body></methods><methods><class-id>VWTestRunner.TestRunner</class-id> <category>actions-debugging</category><body package="TestRunner" selector="assignDebugLabel">assignDebugLabel	self 		setTestLabel: (#x1QPassedORFailed2pRun3pFailed4pErrors &lt;&lt; #browser 				&gt;&gt; '&lt;1?Passed:Failed&gt;: &lt;2p&gt; run, &lt;3p&gt; failed, &lt;4p&gt; errors' 					expandMacrosWith: defects isNil					with: result ranCount					with: self failedTestList list size					with: self errorTestList list size)</body><body package="TestRunner" selector="debug:">debug: aTest	"	***This is decompiled code.*** 	No source was available"	SUnit.TestCase		when: SUnit.Failure		do: [:t1 | self debugFailure: t1 exception]		for: self.	SUnit.TestCase		when: SUnit.SomeError		do: [:t2 | self debugError: t2 exception]		for: self.	[aTest debug]		ensure: [SUnit.TestCase unsubscribe: self].	^self</body><body package="TestRunner" selector="debugError:">debugError: t1 	(t1 respondsTo: #pretendDefaultAction)		ifTrue: [t1 pretendDefaultAction].	^Notifier developmentNotifier openOnException: t1</body><body package="TestRunner" selector="debugFailure:">debugFailure: t1 	| t2 t3 t4 t5 |	t3 := (t4 := self searchForFirstTestMachineryContext: t1) sender.	t1 unwindTo: t3.	t5 := Message new setSelector: t4 selector arguments: ((1 to: t4 selector numArgs)					collect: [:t6 | t4 localAt: t6]).	t3 restackMessage: t5 to: t3 receiver.	t2 := DebuggerService basicNew.	t3 jump: (t2 presendPCFor: t3)			- t3 pc.	DebuggerService		openOn: t3		exception: t1		interrupted: true.	^self</body><body package="TestRunner" selector="debugSelectedErrorTest">debugSelectedErrorTest	| selectedTest |	selectedTest := self errorTestList selection value.	self debugTest: selectedTest.</body><body package="TestRunner" selector="debugSelectedFailedTest">debugSelectedFailedTest	| selectedTest |	selectedTest := self failedTestList selection value.	self debugTest: selectedTest.</body><body package="TestRunner" selector="debugTest:">debugTest: aTest 	| test |	self updateForDebuggingDefect.	test := false.	testCount := 1.		[	[	[self subscribeToAnnouncements.	self debug: aTest asTestCase] 			ensure: [SUnit.TestCase unsubscribe: self]] 			on: Error , SUnit.FailedAssertion			do: 				[:t3 | 				test := true.				t3 pass]] 			ifCurtailed: [				self assignDebugLabel.				self setFailedLabel ].	test 		ifTrue: [			self assignDebugLabel.			self setFailedLabel ]		ifFalse: 			[self removeDefect: aTest.			self assignDefectsToList.			self assignDebugLabel.			defects isNil ifTrue: [ self setPassedLabel ] ifFalse: [ self setFailedLabel ] ].	^self</body><body package="TestRunner" selector="debugTests">debugTests	| dialog |	(defects isNil or: [defects isEmpty])		ifTrue: [^self].	(dialog := Dialog				choose: #ChooseATestToDebug &lt;&lt; #browser &gt;&gt; 'Choose A Test To Debug'				fromList: (defects collect: [ :defect | defect definition printString ])				values: defects				lines: 8				cancel: [nil]				for: Dialog defaultParentWindow) ifNotNil: [:test | self debugTest: test].	^self</body><body package="TestRunner" selector="searchForFirstTestMachineryContext:">searchForFirstTestMachineryContext: t1 	| t2 t3 |	t3 := 10.	t2 := t1 topOfContextStack.	[t3 &gt; 0 and: [t2 notNil]]		whileTrue: 			[t2 sender				ifNotNil: 					[:t4 | 					(t4 mclass inheritsFrom: SUnit.TestCase)						ifTrue: [^t2].					nil].			t2 := t2 sender.			t3 := t3 - 1].	^t1 topOfContextStack</body><body package="TestRunner" selector="updateForDebuggingDefect">updateForDebuggingDefect	self setRunningDefectsAttributes.	self setTestLabel: 'Debugging...'.</body></methods><methods><class-id>VWTestRunner.TestRunner</class-id> <category>actions-profiled</category><body package="TestRunner" selector="profileTests">profileTests	| profiler |		(profiler := #{TimeProfiler} valueOrDo: [nil]) isNil 		ifTrue: [ 			^ Dialog warn: #ProfilerNotLoadedLoad &lt;&lt; #browser &gt;&gt; 'Profiler not loaded. Load the "AT Profiling" parcel.' ].	profiler profile: [self runTests].	^self</body></methods><methods><class-id>VWTestRunner.LCodeCoverageController</class-id> <category>initialize-release</category><body package="TestRunner" selector="addBlock:">addBlock: aBlock	blocks add: aBlock.</body><body package="TestRunner" selector="blocks">blocks	^ blocks.</body><body package="TestRunner" selector="blocks:">blocks: aList		blocks := aList</body><body package="TestRunner" selector="initialize">initialize	super initialize.	self blocks: OrderedCollection new.</body></methods><methods><class-id>VWTestRunner.LCodeCoverageView</class-id> <category>private</category><body package="TestRunner" selector="controller:">controller: aController	super controller: aController.	aController initialize.</body><body package="TestRunner" selector="defaultControllerClass">defaultControllerClass	"Answer the default controller class for the receiver."		^ LCodeCoverageController</body><body package="TestRunner" selector="displayCoverage:">displayCoverage: gc	self controller blocks do:[ :block |		| color |		color :=  block wasExecuted 					ifTrue:[ ColorValue paleGreen ] 					ifFalse: [ 						((self controller blocks size) = 1)							ifTrue: [ ColorValue hex: 16rFCBDBA ]							ifFalse: [ ColorValue hex: 16rFCFE9E ] ].		self			displayFromSelectionBlock: (self characterBlockForIndex: block start)			toSelectionBlock: (self characterBlockForIndex: block stop)			on: gc			fColor: ColorValue black			bColor: color			within: gc clippingBounds. ].</body><body package="TestRunner" selector="displayOn:">displayOn: aCanvas	| gc |	super displayOn: aCanvas.	gc := self graphicsContext.	self displayCoverage: gc.</body></methods><methods><class-id>VWTestRunner.LCodeCoverageView class</class-id> <category>private</category><body package="TestRunner" selector="defaultControllerClass">defaultControllerClass	"Answer the default controller class for the receiver."	^ LCodeCoverageController</body></methods><methods><class-id>UI.UILookPolicy</class-id> <category>building</category><body package="TestRunner" selector="ledCoverageView:into:">ledCoverageView: spec into: builder		| model component menu performer alignment style |	model := spec modelInBuilder: builder.	component := VWTestRunner.LCodeCoverageView model: model.	component controller: component defaultControllerClass new.		self setHelpTextFor: spec component: component in: builder.	(menu := spec getMenuIn: builder) == nil		ifFalse: [component controller menuHolder: menu].	(performer := spec getPerformerIn: builder) == nil		ifFalse: [component controller performer:  performer].	spec isWrapped ifFalse: [component wordWrap: false].	(style := spec style) == #default		ifFalse: [self setStyleOf: component to: style].	(alignment := spec alignment) == #left		ifFalse: [self setAlignmentOf: component displayContents to: alignment].	spec isReadOnly ifFalse: [	component controller autoAccept: true].	builder component: component.	component displaySelection: false.	self setDispatcherOf: component fromSpec: spec builder: builder.	self setSecurityAspectsFor: spec component: component in: builder.	spec isReadOnly 		ifFalse:			[spec tabable				ifTrue: [component widgetState isTabStop: true.						component controller tabMeansNextField: true.						component controller tabRequiresControl: spec tabRequiresControl.						builder sendKeyboardTo: component]				ifFalse: [component widgetState canTakeFocus: true.						component controller keyboardProcessor: builder keyboardProcessor]]		ifTrue: 			[component widgetState canTakeFocus: true.			component controller keyboardProcessor: builder keyboardProcessor].	component widgetState isEnabled: spec initiallyEnabled.	builder isEditing ifFalse: [component widgetState isVisible: spec initiallyVisible].	self manufactureGeneralWrapperFor: spec  into: builder.	builder applyLayout: spec layout.	builder wrapWith: (self simpleWidgetWrapperOn: builder spec: spec)</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>semantics</category><body package="TestRunner" selector="canAccessTestRunner">canAccessTestRunner	^ (Store.Registry allPackages select: [ :package | package name ahsContainsString: 'TestRunner' ]) isNotEmpty</body></methods><methods><class-id>VWTestRunner.TestRunnerCodeCoverageView class</class-id> <category>interface specs</category><body package="TestRunner" selector="windowClassSpec">windowClassSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowClassSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 			#label: '' 			#min: #(#{Core.Point} 446 346 ) 			#max: #(#{Core.Point} 446 346 ) 			#bounds: #(#{Graphics.Rectangle} 1294 479 1740 825 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 2 0 0 0.5 -2 1 ) 					#name: #ListClassCategory 					#model: #listClassCategory 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.5 2 0 -2 1 -2 1 ) 					#name: #ListClassMethod 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) ) 					#model: #listClassMethod 					#tabable: true 					#selectionType: #highlight 					#autoSelect: true ) ) ) )</body><body package="TestRunner" selector="windowInstanceSpec">windowInstanceSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowInstanceSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 			#label: '' 			#min: #(#{Core.Point} 446 346 ) 			#max: #(#{Core.Point} 446 346 ) 			#bounds: #(#{Graphics.Rectangle} 960 475 1406 821 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 2 0 0 0.5 -2 1 ) 					#name: #ListInstanceCategory 					#model: #listInstanceCategory 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0.5 2 0 -2 1 -2 1 ) 					#name: #ListInstanceMethod 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) ) 					#model: #listInstanceMethod 					#tabable: true 					#selectionType: #highlight 					#autoSelect: true ) ) ) )</body><body package="TestRunner" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 			#label: '' 			#min: #(#{Core.Point} 709 645 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 917 164 1626 809 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 4 0 -5 1 8 0 ) 					#name: #Divider1 ) 				#(#{VWTestRunner.LCodeCoverageSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 226 0.25 -4 1 -4 1 ) 					#name: #TextEditorMethodCoverage 					#flags: 45 					#model: #textEditorMethodCoverage 					#tabable: false 					#isReadOnly: true 					#tabRequiresControl: false ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 4 0 11 0 40 0.3 222 0.25 ) 					#name: #ListClassCoverage 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) ) 					#model: #listClassCoverage 					#tabable: true 					#selectionType: #highlight 					#autoSelect: true ) 				#(#{UI.TabControlSpec} 					#layout: #(#{Graphics.LayoutFrame} 42 0.3 11 0 -4 1 222 0.25 ) 					#name: #TabControlCoverage 					#model: #tabControlCoverage 					#tabable: false 					#labels: #() ) ) ) )</body></methods><methods><class-id>VWTestRunner.TestRunnerSelectionPackageView class</class-id> <category>interface specs</category><body package="TestRunner" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'Packages' 			#min: #(#{Core.Point} 364 324 ) 			#max: #(#{Core.Point} 364 324 ) 			#bounds: #(#{Graphics.Rectangle} 960 475 1324 799 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 85 0 30 0 268 25 ) 					#name: #PackagesCoverageInput 					#model: #packageCoverageInput 					#tabable: false ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 10 0 30 0 60 25 ) 					#name: #LabelPackageFilter 					#label: 'Packages:' 					#style: #'Arbor-12' ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 2 0 58 0 360 230 ) 					#name: #ListPackageCoverage 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 7700 7700 7700 ) ) 					#model: #listPackageCoverage 					#tabable: false 					#multipleSelections: false 					#selectionType: #checkMark 					#autoSelect: false ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 55 0 6 0 241 25 ) 					#name: #LabelMessageFilterPackages 					#label: 'Select the packages to run coverage' 					#style: #'Arbor-14-Squeeze' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutSizedOrigin} 135 0 292 0 96 27 ) 					#name: #RunCoverageOfPackages 					#model: #runCoverageOfPackages 					#tabable: false 					#label: 'Run Coverage' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>VWTestRunner.TestRunner class</class-id> <category>interface specs</category><body package="TestRunner" selector="windowSpec">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 			#label: 'Test Runner' 			#min: #(#{Core.Point} 815 590 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 960 320 1773 910 ) 			#colors: 			#(#{UI.LookPreferences} 				#setForegroundColor: #(#{Graphics.ColorValue} #white ) 				#setBackgroundColor: #(#{Graphics.ColorValue} 7700 7700 7700 ) ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 -8 0.957 -1 0.2 15 0.97 ) 					#name: #RunTestButton 					#flags: 40 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 7700 7700 7700 ) ) 					#model: #runTests 					#tabable: false 					#label: 'Execute' 					#style: #'Arbor-12' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.2 -8 0.957 -3 0.4 15 0.97 ) 					#name: #RunProfiledButton 					#flags: 40 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 7700 7700 7700 ) ) 					#model: #profileTests 					#tabable: false 					#label: 'Profile' 					#style: #'Arbor-12' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} -2 0.4 -8 0.957 -5 0.6 15 0.97 ) 					#name: #RunCoverageButton 					#flags: 40 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 7700 7700 7700 ) ) 					#helpText: '' 					#model: #openPackageSelectionWindow 					#tabable: false 					#label: 'Coverage' 					#style: #'Arbor-12' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.6 -8 0.957 -1 0.8 15 0.97 ) 					#name: #DebugButton 					#flags: 40 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 7700 7700 7700 ) ) 					#model: #debugTests 					#tabable: false 					#label: 'Debug Defects' 					#style: #'Arbor-12' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 0 0.8 -8 0.957 -2 1 15 0.97 ) 					#name: #RunDefectsButton 					#flags: 40 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 7700 7700 7700 ) ) 					#model: #runDefects 					#tabable: false 					#label: 'Run Defects' 					#style: #'Arbor-12' 					#defaultable: true ) 				#(#{UI.DividerSpec} 					#layout: #(#{Graphics.LayoutFrame} -1 0.6 0 0.005 2 0.599 0 0.99 ) 					#name: #Divider1 					#orientation: #vertical ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 29 0 38 0.25 -7 0.95 ) 					#name: #PackageSelectionList 					#flags: 15 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 7700 7700 7700 ) ) 					#model: #packageList 					#tabable: false 					#menu: #packageSelectionMenu 					#multipleSelections: true 					#selectionType: #checkMark 					#autoSelect: false ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 40 0.25 29 0 -4 0.6 -7 0.95 ) 					#name: #ClassSelectionList 					#flags: 15 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 7700 7700 7700 ) ) 					#model: #classList 					#tabable: false 					#menu: #classSelectionMenu 					#multipleSelections: true 					#selectionType: #checkMark 					#autoSelect: false ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 2 0 2 0 38 0.25 27 0 ) 					#name: #PackageSearchInput 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) ) 					#helpText: 'Package #1 | Package #2' 					#model: #packageSearchInput 					#tabable: false 					#style: #'Arbor-14' ) 				#(#{UI.InputFieldSpec} 					#layout: #(#{Graphics.LayoutFrame} 40 0.25 2 0 -4 0.6 27 0 ) 					#name: #TestCaseSearchInput 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) ) 					#helpText: 'TestCase #1 | TestCase #2' 					#model: #testCaseSearchInput 					#tabable: false 					#style: #'Arbor-14' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.6 4 0 -2 1 47 0 ) 					#name: #TestResult 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 5734 5734 5734 ) ) 					#label: 'No test ran' 					#style: #'Arbor-16' ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.6 4 0 -2 1 47 0 ) 					#name: #GroupBox1 ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.6 9 0.5 -2 1 -8 0.95 ) 					#name: #ErrorTestList 					#flags: 15 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 7700 7700 7700 ) ) 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #debugSelectedErrorTest ) 					#model: #errorTestList 					#useModifierKeys: true 					#selectionType: #highlight ) 				#(#{UI.SequenceViewSpec} 					#layout: #(#{Graphics.LayoutFrame} 3 0.6 49 0 -2 1 6 0.5 ) 					#name: #FailedTestList 					#flags: 15 					#isOpaque: true 					#colors: 					#(#{UI.LookPreferences} 						#setForegroundColor: #(#{Graphics.ColorValue} #black ) 						#setBackgroundColor: #(#{Graphics.ColorValue} 7700 7700 7700 ) ) 					#callbacksSpec: 					#(#{UI.UIEventCallbackSubSpec} 						#doubleClickSelector: #debugSelectedFailedTest ) 					#model: #failedTestList 					#tabable: false 					#selectionType: #highlight 					#autoSelect: false ) ) ) )</body></methods><methods><class-id>VWTestRunner.TestRunner class</class-id> <category>resources</category><body package="TestRunner" selector="classSelectionMenu">classSelectionMenu	"Tools.MenuEditor new openOnClass: self andSelector: #classSelectionMenu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Select All' 				#value: #selectAllClasses ) 			#(#{UI.MenuItem} 				#rawLabel: 'Deselect all' 				#value: #deselectAllClasses ) ) #(2 ) nil ) decodeAsLiteralArray</body><body package="TestRunner" selector="packageSelectionMenu">packageSelectionMenu	"Tools.MenuEditor new openOnClass: self andSelector: #packageSelectionMeu"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Select All' 				#value: #selectAllPackages ) 			#(#{UI.MenuItem} 				#rawLabel: 'Deselect all' 				#value: #deselectAllPackages ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>Tools.VisualLauncher class</class-id> <category>resources</category><body package="TestRunner" selector="SemanticsMenuIcon">SemanticsMenuIcon	"Tools.UIMaskEditor new openOnClass: self andSelector: #SemanticsMenuIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 18@18 depth: 2 bitsPerPixel: 2 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5460 5460 5460 ) ) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 4111 ) ) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 8191 8191 ) ) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4111 4111 4111 ) ) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: #[254 170 90 171 240 0 0 0 234 169 86 170 176 0 0 0 234 165 5 170 176 0 0 0 234 148 81 106 176 0 0 0 234 81 84 90 176 0 0 0 234 69 5 26 176 0 0 0 233 68 1 22 176 0 0 0 229 64 16 21 176 0 0 0 214 69 20 25 112 0 0 0 214 65 69 25 112 0 0 0 229 64 64 21 176 0 0 0 233 68 1 22 176 0 0 0 234 69 5 26 176 0 0 0 234 81 84 90 176 0 0 0 234 148 81 106 176 0 0 0 234 165 5 170 176 0 0 0 234 169 86 170 176 0 0 0 254 170 90 171 240 0 0 0])</body><body package="TestRunner" selector="VWTestRunnerIcon">VWTestRunnerIcon	"Tools.UIMaskEditor new openOnClass: self andSelector: #VWTestRunnerIcon"	&lt;resource: #image&gt;	^CachedImage on: (Image extent: 19@19 depth: 3 bitsPerPixel: 4 palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5460 5460 5460 ) ) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 8191 0 ) ) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 0 ) ) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 0 0 ) ) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4111 4111 4111 ) ) ) collect: [:each | (each at: 1) value perform: (each at: 2) withArguments: (each at: 3)])) usingBits: (ByteArray fromPackedString: '@@@@@@@@@@@@@@@@ADQDADQDADQD@@@@ADQDADQDADQD@@@@ADQDADQDADQD@@@@ADQDADQD@QDQ@@@@ADQDADQD@QDQ@@@@ADQDADQD@QDQ@@@@ADQDADQD@QDQ@@@@ADQDADQD@QDQ@@@@ADQD@"H"@QDQ@@@@ADQD@"H"@QDQ@@@@ADQD@"H"@QDQ@@@@@3L3@"H"@QDQ@@@@@3L3@"H"@QDQ@@@@@3L3@"H"@QDQ@@@@@3L3@"H"@QDQ@@@@@3L3@"H"@QDQ@@@@@3L3@"H"@QDQ@@@@@@@@@@@@@@@@@@@@'))</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>semantics</category><body package="TestRunner" selector="openTestRunner">openTestRunner	&lt;menuItem: 'Test Runner'		icon: #VWTestRunnerIcon		nameKey: nil		enablement: #canAccessTestRunner		indication: nil		menu: #(#menuBar #tools #semanticsTools) 		position: 1.01&gt;	&lt;menuItem: #(#TestRunnerWindow #TestRunner 'Test Runner')		icon: #VWTestRunnerIcon		nameKey: nil		menu: #(#launcherToolBar)		position: 40.01		helpText: #(#OpenTestRunner #TestRunner 'Open Test Runner')&gt;	VWTestRunner.TestRunner open</body><body package="TestRunner" selector="semanticsTools">semanticsTools	&lt;submenu: 'Semantics Developer Tools'		nameKey: #semanticsTools		menu: #(#menuBar #tools)		position: 200.02&gt;</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>ReadOnlyTextEditorController</name><environment>UI</environment><super>UI.ParagraphEditor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>keyboardProcessor dispatcher </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>UIBasics-Controllers</category><attributes><package>UIBasics-Controllers</package></attributes></class><class><name>TextEditorSpec</name><environment>UI</environment><super>UI.MenuComponentSpec</super><private>false</private><indexed-type>none</indexed-type><inst-vars>alignment style isReadOnly tabRequiresControl isWrapped </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBuilder-Specifications</category><attributes><package>UIBuilder-Specifications</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector toolDock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>UILookPolicy</name><environment>UI</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>systemAttributes systemWidgetAttributes useSystemFontOnWidgets systemMenuAttributes </class-inst-vars><imports></imports><category>UIBuilder-Support</category><attributes><package>UIBuilder-Support</package></attributes></class><class><name>TextEditorView</name><environment>UI</environment><super>UI.ComposedTextView</super><private>false</private><indexed-type>none</indexed-type><inst-vars>state helpText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Components</category><attributes><package>UIBasics-Components</package></attributes></class></st-source>