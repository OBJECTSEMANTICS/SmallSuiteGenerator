<?xml version="1.0"?><st-source><!-- Name: SmallSuiteGenerator-ExtensionsBundleName: SmallSuiteGenerator-ExtensionsBundleStructure: a Store.BundleForParcelParcel: #('SmallSuiteGenerator-Extensions' )ParcelName: SmallSuiteGenerator-ExtensionsPrerequisiteParcels: #(#('SmallSuiteGenerator' '' ) )Date: 9:52:05 am June 5, 2020 --><time-stamp>From VisualWorksÂ®, 7.4 of December 5, 2005 on June 5, 2020 at 9:52:05 am</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SVisitorNodes</name><environment>SmallSuiteGenerator</environment><super>Refactory.Browser.RBProgramNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isAbstractt </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Extensions2</category><attributes><package>SmallSuiteGenerator-Extensions2</package></attributes></class><class><name>AbstractSmallSuiteGeneratorUI</name><environment>SmallSuiteGenerator</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packageModule packageModule1 classModule dialog generations population statements numberGenerations populationSize numberStatements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SmallSuiteGenerator-Extension-UI</package></attributes></class><class><name>SmallSuiteGeneratorGenericUI</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.AbstractSmallSuiteGeneratorUI</super><private>false</private><indexed-type>none</indexed-type><inst-vars>profiler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SmallSuiteGenerator-Extension-UI</package></attributes></class><class><name>OrderedDictionary</name><environment>Smalltalk</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>dictionary orderedKeys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SmallSuiteGenerator-Extensions</package></attributes></class><comment><class-id>OrderedDictionary</class-id><body>Missing comment</body></comment><class><name>SStateCoverage</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSimpleFitnessFunction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>class </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-Extensions2</package></attributes></class><class><name>IconsSmallSuiteGenerator</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SmallSuiteGenerator-Extension-UI</package></attributes></class><class><name>SmallSuiteGeneratorEditorUI</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.AbstractSmallSuiteGeneratorUI</super><private>false</private><indexed-type>none</indexed-type><inst-vars>documentModel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SmallSuiteGenerator-Extension-UI</package></attributes></class><shared-variable><name>PundleAccess</name><environment>SmallSuiteGenerator.STestCaseFactory</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>SmallSuiteGenerator-Extensions2</package></attributes></shared-variable><methods><class-id>SmallSuiteGenerator.SVisitorNodes</class-id> <category>visitor-double dispatching</category><body package="SmallSuiteGenerator-Extensions2" selector="acceptMessageNode:">acceptMessageNode: t1 	isAbstractt := t1 selector == #subclassResponsibility </body></methods><methods><class-id>SmallSuiteGenerator.SVisitorNodes</class-id> <category>initialize-release</category><body package="SmallSuiteGenerator-Extensions2" selector="isAbstract">isAbstract	^isAbstractt ifNil: [false] </body></methods><methods><class-id>SmallSuiteGenerator.AbstractSmallSuiteGeneratorUI</class-id> <category>interface opening</category><body package="SmallSuiteGenerator-Extension-UI" selector="openDialogInterface:">openDialogInterface: t1 	builder := (dialog := SimpleDialog new) builder.	dialog postBuildBlock: [:t2 :t3 | self postBuildWith: t3].	dialog postOpenBlock: [:t4 :t5 | self postOpenWith: t5].	dialog openFor: self interface: t1</body></methods><methods><class-id>SmallSuiteGenerator.AbstractSmallSuiteGeneratorUI</class-id> <category>initialize-release</category><body package="SmallSuiteGenerator-Extension-UI" selector="initialize">initialize	super initialize.	packageModule := EntryWithPasteButtonModule forPackages.	packageModule1 := EntryWithPasteButtonModule forPackages.	classModule := EntryWithPasteButtonModule forClasses.	generations := 20.	statements := 10.	population := 30.	numberStatements := statements asValue.	numberGenerations := generations asValue.	populationSize := population asValue</body></methods><methods><class-id>SmallSuiteGenerator.AbstractSmallSuiteGeneratorUI</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extension-UI" selector="acceptButton">acceptButton	population := self populationSize value.	generations := self numberGenerations value.	statements := self numberStatements value.	dialog accept; closeRequest</body><body package="SmallSuiteGenerator-Extension-UI" selector="cancelButton">cancelButton	self populationSize value: population.	self numberGenerations value: generations.	self numberStatements value: statements.	dialog doCancel</body><body package="SmallSuiteGenerator-Extension-UI" selector="classModule">classModule	^classModule </body><body package="SmallSuiteGenerator-Extension-UI" selector="numberGenerations">numberGenerations	^numberGenerations </body><body package="SmallSuiteGenerator-Extension-UI" selector="numberOfGenerations">numberOfGenerations	^self widgetAt: #numberGenerations </body><body package="SmallSuiteGenerator-Extension-UI" selector="numberOfPopulation">numberOfPopulation	^self widgetAt: #numberPopulation </body><body package="SmallSuiteGenerator-Extension-UI" selector="numberOfStatements">numberOfStatements	^self widgetAt: #numberStatements </body><body package="SmallSuiteGenerator-Extension-UI" selector="numberStatements">numberStatements	^numberStatements </body><body package="SmallSuiteGenerator-Extension-UI" selector="packageModule">packageModule	^packageModule </body><body package="SmallSuiteGenerator-Extension-UI" selector="packageModule1">packageModule1	^packageModule1 </body><body package="SmallSuiteGenerator-Extension-UI" selector="populationSize">populationSize	^populationSize </body></methods><methods><class-id>SmallSuiteGenerator.AbstractSmallSuiteGeneratorUI</class-id> <category>actions</category><body package="SmallSuiteGenerator-Extension-UI" selector="createTestCasesFor:">createTestCasesFor: t1 	^(STestCaseFactoryVisualWorks new) typeInfo: t1; fitness: SStatementCoverage new; targetClassName: classModule value asSymbol; targetPackageRegex: packageModule value; outputPackageName: packageModule1 value; numberOfGenerations: generations; numberOfStatements: statements; populationSize: population; createTestCases; yourself </body><body package="SmallSuiteGenerator-Extension-UI" selector="showAdvancedSettings">showAdvancedSettings	self openDialogInterface: #advancedSettings</body></methods><methods><class-id>SmallSuiteGenerator.AbstractSmallSuiteGeneratorUI class</class-id> <category>interface opening</category><body package="SmallSuiteGenerator-Extension-UI" selector="open">open	^super open </body></methods><methods><class-id>SmallSuiteGenerator.SmallSuiteGeneratorGenericUI</class-id> <category>initialize-release</category><body package="SmallSuiteGenerator-Extension-UI" selector="packagesMatchingWith:">packagesMatchingWith: t1 	^Store.Registry allPackages select: [:t2 | t1 match: t2 name asString] </body><body package="SmallSuiteGenerator-Extension-UI" selector="profilerForPackagesMatching:">profilerForPackagesMatching: t1 	profiler := Spy1.SSTypeCollector new.	Transcript show: 'profiling...'; cr.	profiler beforeProfiling.	profiler gatherForPackages: (self packagesMatchingWith: t1).	profiler install.	profiler beforeProfiling</body></methods><methods><class-id>SmallSuiteGenerator.SmallSuiteGeneratorGenericUI</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extension-UI" selector="checkInvariants">checkInvariants	self assert: classModule value isNil not description: 'Please provide a target class'.	self assert: packageModule1 value isNil not description: 'Please provide a package output'</body><body package="SmallSuiteGenerator-Extension-UI" selector="generateTests">generateTests	[Notice show: #LoadingParcelOrParcels &lt;&lt; #dialogs &gt;&gt; 'Generating tests...' while: [profiler ifNotNil: [self createTestCasesFor: (SmallSuiteGenerator.STypeInfo asTypeInfo: profiler)]]]		on: SError do: [:t1 | Dialog warn: t1 messageText withCRs]</body><body package="SmallSuiteGenerator-Extension-UI" selector="start">start	Notice show: #LoadingParcelOrParcels &lt;&lt; #dialogs &gt;&gt; 'Instrumenting...'		while: 			[profiler ifNotNil: [self uninstall].			self profilerForPackagesMatching: packageModule value]</body><body package="SmallSuiteGenerator-Extension-UI" selector="stop">stop	Notice show: #LoadingParcelOrParcels &lt;&lt; #dialogs &gt;&gt; 'Deconstructing...' while: [profiler ifNotNil: [self uninstall]]</body><body package="SmallSuiteGenerator-Extension-UI" selector="uninstall">uninstall	profiler afterProfiling; uninstall.	Transcript show: 'ended...'; cr</body></methods><methods><class-id>OrderedDictionary</class-id> <category>testing</category><body package="SmallSuiteGenerator-Extensions" selector="isDictionary">isDictionary	^true </body></methods><methods><class-id>OrderedDictionary</class-id> <category>initialize-release</category><body package="SmallSuiteGenerator-Extensions" selector="initialize">initialize	dictionary := Dictionary new: 10.	orderedKeys := Array new: 10</body></methods><methods><class-id>OrderedDictionary</class-id> <category>adding</category><body package="SmallSuiteGenerator-Extensions" selector="add:">add: value 	| size |	size := dictionary size.	dictionary add: value.	dictionary size &gt; size		ifTrue: 			[orderedKeys size &gt; size ifFalse: [self growOrderedKeys].			orderedKeys at: size + 1 put: value key].	^value</body><body package="SmallSuiteGenerator-Extensions" selector="addAll:">addAll: aColl 	aColl associationsDo: [:t2 | self add: t2].	^aColl</body></methods><methods><class-id>OrderedDictionary</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions" selector="associationAt:">associationAt: key 	^dictionary associationAt: key</body><body package="SmallSuiteGenerator-Extensions" selector="associations">associations	| t1 t2 |	t2 := Array new: self size.	t1 := 1.	self		associationsDo: 			[:t3 | 			t2 at: t1 put: t3.			t1 := t1 + 1].	^t2 </body><body package="SmallSuiteGenerator-Extensions" selector="associationsDo:">associationsDo: aBlock 	self keysDo: [:key | aBlock value: (self associationAt: key)].	^self </body><body package="SmallSuiteGenerator-Extensions" selector="at:">at: key 	^dictionary at: key </body><body package="SmallSuiteGenerator-Extensions" selector="at:ifAbsent:">at: key ifAbsent: aBlock 	^dictionary at: key ifAbsent: aBlock</body><body package="SmallSuiteGenerator-Extensions" selector="at:ifAbsentPut:">at: key ifAbsentPut: aBlock 	^self at: key ifAbsent: [self at: key put: aBlock value]</body><body package="SmallSuiteGenerator-Extensions" selector="at:ifPresent:">at: key ifPresent: aBlock 	^dictionary at: key ifPresent: aBlock</body><body package="SmallSuiteGenerator-Extensions" selector="at:put:">at: key put: value 	| size |	size := dictionary size.	dictionary at: key put: value.	dictionary size &gt; size		ifTrue: 			[orderedKeys size &gt; size ifFalse: [self growOrderedKeys].			orderedKeys at: size + 1 put: key].	^value</body><body package="SmallSuiteGenerator-Extensions" selector="do:">do: aBlock 	self valuesDo: aBlock.	^self </body><body package="SmallSuiteGenerator-Extensions" selector="encodeAsJSONDataUsing:">encodeAsJSONDataUsing: t1 	| t2 |	t1 beginObject.	t2 := 0.	(orderedKeys reject: #isNil)		do: 			[:t3 | 			| t4 |			t2 := t2 + 1.			t4 := dictionary at: t3.			t2 &gt; 1 ifTrue: [t1 emitComma].			t1 encodeKey: t3 value: t4].	t1 endObject</body><body package="SmallSuiteGenerator-Extensions" selector="growOrderedKeys">growOrderedKeys	orderedKeys := (Array new: ((orderedKeys size * 1.5) asInteger max: 10))				replaceFrom: 1				to: orderedKeys size				with: orderedKeys				startingAt: 1</body><body package="SmallSuiteGenerator-Extensions" selector="includesKey:">includesKey: key 	^dictionary includesKey: key </body><body package="SmallSuiteGenerator-Extensions" selector="keys">keys	^orderedKeys copyFrom: 1 to: self size </body><body package="SmallSuiteGenerator-Extensions" selector="keysDo:">keysDo: aBlock 	| index size |	index := 1.	size := self size.	[index &lt;= size]		whileTrue: 			[aBlock value: (orderedKeys at: index).			index := index + 1]</body><body package="SmallSuiteGenerator-Extensions" selector="size">size	^dictionary size </body><body package="SmallSuiteGenerator-Extensions" selector="values">values	^self associations collect: [:each | each value] </body></methods><methods><class-id>OrderedDictionary</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Extensions" selector="=">= another	self == another ifTrue: [^true].	(self species == another species and: [self size = another size])		ifFalse: [^false].	dictionary associationsDo: [:assoc | (another at: assoc key ifAbsent: [^false])			= assoc value			ifTrue: [nil]			ifFalse: [^false]].	^true </body><body package="SmallSuiteGenerator-Extensions" selector="hash">hash	^dictionary hash </body></methods><methods><class-id>OrderedDictionary</class-id> <category>enumerating</category><body package="SmallSuiteGenerator-Extensions" selector="collect:">collect: aBlock 	^self species newFrom: (self associations collect: [:t2 | t2 key -&gt; (aBlock value: t2 value)]) </body><body package="SmallSuiteGenerator-Extensions" selector="keysAndValuesDo:">keysAndValuesDo: aBlock 	self keysDo: [:key | aBlock value: key value: (self at: key)]</body><body package="SmallSuiteGenerator-Extensions" selector="valuesDo:">valuesDo: aBlock 	self keysDo: [:key | aBlock value: (self at: key)]</body></methods><methods><class-id>OrderedDictionary class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Extensions" selector="new">new	^super new initialize </body><body package="SmallSuiteGenerator-Extensions" selector="newFrom:">newFrom: aColl 	| aDict |	aDict := self new.	aColl associationsDo: [:each | aDict at: each key put: each value].	^aDict </body></methods><methods><class-id>SmallSuiteGenerator.SStateCoverage</class-id> <category>As yet unclassified</category><body package="SmallSuiteGenerator-Extensions2" selector="class:">class: aClass	class := aClass </body><body package="SmallSuiteGenerator-Extensions2" selector="computeFitness">computeFitness	^ profiler stateCoverageFor: class </body><body package="SmallSuiteGenerator-Extensions2" selector="fitnessOf:withKey:">fitnessOf: testCase withKey: string	testCase fitness at:string put: (profiler stateCoverageFor: class).	testCase fitnessByClass at: string put: (profiler statementCoverage1) </body><body package="SmallSuiteGenerator-Extensions2" selector="functionName">functionName	^ 'state-coverage' </body><body package="SmallSuiteGenerator-Extensions2" selector="setUp">setUp </body><body package="SmallSuiteGenerator-Extensions2" selector="tearDown">tearDown </body></methods><methods><class-id>SmallSuiteGenerator.SStateCoverage class</class-id> <category>As yet unclassified</category><body package="SmallSuiteGenerator-Extensions2" selector="for:">for: aClass	^ self new class: aClass </body></methods><methods><class-id>SmallSuiteGenerator.SmallSuiteGeneratorEditorUI</class-id> <category>initialize-release</category><body package="SmallSuiteGenerator-Extension-UI" selector="initialize">initialize	super initialize.	documentModel := Graphics.Document new asValue</body></methods><methods><class-id>SmallSuiteGenerator.SmallSuiteGeneratorEditorUI</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extension-UI" selector="document">document	^documentModel value </body><body package="SmallSuiteGenerator-Extension-UI" selector="document:">document: t1 	documentModel value: t1</body><body package="SmallSuiteGenerator-Extension-UI" selector="documentModel">documentModel	^documentModel </body><body package="SmallSuiteGenerator-Extension-UI" selector="newCode">newCode	self class compile: 'performTest	' , self document asString</body><body package="SmallSuiteGenerator-Extension-UI" selector="typeInfoFor:">typeInfoFor: t1	^STypeInfo asTypeInfo: (Spy1.SSTypeCollector profile: t1 inPackagesMatching: packageModule value) </body></methods><methods><class-id>SmallSuiteGenerator.SmallSuiteGeneratorEditorUI</class-id> <category>actions</category><body package="SmallSuiteGenerator-Extension-UI" selector="generateTests">generateTests	[Notice show: #LoadingParcelOrParcels &lt;&lt; #dialogs &gt;&gt; 'Generating tests...'		while: 			[| t1 |			self newCode.			t1 := self typeInfoFor: [self performTest].			self createTestCasesFor: t1]]		on: SError do: [:t2 | Dialog warn: t2 messageText withCRs]</body><body package="SmallSuiteGenerator-Extension-UI" selector="performTest">performTest	^self </body></methods><methods><class-id>Core.Double</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Extensions" selector="mantissaBitsAreZero">mantissaBitsAreZero	| t1 t2 | 	self isLittleEndian		ifTrue: 			[t1 := 1.			[t1 &lt;= 6]				whileTrue: 					[(self basicAt: t1)						= 0 ifFalse: [^false].					t1 := t1 + 1].			^((self basicAt: 7)				bitAnd: 15)				= 0].	t2 := 3.	[t2 &lt;= 8]		whileTrue: 			[(self basicAt: t2)				= 0 ifFalse: [^false].			t2 := t2 + 1].	^((self basicAt: 2)		bitAnd: 15)		= 0</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>copying</category><body package="SmallSuiteGenerator-Extensions" selector="allButLast">allButLast	^self allButLast: 1 </body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Extensions" selector="beginsWith:">beginsWith: t1 	| t2 t3 |	self size &lt; t1 size ifTrue: [^false].	t2 := 1.	t3 := t1 size.	[t2 &lt;= t3]		whileTrue: 			[(self at: t2)				= (t1 at: t2) ifFalse: [^false].			t2 := t2 + 1].	^true </body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions" selector="combinations:atATimeDo:">combinations: t1 atATimeDo: t2 	| t3 |	t3 := Array new: t1.	self		combinationsAt: 1		in: t3		after: 0		do: t2 </body><body package="SmallSuiteGenerator-Extensions" selector="combinationsAt:in:after:do:">combinationsAt: t1 in: t2 after: t3 do: t4 	| t5 t6 |	t5 := t3 + 1.	t6 := self size.	[t5 &lt;= t6]		whileTrue: 			[t2 at: t1 put: (self at: t5).			t1 = t2 size				ifTrue: [t4 value: t2]				ifFalse: [self						combinationsAt: t1 + 1						in: t2						after: t5						do: t4].			t5 := t5 + 1] </body></methods><methods><class-id>Core.Set</class-id> <category>removing</category><body package="SmallSuiteGenerator-Extensions" selector="=">= another	self == another ifTrue: [^true].	self species == another species ifFalse: [^false].	self size = another size ifFalse: [^false].	^self allSatisfy: [:t2 | another includes: t2] </body></methods><methods><class-id>Core.Array</class-id> <category>printing</category><body package="SmallSuiteGenerator-Extensions" selector="printOn:">printOn: aString 	| t2 |	t2 := aString position + self maxPrint.	aString nextPutAll: '#('.	self		do: 			[:t3 | 			aString position &gt; t2				ifTrue: 					[aString nextPutAll: (#etc &lt;&lt; #dialogs &gt;&gt; '...etc...') asString , ')'.					^self].			t3 printOn: aString]		separatedBy: [aString space].	aString space.	aString nextPut: $)</body><body package="SmallSuiteGenerator-Extensions" selector="storeOn:">storeOn: anObject 	self isLiteral		ifTrue: 			[anObject nextPutAll: '#('.			anObject policy printCharactersLiterally: true while: [self do: [:t2 | t2 storeOn: anObject]					separatedBy: [anObject space]].			anObject space.			anObject nextPut: $)]		ifFalse: [super storeOn: anObject]</body></methods><methods><class-id>Core.Object</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Extensions" selector="asLink">asLink	^ LinkValue value: self </body></methods><methods><class-id>Core.Object</class-id> <category>copying</category><body package="SmallSuiteGenerator-Extensions" selector="aSLProfilerCoverage">aSLProfilerCoverage	^ Spy1.SLProfilerCoverage</body></methods><methods><class-id>Core.Object</class-id> <category>controlling</category><body package="SmallSuiteGenerator-Extensions" selector="assert:description:">assert: aBoolean description: aString 	aBoolean value ifFalse: [self error: aString].	^self</body><body package="SmallSuiteGenerator-Extensions" selector="aSTypeCollectorClass">aSTypeCollectorClass	^  Spy1.SSTypeCollector</body><body package="SmallSuiteGenerator-Extensions" selector="aVariableNodeClass">aVariableNodeClass	^ Refactory.Browser.RBVariableNode</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="SmallSuiteGenerator-Extensions" selector="className">className	^self class name asString </body></methods><methods><class-id>Core.Object</class-id> <category>copying</category><body package="SmallSuiteGenerator-Extensions" selector="deepCopy">deepCopy	^ self dcopy</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="SmallSuiteGenerator-Extensions" selector="isBlock">isBlock	^false </body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="SmallSuiteGenerator-Extensions" selector="isDeprecated">isDeprecated	^false </body></methods><methods><class-id>Core.Object</class-id> <category>event accessing</category><body package="SmallSuiteGenerator-Extensions" selector="isNotNil">isNotNil	^true </body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="SmallSuiteGenerator-Extensions" selector="mutateToChange">mutateToChange	^self </body></methods><methods><class-id>Core.Object</class-id> <category>class initialization</category><body package="SmallSuiteGenerator-Extensions" selector="perform:withEnoughArguments:">perform: aSymbol withEnoughArguments: t2 	| args t4 |	args := aSymbol numArgs.	t2 size == args ifTrue: [^self perform: aSymbol withArguments: t2 asArray].	(t4 := Array new: args)		replaceFrom: 1		to: (t2 size min: t4 size)		with: t2		startingAt: 1.	^self perform: aSymbol withArguments: t4 </body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="SmallSuiteGenerator-Extensions" selector="storeOn:">storeOn: t1 	| t2 t3 t4 t5 |	SmallSuiteGenerator.SPlatform reduceLevel.	t1 nextPut: $(.	self class isVariable		ifTrue: [t1 nextPutAll: '(' , self class name , ' basicNew: '; store: self basicSize; nextPutAll: ') ']		ifFalse: [t1 nextPutAll: self class name , ' basicNew'].	SmallSuiteGenerator.SPlatform levelToPrint &lt; 0		ifFalse: 			[t2 := 1.			t3 := self class instSize.			[t2 &lt;= t3]				whileTrue: 					[t1 nextPutAll: ' instVarAt: '; store: t2; nextPutAll: ' put: '; store: (self instVarAt: t2); nextPut: $;.					t2 := t2 + 1].			t4 := 1.			t5 := self basicSize.			[t4 &lt;= t5]				whileTrue: 					[t1 nextPutAll: ' basicAt: '; store: t4; nextPutAll: ' put: '; store: (self basicAt: t4); nextPut: $;.					t4 := t4 + 1]].	t1 nextPutAll: ' yourself)'</body></methods><methods><class-id>Kernel.Context</class-id> <category>accessing-debugger</category><body package="SmallSuiteGenerator-Extensions" selector="namedTempAt:">namedTempAt: index	^ self tempAt: index</body></methods><methods><class-id>CraftedSmalltalk.AuxCodeInfoExtractor</class-id> <category>decoding</category><body package="SmallSuiteGenerator-Extensions" selector="run">run	[self atEnd]		whileFalse: 			[visited at: pc put: true.			self interpretNextInstructionFor: self.			pc &lt;= visited size ifTrue: [(visited at: pc)					ifTrue: [self endBranch]]]</body></methods><methods><class-id>SUnit.TestCase</class-id> <category>backwards compatibility</category><body package="SmallSuiteGenerator-Extensions" selector="assertCollection:includesAll:">assertCollection: t1 includesAll: t2 	^self assert: (t1 includesAll: t2)		description: [t1 asString , ' does not include all in ' , t2 asString] </body><body package="SmallSuiteGenerator-Extensions" selector="deny:equals:">deny: t1 equals: t2 	t1 = t2 ifTrue: [self signalFailure: t1 printString , ' is not equal to ' , t2 printString]</body></methods><methods><class-id>SUnit.TestCase</class-id> <category>converting</category><body package="SmallSuiteGenerator-Extensions" selector="fullNameOfClass:">fullNameOfClass: t1 	#('Core.' 'Smalltalk.' 'SmallSuiteGenerator.' ) detect: [:t2 | (Smalltalk at: t2 , t1 ifAbsent: [nil]) isNil not]		ifFound: [:t3 | ^t3 , t1 asString].	self error: 'I cant find the namespace for: ' , t1</body><body package="SmallSuiteGenerator-Extensions" selector="fullSymbolOf:">fullSymbolOf: aSymbol 	#('Core.' 'Smalltalk.' 'SmallSuiteGenerator.' ) detect: [:t2 | (Smalltalk at: t2 , aSymbol ifAbsent: [nil]) isNil not]		ifFound: [:t3 | ^(t3 , aSymbol) asSymbol].	self error: 'I cant find the namespace for: ' , aSymbol</body></methods><methods><class-id>Core.ByteString</class-id> <category>binary storage</category><body package="SmallSuiteGenerator-Extensions" selector="representBinaryOn:">representBinaryOn: t1 		^BinaryObjectStorage indexImportByteString -&gt; self</body></methods><methods><class-id>Core.Number</class-id> <category>testing</category><body package="SmallSuiteGenerator-Extensions" selector="mutateToChange">mutateToChange	^ (self perform: (SmallSuiteGenerator.SPlatform randomGenerator selectAtRandom: #(#+ #- #*))  with: (SmallSuiteGenerator.SPlatform randomGenerator selectAtRandom: (1 to: 100) asArray) )		perform: (SmallSuiteGenerator.SPlatform randomGenerator selectAtRandom: #(#+ #-))		with: 1 </body></methods><methods><class-id>Core.Link</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions" selector="asLink">asLink	^self </body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>adding</category><body package="SmallSuiteGenerator-Extensions" selector="add:afterIndex:">add: anObject afterIndex: index 	(index between: 0 and: self size)		ifFalse: [^self errorOutOfBounds].	self insert: anObject before: firstIndex + index.	^anObject </body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>enumerating</category><body package="SmallSuiteGenerator-Extensions" selector="average">average	^self sum / self size </body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>binary storage</category><body package="SmallSuiteGenerator-Extensions" selector="representBinaryOn:">representBinaryOn: t1 	^MessageSend		receiver: self class		selector: #withAll:		argument: (self isEmpty				ifTrue: [#( )]				ifFalse: [self asArray])</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>enumerating</category><body package="SmallSuiteGenerator-Extensions" selector="sum">sum	^self inject: 0 into: [:t1 :t2 | t1 + t2] </body></methods><methods><class-id>Core.ByteSymbol</class-id> <category>testing</category><body package="SmallSuiteGenerator-Extensions" selector="mutateToChange">mutateToChange	| interval stringCopy |	"correct bug to some characters form the string correctly, e.g: $-&gt; problem in a string"	interval := Character alphabet , $_ asString.	stringCopy := self 		ifEmpty: [ '' ]		ifNotEmpty: [ self copyFrom: 1 to: self size - 1 ].	^ ((SmallSuiteGenerator.SPlatform randomGenerator selectAtRandom: interval)		asString , stringCopy		,			(SmallSuiteGenerator.SPlatform randomGenerator selectAtRandom: interval) asString)		asSymbol </body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>testing</category><body package="SmallSuiteGenerator-Extensions" selector="ast">ast	^ Refactory.Browser.RBParser parseMethod: self getSource </body><body package="SmallSuiteGenerator-Extensions" selector="isAbstract">isAbstract	| t1 t2 |	t1 := Refactory.Browser.RBParser parseMethod: self getSource.	t2 := SmallSuiteGenerator.SVisitorNodes new.	t1 acceptVisitor: t2.	^t2 isAbstract </body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions" selector="isReturnField">isReturnField	| firstStm statements |	(statements := (Refactory.Browser.RBParser parseMethod: self getSource) body statements) ifEmpty: [^false].	((firstStm := statements first) isKindOf: Refactory.Browser.RBReturnNode)		ifTrue: 			[(firstStm value isKindOf: Refactory.Browser.RBVariableNode)				ifTrue: [^self mclass instVarNames includes: firstStm value token value].			^false].	^false </body><body package="SmallSuiteGenerator-Extensions" selector="origin">origin	^self mclass</body></methods><methods><class-id>Core.LimitedPrecisionReal</class-id> <category>As yet unclassified</category><body package="SmallSuiteGenerator-Extensions" selector="isBigEndian">isBigEndian	&lt;primitive: 534&gt;	self primitiveFailed.	^self </body><body package="SmallSuiteGenerator-Extensions" selector="isInfinity">isInfinity	self isSpecialValue ifTrue: [^self mantissaBitsAreZero].	^false </body><body package="SmallSuiteGenerator-Extensions" selector="isLittleEndian">isLittleEndian	^self isBigEndian not </body><body package="SmallSuiteGenerator-Extensions" selector="mantissaBitsAreZero">mantissaBitsAreZero	self subclassResponsibility.	^self </body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>dependents collection</category><body package="SmallSuiteGenerator-Extensions" selector="isNotNil">isNotNil	^false </body></methods><methods><class-id>Core.Time class</class-id> <category>TimeServicesApp(dbonly)</category><body package="SmallSuiteGenerator-Extensions" selector="new">new	^super new initialize</body></methods><methods><class-id>Core.Time</class-id> <category>TimeServicesApp(dbonly)</category><body package="SmallSuiteGenerator-Extensions" selector="initialize">initialize	hours := minutes := seconds := 0 </body></methods><methods><class-id>Core.Behavior</class-id> <category>accessing method dictionary</category><body package="SmallSuiteGenerator-Extensions" selector="allSelectorsBelow:">allSelectorsBelow: t1	| t2 |	t2 := IdentitySet new.	self withAllSuperclasses		do: 			[:t3 | 			t3 = t1 ifTrue: [^t2].			t3 selectors do: [:t4 | t2 add: t4]].	^t2 </body></methods><methods><class-id>Core.Behavior</class-id> <category>creating method dictionary</category><body package="SmallSuiteGenerator-Extensions" selector="isAbstract">isAbstract	^false </body></methods><methods><class-id>Core.Boolean</class-id> <category>testing</category><body package="SmallSuiteGenerator-Extensions" selector="mutateToChange">mutateToChange 	^self not </body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>copying</category><body package="SmallSuiteGenerator-Extensions" selector="deepCopy">deepCopy	^ self dcopy</body></methods><methods><class-id>Core.GenericException</class-id> <category>private</category><body package="SmallSuiteGenerator-Extensions" selector="performHandler:">performHandler: t1 	| t2 t3 |	(handlerContext := t1) == nil		ifTrue: 			[t2 := self defaultAction.			self isResumable				ifTrue: 					[handlerContext := initialContext.					firstUnwindContext := nil.					self unwind.					thisContext terminateTo: handlerContext.					handlerContext := nil]]		ifFalse: 			[t3 := handlerContext.			t2 := handlerContext handlerBlock cull: self.			handlerContext := t3.			self unwind.			thisContext terminateTo: handlerContext].	^t2 </body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="SmallSuiteGenerator-Extensions" selector="asString">asString	^self </body></methods><methods><class-id>Core.String</class-id> <category>testing</category><body package="SmallSuiteGenerator-Extensions" selector="mutateToChange">mutateToChange	| interval stringCopy |	"correct bug to some characters form the string correctly, e.g: $-&gt; problem in a string"	interval := (41 to: 127) asArray.	stringCopy := self		ifEmpty: [ '' ] 		ifNotEmpty: [ self copyFrom: 1 to: self size - 1 ].	^ ((Character value: (SmallSuiteGenerator.SPlatform randomGenerator selectAtRandom: interval))		asString , stringCopy		,			(Character value: (SmallSuiteGenerator.SPlatform randomGenerator selectAtRandom: interval)) asString)		asString </body></methods><methods><class-id>Core.String</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Extensions" selector="substrings:">substrings: t1	| t2 t3 t4 t5 t6 t7 |	t3 := (Array new: 10) writeStream.	t5 := 1.	t6 := self size.	[t5 &lt;= t6]		whileTrue: 			[t4 := t5.			t7 := self at: t4.			(t1 includes: t7)				ifTrue: [t2						ifNotNil: 							[t3 nextPut: (self copyFrom: t2 to: t4 - 1).							t2 := nil]]				ifFalse: [t2 ifNil: [t2 := t4]].			t5 := t5 + 1].	t2 ifNotNil: [t3 nextPut: (self copyFrom: t2 to: self size)].	^t3 contents </body></methods><methods><class-id>Core.Dictionary</class-id> <category>testing</category><body package="SmallSuiteGenerator-Extensions" selector="=">= anotherDict 	self == anotherDict ifTrue: [^true].	self species == anotherDict species ifFalse: [^false].	self size = anotherDict size ifFalse: [^false].	self keysAndValuesDo: 		[:key :value | 		(anotherDict at: key ifAbsent: [^false]) = value			ifTrue: [nil]			ifFalse: [^false]].	^true</body></methods><methods><class-id>Core.Dictionary</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions" selector="at:ifPresent:ifAbsent:">at: key ifPresent: aBlock1 ifAbsent: aBlock2 	| flag value |	flag := true.	value := self at: key ifAbsent: [flag := false].	flag ifTrue: [^aBlock1 cull: value].	^aBlock2 value</body><body package="SmallSuiteGenerator-Extensions" selector="at:ifPresent:ifAbsentPut:">at: key ifPresent: aBlock1 ifAbsentPut: aBlock2 	^self		at: key		ifPresent: aBlock1		ifAbsent: [self at: key put: aBlock2 value] </body></methods><methods><class-id>Core.Dictionary</class-id> <category>binary storage</category><body package="SmallSuiteGenerator-Extensions" selector="representBinaryOn:">representBinaryOn: t1 	| t2 |	t2 := MessageSend				receiver: self class				selector: #withAll:				argument: self associations asArray.	t1 expectCycles ifTrue: [^BinaryObjectStorage indexImportSendSelf -&gt; (Array with: #createSpecialObject: with: (BOSSSpecialObjectLoader message: t2))].	^t2</body></methods><methods><class-id>Core.Random</class-id> <category>private</category><body package="SmallSuiteGenerator-Extensions" selector="nextInt:">nextInt: anInteger 	anInteger strictlyPositive ifFalse: [self error: 'Range must be positive'].	anInteger asFloat isInfinity ifTrue: [^(self next asFraction * anInteger) truncated + 1].	^(self next * anInteger) truncated + 1 </body></methods><methods><class-id>Core.Random</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions" selector="seed:">seed: aSmallInteger	"Initialize the first random number."		seed := aSmallInteger </body></methods><methods><class-id>Core.Collection</class-id> <category>copying</category><body package="SmallSuiteGenerator-Extensions" selector="allButFirst">allButFirst	^self copyFrom: 2 to: self size </body></methods><methods><class-id>Core.Collection</class-id> <category>COMPATIBILITY-testing</category><body package="SmallSuiteGenerator-Extensions" selector="anyOne">anyOne	self emptyCheck.	self do: [:t1 | ^t1].	^self </body></methods><methods><class-id>Core.Collection</class-id> <category>copying</category><body package="SmallSuiteGenerator-Extensions" selector="copyFrom:to:">copyFrom: anIndex1 to: anIndex2 	| size |	size := anIndex2 - anIndex1 + 1.	^(self species withSize: size)		replaceFrom: 1		to: size		with: self		startingAt: anIndex1 </body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="SmallSuiteGenerator-Extensions" selector="detect:ifFound:">detect: t1 ifFound: t2 	^self		detect: t1		ifFound: t2		ifNone: [nil]</body><body package="SmallSuiteGenerator-Extensions" selector="do:displayingProgress:">do: aBlock displayingProgress: aStringOrBlock	^ self do: aBlock</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions" selector="fifth">fifth 	^self at: 5</body><body package="SmallSuiteGenerator-Extensions" selector="fourth">fourth	^self at: 4 </body></methods><methods><class-id>Core.Collection</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Extensions" selector="includesAll:">includesAll: aColl 	aColl isCollection		ifTrue: 			[aColl size &lt;= self size ifTrue: [^aColl allSatisfy: [:each | (aColl occurrencesOf: each)						&lt;= (self occurrencesOf: each)]].			^false].	^false</body><body package="SmallSuiteGenerator-Extensions" selector="includesAny:">includesAny: aColl 	aColl		do: 			[:t2 | 			(self includes: t2)				ifTrue: [^true].			nil].	^false</body></methods><methods><class-id>Core.Collection</class-id> <category>COMPATIBILITY-testing</category><body package="SmallSuiteGenerator-Extensions" selector="max">max	^self inject: self anyOne into: [:t1 :t2 | t1 max: t2] </body></methods><methods><class-id>Core.Collection</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Extensions" selector="min">min	^self inject: self anyOne into: [:t1 :t2 | t1 min: t2] </body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions" selector="second">second	^self at: 2 </body></methods><methods><class-id>Core.Collection</class-id> <category>copying</category><body package="SmallSuiteGenerator-Extensions" selector="sort:">sort: aBlock	| orderedColl |	orderedColl := SortedCollection withAll: self sortBlock: aBlock.	^ orderedColl </body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions" selector="third">third	^self at: 3 </body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="SmallSuiteGenerator-Extensions" selector="union:">union: aColl 	| aSet |	aSet := (self asSet) addAll: aColl; yourself.	^self species withAll: aSet asArray </body></methods><methods><class-id>Core.LinkValue</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Extensions" selector="=">= another 	self species == another species		ifTrue: 			[self value = another value ifTrue: [^self nextLink == another nextLink].			^false].	^false </body></methods><methods><class-id>Core.SmallDouble</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Extensions" selector="mantissaBitsAreZero">mantissaBitsAreZero	^self asDegenerateDouble mantissaBitsAreZero </body></methods><methods><class-id>Core.Float</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Extensions" selector="mantissaBitsAreZero">mantissaBitsAreZero	self isLittleEndian		ifTrue: 			[(self basicAt: 1)				= 0				ifTrue: 					[(self basicAt: 2)						= 0 ifTrue: [^((self basicAt: 3)							bitAnd: 127)							= 0].					^false].			^false].	(self basicAt: 4)		= 0		ifTrue: 			[(self basicAt: 3)				= 0 ifTrue: [^((self basicAt: 2)					bitAnd: 127)					= 0].			^false].	^false </body></methods><methods><class-id>Core.Float</class-id> <category>converting</category><body package="SmallSuiteGenerator-Extensions" selector="specialValueExponent">specialValueExponent	^128 </body></methods><methods><class-id>Core.Character</class-id> <category>testing</category><body package="SmallSuiteGenerator-Extensions" selector="mutateToChange">mutateToChange	| newValue interval |	interval := (33 to: 127) asArray. 	newValue := SmallSuiteGenerator.SPlatform randomGenerator selectAtRandom: interval.	[ newValue == self asInteger ]		whileTrue: [ newValue := SmallSuiteGenerator.SPlatform randomGenerator selectAtRandom: interval ].	^ Character value: newValue </body></methods><methods><class-id>Core.SmallInteger</class-id> <category>security</category><body package="SmallSuiteGenerator-Extensions" selector="asBigEndianByteArray">asBigEndianByteArray	| t1 t2 |	self negative ifTrue: [self errorConvertingNegativeIntegerToBytes].	self &gt; 65535 		ifTrue: 			[t1 := self bitShift: -16.			t2 := self bitAnd: 65535.			t1 &gt; 255 ifTrue: [^ByteArray					with: (t1 bitShift: -8)					with: (t1 bitAnd: 255)					with: (t2 bitShift: -8)					with: (t2 bitAnd: 255)].			^ByteArray				with: (t1 bitAnd: 255)				with: (t2 bitShift: -8)				with: (t2 bitAnd: 255)].	self &gt; 255 ifTrue: [^ByteArray with: (self bitShift: -8)			with: (self bitAnd: 255)].	^ByteArray with: (self bitAnd: 255) </body><body package="SmallSuiteGenerator-Extensions" selector="specialLeftShift:">specialLeftShift: t1 	t1 = 0 ifFalse: [^(self bitAnd: (self class leftShiftArray at: t1))			bitShift: t1]</body></methods><methods><class-id>Kernel.SequenceNode</class-id> <category>probes</category><body package="SmallSuiteGenerator-Extensions" selector="probeInfoFor:doBefore:doAfter:">probeInfoFor: t1 doBefore: aBlock1 doAfter: aBlock2  	| t4 t5 t6 t7 t8 |	sourcePosition last + 1 &lt; t1 first ifTrue: aBlock2.	t7 := [^self probeRecordAtStart].	sourcePosition first &gt; t1 first ifTrue: aBlock1.	sourcePosition first &gt; sourcePosition last ifTrue: [^self probeRecordAtStart].	(sourcePosition first = t1 first and: [self mapEntry notNil])		ifTrue: [^super probeRecordAtStart].	t8 := statements size.	t4 := 0.	t5 := 			[| t9 |			(t4 := t4 - 1) = 0 ifTrue: t7.			(t9 := (statements at: t4) probeRecordAtEnd) isNil ifFalse: [^t9].			t5 value].	^(t6 := 			[(t4 := t4 + 1) &gt; t8 ifTrue: t5.			^(statements at: t4)				probeInfoFor: t1				doBefore: t5				doAfter: t6]) value </body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>evaluating</category><body package="SmallSuiteGenerator-Extensions" selector="cull:cull:">cull: arg1 cull: arg2 	self numArgs &lt; 2 ifTrue: [^self cull: arg1].	^self value: arg1 value: arg2</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>printing</category><body package="SmallSuiteGenerator-Extensions" selector="isBlock">isBlock	^ true </body></methods><methods><class-id>Refactory.Browser.RBVariableNode</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions" selector="token">token	^token </body></methods><methods><class-id>SmallSuiteGenerator.SSTestCase</class-id> <category>actions</category><body package="SmallSuiteGenerator-Extensions2" selector="setUp">setUp	(Process allInstances select: [:t1 | t1 name ~= nil and: [(t1 name startsWith: 'FiniteStateMachine')				or: [t1 name startsWith: 'FSMTicTacToe']]])		do: [:t2 | t2 terminate]</body><body package="SmallSuiteGenerator-Extensions2" selector="tearDown">tearDown	(Process allInstances select: [:t1 | t1 name ~= nil and: [(t1 name startsWith: 'FiniteStateMachine')				or: [t1 name startsWith: 'FSMTicTacToe']]])		do: [:t2 | t2 terminate]</body></methods><methods><class-id>SmallSuiteGenerator.SStack</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions2" selector="=">= another	self == another ifTrue: [^true].	self species == another species ifFalse: [^false].	^self hasEqualElements: another </body><body package="SmallSuiteGenerator-Extensions2" selector="addFirst:">addFirst: t1	| t2 |	t2 := t1 asLink.	self isEmpty ifTrue: [lastLink := t2].	t2 nextLink: firstLink.	firstLink := t2.	^t2 </body><body package="SmallSuiteGenerator-Extensions2" selector="addLast:">addLast: t1	| t2 |	t2 := t1 asLink.	self isEmpty		ifTrue: [firstLink := t2]		ifFalse: [lastLink nextLink: t2].	lastLink := t2.	^t2 </body><body package="SmallSuiteGenerator-Extensions2" selector="hasEqualElements:">hasEqualElements: t1	| t2 t3 |	(t1 isKindOf: SequenceableCollection)		ifFalse: [^false].	(t2 := self size) = t1 size ifFalse: [^false].	t3 := 1.	[t3 &lt;= t2]		whileTrue: 			[(self at: t3) value = (t1 at: t3) value ifFalse: [^false].			t3 := t3 + 1].	^true </body><body package="SmallSuiteGenerator-Extensions2" selector="removeFirst">removeFirst	| t1 |	self emptyCheck.	t1 := firstLink.	firstLink == lastLink		ifTrue: 			[firstLink := nil.			lastLink := nil]		ifFalse: [firstLink := t1 nextLink]. 	t1 nextLink: nil.	^t1 value</body><body package="SmallSuiteGenerator-Extensions2" selector="removeLast">removeLast	| t1 t2 |	self emptyCheck.	t1 := lastLink.	firstLink == lastLink		ifTrue: 			[firstLink := nil.			lastLink := nil]		ifFalse: 			[t2 := firstLink.			[t2 nextLink == t1]				whileFalse: [t2 := t2 nextLink].			t2 nextLink: nil.			lastLink := t2].	t1 nextLink: nil.	^t1 value </body></methods><methods><class-id>SmallSuiteGenerator.STypeInfoTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Extensions2" selector="nameOf:">nameOf: aClass 	^aClass fullName asSymbol </body><body package="SmallSuiteGenerator-Extensions2" selector="testAsTypeInfoScalars">testAsTypeInfoScalars	| t1 |	t1 := STypeInfo asTypeInfo: (self aSTypeCollectorClass profile: [SConference price: 95]					onPackagesMatching: 'SmallSuiteGenerator-Scenario').	self assertCollection: (t1 scalars values flatCollect: [:t2 | t2])		hasSameElements: #(95 0 100 ).	t1 := STypeInfo asTypeInfo: (self aSTypeCollectorClass profile: [(SFoo new) returnCollection; returnFloat; returnNum; returnString]					onPackagesMatching: 'SmallSuiteGenerator-Scenario').	self assertCollection: t1 scalars associations hasSameElements: (Array			with: (self nameOf: SmallInteger)					-&gt; #(0 4 )			with: (self nameOf: OrderedCollection)					-&gt; (Array with: OrderedCollection new)			with: (self nameOf: ByteString)					-&gt; #('Hello' )			with: (self nameOf: 2.3 class)					-&gt; #(2.3 ))</body><body package="SmallSuiteGenerator-Extensions2" selector="testAsTypeInfoSConferenceOnPackagesMatching">testAsTypeInfoSConferenceOnPackagesMatching	| typeInfo messages |	typeInfo := STypeInfo asTypeInfo: (self aSTypeCollectorClass		profile: [ SConference price: 95 ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario').	messages := typeInfo messagesFrom: (self nameOf: SConference).	self		assertCollection: (messages collect: #selector)		hasSameElements: #(#initialize #price:).	self		assert:			((messages flatCollect: [ :aMessage | aMessage receiver types ])				allSatisfy: [ :aType | aType = (self nameOf: SConference) ]).	self assert: ((typeInfo messagesFrom: (self nameOf: SEvent)) allSatisfy: #isUnary).	self assert: (typeInfo messagesFrom: (self nameOf: SParty)) isEmpty.	messages := typeInfo factoryMessagesFrom: (self nameOf:  SConference).	self		assertCollection: (messages collect: #selector)		hasSameElements: #(#price:)</body><body package="SmallSuiteGenerator-Extensions2" selector="testAsTypeInfoSEventOnPackagesMatching">testAsTypeInfoSEventOnPackagesMatching	| typeInfo messages methodInfo classNameSEvent classNameSConference classNameSParty classNameByteString classNameSmallInteger classNameSStudent |	classNameSEvent := self nameOf: SEvent.	classNameSConference := self nameOf: SConference.	classNameSParty := self nameOf: SParty.	classNameByteString := self nameOf: ByteString.	classNameSmallInteger := self nameOf: SmallInteger.	classNameSStudent := self nameOf: SStudent.	typeInfo := STypeInfo asTypeInfo: (self aSTypeCollectorClass		profile: [ | aConference aPerson |			aConference := SConference new offerPrice: 95.			aPerson := SStudent new name: 'Mary'.			aConference canRegister: aPerson ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario').	self		assert: (typeInfo types at: classNameSEvent) methodTypes size		equals: 4.	self		assert: (typeInfo types at: classNameSEvent) classMethodTypes isEmpty.	self		assert: (typeInfo types at: classNameSConference) methodTypes size		equals: 5.	self		assert: (typeInfo types at: classNameSConference) classMethodTypes isEmpty.	self assert: ((typeInfo types at: classNameSParty) methodTypes allSatisfy: #isUnary).	self		assert: (typeInfo types at: classNameSParty) classMethodTypes isEmpty.	messages := typeInfo messagesFrom: classNameSConference.	self		assertCollection: (messages collect: #selector)		hasSameElements: #(#initialize #offerPrice: #canRegister: #price).	self		assert:			((messages flatCollect: [ :aMessage | aMessage receiver types ])				allSatisfy: [ :aType | aType = classNameSConference ]).	methodInfo := messages		detect: [ :aMessage | aMessage selector = #canRegister: ].	self		assertCollection: methodInfo returnType types		hasSameElements: (Array with: (self nameOf: False)).	self		assertCollection: methodInfo allArgTypes		hasSameElements: (Array with: classNameSStudent).	self		assertCollection: methodInfo allReceivers		hasSameElements: (Array with: classNameSConference).	self		assertCollection: typeInfo scalars keys		hasSameElements:			(Array				with: (self nameOf: (SUndefinedObject basicNew) class)				with: classNameSStudent				with: classNameSmallInteger				with: (self nameOf: False)				with: classNameByteString				with: (self nameOf: 2.3 class))</body><body package="SmallSuiteGenerator-Extensions2" selector="testAsTypeInfoSFoo">testAsTypeInfoSFoo	| t1 t2 t3 t4 t5 t6 t7 t8 t9 |	t4 := self nameOf: SFoo.	t5 := self nameOf: OrderedCollection.	t6 := self nameOf: Float.	t7 := self nameOf: ByteString.	t8 := self nameOf: SmallInteger.	t9 := self nameOf: Dictionary.	t1 := self aSTypeCollectorClass profile: [(SFoo new) return: Dictionary new; return: OrderedCollection new; returnFloat; returnString; returnCollection; returnNum; score; score: 5]				forClassNamed: t4.	t2 := STypeInfo asTypeInfo: t1.	self assert: (t2 types at: t4) methodTypes size equals: 8.	self assert: (t2 types at: t4) classMethodTypes size equals: 0.	self assert: (t2 methodType: #initialize from: t4) returnType type equals: t4.	t3 := t2 methodType: #return: from: t4.	self assertCollection: t3 returnType types hasSameElements: (Array with: t5 with: t9).	self assertCollection: t3 allArgTypes hasSameElements: (Array with: t5 with: t9).	self assert: (t2 methodType: #returnFloat from: t4) returnType type equals: t6.	self assert: (t2 methodType: #returnCollection from: t4) returnType type equals: t5.	self assert: (t2 methodType: #returnString from: t4) returnType type equals: t7.	self assert: (t2 methodType: #returnNum from: t4) returnType type equals: t8.	self assert: (t2 methodType: #score from: t4) returnType type equals: t8.	t3 := t2 methodType: #score: from: t4.	self assert: t3 returnType type equals: t4.	self assertCollection: t3 allArgTypes hasSameElements: (Array with: t8).	self assert: (t2 factoryMessagesFrom: t4) isEmpty.	self assertCollection: t2 scalars keys hasSameElements: (Array			with: t5			with: t9			with: t7			with: t8			with: t6)</body><body package="SmallSuiteGenerator-Extensions2" selector="testAsTypeInfoSFooOnClass">testAsTypeInfoSFooOnClass	| profile typeInfo methodInfo classNameSFoo |	classNameSFoo := self nameOf: SFoo.	profile := self aSTypeCollectorClass		profile: [ SFoo new return: OrderedCollection ]		forClassNamed: classNameSFoo.	typeInfo := STypeInfo asTypeInfo: profile.	self		assert: (typeInfo types at: classNameSFoo) methodTypes size 		equals: 7.	self		assert: (typeInfo types at: classNameSFoo) classMethodTypes isEmpty.	self		assert: (typeInfo methodType: #initialize from: classNameSFoo) returnType type		equals: classNameSFoo.	methodInfo := typeInfo methodType: #return: from: classNameSFoo.	self		assertCollection: methodInfo returnType types		hasSameElements: (Array with: (self nameOf: OrderedCollection class)).	self		assertCollection: methodInfo allArgTypes		hasSameElements: (Array with: (self nameOf: OrderedCollection class)).	self		assertCollection: ((typeInfo messagesFrom: classNameSFoo) collect: #selector)		hasSameElements: #(#returnFloat #returnCollection #initialize #returnNum #returnString #return:)</body><body package="SmallSuiteGenerator-Extensions2" selector="testAsTypeInfoSFooWithNil">testAsTypeInfoSFooWithNil	| profile typeInfo methodInfo classNameSFoo |	classNameSFoo := self nameOf: SFoo.	profile := self aSTypeCollectorClass		profile: [ SFoo new return: nil ]		forClassNamed: classNameSFoo.	typeInfo := STypeInfo asTypeInfo: profile.	self		assert: (typeInfo types at: classNameSFoo) methodTypes size		equals: 7.	self		assert: (typeInfo types at: classNameSFoo) classMethodTypes isEmpty.	self		assert: (typeInfo methodType: #initialize from: classNameSFoo) returnType type		equals: classNameSFoo.	methodInfo := typeInfo methodType: #return: from: classNameSFoo.	self		assertCollection: methodInfo returnType types		hasSameElements: (Array with: (self nameOf: UndefinedObject)).	self		assertCollection: methodInfo allArgTypes		hasSameElements: (Array with: (self nameOf: UndefinedObject)).	self		assertCollection: ((typeInfo messagesFrom: classNameSFoo) collect: #selector)		hasSameElements: #(#returnFloat #returnCollection #initialize #returnNum #returnString #return:)</body><body package="SmallSuiteGenerator-Extensions2" selector="testAsTypeInfoSTeacherOnClass">testAsTypeInfoSTeacherOnClass	| t1 t2 |	t2 := self nameOf: SSTeacher.	t1 := STypeInfo asTypeInfo: (self aSTypeCollectorClass profile: [(SSTeacher name: 'Ann' with: 34) name; nickname; yearsWorkExperience; idTeacher; id]					forClassNamed: t2).	self assertCollection: ((t1 types at: t2) methodTypes values collect: #selector)		hasSameElements: #(#idTeacher #initialize #nickname #yearsWorkExperience ).	self assert: (t1 types at: t2) classMethodTypes isEmpty.	self assertCollection: ((t1 messagesFrom: t2)			collect: #selector)		hasSameElements: #(#initialize #nickname ).	self assertCollection: ((t1 accessMessagesFrom: t2)			collect: #selector)		hasSameElements: #(#idTeacher #yearsWorkExperience )</body><body package="SmallSuiteGenerator-Extensions2" selector="testAsTypeInfoSTeacherOnPackagesMatching">testAsTypeInfoSTeacherOnPackagesMatching	| t1 |	t1 := STypeInfo asTypeInfo: (self aSTypeCollectorClass profile: [(SSTeacher name: 'Ann' with: 34) name; nickname; yearsWorkExperience; idTeacher; id]					onPackagesMatching: 'SmallSuiteGenerator-Scenario').	self assertCollection: ((t1 types at: (self nameOf: SSTeacher)) methodTypes values collect: #selector)		hasSameElements: #(#idTeacher #initialize #nickname #yearsWorkExperience ).	self assertCollection: ((t1 factoryMessagesFrom: (self nameOf: SSTeacher))			collect: #selector)		hasSameElements: #(#name:with: ).	self assertCollection: ((t1 messagesFrom: (self nameOf: SSTeacher))			collect: #selector)		hasSameElements: #(#initialize #nickname #id: #nickname: #name: ).	self assertCollection: ((t1 accessMessagesFrom: (self nameOf: SSTeacher))			collect: #selector)		hasSameElements: #(#idTeacher #yearsWorkExperience #name #id )</body><body package="SmallSuiteGenerator-Extensions2" selector="testFactoryMessages">testFactoryMessages	| t1 t2 |	t2 := self nameOf: SStudent.	t1 := STypeInfo asTypeInfo: (self aSTypeCollectorClass profile: [SStudent name: 'Mary']					forClassNamed: t2).	self assert: (t1 factoryMessagesFrom: t2) isEmpty.	t1 := STypeInfo asTypeInfo: (self aSTypeCollectorClass profile: [SStudent name: 'Mary']					onPackagesMatching: 'SmallSuiteGenerator-Scenario').	self assertCollection: ((t1 factoryMessagesFrom: t2)			collect: #selector)		hasSameElements: #(#name: ).	t1 := STypeInfo asTypeInfo: (self aSTypeCollectorClass profile: [SConference price: 95]					onPackagesMatching: 'SmallSuiteGenerator-Scenario').	self assertCollection: ((t1 factoryMessagesFrom: (self nameOf: SConference))			collect: #selector)		hasSameElements: #(#price: )</body></methods><methods><class-id>SmallSuiteGenerator.SAssertionTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Extensions2" selector="testAssertString">testAssertString	| t1 |	(t1 := SSTestCase new) addStatements: (self parse: '_var0 := 1.			 _var1 := 2.			 _var3 := Point x: _var1 y: _var0.').	t1 generateAssertions: (Array with: SStringAssertion).	self assert: t1 assertions size equals: 1.	self assert: t1 assertions first printString equals: 'self assert: _var3 printString equals: ''2@1''.' </body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifterTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Extensions2" selector="testNewFieldAccessMessageOfTypeBefore">testNewFieldAccessMessageOfTypeBefore	| testCase expression |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: (self fullSymbolOf:#SFoo).	expression := testCase addLiteral:(self fullSymbolOf: #SmallInteger).	self		should: [ testCase newFieldAccessMessageOfType: (self fullSymbolOf:#SmallInteger) before: expression ]		raise: SError.	testCase		addStatement:			(testCase				newAssignment: (testCase newFactoryMessage: (self fullSymbolOf:#SFoo) before: expression))		before: expression.	self		assert:			(testCase newFieldAccessMessageOfType: (self fullSymbolOf:#Float) before: expression)				printString		equals: '_var2 score'.	self		assertCollection: testCase printStatements		hasSameElements: (Array with: '_var1 := 7.3.'									with: '_var2 := ',(self fullNameOfClass: 'SFoo')asString,' score: _var1.'									with: '_var0 := 5.') </body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine</class-id> <category>actions</category><body package="SmallSuiteGenerator-Extensions2" selector="exportFitnessLog">exportFitnessLog	| t1 t2 t3 |	t1 := 'fitnessEvolution.txt' asFilename.	t3 := $,.	(t2 := t1 writeStream) nextPutAll: 'generation'; nextPut: t3; nextPutAll: 'bestFit'; nextPut: t3; nextPutAll: 'lowestFit'; nextPut: t3; nextPutAll: 'averageFit'; nextLine.	([self logs do: [:t5 | t2 nextPutAll: t5 generationNumber asString; nextPut: t3; nextPutAll: t5 fittestTestCase fitness values first asString; nextPut: t3; nextPutAll: t5 lowestFit values first asString; nextPut: t3; nextPutAll: t5 averageFit values first asString; nextLine]]) valueNowOrOnUnwindDo: [t2 close]</body><body package="SmallSuiteGenerator-Extensions2" selector="updateTypeInfoWith:">updateTypeInfoWith: aPopulation	"fitness profiler uninstallClass: targetClassName."   self profilerForTargetClass.   aPopulation do:		[ :aTestCase | aTestCase runWithoutAssertions ].   self mergeTypeInfo: (STypeInfo asTypeInfo: typeInfoProfiler).   self uninstall .   "fitness profiler updateClass: ((self initializeProfiler packages at:1) classes at: targetClassName). 	fitness profiler deleteCache." </body></methods><methods><class-id>SmallSuiteGenerator.SObject</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions2" selector="classOf:">classOf: aString 	| classes |	classes := self findClass: aString.	classes 		ifEmpty: [ self error: 'I cant find the class with name: ' , aString. ].	^ classes </body><body package="SmallSuiteGenerator-Extensions2" selector="findClass:">findClass: aString	| classes |	classes := Root allClasses select: [:each | aString  = each fullName or: [ (('*.', aString) match: each fullName) ]].	^ classes </body><body package="SmallSuiteGenerator-Extensions2" selector="fullNameOfClass:">fullNameOfClass: aString	| classes |	classes := self findClass: aString.	classes ifNotEmpty: [ ^ classes collect: [:cls | cls fullName ] ]		ifEmpty: [ self error: 'I cant find the namespace for: ' , aString ]</body><body package="SmallSuiteGenerator-Extensions2" selector="fullSymbolOf:">fullSymbolOf: aSymbol 	| classes |	classes := self findClass: aSymbol asString.	classes ifNotEmpty: [ ^ classes collect: [:cls | cls fullName asSymbol ] ]		ifEmpty: [ self error: 'I cant find the namespace for: ' , aSymbol ]</body><body package="SmallSuiteGenerator-Extensions2" selector="initialize">initialize	^self </body></methods><methods><class-id>SmallSuiteGenerator.SInsertTest</class-id> <category>mutation-insert</category><body package="SmallSuiteGenerator-Extensions2" selector="testInsertStatementOfSelectorRandomMessageInLiteral">testInsertStatementOfSelectorRandomMessageInLiteral	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addLiteral: (self fullSymbolOf: #Float).	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 7.3.').	self		should: [ testCase insertStatementOfSelector: #insertRandomMessage:using: ]		raise: SError </body></methods><methods><class-id>SmallSuiteGenerator.SmallTypeCollector</class-id> <category>action</category><body package="SmallSuiteGenerator-Extensions2" selector="blackList">blackList	^ #('var' 'arg' 'anObject' 't[0-9]+' 'temp') </body><body package="SmallSuiteGenerator-Extensions2" selector="classesOf:">classesOf: aString	^ Root allClasses select: [ :e |( ('*', aString asLowercase, '*') match: e fullName asLowercase) and: [ (e allSuperclasses includes: SUnit.TestCase)not  and: [e isAbstract not ] ] ]</body><body package="SmallSuiteGenerator-Extensions2" selector="cleanArgName:">cleanArgName: argName	[		((argName beginsWith:  'an') and: [ (argName at: 3) isUppercase ]) ifTrue: [			^ argName copyFrom: 3 to: argName size			 ].		((argName beginsWith:  'a') and: [ (argName at: 2) isUppercase ]) ifTrue: [ 			^ argName copyFrom: 2 to: argName size			 ].		^ argName	] on: Error do: [ ^ argName ] </body><body package="SmallSuiteGenerator-Extensions2" selector="collectArgTypesOf:">collectArgTypesOf: aCompiledMethod	| argTypes methodInfo |	argTypes := (aCompiledMethod ast argumentNames collect: [ :arg | | tempArg types |		tempArg := self cleanArgName: arg asString.		(self blackList anySatisfy: [ :e | e match: tempArg ]) ifFalse: [ 			types:=(self classesOf: tempArg) 		] ifTrue: [ types := #() ].		types]) asOrderedCollection.	argTypes add: #().	methodInfo := self methodInfoIn: aCompiledMethod from: argTypes.	^ methodInfo </body><body package="SmallSuiteGenerator-Extensions2" selector="collectTypeFrom:">collectTypeFrom: aClass	"|typeInfo|	typeInfo := STypeClassInfo newFrom: aClass name.	aClass methodDictionary values do: [ :method | 		typeInfo addMethod: (self collectArgTypesOf: method)	].	aClass class methodDictionary values do:[ :method | 		typeInfo addClassMethod: (self collectArgTypesOf: method)	].		^ typeInfo"	|  typeInfo methodInfo|	aClass isMeta ifTrue:[ ^ nil.].	typeInfo := STypeClassInfo newFrom: aClass name.	aClass methodDictionary values do:[ :method | 				methodInfo := self methodInfoIn: method.				typeInfo addMethod: methodInfo.		].	aClass class methodDictionary values do:[ :method | 						methodInfo := self methodInfoIn: method.				typeInfo addClassMethod: methodInfo.					].	^ typeInfo</body><body package="SmallSuiteGenerator-Extensions2" selector="methodInfoIn:">methodInfoIn: aCompiledMethod	| methodTypeInfo argTypes returnType |	methodTypeInfo := STypeMethodInfo new.	methodTypeInfo		selector: aCompiledMethod selector;		isQuick: aCompiledMethod isQuick;		scalars: Dictionary new;		isDeprecated: aCompiledMethod isDeprecated;		executions: 0.	argTypes := OrderedCollection new.	aCompiledMethod ast argumentNames		doWithIndex: [ :argName :index | 			| argType |			argType := SMultiTypeInfo new.			 (self fullSymbolOf: (self typeFor: argName)) do: [ :t | argType type: t].			argTypes add: argType ].	returnType := SMultiTypeInfo new.	 returnType type: aCompiledMethod mclass instanceBehavior fullName asSymbol.	"if not it is empty"	methodTypeInfo returnType: returnType.	methodTypeInfo argTypes: argTypes.	^ methodTypeInfo </body><body package="SmallSuiteGenerator-Extensions2" selector="methodInfoIn:from:">methodInfoIn: aCompiledMethod from: tempTypes	|methodTypeInfo argTypes returnType types|	methodTypeInfo := STypeMethodInfo new.	methodTypeInfo 		selector: aCompiledMethod selector;		isQuick: aCompiledMethod isQuick;		scalars: Dictionary new;		isDeprecated: aCompiledMethod isDeprecated;		executions: 0.	argTypes := OrderedCollection new.	aCompiledMethod ast argumentNames doWithIndex:[ :argName : index|			|argType|			argType := SMultiTypeInfo new.			types := (tempTypes at: index)" types".			((types size = 1) and:[types first = Object]) ifTrue:[ "name type"					argType type: (self typeFor:argName).				] ifFalse:[					types do:[ :argClass | argClass isMeta ifFalse: [ argType type: argClass fullName asSymbol ] ].								].			argTypes add: argType.		].	returnType := SMultiTypeInfo new.	types := tempTypes last "types".	((types size =1) and:[ types first = Object]) ifFalse:[		types do:[ :argClass | returnType type: argClass fullName asSymbol. ].	]. "if not it is empty"	methodTypeInfo returnType: returnType.	methodTypeInfo argTypes: argTypes.	^ methodTypeInfo</body><body package="SmallSuiteGenerator-Extensions2" selector="typeFor:">typeFor: argName	|index lastPart|	(argName = 'arg') ifTrue:[^#'SUndefinedObject'.].	"Case 1:"	(classDict at: argName asLowercase ifPresent:[ :value | ^ value name ]).	"Case 2:"	index := 1.	[(index &lt;= argName size) and:[ (argName at: index) isLowercase]] whileTrue:[ index := index + 1.].	lastPart := argName copyFrom: index to: argName size.	(classDict at: lastPart asLowercase ifPresent:[ :value | ^ value name ]).	"Case 3:"	(argName asLowercase = 'spec') ifTrue:[^ #MetacelloAbstractVersionConstructor].	"Case 4:"	('.*(b|B)lock.*' match: argName) ifTrue:[^#BlockClosure].	"Case 5:"	('.*(o|O)rderedCollection.*' match: argName) ifTrue:[^#OrderedCollection].	('.*(a|A)rray.*' match: argName) ifTrue:[^#Array].	('.*(d|D)ictionary.*' match: argName) ifTrue:[^#Dictionary].	('.*(s|S)et.*' match: argName) ifTrue:[^#Set ].	('.*(b|B)ag.*' match: argName) ifTrue:[^#Bag].	('.*(c|C)ollection.*' match: argName) ifTrue:[^#Collection].	('.*(s|S)tring.*' match: argName) ifTrue:[^#String].	('.*(s|S)ymbol.*' match: argName) ifTrue:[^#Symbol].		^ #SUndefinedObject</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>actions</category><body package="SmallSuiteGenerator-Extensions2" selector="createConfigurationMethods">createConfigurationMethods	| t1 |	t1 := self getClassOf: 'GA' , (self targetClassName substrings: '.') last , 'Test'.	setUpMethod ifNotNil: [t1 compile: setUpMethod].	tearDownMethod ifNotNil: [t1 compile: tearDownMethod]</body><body package="SmallSuiteGenerator-Extensions2" selector="export:with:">export: t1 with: t2 	| t3 |	t3 := self getClassOf: 'GA' , (self targetClassName substrings: '.') last , 'Test'.	self moveClass: t3.	[ t1 generateAssertions.	t3		compile: (SPlatform rbParserClass parseMethod: t2 , t1 printDescriptiveComment , t1 parseTreeWithAssertions body formattedCode) formattedCode		classified: ClassOrganizer defaultProtocol		notifying: SilentCompilerErrorHandler new]		on: Error		do: 			[:e || t4 |			self halt.			t4 := String with: Character cr.			t3 compile: t2 , t4 , 'self should:' , t1 parseTree formattedCode , t4 , ' raise:Error.' , t4]</body><body package="SmallSuiteGenerator-Extensions2" selector="exportFitnessLog">exportFitnessLog	| t1 t2 t3 |	t1 := 'fitnessEvolution.txt' asFilename.	t3 := $,.	(t2 := t1 writeStream) nextPutAll: 'Generation number'; nextPut: t3; nextPutAll: 'bestFit'; nextPut: t3; nextPutAll: 'lowestFit'; nextPut: t3; nextPutAll: 'averageFit'; cr.	([engine logs do: [:t5 | t2 nextPutAll: t5 generationNumber asString; nextPut: t3; nextPutAll: t5 fittestTestCase fitness values first asString; nextPut: t3; nextPutAll: t5 lowestFit values first asString; nextPut: t3; nextPutAll: t5 averageFit values first asString; cr]]) valueNowOrOnUnwindDo: [t2 close]</body><body package="SmallSuiteGenerator-Extensions2" selector="exportTests">exportTests	engine population		doWithIndex: [ :test :index | 			test lastMessage: lastMessage.			self export: test with: 'test' , index printString ].	self createConfigurationMethods </body><body package="SmallSuiteGenerator-Extensions2" selector="moveClass:">moveClass: t1 	| t2 t3 t4 t5 |	t2 := Store.Registry bundleNamed: 'SmallSuiteGenerator'.	t3 := Store.Registry packageNamedOrCreate: self outputPackageName.	Store.XMainChangeSet current moveWholeClass: t1 toPackage: t3.	(t5 := (t4 := t2 containedItems) select: [:t6 | t6 name = self outputPackageName]) isEmpty ifFalse: [t4 remove: t5 first].	t4 add: t3.	t2 containedItems: t4</body><body package="SmallSuiteGenerator-Extensions2" selector="tearDown">tearDown	self uninstall.	self exportTests.	self exportFitnessLog.	SPlatform asDict: false.	SPlatform resetRandomGenerator </body></methods><methods><class-id>SmallSuiteGenerator.SUtilityTypeInfo</class-id> <category>examples</category><body package="SmallSuiteGenerator-Extensions2" selector="typeInfoSFoo1">typeInfoSFoo1	^ STypeInfo new		type:			(self fullSymbolOf: #SFoo)				-&gt;					(Array						with:							(Array								with: #returnNum -&gt; (Array 									with: (self fullSymbolOf: #SFoo) 									with: (self fullSymbolOf: #SmallInteger) 									with: #()									with: false)								with: #returnFloat -&gt; (Array 									with: (self fullSymbolOf: #SFoo) 									with: (self fullSymbolOf: #Float) 									with: #()									with: false)								with: #returnString -&gt; (Array 									with: (self fullSymbolOf: #SFoo) 									with: (self fullSymbolOf: #ByteString) 									with: #()									with: false)								with: #score -&gt; (Array 									with: (self fullSymbolOf: #SFoo) 									with: (self fullSymbolOf: #Float) 									with: #()									with: true)								with: #return: -&gt; (Array 									with: (self fullSymbolOf: #SFoo) 									with: (self fullSymbolOf: #ByteString) 									with: (Array with: (self fullSymbolOf: #ByteString))									with: false))						with: (Array with: #score: -&gt; (Array 									with: (self fullSymbolOf: #SFoo) 									with: (self fullSymbolOf: #SFoo) 									with: (Array with: (self fullSymbolOf: #Float))									with: false)));		scalar: (self fullSymbolOf: #ByteString) with: #('hello');		scalar: (self fullSymbolOf: #SmallInteger) with: #(5);		scalar: (self fullSymbolOf: #Float) with: #(7.3) </body><body package="SmallSuiteGenerator-Extensions2" selector="typeInfoSFoo3">typeInfoSFoo3	^ STypeInfo new		type:			(self fullSymbolOf: #SFoo)				-&gt;					(Array						with:							(Array								with: #returnNum -&gt; (Array																with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #SmallInteger)																with: #()																with: false)								with: #returnFloat -&gt; (Array																with: (self fullSymbolOf:#SFoo)																with: (self fullSymbolOf:#Float)																with: #()																with: false)								with: #returnString -&gt; (Array																with: (self fullSymbolOf:#SFoo)																with: (self fullSymbolOf:#ByteString)																with: #()																with: false)								with: #score -&gt; (Array 																with: (self fullSymbolOf:#SFoo)																with: (self fullSymbolOf: #SmallInteger)																with: #()																with: true)								with: #score: -&gt; (Array																with: (self fullSymbolOf:#SFoo)																with: (self fullSymbolOf: #SFoo) 																with: (Array with: (self fullSymbolOf:#SmallInteger))																with: false))						with: (Array with: #score: -&gt; (Array 																with: (self fullSymbolOf:#SFoo)																with: (self fullSymbolOf: #SFoo)																with: (Array with: (self fullSymbolOf:#SmallInteger))																with: false)));		scalar: (self fullSymbolOf: #ByteString) with: #('Hello');		scalar: (self fullSymbolOf: #SmallInteger) with: #(4);		scalar: (self fullSymbolOf: #Float) with: #(2.3) </body><body package="SmallSuiteGenerator-Extensions2" selector="typeInfoSFooOnPackage2">typeInfoSFooOnPackage2	^ STypeInfo new		type:			(self fullSymbolOf: #SFoo)				-&gt;					(Array						with:							(Array								with: #returnFloat -&gt; (Array with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #Float)																with: #()																with: false)								with: #returnCollection -&gt; (Array with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #OrderedCollection)																with: #()																with: false)								with: #initialize -&gt; (Array with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #SFoo)																with: #()																with: false)								with: #score -&gt; (Array with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #SmallInteger)																with: #()																with: true)								with: #score: -&gt; (Array with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #SFoo)																with: (Array with: (self fullSymbolOf: #SmallInteger))																with: false)								with: #return: -&gt; (Array with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #SStudent)																with: (Array with: (self fullSymbolOf: #SStudent))																with: false))						with: (Array with: #score: -&gt; (Array with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #SFoo)																with: (Array with: (self fullSymbolOf: #SmallInteger))																with: false)));		type: (self fullSymbolOf: #SSPerson) -&gt; #(#() #());		type: (self fullSymbolOf: #SStack) -&gt; #(#() #());		type: (self fullSymbolOf: #SConference) -&gt; #(#() #());		type: (self fullSymbolOf: #SEvent) -&gt; #(#() #());		type: (self fullSymbolOf: #SSTeacher) -&gt; #(#() #());		type: (self fullSymbolOf: #SParty) -&gt; #(#() #());		type: (self fullSymbolOf: #SEventTest) -&gt; #(#() #());		scalar: (self fullSymbolOf: #SmallInteger) with: #(15);		scalar: (self fullSymbolOf: #Float) with: #(2.3);		scalar: (self fullSymbolOf: #OrderedCollection)			with: (Array with: OrderedCollection new);		scalar: (self fullSymbolOf: #Array) with: #(#(1 5 6)) </body></methods><methods><class-id>SmallSuiteGenerator.SError</class-id> <category>signaling</category><body package="SmallSuiteGenerator-Extensions2" selector="signal:">signal: aString 	SPlatform saveOnLog: aString.	self raiseSignal: aString</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCaseTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Extensions2" selector="typeInfo">typeInfo 	|typeInfo|	typeInfo := STypeInfo new		type:			(self fullSymbolOf: #SFoo)				-&gt;					(Array						with:							(Array								with: #returnNum -&gt; (Array																with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #Float)																with: #()																with: false)								with: #returnFloat -&gt; (Array																with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #Float)																with: #()																with: false)								with: #score -&gt; (Array																with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #SmallInteger)																with: #()																with: true)								with: #return: -&gt; (Array																with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #ByteString)																with: (Array with: (self fullSymbolOf: #ByteString))																with: false))						with: (Array with: #score: -&gt; (Array																with: (self fullSymbolOf: #SFoo)																with: (self fullSymbolOf: #SFoo)																with: (Array with: (self fullSymbolOf: #Float))																with: false))).	typeInfo scalar: (self fullSymbolOf: #ByteString) with: #('hello').	typeInfo scalar: (self fullSymbolOf: #SmallInteger) with: #(5).	typeInfo scalar: (self fullSymbolOf: #Float) with: #(7.3).	^ typeInfo </body></methods><methods><class-id>SmallSuiteGenerator.SPlatformVisualWorks class</class-id> <category>logging</category><body package="SmallSuiteGenerator-Extensions2" selector="classConfigurationName">classConfigurationName	^superclass fullName , self implementationType </body><body package="SmallSuiteGenerator-Extensions2" selector="createTestCaseClass:inPackage:">createTestCaseClass: t1 inPackage: t2 	| t3 t4 t5 |	(t3 := SystemUtils validateClassName: t1 for: nil) ifNil: [^nil].	^(t4 := (t5 := self testCaseClass) classBuilder addRecord: (BehaviorBuilderRecord forName: t3 in: self environment)) superclass: t5; instVarString: ''; classVarString: ''; poolString: (t5 computeFullPoolString: ''); category: t2; beFixed; reviseSystem </body><body package="SmallSuiteGenerator-Extensions2" selector="implementationType">implementationType	^'VisualWorks' </body><body package="SmallSuiteGenerator-Extensions2" selector="rbParserClass">rbParserClass	^Refactory.Browser.RBParser</body><body package="SmallSuiteGenerator-Extensions2" selector="testCaseClass">testCaseClass	^SUnit.TestCase </body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>converting</category><body package="SmallSuiteGenerator-Extensions2" selector="asTypeInfo:methodsBlacklist:">asTypeInfo: t1 methodsBlacklist: t2 	| t3 |	t3 := self class new.	t1 allClasses		do: 			[:t4 | 			t2 select: [:t5 | (t5 mclass name without: ' class') asSymbol == (t4 className substrings: '.') last asSymbol]				thenDo: [:t6 | t4 removeMethod: t6].			(t4 className endsWith: 'BlockClosure')				ifTrue: [nil]				ifFalse: [t3 addClassInfo: (STypeClassInfo asClassInfo: t4)]].	t3 joinScalars: t1 scalars copy.	^t3 </body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>adding</category><body package="SmallSuiteGenerator-Extensions2" selector="completeTypeInfo">completeTypeInfo	self types keysDo: [:aClass | |classInfo realClassInfo|	classInfo := SmallTypeCollector new collectTypeFrom: (self classOf: aClass asString) first.	realClassInfo := self types at: aClass.	classInfo methodTypes keysAndValuesDo: [ :key :value | 		((self isInBlackListClass: aClass with: key) not and: [ key isUnary not and: [ value argTypes allSatisfy: [ :arg | arg types notEmpty ] ] ]) 		ifTrue: [			realClassInfo methodTypes 			at: key			ifAbsentPut: [ 				self updateArgsOf: value.				value returnType types ifEmpty: [value returnType type: #SUndefinedObject].				value receiver type: aClass.				value hasProfiler: false.				value executions: 0.5 ] ] ] ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>as yet unclassified</category><body package="SmallSuiteGenerator-Extensions2" selector="isAbstractClass:">isAbstractClass: symbol	| aClass |	aClass := self classes at: symbol.	^  (aClass methodDictionary values select: #isAbstract) isNotEmpty</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>converting</category><body package="SmallSuiteGenerator-Extensions2" selector="updateArgsOf:">updateArgsOf: aMethod 	aMethod argTypes do: [ :argType |	| includeTypes |	includeTypes := argType types anySatisfy: [ :type | self scalars keys includes: type ].	includeTypes ifFalse: [ 		argType types do: [ :type |			(type substrings: '.') last = 'Object' ifFalse: [			self scalars keys 				select: [ :scalar | ((self classOf: type asString) first allSubclasses 					collect: [:e | e fullName asSymbol]) includes: scalar ] 				thenDo: [ :scalar | argType type: scalar ] ] ] ]] </body></methods><methods><class-id>SmallSuiteGenerator.SGAEngineTest</class-id> <category>as yet unclassified</category><body package="SmallSuiteGenerator-Extensions2" selector="profilerOf:">profilerOf: t1 	profiler beforeProfiling; gatherForPackages: (Store.Registry allPackages select: [:t2 | t1 match: t2 name asString]); install; beforeProfiling</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngineTest</class-id> <category>running</category><body package="SmallSuiteGenerator-Extensions2" selector="tearDown">tearDown	[profiler cleanInstrumentation]		on: Error do: [nil].	super tearDown</body></methods><methods><class-id>SmallSuiteGenerator.SChangeTest</class-id> <category>mutation-change</category><body package="SmallSuiteGenerator-Extensions2" selector="testChangeStatementOfFactoryMessageWithMoreThanOneLiteral">testChangeStatementOfFactoryMessageWithMoreThanOneLiteral	| testCase expression expressionChanged |	testCase := (SSTestCase with: utility typeInfoSFoo1) addTargetClassName: (self fullSymbolOf: #SFoo).	testCase		addLiteral: (self fullSymbolOf: #Float);		addLiteral: (self fullSymbolOf: #Float).	expression := testCase addFactoryMessage: (self fullSymbolOf: #SFoo) ofSelector: #score:.	self		assertCollection: (testCase statements collect: #printString)		includesAll: #('_var0 := 7.3.' '_var1 := 7.3.').	self		assert:			((Array with: '_var3 := ',(self fullNameOfClass: 'SFoo')asString,' score: _var2.')				includes: expression printString).	expressionChanged := testCase changeStatementOfVarName: '_var2'.	self		assert:			(#('_var2 := 679.9.')				includes: expressionChanged printString).	self assert: testCase validReferences </body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactoryVisualWorks</class-id> <category>actions</category><body package="SmallSuiteGenerator-Extensions2" selector="cleanInstrumentation">cleanInstrumentation	"profiler class removeFromPackages: packageInfos.	^self"</body><body package="SmallSuiteGenerator-Extensions2" selector="initializeProfiler">initializeProfiler	profiler := self aSLProfilerCoverage 	profilerForPackagesMatching: 	self targetPackageRegex.	(profiler allMethods select: #isNotMethodExtension)		do: #installGhosts		displayingProgress: 'Instrumenting ' ,		 self targetPackageRegex.</body><body package="SmallSuiteGenerator-Extensions2" selector="uninstall">uninstall	profiler uninstall</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngineExample</class-id> <category>actions</category><body package="SmallSuiteGenerator-Extensions2" selector="runOnClass:withBlock:andFitness:">runOnClass: t1 withBlock: t2 andFitness: t3 	| t4 |	(t4 := SGAEngine new) populationSize: 30; numberOfStatements: 15; blockToExecute: t2; targetClassName: t1 name.	t4 typeInfo: (Spy1.SSTypeCollector profile: t4 blockToExecute forClassNamed: t1) asTypeInfo; fitness: t3; targetClassName: t1 name; numberOfIterations: 15; run.	^t4 </body></methods><methods><class-id>SmallSuiteGenerator.AbstractSmallSuiteGeneratorUI class</class-id> <category>interface specs</category><body package="SmallSuiteGenerator-Extension-UI" selector="advancedSettings">advancedSettings	&lt;resource: #canvas&gt; 	^#(#{UI.FullSpec} #window: #(#{UI.WindowSpec} #properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) #label: 'Advanced Settings' #min: #(#{Core.Point} 20 20 ) #max: #(#{Core.Point} 0 0 ) #bounds: #(#{Graphics.Rectangle} 640 311 972 581 ) ) #component: #(#{UI.SpecCollection} #collection: #(#(#{UI.GroupBoxSpec} #layout: #(#{Graphics.LayoutFrame} 10 0 12 0 320 0 120 0 ) #name: #GroupBox2 ) #(#{UI.GroupBoxSpec} #layout: #(#{Graphics.LayoutFrame} 10 0 126 0 320 0 229 0 ) #name: #GroupBox1 ) #(#{UI.LabelSpec} #layout: #(#{Graphics.LayoutOrigin} 21 0 27 0 ) #name: #Label1 #label: 'Generations:' ) #(#{UI.LabelSpec} #layout: #(#{Graphics.LayoutOrigin} 22 0 58 0 ) #name: #Label2 #label: 'Statements:' ) #(#{UI.LabelSpec} #layout: #(#{Graphics.LayoutOrigin} 21 0 81 0 ) #name: #Label3 ) #(#{UI.SpinButtonSpec} #layout: #(#{Graphics.LayoutFrame} 119 0 26 0 305 0 47 0 ) #name: #numberGenerations #model: #numberGenerations #type: #number #low: 1 #high: 100 #interval: 1 ) #(#{UI.SpinButtonSpec} #layout: #(#{Graphics.LayoutFrame} 117 0 57 0 308 0 78 0 ) #name: #numberStatements #model: #numberStatements #type: #number #low: 1 #high: 100 #interval: 1 ) #(#{UI.LabelSpec} #layout: #(#{Graphics.LayoutOrigin} 22 0 89 0 ) #name: #Label4 #label: 'Population:' ) #(#{UI.SpinButtonSpec} #layout: #(#{Graphics.LayoutFrame} 117 0 89 0 307 0 110 0 ) #name: #numberPopulation #model: #populationSize #type: #number #low: 1 #high: 100 #interval: 1 ) #(#{UI.LabelSpec} #layout: #(#{Graphics.LayoutOrigin} 22 0 135 0 ) #name: #Label5 #label: 'Class:' ) #(#{UI.LabelSpec} #layout: #(#{Graphics.LayoutOrigin} 22 0 168 0 ) #name: #Label6 #label: 'Package(s):' ) #(#{UI.LabelSpec} #layout: #(#{Graphics.LayoutOrigin} 20 0 200 0 ) #name: #Label7 #label: 'Output package:' ) #(#{UI.SubCanvasSpec} #layout: #(#{Graphics.LayoutFrame} 117 0 194 0 311 0 222 0 ) #name: #packageModule1 #flags: 0 #majorKey: #{EntryWithPasteButtonModule} #minorKey: #windowSpec #clientKey: #packageModule1 ) #(#{UI.SubCanvasSpec} #layout: #(#{Graphics.LayoutFrame} 117 0 164 0 310 0 189 0 ) #name: #packageModule #flags: 0 #majorKey: #{EntryWithPasteButtonModule} #minorKey: #windowSpec #clientKey: #packageModule ) #(#{UI.SubCanvasSpec} #layout: #(#{Graphics.LayoutFrame} 117 0 134 0 310 0 158 0 ) #name: #classModule #flags: 0 #majorKey: #{EntryWithPasteButtonModule} #minorKey: #windowSpec #clientKey: #classModule ) #(#{UI.ActionButtonSpec} #layout: #(#{Graphics.LayoutFrame} 193 0 240 0 250 0 261 0 ) #name: #accept #model: #acceptButton #label: #(#{Kernel.UserMessage} #key: #OK #defaultString: 'OK' #catalogID: #labels ) #isDefault: true #defaultable: true ) #(#{UI.ActionButtonSpec} #layout: #(#{Graphics.LayoutFrame} 263 0 241 0 320 0 262 0 ) #model: #cancelButton #label: #(#{Kernel.UserMessage} #key: #Cancel #defaultString: 'Cancel' #catalogID: #labels ) #defaultable: true ) ) ) )</body></methods><methods><class-id>SmallSuiteGenerator.SmallSuiteGeneratorGenericUI class</class-id> <category>interface specs</category><body package="SmallSuiteGenerator-Extension-UI" selector="windowSpec">windowSpec	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} #window: #(#{UI.WindowSpec} #label: 'SmallSuiteGenerator' #min: #(#{Core.Point} 430 155 ) #max: #(#{Core.Point} 430 155 ) #bounds: #(#{Graphics.Rectangle} 576 434 1006 589 ) #flags: 4 ) #component: #(#{UI.SpecCollection} #collection: #(#(#{UI.GroupBoxSpec} #layout: #(#{Graphics.LayoutFrame} 11 0 9 0 416 0 110 0 ) #name: #GroupBox1 ) #(#{UI.LabelSpec} #layout: #(#{Graphics.LayoutOrigin} 24 0 54 0 ) #name: #Label1 #label: 'Packages:' ) #(#{UI.LabelSpec} #layout: #(#{Graphics.LayoutOrigin} 23 0 79 0 ) #name: #Label2 #label: 'Output package:' ) #(#{UI.ActionButtonSpec} #layout: #(#{Graphics.LayoutFrame} 308 0 125 0 413 0 146 0 ) #name: #ActionButton1 #model: #generateTests #label: 'Create tests' #defaultable: true ) #(#{UI.SubCanvasSpec} #layout: #(#{Graphics.LayoutFrame} 121 0 45 0 403 0 73 0 ) #name: #packageModule #flags: 0 #clientKey: #packageModule #majorKey: #{EntryWithPasteButtonModule} #minorKey: #windowSpec ) #(#{UI.SubCanvasSpec} #layout: #(#{Graphics.LayoutFrame} 122 0 75 0 403 0 100 0 ) #name: #packageModule1 #flags: 0 #clientKey: #packageModule1 #majorKey: #{EntryWithPasteButtonModule} #minorKey: #windowSpec ) #(#{UI.LabelSpec} #layout: #(#{Graphics.LayoutOrigin} 24 0 24 0 ) #name: #Label3 #label: 'For class:' ) #(#{UI.SubCanvasSpec} #layout: #(#{Graphics.LayoutFrame} 120 0 21 0 402 0 42 0 ) #name: #classModule #flags: 0 #clientKey: #classModule #majorKey: #{EntryWithPasteButtonModule} #minorKey: #windowSpec ) #(#{UI.ActionButtonSpec} #layout: #(#{Graphics.LayoutFrame} 11 0 124 0 124 0 145 0 ) #name: #ActionButton2 #model: #showAdvancedSettings #label: 'Advanced Settings' #defaultable: true ) #(#{UI.ActionButtonSpec} #layout: #(#{Graphics.LayoutFrame} 129 0 124 0 186 0 145 0 ) #name: #startButton #model: #start #label: 'Rec' #defaultable: true ) #(#{UI.ActionButtonSpec} #layout: #(#{Graphics.LayoutFrame} 190 0 124 0 247 0 145 0 ) #name: #startButton #model: #stop #label: 'Stop' #defaultable: true ) ) ) ) </body></methods><methods><class-id>IconsSmallSuiteGenerator class</class-id> <category>resources</category><body package="SmallSuiteGenerator-Extension-UI" selector="console">console	&lt;resource: #image&gt; 	^CachedImage on: (Image			extent: 32 @ 32			depth: 3			bitsPerPixel: 4			palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0 ) ) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 8191 0 ) ) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 4096 0 ) ) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191 ) ) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3072 3072 3072 ) ) ) collect: [:t1 | (t1 at: 1) value perform: (t1 at: 2)							withArguments: (t1 at: 3)]))			usingBits: (ByteArray fromPackedString: 'L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L1D3L0@@@@@@@@@@@@@@@@DRL3L@@@@@@@@@@@@@@@@QH#L3@DQDQDQDQDQDQDQAD"H3L0ACL3L3L3L3L3L3DRH!L3L@P3@3L3L3L3L3LQH"D3L3@DL0@3L3L3L3L1D"HSL3L0ACL@@3L3L3DSDRH!L3L3L@P3L@@3L3LRHQH"DCL3L3@DL3L@@3L3D"H"HP@3L3L0ACL0@CL3L3D"H!P@L3L3L@P3@@L3L3L3D"D4@CL3L3@DL0@3L0@@L3DSM@@3L3L0ACLCL3@@@@L3L3P@L3L3L@P3L3L3L3L3L3L4@CL3L3@DL3L3L3L3L3L3M@@3L3L0ADQDQDQDQDQDQDP@L3L3L@@@@@@@@@@@@@@@@CL3L3@@@@@@@@@@@@@@@@@3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3L3Lb'))</body><body package="SmallSuiteGenerator-Extension-UI" selector="rec">rec	&lt;resource: #image&gt; 	^CachedImage on: (Image			extent: 32 @ 32			depth: 2			bitsPerPixel: 2			palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(4096 0 0 ) ) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 0 0 ) ) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191 ) ) ) collect: [:t1 | (t1 at: 1) value perform: (t1 at: 2)							withArguments: (t1 at: 3)]))			usingBits: (ByteArray fromPackedString: '******************************************************* @@@@@@J***@AUUUUT***(@@@@@@R*** @@@@@AJ***@@@@@@D***(@@@@@@R*** @@@@@AJ***@@@@@@D***(@@@@@@R***!@@@@@AJ***D@@@@@D***(P@@@@@R***!@@@@@AJ***D@@@@@@***(P@@@@@B***!@@@@@@J***D@@@@@@***(P@@@@@B***!UUUU@@J***@@@@@@@**************************************************************************** @a'))</body><body package="SmallSuiteGenerator-Extension-UI" selector="tests">tests	&lt;resource: #image&gt; 	^CachedImage on: (Image			extent: 32 @ 32			depth: 3			bitsPerPixel: 4			palette: (Graphics.MappedPalette withColors: (#(#(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 0 0 ) ) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(3072 3072 3072 ) ) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(8191 8191 8191 ) ) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(5461 5461 5461 ) ) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 8191 0 ) ) #(#{Graphics.ColorValue} #scaledRed:scaledGreen:scaledBlue: #(0 4096 0 ) ) ) collect: [:t1 | (t1 at: 1) value perform: (t1 at: 2)							withArguments: (t1 at: 3)]))			usingBits: (ByteArray fromPackedString: 'H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"IEH"H"L3L3L3L3L3L2H"H$URH"H#DQDQDQDQDQD"H"QUT"H"H1@@@@@@@@@@H"IEUTH"H"LP@@@@@@@@@BH$UUP"H"H#D@DQDQDQDQD"QUUBH"H"H1@AH"H"H"H"IEUTH"H"H"LP@RH"H"H"H$UUP"H"H"H#D@D"H"H"H"QUUBH"H"H"H1@AH"H"H"IEUTH"H"H"H"LP@RH$P"H$UUP"D@D2H"H#D@D"QUP"QUUBH!@AL"H"H1@AH$UUQEUTH"HP@SH"H"LP@RH$UUUUP"H"D@D2H"H#D@D"H$UUUBH"H!@AL"H"H1@AH"H$UTH"H"HP@SH"H"LP@RH"H$P"H"H"D@D2H"H#D@D"H"H"H"H"H!@AL"H"H1@AH"H"H"H"H"HP@SH"H"LP@RH"H"H"H"H"D@D2H"H#D@D3L3L3L3L3L1@AL"H"H1@ADQDQDQDQDQDP@SH"H"LP@@@@@@@@@@@@@@D2H"H#D@@@@@@@@@@@@@@AL"H"H1DQDQDQDQDQDQDQDSH"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"H"Hb'))</body></methods><methods><class-id>SmallSuiteGenerator.SmallSuiteGeneratorEditorUI class</class-id> <category>resources</category><body package="SmallSuiteGenerator-Extension-UI" selector="menuBar">menuBar	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(#(#{UI.MenuItem} #rawLabel: 'Settings' ) #(#{UI.MenuItem} #rawLabel: 'Help' ) ) #(2 ) nil ) decodeAsLiteralArray </body></methods><methods><class-id>SmallSuiteGenerator.SmallSuiteGeneratorEditorUI class</class-id> <category>interface specs</category><body package="SmallSuiteGenerator-Extension-UI" selector="windowSpec">windowSpec	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} #window: #(#{UI.WindowSpec} #label: 'SmallSuiteGenerator' #min: #(#{Core.Point} 577 422 ) #max: #(#{Core.Point} 577 422 ) #bounds: #(#{Graphics.Rectangle} 687 239 1264 661 ) #flags: 4 ) #component: #(#{UI.SpecCollection} #collection: #(#(#{Refactory.Browser.SourceCodeEditorSpec} #properties: #(#{UI.PropertyListDictionary} #dropSelector #drop: #dragOverSelector #dragOver: #dragEnterSelector #dragEntry: ) #layout: #(#{Graphics.LayoutFrame} 2 0 39 0 584 0 366 0 ) #name: #document #flags: 15 #isOpaque: true #model: #documentModel #isWrapped: true #isReadOnly: false #showHiddenCharacters: false #showLineStriping: false #autoAccept: true #continuousAccept: false #showInputCursor: true #showSelection: true ) #(#{UI.LabelSpec} #layout: #(#{Graphics.LayoutOrigin} 11 0 376 0 ) #name: #Label1 #label: 'Packages:' ) #(#{UI.LabelSpec} #layout: #(#{Graphics.LayoutOrigin} 298 0 376 0 ) #name: #Label2 #label: 'Output package:' ) #(#{UI.ActionButtonSpec} #layout: #(#{Graphics.LayoutFrame} 5 0 11 0 110 0 32 0 ) #name: #ActionButton1 #model: #generateTests #label: 'Create tests' #defaultable: true ) #(#{UI.SubCanvasSpec} #layout: #(#{Graphics.LayoutFrame} 7 0 387 0 289 0 415 0 ) #name: #packageModule #flags: 0 #majorKey: #{EntryWithPasteButtonModule} #minorKey: #windowSpec #clientKey: #packageModule ) #(#{UI.SubCanvasSpec} #layout: #(#{Graphics.LayoutFrame} 296 0 392 0 564 0 417 0 ) #name: #packageModule1 #flags: 0 #majorKey: #{EntryWithPasteButtonModule} #minorKey: #windowSpec #clientKey: #packageModule1 ) #(#{UI.LabelSpec} #layout: #(#{Graphics.LayoutOrigin} 233 0 14 0 ) #name: #Label3 #label: 'For class:' ) #(#{UI.SubCanvasSpec} #layout: #(#{Graphics.LayoutFrame} 293 0 16 0 566 0 34 0 ) #name: #classModule #flags: 0 #majorKey: #{EntryWithPasteButtonModule} #minorKey: #windowSpec #clientKey: #classModule ) #(#{UI.ActionButtonSpec} #layout: #(#{Graphics.LayoutFrame} 116 0 11 0 229 0 32 0 ) #name: #ActionButton2 #model: #showAdvancedSettings #label: 'Advanced Settings' #defaultable: true ) ) ) ) </body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>toolbar</category><body package="SmallSuiteGenerator-Extension-UI" selector="toolbarItemNewSmallSuiteGenerator">toolbarItemNewSmallSuiteGenerator	&lt;menuItem: #(#NewCanvas #UIPainter 'New SmallSuite' ) icon: #newSmallSuiteIcon nameKey: nil menu: #(#launcherToolBar ) position: 45.01 helpText: #(#EditANewCanvas #UIPainter 'Open generator of tests' )&gt;	self applicationForClassNamed: #{SmallSuiteGenerator.SmallSuiteGeneratorGenericUI} do: [:t1 | t1 open]</body><body package="SmallSuiteGenerator-Extension-UI" selector="toolbarItemNewSmallSuiteGeneratorEditor">toolbarItemNewSmallSuiteGeneratorEditor	&lt;menuItem: #(#NewCanvas #UIPainter 'New SmallSuite' ) icon: #newSmallSuiteEditorIcon nameKey: nil menu: #(#launcherToolBar ) position: 45.02 helpText: #(#EditANewCanvas #UIPainter 'Open generator of tests with editor' )&gt;	self applicationForClassNamed: #{SmallSuiteGenerator.SmallSuiteGeneratorEditorUI} do: [:t1 | t1 open]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Time</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hours minutes seconds </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Context</name><environment>Kernel</environment><super>Kernel.InstructionStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sender receiver stackp stack </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Random</name><environment>Core</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>seed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>RBVariableNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>token </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector toolDock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SObject</name><environment>SmallSuiteGenerator</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><class><name>SSTestCase</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSTestShifter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>idPopulation previousOpenWindows summaryExecutionMethods generationNumber hasErrors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><class><name>SGAEngine</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>populationSize mutationOperator crossoverOperator numberOfStatements population logs typeInfo fitness selectionStrategy targetClassName numberOfGenerations lastMessage packageRegex initialPopulation typeInfoProfiler targetPackageRegex elitismRate crossoverRate stopIterations </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><class><name>SGAEngineExample</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SStack</name><environment>SmallSuiteGenerator</environment><super>Core.LinkedList</super><private>false</private><indexed-type>none</indexed-type><inst-vars>firstLinkStack lastLinkStack </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario</category><attributes><package>SmallSuiteGenerator-Scenario</package></attributes></class><class><name>SequenceNode</name><environment>Kernel</environment><super>Kernel.ValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>temporaries statements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>GenericException</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messageText originator initialContext firstUnwindContext handlerContext parameter proceedBlock isResumable signal searchContext </inst-vars><class-inst-vars>notifierString </class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>SError</name><environment>SmallSuiteGenerator</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><class><name>Link</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nextLink </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>LinkValue</name><environment>Core</environment><super>Core.Link</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>OrderedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>firstIndex lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>LimitedPrecisionReal</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SmallDouble</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SmallTypeCollector</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>classDict </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-SmallType</category><attributes><package>SmallSuiteGenerator-SmallType</package></attributes></class><class><name>ByteSymbol</name><environment>Core</environment><super>Core.Symbol</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>STestCaseFactory</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>reportClass engine typeInfo targetClassName targetPackageRegex outputPackageName fitness numberOfIterations profiler setUpMethod tearDownMethod lastMessage asDict fitnessSeed typeInfoSeed firstExecution </inst-vars><class-inst-vars>instance </class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><class><name>STestCaseFactoryVisualWorks</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.STestCaseFactory</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>RBProgramNodeVisitor</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><class><name>ProbedCompiledMethod</name><environment>CraftedSmalltalk</environment><super>Kernel.CompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>original methodHolder probeStart </inst-vars><class-inst-vars>removedProbedMethodsHolder </class-inst-vars><imports>			OpcodePool.*			</imports><category>CraftedSt-VM</category><attributes><package>Debugger-Probes</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Double</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>STypeInfo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>types classes noneAbstractClasses scalars blackList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Info</category><attributes><package>SmallSuiteGenerator-Info</package></attributes></class><class><name>AuxCodeInfoExtractor</name><environment>CraftedSmalltalk</environment><super>Kernel.InstructionStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>depth jumpStack maxDepth visited </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-VM</category><attributes><package>Debugger-Probes</package></attributes></class><class><name>Float</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Array</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>SUtilityTypeInfo</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Utility</category><attributes><package>SmallSuiteGenerator-Tests-Utility</package></attributes></class><class><name>SSTestShifterTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SmallSuiteGenerator-Tests-Core</package></attributes></class><class><name>SAssertionTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpressionTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-AST</category><attributes><package>SmallSuiteGenerator-Tests-AST</package></attributes></class><class><name>SGAEngineTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>engine profiler utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-GA</category><attributes><package>SmallSuiteGenerator-Tests-GA</package></attributes></class><class><name>SSTestCaseTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SmallSuiteGenerator-Tests-Core</package></attributes></class><class><name>SChangeTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSTestCaseTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SmallSuiteGenerator-Tests-Core</package></attributes></class><class><name>SInsertTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSTestCaseTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SmallSuiteGenerator-Tests-Core</package></attributes></class><class><name>ByteString</name><environment>Core</environment><super>Core.ByteEncodedString</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>SmallInteger</name><environment>Core</environment><super>Core.Integer</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars>minVal maxVal maxBits maxBytes </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>STypeInfoTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Info</category><attributes><package>SmallSuiteGenerator-Tests-Info</package></attributes></class><class><name>SSimpleFitnessFunction</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SFitnessFunction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>profiler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class></st-source>