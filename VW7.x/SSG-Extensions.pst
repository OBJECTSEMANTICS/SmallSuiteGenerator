<?xml version="1.0"?><st-source><!-- Name: SSG-ExtensionsBundleName: SSG-ExtensionsBundleStructure: a Store.BundleForParcelParcel: #('SSG-Extensions' )ParcelName: SSG-ExtensionsDate: 1:14:28 pm July 13, 2020 --><time-stamp>From VisualWorksÂ®, 7.4 of December 5, 2005 on July 13, 2020 at 1:14:28 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>OrderedDictionary</name><environment>Smalltalk</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>dictionary orderedKeys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SSG-Extensions</package></attributes></class><comment><class-id>OrderedDictionary</class-id><body>Missing comment</body></comment><class><name>SVisitorNodes</name><environment>SmallSuiteGenerator</environment><super>Refactory.Browser.RBProgramNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isAbstractt </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Extensions2</category><attributes><package>SSG-Extensions2</package></attributes></class><class><name>SStateCoverage</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSimpleFitnessFunction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>class </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SSG-Extensions2</package></attributes></class><class><name>SConfigGenerationTestCase</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>typeInfos defaultTypeInfo </class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SSG-Extensions2</package></attributes></class><shared-variable><name>PundleAccess</name><environment>SmallSuiteGenerator.STestCaseFactory</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>SSG-Extensions2</package></attributes></shared-variable><methods><class-id>OrderedDictionary</class-id> <category>testing</category><body package="SSG-Extensions" selector="isDictionary">isDictionary	^true</body></methods><methods><class-id>OrderedDictionary</class-id> <category>initialize-release</category><body package="SSG-Extensions" selector="initialize">initialize	dictionary := Dictionary new: 10.	orderedKeys := Array new: 10.</body></methods><methods><class-id>OrderedDictionary</class-id> <category>adding</category><body package="SSG-Extensions" selector="add:">add: anObject	| size |	size := dictionary size.	dictionary add: anObject.	dictionary size &gt; size		ifTrue: 			[orderedKeys size &gt; size ifFalse: [self growOrderedKeys].			orderedKeys at: size + 1 put: anObject key].	^anObject </body><body package="SSG-Extensions" selector="addAll:">addAll: aCollection 	aCollection associationsDo: [:anObject | self add: anObject].	^aCollection</body></methods><methods><class-id>OrderedDictionary</class-id> <category>accessing</category><body package="SSG-Extensions" selector="associationAt:">associationAt: aKey	^dictionary associationAt: aKey</body><body package="SSG-Extensions" selector="associations">associations	| index associations |	associations := Array new: self size.	index := 1.	self		associationsDo: 			[:t3 | 			associations at: index put: t3.			index := index + 1].	^associations</body><body package="SSG-Extensions" selector="associationsDo:">associationsDo: aBlock	self keysDo: [:each | aBlock value: (self associationAt: each)]</body><body package="SSG-Extensions" selector="at:">at: key	^dictionary at: key</body><body package="SSG-Extensions" selector="at:ifAbsent:">at: aKey ifAbsent: aBlock 	^dictionary at: aKey ifAbsent: aBlock</body><body package="SSG-Extensions" selector="at:ifAbsentPut:">at: aKey ifAbsentPut: anObject 	^self at: aKey ifAbsent: [self at: aKey put: anObject value]</body><body package="SSG-Extensions" selector="at:ifPresent:">at: key ifPresent: aBlock	^dictionary at: key ifPresent: aBlock</body><body package="SSG-Extensions" selector="at:put:">at: key put: anObject 	| oldSize |	oldSize := dictionary size.	dictionary at: key put: anObject.	dictionary size &gt; oldSize		ifTrue: 			[orderedKeys size &gt; oldSize ifFalse: [self growOrderedKeys].			orderedKeys at: oldSize + 1 put: key].	^anObject</body><body package="SSG-Extensions" selector="do:">do: aBlock 	self valuesDo: aBlock</body><body package="SSG-Extensions3" selector="encodeAsJSONDataUsing:">encodeAsJSONDataUsing: t1	| t2 |	t1 beginObject.	t2 := 0.	(orderedKeys reject: #isNil)		do: 			[:t3 | 			| t4 |			t2 := t2 + 1.			t4 := dictionary at: t3.			t2 &gt; 1 ifTrue: [t1 emitComma].			t1 encodeKey: t3 value: t4].	t1 endObject.</body><body package="SSG-Extensions" selector="growOrderedKeys">growOrderedKeys	orderedKeys := (Array new: ((orderedKeys size * 1.5) asInteger max: 10))				replaceFrom: 1				to: orderedKeys size				with: orderedKeys				startingAt: 1</body><body package="SSG-Extensions" selector="includesKey:">includesKey: aKey	^dictionary includesKey: aKey</body><body package="SSG-Extensions" selector="keys">keys	^orderedKeys copyFrom: 1 to: self size</body><body package="SSG-Extensions" selector="keysDo:">keysDo: aBlock	| index size |	index := 1.	size := self size.	[index &lt;= size]		whileTrue: 			[aBlock value: (orderedKeys at: index).			index := index + 1]</body><body package="SSG-Extensions" selector="size">size	^dictionary size</body><body package="SSG-Extensions" selector="values">values 	^self associations collect: [:each | each value]</body></methods><methods><class-id>OrderedDictionary</class-id> <category>comparing</category><body package="SSG-Extensions" selector="=">= anObject  	self == anObject ifTrue: [^true].	(self species == anObject species and: [self size = anObject size])		ifFalse: [^false].	dictionary associationsDo: [:each | (anObject at: each key ifAbsent: [^false])			= each value			ifTrue: [nil]			ifFalse: [^false]].	^true</body><body package="SSG-Extensions" selector="hash">hash	^dictionary hash</body></methods><methods><class-id>OrderedDictionary</class-id> <category>enumerating</category><body package="SSG-Extensions" selector="collect:">collect: aBlock 	^self species newFrom: (self associations collect: [:assoc | assoc key -&gt; (aBlock value: assoc value)])</body><body package="SSG-Extensions" selector="keysAndValuesDo:">keysAndValuesDo: aBlock 	self keysDo: [:key | aBlock value: key value: (self at: key)].</body><body package="SSG-Extensions" selector="valuesDo:">valuesDo: aBlock  	self keysDo: [:each | aBlock value: (self at: each)]</body></methods><methods><class-id>OrderedDictionary class</class-id> <category>instance creation</category><body package="SSG-Extensions" selector="new">new	^super new initialize</body><body package="SSG-Extensions" selector="newFrom:">newFrom: aCollection	| inst |	inst := self new.	aCollection associationsDo: [:assoc | inst at: assoc key put: assoc value].	^inst</body></methods><methods><class-id>SmallSuiteGenerator.SVisitorNodes</class-id> <category>initialize-release</category><body package="SSG-Extensions2" selector="isAbstract">isAbstract	^isAbstractt ifNil: [false]</body></methods><methods><class-id>SmallSuiteGenerator.SVisitorNodes</class-id> <category>visitor-double dispatching</category><body package="SSG-Extensions2" selector="acceptMessageNode:">acceptMessageNode: aNode	isAbstractt := aNode selector == #subclassResponsibility. </body></methods><methods><class-id>SmallSuiteGenerator.SStateCoverage</class-id> <category>As yet unclassified</category><body package="SSG-Extensions2" selector="class:">class: aClass 	class := aClass</body><body package="SSG-Extensions2" selector="computeFitness">computeFitness	^profiler stateCoverageFor: class</body><body package="SSG-Extensions2" selector="fitnessOf:withKey:">fitnessOf: tesCase withKey: aString 	tesCase fitness at: aString put: (profiler stateCoverageFor: class).	tesCase fitnessByClass at: aString put: profiler statementCoverage1</body><body package="SSG-Extensions2" selector="functionName">functionName	^'state-coverage'</body><body package="SSG-Extensions2" selector="setUp">setUp</body><body package="SSG-Extensions2" selector="tearDown">tearDown</body></methods><methods><class-id>SmallSuiteGenerator.SStateCoverage class</class-id> <category>As yet unclassified</category><body package="SSG-Extensions2" selector="for:">for: aClass	^self new class: aClass</body></methods><methods><class-id>SmallSuiteGenerator.SConfigGenerationTestCase class</class-id> <category>As yet unclassified</category><body package="SSG-Extensions2" selector="aClass">aClass	</body><body package="SSG-Extensions2" selector="addTypeInfo:withKey:">addTypeInfo: aTypeInfo withKey: aString	^ self typeInfos at: aString put: aTypeInfo</body><body package="SSG-Extensions2" selector="asDict">asDict	^ true</body><body package="SSG-Extensions2" selector="blackList">blackList	^ #()</body><body package="SSG-Extensions2" selector="decodeBlackList">decodeBlackList	|result|	result := OrderedCollection new.	self blackList do: [:e | |class finded|		finded := self findClass: (e at:1).		finded isNotEmpty ifTrue: [			class := finded first.			(e at: 3) ifTrue: [class := class class].			result add: (class compiledMethodAt: (e at: 2))		]	 ].	 ^ result</body><body package="SSG-Extensions2" selector="defaultTypeInfo">defaultTypeInfo	defaultTypeInfo ifNil: [defaultTypeInfo := SmallSuiteGenerator.STypeInfo asTypeInfo: (Spy1.SSTypeCollector profile: []						inPackagesMatching: self targetPackageRegex)].	^ defaultTypeInfo</body><body package="SSG-Extensions2" selector="factory">factory	^ STestCaseFactoryVisualWorks from: self</body><body package="SSG-Extensions2" selector="findClass:">findClass: aString		^ Root allClasses select: [:aclass | aString = aclass fullName or: ['*.' , aString match: aclass fullName]]</body><body package="SSG-Extensions2" selector="fitness">fitness	^ #statement</body><body package="SSG-Extensions2" selector="fitnessDictionary">fitnessDictionary	^ Dictionary new		at: #statement put: [SStatementCoverage new];		at: #state put: [SStateCoverage for: self aClass fullName asSymbol];		yourself</body><body package="SSG-Extensions2" selector="fitnessValue">fitnessValue	^ (self fitnessDictionary at: self fitness) value</body><body package="SSG-Extensions2" selector="generateTests">generateTests	^ self factory createTestCases; yourself</body><body package="SSG-Extensions2" selector="lastMessage">lastMessage	^ ''</body><body package="SSG-Extensions2" selector="numberOfGenerations">numberOfGenerations	^ 5</body><body package="SSG-Extensions2" selector="numberOfStatements">numberOfStatements	^ 30</body><body package="SSG-Extensions2" selector="outputPackageName">outputPackageName	^ 'GeneratedTests'</body><body package="SSG-Extensions2" selector="populationSize">populationSize	^ 30</body><body package="SSG-Extensions2" selector="setUpMethod">setUpMethod	^ ''</body><body package="SSG-Extensions2" selector="stopIterations">stopIterations	^ 10</body><body package="SSG-Extensions2" selector="targetPackageRegex">targetPackageRegex	</body><body package="SSG-Extensions2" selector="tearDownMethod">tearDownMethod	^ ''</body><body package="SSG-Extensions2" selector="typeInfo">typeInfo	^ 'Default'</body><body package="SSG-Extensions2" selector="typeInfos">typeInfos	typeInfos ifNil: [typeInfos := Dictionary new		at: 'Default' put: nil;		yourself].	^ typeInfos</body><body package="SSG-Extensions2" selector="typeInfoValue">typeInfoValue	[|value|	value := SConfigGenerationTestCase typeInfos at: self typeInfo.	value ifNil: [ SError signal: 'Default typeInfo'].	^ value]	on: Error	do: [ ^ self defaultTypeInfo ]</body></methods><methods><class-id>Core.Object</class-id> <category>comparing</category><body package="SSG-Extensions" selector="asLink">asLink	^LinkValue value: self</body></methods><methods><class-id>Core.Object</class-id> <category>copying</category><body package="SSG-Extensions" selector="aSLProfilerCoverage">aSLProfilerCoverage	^Spy1.SLProfilerCoverage</body></methods><methods><class-id>Core.Object</class-id> <category>controlling</category><body package="SSG-Extensions" selector="assert:description:">assert: aBlock description: aStringOrBlock 	aBlock value ifFalse: [self error: aStringOrBlock]</body><body package="SSG-Extensions" selector="aSTypeCollectorClass">aSTypeCollectorClass	^Spy1.SSTypeCollector</body><body package="SSG-Extensions" selector="aVariableNodeClass">aVariableNodeClass	^Refactory.Browser.RBVariableNode</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="SSG-Extensions" selector="className">className	^self class name asString</body></methods><methods><class-id>Core.Object</class-id> <category>copying</category><body package="SSG-Extensions" selector="deepCopy">deepCopy	^self dcopy</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="SSG-Extensions" selector="isBlock">isBlock	^false</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="SSG-Extensions" selector="isDeprecated">isDeprecated	^false</body></methods><methods><class-id>Core.Object</class-id> <category>event accessing</category><body package="SSG-Extensions" selector="isNotNil">isNotNil	^true</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="SSG-Extensions" selector="mutateToChange">mutateToChange	^self</body></methods><methods><class-id>Core.Object</class-id> <category>class initialization</category><body package="SSG-Extensions" selector="perform:withEnoughArguments:">perform: selector withEnoughArguments: anArray 	| numArgs args |	numArgs := selector numArgs.	anArray size == numArgs ifTrue: [^self perform: selector withArguments: anArray asArray].	(args := Array new: numArgs)		replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^self perform: selector withArguments: args</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="SSG-Extensions" selector="storeOn:">storeOn: aStream 	"Append to the argument aStream a sequence of characters that is an expression 	whose evaluation creates an object similar to the receiver.  This is appropriate only	for smaller simpler objects.  It cannot handle arbitrary circular references of objects.	For large complex objects with circular references you should consider using the	Binary Object Storage System (BOSS) class (BinaryObjectStorage).	The general format for objects is		(class-name basicNew 			instVarAt: index put: variable;			basicAt: index put: element;			yourself)	or		((class-name basicNew: size )			instVarAt: index put: variable;			basicAt: index put: element;			yourself) "	aStream nextPut: $(.	self class isVariable		ifTrue: [aStream nextPutAll: '(';					store: self class;					nextPutAll: ' basicNew: ';					store: self basicSize;					nextPutAll: ') ']		ifFalse: [aStream store: self class; nextPutAll: ' basicNew'].	1 to: self class instSize do:		[:i |		aStream nextPutAll: ' instVarAt: ';			store: i;			nextPutAll: ' put: ';			store: (self instVarAt: i);			nextPut: $;].	1 to: self basicSize do:		[:i |		aStream nextPutAll: ' basicAt: ';			store: i;			nextPutAll: ' put: ';			store: (self basicAt: i);			nextPut: $;].	aStream nextPutAll: ' yourself)'</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="SSG-Extensions" selector="asString">asString	^self</body></methods><methods><class-id>Core.String</class-id> <category>testing</category><body package="SSG-Extensions" selector="mutateToChange">mutateToChange	| interval stringCopy |	interval := (41 to: 127) asArray.	stringCopy := self ifEmpty: ['']				ifNotEmpty: [self copyFrom: 1 to: self size - 1].	^((Character value: (SmallSuiteGenerator.SPlatform randomGenerator selectAtRandom: interval)) asString , stringCopy , (Character value: (SmallSuiteGenerator.SPlatform randomGenerator selectAtRandom: interval)) asString) asString</body></methods><methods><class-id>Core.String</class-id> <category>instance creation</category><body package="SSG-Extensions" selector="substrings:">substrings: separators	| t2 anArray t4 index size t7 |	anArray := (Array new: 10) writeStream.	index := 1.	size := self size.	[index &lt;= size]		whileTrue: 			[t4 := index.			t7 := self at: t4.			(separators includes: t7)				ifTrue: [t2						ifNotNil: 							[anArray nextPut: (self copyFrom: t2 to: t4 - 1).							t2 := nil]]				ifFalse: [t2 ifNil: [t2 := t4]].			index := index + 1].	t2 ifNotNil: [anArray nextPut: (self copyFrom: t2 to: self size)].	^anArray contents</body></methods><methods><class-id>Kernel.InstructionStream</class-id> <category>testing</category><body package="SSG-Extensions" selector="isLoadInst">isLoadInst	| byte |	byte := self baseBytecodeAt: self pc.	^ byte between: OpLoadInst and: (OpLoadInst+MaxLoadInst)</body></methods><methods><class-id>Core.Collection</class-id> <category>copying</category><body package="SSG-Extensions" selector="allButFirst">allButFirst	^self copyFrom: 2 to: self size</body></methods><methods><class-id>Core.Collection</class-id> <category>COMPATIBILITY-testing</category><body package="SSG-Extensions" selector="anyOne">anyOne	self emptyCheck.	self do: [:each | ^ each ]</body></methods><methods><class-id>Core.Collection</class-id> <category>copying</category><body package="SSG-Extensions" selector="copyFrom:to:">copyFrom: start to: stop	| newSize |	newSize := stop - start + 1.	^(self species withSize: newSize)		replaceFrom: 1		to: newSize		with: self		startingAt: start</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="SSG-Extensions" selector="detect:ifFound:">detect: aBlock ifFound: foundBlock	^self		detect: aBlock		ifFound: foundBlock		ifNone: [ 			"Do nothing on purpose"			 ]</body><body package="SSG-Extensions" selector="do:displayingProgress:">do: aBlock displayingProgress: anObject 	^self do: aBlock</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="SSG-Extensions" selector="fifth">fifth	^self at: 5</body><body package="SSG-Extensions" selector="fourth">fourth	^self at: 4</body></methods><methods><class-id>Core.Collection</class-id> <category>comparing</category><body package="SSG-Extensions" selector="includesAll:">includesAll: aList	aList isCollection		ifTrue: 			[aList size &lt;= self size ifTrue: [^aList allSatisfy: [:t2 | (aList occurrencesOf: t2)						&lt;= (self occurrencesOf: t2)]].			^false].	^false</body><body package="SSG-Extensions" selector="includesAny:">includesAny: aList	aList do: [:each | 			(self includes: each)				ifTrue: [^true].			nil].	^false</body></methods><methods><class-id>Core.Collection</class-id> <category>COMPATIBILITY-testing</category><body package="SSG-Extensions" selector="max">max	^self inject: self anyOne into: [:max :each | max max: each] </body></methods><methods><class-id>Core.Collection</class-id> <category>comparing</category><body package="SSG-Extensions" selector="min">min	^self inject: self anyOne into: [:min :each | min min: each]</body></methods><methods><class-id>Core.Collection</class-id> <category>copying</category><body package="SSG-Extensions" selector="reject:thenDo:">reject: rejectBlock thenDo: doBlock 	"Utility method to improve readability.	Do not create the intermediate collection."		self do: [ :each |		(rejectBlock value: each)			ifFalse: [ doBlock value: each ] ].</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="SSG-Extensions" selector="second">second	^self at: 2</body></methods><methods><class-id>Core.Collection</class-id> <category>copying</category><body package="SSG-Extensions" selector="sort:">sort: aBlock	^SortedCollection withAll: self sortBlock: aBlock	</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="SSG-Extensions" selector="third">third	^self at: 3</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="SSG-Extensions" selector="union:">union: aCollection	| set |	set := (self asSet) addAll: aCollection; yourself.	^self species withAll: set asArray</body></methods><methods><class-id>Core.LinkValue</class-id> <category>comparing</category><body package="SSG-Extensions" selector="=">= anotherLink	self species == anotherLink species		ifTrue: 			[self value = anotherLink value ifTrue: [^self nextLink == anotherLink nextLink].			^false].	^false </body></methods><methods><class-id>Core.Character class</class-id> <category>external accessing</category><body package="SSG-Extensions" selector="alphabet">alphabet	^'abcdefghijklmnopqrstuvwxyz' copy</body></methods><methods><class-id>Core.Character</class-id> <category>testing</category><body package="SSG-Extensions" selector="mutateToChange">mutateToChange	| newValue interval |	interval := (33 to: 127) asArray.	newValue := SmallSuiteGenerator.SPlatform randomGenerator selectAtRandom: interval.	[newValue == self asInteger]		whileTrue: [newValue := SmallSuiteGenerator.SPlatform randomGenerator selectAtRandom: interval].	^Character value: newValue</body></methods><methods><class-id>Refactory.Browser.RBVariableNode</class-id> <category>accessing</category><body package="SSG-Extensions" selector="token">token	^token</body></methods><methods><class-id>Kernel.SequenceNode</class-id> <category>probes</category><body package="SSG-Extensions" selector="probeInfoFor:doBefore:doAfter:">probeInfoFor: t1 doBefore: t2 doAfter: t3	| t4 t5 t6 t7 t8 |	sourcePosition last + 1 &lt; t1 first ifTrue: t3.	t7 := [^self probeRecordAtStart].	sourcePosition first &gt; t1 first ifTrue: t2.	sourcePosition first &gt; sourcePosition last ifTrue: [^self probeRecordAtStart].	(sourcePosition first = t1 first and: [self mapEntry notNil])		ifTrue: [^super probeRecordAtStart].	t8 := statements size.	t4 := 0.	t5 := 			[| t9 |			(t4 := t4 - 1) = 0 ifTrue: t7.			(t9 := (statements at: t4) probeRecordAtEnd) isNil ifFalse: [^t9].			t5 value].	^(t6 := 			[(t4 := t4 + 1) &gt; t8 ifTrue: t5.			^(statements at: t4)				probeInfoFor: t1				doBefore: t5				doAfter: t6]) value</body></methods><methods><class-id>Core.Link</class-id> <category>accessing</category><body package="SSG-Extensions" selector="asLink">asLink	^self</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>copying</category><body package="SSG-Extensions" selector="allButLast">allButLast	^self allButLast: 1</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>comparing</category><body package="SSG-Extensions" selector="beginsWith:">beginsWith: aSequenceableCollection	| index aColl |	self size &lt; aSequenceableCollection size ifTrue: [^false].	index := 1.	aColl := aSequenceableCollection size.	[index &lt;= aColl]		whileTrue: 			[(self at: index)				= (aSequenceableCollection at: index) ifFalse: [^false].			index := index + 1].	^true</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="SSG-Extensions" selector="combinations:atATimeDo:">combinations: kk atATimeDo: aBlock  	| aCollection |	aCollection := Array new: kk.	self		combinationsAt: 1		in: aCollection		after: 0		do: aBlock</body><body package="SSG-Extensions" selector="combinationsAt:in:after:do:">combinationsAt: jj in: aCollection after: nn do: aBlock  	| index size |	index := nn + 1.	size := self size.	[index &lt;= size]		whileTrue: 			[aCollection at: jj put: (self at: index).			jj = aCollection size				ifTrue: [aBlock value: aCollection]				ifFalse: [self						combinationsAt: jj + 1						in: aCollection						after: index						do: aBlock].			index := index + 1]</body></methods><methods><class-id>CraftedSmalltalk.AuxCodeInfoExtractor</class-id> <category>decoding</category><body package="SSG-Extensions" selector="run">run	[self atEnd]		whileFalse: 			[visited at: pc put: true.			self interpretNextInstructionFor: self.			pc &lt;= visited size ifTrue: [(visited at: pc)					ifTrue: [self endBranch]]]</body></methods><methods><class-id>Core.Number</class-id> <category>testing</category><body package="SSG-Extensions" selector="mutateToChange">mutateToChange	^(self perform: (SmallSuiteGenerator.SPlatform randomGenerator selectAtRandom: #(#+ #- #* ))		with: (SmallSuiteGenerator.SPlatform randomGenerator selectAtRandom: (1 to: 100) asArray))		perform: (SmallSuiteGenerator.SPlatform randomGenerator selectAtRandom: #(#+ #- ))		with: 1</body></methods><methods><class-id>Core.Set</class-id> <category>removing</category><body package="SSG-Extensions" selector="=">= aCollection 	self == aCollection ifTrue: [^true].	self species == aCollection species ifFalse: [^false].	self size = aCollection size ifFalse: [^false].	^self allSatisfy: [:t2 | aCollection includes: t2]</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>dependents collection</category><body package="SSG-Extensions" selector="isNotNil">isNotNil	^false</body></methods><methods><class-id>Core.Behavior</class-id> <category>accessing method dictionary</category><body package="SSG-Extensions" selector="allMethodsBelow:">allMethodsBelow: aClass	| aSet |	aSet := IdentitySet new.	self withAllSuperclasses		do: 			[:superClass | 			superClass = aClass ifTrue: [^aSet].			superClass methodDictionary do: [:compMethod | aSet add: compMethod]].	^aSet</body><body package="SSG-Extensions" selector="allSelectorsBelow:">allSelectorsBelow: aClass	| aSet |	aSet := IdentitySet new.	self withAllSuperclasses		do: 			[:t3 | 			t3 = aClass ifTrue: [^aSet].			t3 selectors do: [:t4 | aSet add: t4]].	^aSet</body></methods><methods><class-id>Core.Behavior</class-id> <category>creating method dictionary</category><body package="SSG-Extensions" selector="isAbstract">isAbstract	^false</body></methods><methods><class-id>Core.Time class</class-id> <category>TimeServicesApp(dbonly)</category><body package="SSG-Extensions" selector="new">new	^super new initialize</body></methods><methods><class-id>Core.Time</class-id> <category>TimeServicesApp(dbonly)</category><body package="SSG-Extensions" selector="initialize">initialize	hours := minutes := seconds := 0.</body></methods><methods><class-id>Core.Boolean</class-id> <category>testing</category><body package="SSG-Extensions" selector="mutateToChange">mutateToChange	^self not</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>copying</category><body package="SSG-Extensions" selector="deepCopy">deepCopy	^self dcopy</body></methods><methods><class-id>Core.Random</class-id> <category>private</category><body package="SSG-Extensions" selector="nextInt:">nextInt: anInteger	anInteger strictlyPositive ifFalse: [self error: 'Range must be positive'].	anInteger asFloat isInfinity ifTrue: [^(self next asFraction * anInteger) truncated + 1].	^(self next * anInteger) truncated + 1</body></methods><methods><class-id>Core.Random</class-id> <category>accessing</category><body package="SSG-Extensions" selector="seed:">seed: aSmallInteger	"Initialize the first random number."		seed := aSmallInteger</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>evaluating</category><body package="SSG-Extensions" selector="cull:cull:">cull: firstArg cull: secondArg	self numArgs &lt; 2 ifTrue: [^self cull: firstArg].	^self value: firstArg value: secondArg</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>printing</category><body package="SSG-Extensions" selector="isBlock">isBlock	^true</body></methods><methods><class-id>Kernel.Context</class-id> <category>accessing-debugger</category><body package="SSG-Extensions" selector="namedTempAt:">namedTempAt: index	^self tempAt: index</body></methods><methods><class-id>Core.OrderedCollection class</class-id> <category>instance creation</category><body package="SSG-Extensions" selector="newFrom:">newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."	| newCollection |	newCollection := self new: aCollection size.	newCollection addAll: aCollection.	^newCollection</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>removing</category><body package="SSG-Extensions" selector="removeAt:">removeAt: index	^ self removeAtIndex: index	</body></methods><methods><class-id>Core.Array class</class-id> <category>instance creation</category><body package="SSG-Extensions" selector="with:with:with:with:with:with:">with: first with: second with: third with: fourth with: fifth with: sixth	| inst |	(inst := self new: 6) at: 1 put: first.	inst at: 2 put: second.	inst at: 3 put: third.	inst at: 4 put: fourth.	inst at: 5 put: fifth.	inst at: 6 put: sixth.	^inst</body></methods><methods><class-id>Core.Array</class-id> <category>printing</category><body package="SSG-Extensions" selector="printOn:">printOn: aStream 	"Append the string representation of the receiver to aStream."		| toMany |	toMany := aStream position + self maxPrint.	aStream nextPutAll: '#('.	self		do: 			[:t3 | 			aStream position &gt; toMany				ifTrue: 					[aStream nextPutAll: (#etc &lt;&lt; #dialogs &gt;&gt; '...etc...') asString , ')'.					^self].			t3 printOn: aStream]		separatedBy: [aStream space].	aStream space.	aStream nextPut: $).</body><body package="SSG-Extensions" selector="storeOn:">storeOn: aStream 	self isLiteral		ifTrue: 			[aStream nextPutAll: '#('.			aStream policy printCharactersLiterally: true while: [self do: [:t2 | t2 storeOn: aStream]					separatedBy: [aStream space]].			aStream space.			aStream nextPut: $)]		ifFalse: [super storeOn: aStream]</body></methods><methods><class-id>SUnit.TestCase</class-id> <category>backwards compatibility</category><body package="SSG-Extensions" selector="assertCollection:includesAll:">assertCollection: actualCollection includesAll: subCollection 	^self assert: (actualCollection includesAll: subCollection)		description: [actualCollection asString , ' does not include all in ' , subCollection asString]</body><body package="SSG-Extensions" selector="deny:equals:">deny: actual equals: expected	actual = expected ifTrue: [self signalFailure: actual printString , ' is not equal to ' , expected printString].	^self</body></methods><methods><class-id>SUnit.TestCase</class-id> <category>converting</category><body package="SSG-Extensions" selector="fullNameOfClass:">fullNameOfClass: aSymbol	#('Core.' 'Smalltalk.' 'SmallSuiteGenerator.' ) detect: [:t2 | (Smalltalk at: t2 , aSymbol ifAbsent: [nil]) isNil not]		ifFound: [:t3 | ^t3 , aSymbol asString].	self error: 'I cant find the namespace for: ' , aSymbol.</body><body package="SSG-Extensions" selector="fullSymbolOf:">fullSymbolOf: aSymbol	#('Core.' 'Smalltalk.' 'SmallSuiteGenerator.' ) detect: [:t2 | (Smalltalk at: t2 , aSymbol ifAbsent: [nil]) isNil not]		ifFound: [:t3 | ^(t3 , aSymbol) asSymbol].	self error: 'I cant find the namespace for: ' , aSymbol.</body></methods><methods><class-id>Core.ByteSymbol</class-id> <category>testing</category><body package="SSG-Extensions" selector="mutateToChange">mutateToChange	| interval stringCopy |	interval := Character alphabet , $_ asString.	stringCopy := self ifEmpty: ['']				ifNotEmpty: [self copyFrom: 1 to: self size - 1].	^((SmallSuiteGenerator.SPlatform randomGenerator selectAtRandom: interval) asString , stringCopy , (SmallSuiteGenerator.SPlatform randomGenerator selectAtRandom: interval) asString) asSymbol</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>accessing</category><body package="SSG-Extensions" selector="ast">ast	^Refactory.Browser.RBParser parseMethod: self getSource</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>testing</category><body package="SSG-Extensions" selector="isAbstract">isAbstract	^ self isShort and:[ self messages anySatisfy:[:m | m = #subclassResponsibility]].</body><body package="SSG-Extensions" selector="isReturnField">isReturnField	|c a b|	self isShort ifFalse:[ ^ false].	a := false.	b := false.	c := 0.	self withAllBlockMethodsDo:[ :meth |		|scanner |		scanner := InstructionStream on: meth.		scanner scanFor: [ :byte |			c isZero			ifTrue:[ a:= scanner isLoadInst.].			c =1 ifTrue:[ b:= scanner willReturn].			c := c+1.			false.		].	].	^ (c = 2 and:[ a]) and:[ b].</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>accessing</category><body package="SSG-Extensions" selector="origin">origin	^self mclass</body></methods><methods><class-id>Core.GenericException</class-id> <category>private</category><body package="SSG-Extensions" selector="performHandler:">performHandler: aContext	| result oldHandler |	(handlerContext := aContext) == nil		ifTrue: 			[result := self defaultAction.			self isResumable				ifTrue: 					[handlerContext := initialContext.					firstUnwindContext := nil.					self unwind.					thisContext terminateTo: handlerContext.					handlerContext := nil]]		ifFalse: 			[oldHandler := handlerContext.			result := handlerContext handlerBlock cull: self.			handlerContext := oldHandler.			self unwind.			thisContext terminateTo: handlerContext].	^result</body></methods><methods><class-id>SmallSuiteGenerator.SPlatformPharo class</class-id> <category>accessing</category><body package="SSG-Extensions2" selector="classLogger">classLogger	"^ TinyLogger"</body><body package="SSG-Extensions2" selector="implementationType">implementationType	^ 'Pharo'"SystemVersion current type"</body></methods><methods><class-id>SmallSuiteGenerator.SPlatformPharo class</class-id> <category>settings</category><body package="SSG-Extensions2" selector="rbParserClass">rbParserClass	"^ RBParser"</body></methods><methods><class-id>SmallSuiteGenerator.SPlatformPharo class</class-id> <category>tests</category><body package="SSG-Extensions2" selector="testCaseClass">testCaseClass	"^ TestCase"</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngineExample</class-id> <category>actions</category><body package="SSG-Extensions2" selector="runOnClass:withBlock:andFitness:">runOnClass: aClass withBlock: aBlock andFitness: aClassFitness 	| engine |	(engine := SGAEngine new) populationSize: 30; numberOfStatements: 15; blockToExecute: aBlock; targetClassName: aClass name.	engine typeInfo: (Spy1.SSTypeCollector profile: engine blockToExecute forClassNamed: aClass) asTypeInfo; fitness: aClassFitness; targetClassName: aClass name; numberOfIterations: 15; run.	^engine</body><body package="SSG-Extensions2" selector="runOnPackagesMatching:withBlock:andFitness:">runOnPackagesMatching: regex withBlock: aBlock andFitness: aClassFitness	| engine |	engine := SGAEngine new.	engine		populationSize: 30;		numberOfStatements: 15;		blockToExecute: aBlock.	engine		typeInfo:			(STypeInfo				asTypeInfo:					(Spy1.SSTypeCollector						profile: engine blockToExecute						onPackagesMatching: regex));		fitness: aClassFitness;		numberOfGenerations: 15;		run.	^ engine </body></methods><methods><class-id>SmallSuiteGenerator.SInspectorAssertion class</class-id> <category>instance creation</category><body package="SSG-Extensions2" selector="inspectorAssertionOf:">inspectorAssertionOf: assoc	|values|	values := assoc value class methodDictionary values.	^ (values select: #isReturnField)		collect:			[ :compiledMethod | 			self inspectorAssertionOf: assoc and: compiledMethod ]		thenSelect: [ :assertion | 			assertion isNotNil			 ] </body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>converting</category><body package="SSG-Extensions2" selector="asTypeInfo:methodsBlacklist:">asTypeInfo: typeCollector methodsBlacklist: aCollection      	| inst |	inst := self class new.	typeCollector allClasses		do: 			[:aClass | 			aCollection select: [:compMethod | (compMethod mclass name without: ' class') asSymbol == (aClass className substrings: '.') last asSymbol]				thenDo: [:compMethod | aClass removeMethod: compMethod].			(aClass className endsWith: 'BlockClosure')				ifTrue: [nil]				ifFalse: [inst addClassInfo: (STypeClassInfo asClassInfo: aClass)]].	inst joinScalars: typeCollector scalars copy.	^inst</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>adding</category><body package="SSG-Extensions2" selector="completeTypeInfo">completeTypeInfo	self types		keysDo: 			[:aClass | 			| typeColl realClassInfo |			typeColl := SmallTypeCollector new collectTypeFrom: (self classOf: aClass asString) first.			realClassInfo := self types at: aClass.			typeColl methodTypes keysAndValuesDo: [:key :value | ((self isInBlackListClass: aClass with: key) not and: [key isUnary not and: [value argTypes allSatisfy: [:arg | arg types allSatisfy: [:t | (t = #'SmallSuiteGenerator.SUndefinedObject') not  ] ]]])					ifTrue: [realClassInfo methodTypes at: key							ifAbsentPut: 								[self updateArgsOf: value.								value returnType types ifEmpty: [value returnType type: #SUndefinedObject].								value receiver type: aClass.								value hasProfiler: false.								value executions: 0.5]]]].</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>accessing</category><body package="SSG-Extensions2" selector="deleteBlackListMethods">deleteBlackListMethods	blackList do: [:compMethod |		|aClass selector|		selector := #methodTypes.		compMethod origin isMeta ifTrue: [ 			selector := #classMethodTypes.			aClass := compMethod origin instanceBehavior ]		ifFalse: [ aClass := compMethod origin ].		self types at: aClass fullName asSymbol			ifPresent: [:classInfo | 				(classInfo perform: selector)						removeKey: compMethod selector				 		ifAbsent: []			] 			ifAbsent: [].	]</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>as yet unclassified</category><body package="SSG-Extensions2" selector="isAbstractClass:">isAbstractClass: aClass 	^((self classes at: aClass) methodDictionary values select: #isAbstract) isNotEmpty</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>converting</category><body package="SSG-Extensions2" selector="updateArgsOf:">updateArgsOf: anObject 	anObject argTypes do: 		[:arg | 		(arg types anySatisfy: [:aType | self scalars keys includes: aType])			ifTrue: [nil]			ifFalse: [arg types do: [:aType | (aType substrings: '.') last = 'Object'						ifTrue: [nil]						ifFalse: [self scalars keys select: [:scalar | ((self classOf: aType asString) first allSubclasses collect: [:cls | cls fullName asSymbol])									includes: scalar]								thenDo: [:scalar | arg type: scalar]]]]].</body></methods><methods><class-id>SmallSuiteGenerator.SChangeTest</class-id> <category>mutation-change</category><body package="SSG-Extensions2" selector="testChangeStatementOfFactoryMessageWithMoreThanOneLiteral">testChangeStatementOfFactoryMessageWithMoreThanOneLiteral	| testCase expression expressionChanged |	(testCase := (SSTestCase with: utility typeInfoSFoo1)				addTargetClassName: (self fullSymbolOf: #SFoo)) addLiteral: (self fullSymbolOf: #Float); addLiteral: (self fullSymbolOf: #Float).	expression := testCase addFactoryMessage: (self fullSymbolOf: #SFoo)				ofSelector: #score:.	self assertCollection: (testCase statements collect: #printString)		includesAll: #('_var0 := 7.3.' '_var1 := 7.3.' ).	self assert: ((Array with: '_var3 := ' , (self fullNameOfClass: 'SFoo') asString , ' score: _var2.')			includes: expression printString).	expressionChanged := testCase changeStatementOfVarName: '_var2'.	self assert: (#('_var2 := 679.9.' ) includes: expressionChanged printString).	self assert: testCase validReferences.</body></methods><methods><class-id>SmallSuiteGenerator.SInsertTest</class-id> <category>mutation-insert</category><body package="SSG-Extensions2" selector="testInsertStatementOfSelectorRandomMessageInLiteral">testInsertStatementOfSelectorRandomMessageInLiteral	| testCase |	(testCase := SSTestCase with: utility typeInfoSFoo1) addLiteral: (self fullSymbolOf: #Float).	self assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 7.3.' ).	self should: [testCase insertStatementOfSelector: #insertRandomMessage:using:]		raise: SError.</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory class</class-id> <category>settings-colors</category><body package="SSG-Extensions2" selector="from:">from: configClass	| aTypeInfo |	aTypeInfo := configClass typeInfoValue copy.	aTypeInfo blackList: configClass decodeBlackList.	^(self new) 		fitness: configClass fitnessValue; 		targetClassName: configClass aClass fullName asSymbol; 		targetPackageRegex: configClass targetPackageRegex; 		outputPackageName: configClass outputPackageName; 		numberOfGenerations: configClass numberOfGenerations; 		numberOfStatements: configClass numberOfStatements; 		populationSize: configClass populationSize;		setUpMethod: configClass setUpMethod asString; 		tearDownMethod: configClass tearDownMethod asString; 		lastMessage: configClass lastMessage asString; 		typeInfo: aTypeInfo;		asDict: configClass asDict;		stopIterations: configClass stopIterations;		yourself</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>actions</category><body package="SSG-Extensions2" selector="createConfigurationMethods">createConfigurationMethods 	| aClass |	aClass := self getClassOf: 'GA' , (self targetClassName substrings: '.') last , 'Test'.	setUpMethod ifNotNil: [aClass compile: setUpMethod].	tearDownMethod ifNotNil: [aClass compile: tearDownMethod]</body><body package="SSG-Extensions2" selector="export:with:"> export: aTestCase with: aSelector   	[aTestCase generateAssertions.	self generatedClass		compile: (aSelector , String lf, aTestCase printDescriptiveComment , String lf, aTestCase parseTreeWithAssertions body formattedCode)		classified: ClassOrganizer defaultProtocol		notifying: SilentCompilerErrorHandler new ]		on: Error		do: 			[:t4 | | cr |			self halt.			cr := String with: Character cr.			self generatedClass compile: aSelector , cr , 'self should:' , aTestCase parseTree formattedCode , cr , ' raise:Error.' , cr]</body><body package="SSG-Extensions2" selector="exportFitnessLog">exportFitnessLog 	| file aStream separator |	file := 'fitnessEvolution.txt' asFilename.	separator := $,.	(aStream := file writeStream) nextPutAll: 'Generation number'; nextPut: separator; nextPutAll: 'bestFit'; nextPut: separator; nextPutAll: 'lowestFit'; nextPut: separator; nextPutAll: 'averageFit'; cr.	[engine logs do: [:t4 | aStream nextPutAll: t4 generationNumber asString; nextPut: separator; nextPutAll: t4 fittestTestCase fitness values first asString; nextPut: separator; nextPutAll: t4 lowestFit values first asString; nextPut: separator; nextPutAll: t4 averageFit values first asString; cr]]		valueNowOrOnUnwindDo: [aStream close]</body><body package="SSG-Extensions2" selector="exportTests">exportTests 	| aClass |	aClass := self getClassOf: 'GA' , (self targetClassName substrings: '.') last , 'Test'.	engine population		doWithIndex: 			[:testCase :index | 			testCase lastMessage: lastMessage.			self export: testCase with: 'test' , index printString].	self createConfigurationMethods.	Refactory.Browser.RefactoringBrowser newOnClass: aClass</body><body package="SSG-Extensions2" selector="generatedClass">generatedClass		generatedClass ifNil: [ |newNameClass|	newNameClass :=  'GA' , (self targetClassName substrings: '.') last , 'Test'.	(generatedClass := SmallSuiteGenerator.SPlatform lookUpClass: newNameClass) ifNil: [generatedClass := SmallSuiteGenerator.SPlatform createTestCaseClass: newNameClass inPackage: self outputPackageName].	 ].	^ generatedClass</body><body package="SSG-Extensions2" selector="moveClass:">moveClass: aClass  	| bundle package items t5 |	bundle := Store.Registry bundleNamed: 'SmallSuiteGenerator'.	package := Store.Registry packageNamedOrCreate: self outputPackageName.	Store.XMainChangeSet current moveWholeClass: aClass toPackage: package.	(t5 := (items := bundle containedItems) select: [:t6 | t6 name = self outputPackageName]) isEmpty ifFalse: [items remove: t5 first].	items add: package.	bundle containedItems: items</body><body package="SSG-Extensions2" selector="tearDown">tearDown	self uninstall.	self exportTests.	self exportFitnessLog.	SPlatform asDict: false.	SPlatform resetRandomGenerator.	SmallTypeCollector resetClassDict </body></methods><methods><class-id>SmallSuiteGenerator.SPlatformVisualWorks class</class-id> <category>logging</category><body package="SSG-Extensions2" selector="classConfigurationName">classConfigurationName	^superclass fullName , self implementationType</body><body package="SSG-Extensions2" selector="createTestCaseClass:inPackage:">createTestCaseClass: className inPackage: pkgName 	| t3 t5 pkg generatedClass |	(t3 := SystemUtils validateClassName: className for: nil) ifNil: [^nil].	generatedClass := ((t5 := self testCaseClass) classBuilder addRecord: (BehaviorBuilderRecord forName: t3 in: self environment)) superclass: t5; instVarString: ''; classVarString: ''; poolString: (t5 computeFullPoolString: ''); category: pkgName; beFixed; reviseSystem.	pkg := Store.Registry packageNamedOrCreate: pkgName.	Store.XMainChangeSet current moveWholeClass: generatedClass toPackage: pkg.	^generatedClass</body><body package="SSG-Extensions2" selector="implementationType">implementationType	^'VisualWorks'</body><body package="SSG-Extensions2" selector="rbParserClass">rbParserClass	^Refactory.Browser.RBParser</body><body package="SSG-Extensions2" selector="testCaseClass">testCaseClass	^SmallSuiteGenerator.SConfigGenerationTestCase</body></methods><methods><class-id>SmallSuiteGenerator.SStack</class-id> <category>accessing</category><body package="SSG-Extensions2" selector="=">= aStack	self == aStack ifTrue: [^true].	self species == aStack species ifFalse: [^false].	^self hasEqualElements: aStack</body><body package="SSG-Extensions2" selector="addFirst:">addFirst: anObject  	| aLink |	aLink := anObject asLink.	self isEmpty ifTrue: [lastLink := aLink].	aLink nextLink: firstLink.	firstLink := aLink.	^aLink</body><body package="SSG-Extensions2" selector="addLast:">addLast: anObject   	| aLink |	aLink := anObject asLink.	self isEmpty		ifTrue: [firstLink := aLink]		ifFalse: [lastLink nextLink: aLink].	lastLink := aLink.	^aLink</body><body package="SSG-Extensions2" selector="hasEqualElements:">hasEqualElements: aCollection 	| size index |	(aCollection isKindOf: SequenceableCollection)		ifFalse: [^false].	(size := self size) = aCollection size ifFalse: [^false].	index := 1.	[index &lt;= size]		whileTrue: 			[(self at: index) value = (aCollection at: index) value ifFalse: [^false].			index := index + 1].	^true</body><body package="SSG-Extensions2" selector="removeFirst">removeFirst 	| aLink |	self emptyCheck.	aLink := firstLink.	firstLink == lastLink		ifTrue: 			[firstLink := nil.			lastLink := nil]		ifFalse: [firstLink := aLink nextLink].	aLink nextLink: nil.	^aLink value</body><body package="SSG-Extensions2" selector="removeLast">removeLast 	| aLink |	self emptyCheck.	aLink := lastLink.	firstLink == lastLink		ifTrue: 			[firstLink := nil.			lastLink := nil]		ifFalse:  [ |aFirstLink|			aFirstLink := firstLink.			[aFirstLink nextLink == aLink] whileFalse: [aFirstLink := aFirstLink nextLink].			aFirstLink nextLink: nil.			lastLink := aFirstLink].	aLink nextLink: nil.	^aLink value</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine</class-id> <category>actions</category><body package="SSG-Extensions2" selector="exportFitnessLog">exportFitnessLog	| file stream separator |	file := 'fitnessEvolution.txt' asFilename.	separator := $,.	(stream := file writeStream) nextPutAll: 'generation'; nextPut: separator; nextPutAll: 'bestFit'; nextPut: separator; nextPutAll: 'lowestFit'; nextPut: separator; nextPutAll: 'averageFit'; nextLine.	[self logs do: [:t4 | stream nextPutAll: t4 generationNumber asString; nextPut: separator; nextPutAll: t4 fittestTestCase fitness values first asString; nextPut: separator; nextPutAll: t4 lowestFit values first asString; nextPut: separator; nextPutAll: t4 averageFit values first asString; nextLine]]		valueNowOrOnUnwindDo: [stream close]</body><body package="SSG-Extensions2" selector="updateTypeInfoWith:">updateTypeInfoWith: aCollectionTestCase	self profilerForTargetClass.	aCollectionTestCase do: [:testCase | testCase runWithoutAssertions].	self mergeTypeInfo: (STypeInfo asTypeInfo: typeInfoProfiler).	self uninstall.</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCase</class-id> <category>actions</category><body package="SSG-Extensions2" selector="setUp">setUp	(Process allInstances select: [:t1 | t1 name ~= nil and: [(t1 name startsWith: 'FiniteStateMachine')				or: [t1 name startsWith: 'FSMTicTacToe']]])		do: [:t2 | t2 terminate]</body><body package="SSG-Extensions2" selector="tearDown">tearDown	(Process allInstances select: [:t1 | t1 name ~= nil and: [(t1 name startsWith: 'FiniteStateMachine')				or: [t1 name startsWith: 'FSMTicTacToe']]])		do: [:t2 | t2 terminate]</body></methods><methods><class-id>SmallSuiteGenerator.SUtilityTypeInfo</class-id> <category>examples</category><body package="SSG-Extensions2" selector="typeInfoSFoo1">typeInfoSFoo1	^(STypeInfo new) type: (self fullSymbolOf: #SFoo)			-&gt; (Array with: (Array						with: #returnNum -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #SmallInteger)									with: #( )									with: false)						with: #returnFloat -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #Float)									with: #( )									with: false)						with: #returnString -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #ByteString)									with: #( )									with: false)						with: #score -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #Float)									with: #( )									with: true)						with: #return: -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #ByteString)									with: (Array with: (self fullSymbolOf: #ByteString))									with: false))					with: (Array with: #score: -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #SFoo)									with: (Array with: (self fullSymbolOf: #Float))									with: false))); scalar: (self fullSymbolOf: #ByteString)		with: #('hello' ); scalar: (self fullSymbolOf: #SmallInteger)		with: #(5 ); scalar: (self fullSymbolOf: #Float)		with: #(7.3 )</body><body package="SSG-Extensions2" selector="typeInfoSFoo3">typeInfoSFoo3	^(STypeInfo new) type: (self fullSymbolOf: #SFoo)			-&gt; (Array with: (Array						with: #returnNum -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #SmallInteger)									with: #( )									with: false)						with: #returnFloat -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #Float)									with: #( )									with: false)						with: #returnString -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #ByteString)									with: #( )									with: false)						with: #score -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #SmallInteger)									with: #( )									with: true)						with: #score: -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #SFoo)									with: (Array with: (self fullSymbolOf: #SmallInteger))									with: false))					with: (Array with: #score: -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #SFoo)									with: (Array with: (self fullSymbolOf: #SmallInteger))									with: false))); scalar: (self fullSymbolOf: #ByteString)		with: #('Hello' ); scalar: (self fullSymbolOf: #SmallInteger)		with: #(4 ); scalar: (self fullSymbolOf: #Float)		with: #(2.3 )</body><body package="SSG-Extensions2" selector="typeInfoSFooOnPackage2">typeInfoSFooOnPackage2	^(STypeInfo new) type: (self fullSymbolOf: #SFoo)			-&gt; (Array with: (Array						with: #returnFloat -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #Float)									with: #( )									with: false)						with: #returnCollection -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #OrderedCollection)									with: #( )									with: false)						with: #initialize -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #SFoo)									with: #( )									with: false)						with: #score -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #SmallInteger)									with: #( )									with: true)						with: #score: -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #SFoo)									with: (Array with: (self fullSymbolOf: #SmallInteger))									with: false)						with: #return: -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #SStudent)									with: (Array with: (self fullSymbolOf: #SStudent))									with: false))					with: (Array with: #score: -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #SFoo)									with: (Array with: (self fullSymbolOf: #SmallInteger))									with: false))); type: (self fullSymbolOf: #SSPerson)			-&gt; #(#( ) #( ) ); type: (self fullSymbolOf: #SStack)			-&gt; #(#( ) #( ) ); type: (self fullSymbolOf: #SConference)			-&gt; #(#( ) #( ) ); type: (self fullSymbolOf: #SEvent)			-&gt; #(#( ) #( ) ); type: (self fullSymbolOf: #SSTeacher)			-&gt; #(#( ) #( ) ); type: (self fullSymbolOf: #SParty)			-&gt; #(#( ) #( ) ); type: (self fullSymbolOf: #SEventTest)			-&gt; #(#( ) #( ) ); scalar: (self fullSymbolOf: #SmallInteger)		with: #(15 ); scalar: (self fullSymbolOf: #Float)		with: #(2.3 ); scalar: (self fullSymbolOf: #OrderedCollection)		with: (Array with: OrderedCollection new); scalar: (self fullSymbolOf: #Array)		with: #(#(1 5 6 ) )</body></methods><methods><class-id>SmallSuiteGenerator.SError</class-id> <category>signaling</category><body package="SSG-Extensions2" selector="signal:">signal: aMessage	SPlatform saveOnLog: aMessage.	self raiseSignal: aMessage.</body></methods><methods><class-id>SmallSuiteGenerator.SSTestRunner</class-id> <category>compiling</category><body package="SSG-Extensions2" selector="compile:">compile: aBlock	self class		compileWithoutStoringSource: 'performTest	' , aBlock body formattedCode	classified: ClassOrganizer defaultProtocol </body><body package="SSG-Extensions2" selector="compileWithSource:">compileWithSource: aBlock	self class		compile:			'performTest	' , aBlock body formattedCode </body></methods><methods><class-id>SmallSuiteGenerator.SSTestRunner</class-id> <category>running</category><body package="SSG-Extensions2" selector="evaluate:">evaluate: aSTestCase	| node |	node := aSTestCase parseTree.	node body		addNode:			(SPlatform rbParserClass				parseExpression: '^ self analyze: thisContext').	self compileWithSource: node.	^ self performTest </body></methods><methods><class-id>SmallSuiteGenerator.SAssertionTest</class-id> <category>tests</category><body package="SSG-Extensions2" selector="testAssertString">testAssertString	| aTestCase |	(aTestCase := SSTestCase new) addStatements: (self parse: '_var0 := 1.			 _var1 := 2.			 _var3 := Point x: _var1 y: _var0.').	aTestCase generateAssertions: (Array with: SStringAssertion).	self assert: aTestCase assertions size equals: 1.	self assert: aTestCase assertions first printString equals: 'self assert: _var3 printString equals: ''2@1''.'.	</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngineTest</class-id> <category>as yet unclassified</category><body package="SSG-Extensions2" selector="profilerOf:">profilerOf: aString  	profiler beforeProfiling; gatherForPackages: (Store.Registry allPackages select: [:pkg | aString match: pkg name asString]); install; beforeProfiling.</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngineTest</class-id> <category>running</category><body package="SSG-Extensions2" selector="tearDown">tearDown	[profiler cleanInstrumentation]		on: Error do: [nil].	super tearDown.</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactoryVisualWorks</class-id> <category>actions</category><body package="SSG-Extensions2" selector="cleanInstrumentation">cleanInstrumentation</body><body package="SSG-Extensions2" selector="initializeProfiler">initializeProfiler	((profiler := self aSLProfilerCoverage profilerForPackagesMatching: self targetPackageRegex) allMethods select: #isNotMethodExtension)		do: #installGhosts displayingProgress: 'Instrumenting ' , self targetPackageRegex</body><body package="SSG-Extensions2" selector="uninstall">uninstall	profiler uninstall.</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>accessing</category><body package="SSG-Extensions2" selector="canAddStatement">canAddStatement	SPlatform asDict 		ifFalse: [			^ ((self length + 3) &lt; 40"CompiledMethod fullFrameSize")		] ifTrue: [ ^ true ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>adding</category><body package="SSG-Extensions2" selector="differenceWith:usingSelector:">differenceWith: another usingSelector: aSymbol	| dict1 dict2 result |	result := OrderedCollection new.	dict1 := self perform: aSymbol.	dict2 := another perform: aSymbol.	dict2		keysAndValuesDo: [ :key :val1 | 			| val2 |			[ val2 := dict1 at: key.			val1 = val2				ifFalse: [ result add: (Array with: val2 with: val1) ] ]				on: KeyNotFoundError				do: [ result add: (Array with: nil with: val1) ] ].	^ result</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifterTest</class-id> <category>tests</category><body package="SSG-Extensions2" selector="testNewFieldAccessMessageOfTypeBefore">testNewFieldAccessMessageOfTypeBefore	| testCase expression |	(testCase := SSTestCase with: utility typeInfoSFoo1) addTargetClassName: (self fullSymbolOf: #SFoo).	expression := testCase addLiteral: (self fullSymbolOf: #SmallInteger).	self should: [testCase newFieldAccessMessageOfType: (self fullSymbolOf: #SmallInteger)			before: expression]		raise: SError.	testCase addStatement: (testCase newAssignment: (testCase newFactoryMessage: (self fullSymbolOf: #SFoo)				before: expression))		before: expression.	self assert: (testCase newFieldAccessMessageOfType: (self fullSymbolOf: #Float)			before: expression) printString equals: '_var2 score'.	self assertCollection: testCase printStatements hasSameElements: (Array			with: '_var1 := 7.3.'			with: '_var2 := ' , (self fullNameOfClass: 'SFoo') asString , ' score: _var1.'			with: '_var0 := 5.')</body></methods><methods><class-id>SmallSuiteGenerator.SmallTypeCollector class</class-id> <category>As yet unclassified</category><body package="SSG-Extensions2" selector="classDict">classDict	classDict ifNil: [ classDict := Dictionary new.	Object withAllSubclasses		do: [ :class | classDict at: class name asLowercase put: class ]].	^ classDict</body><body package="SSG-Extensions2" selector="resetClassDict">resetClassDict	classDict := nil</body></methods><methods><class-id>SmallSuiteGenerator.SmallTypeCollector</class-id> <category>action</category><body package="SSG-Extensions2" selector="blackList">blackList	^#('var' 'arg' 'anObject' 't[0-9]+' 'temp' )</body><body package="SSG-Extensions2" selector="classesOf:">classesOf: aString	^Root allClasses select: [:aClass | ('*' , aString asLowercase , '*' match: aClass fullName asLowercase)			and: [(aClass allSuperclasses includes: SUnit.TestCase) not and: [aClass isAbstract not]]]</body><body package="SSG-Extensions2" selector="cleanArgName:">cleanArgName: aString		[((aString beginsWith: 'an')		and: [(aString at: 3) isUppercase])		ifTrue: [^aString copyFrom: 3 to: aString size].	((aString beginsWith: 'a')		and: [(aString at: 2) isUppercase])		ifTrue: [^aString copyFrom: 2 to: aString size].	^aString]		on: Error do: [^aString]</body><body package="SSG-Extensions2" selector="collectArgTypesOf:">collectArgTypesOf: compMethod 	| argCollection |	(argCollection := (compMethod ast argumentNames				collect: 					[:argName | 					| cleanedArgName list |					cleanedArgName := self cleanArgName: argName asString.					(self blackList anySatisfy: [:blackList | blackList match: cleanedArgName])						ifTrue: [list := #( )]						ifFalse: [list := self classesOf: cleanedArgName].					list]) asOrderedCollection) add: #( ).	^self methodInfoIn: compMethod from: argCollection</body><body package="SSG-Extensions2" selector="collectTypeFrom:">collectTypeFrom: aClass	| classType |	aClass isMeta ifTrue: [^nil].	classType := STypeClassInfo newFrom: aClass name.	aClass methodDictionary values do: [:compMethods | classType addMethod: (self methodInfoIn: compMethods)].	aClass class methodDictionary values do: [:compMethod | classType addClassMethod: (self methodInfoIn: compMethod)].	^classType</body><body package="SSG-Extensions2" selector="methodInfoIn:">methodInfoIn: compMethod  	| methodInfo argTypes returnType |	(methodInfo := STypeMethodInfo new) selector: compMethod selector; isQuick: compMethod isQuick; scalars: Dictionary new; isDeprecated: compMethod isDeprecated; executions: 0.	argTypes := OrderedCollection new.	compMethod ast argumentNames do: 			[:argName | | typeInfo |			typeInfo := SMultiTypeInfo new.			(self fullSymbolOf: (self typeFor: argName))				do: [:t7 | typeInfo type: t7].			argTypes add: typeInfo].	(returnType := SMultiTypeInfo new) type: compMethod mclass instanceBehavior fullName asSymbol.	methodInfo returnType: returnType.	methodInfo argTypes: argTypes.	^methodInfo</body><body package="SSG-Extensions2" selector="methodInfoIn:from:">methodInfoIn: compMethod from: argCollection    	| arg methodInfo argTypes returnType |	(methodInfo := STypeMethodInfo new) selector: compMethod selector; isQuick: compMethod isQuick; scalars: Dictionary new; isDeprecated: compMethod isDeprecated; executions: 0.	argTypes := OrderedCollection new.	compMethod ast argumentNames		doWithIndex: 			[:argName :index | | typeInfo |			typeInfo := SMultiTypeInfo new.			((arg := argCollection at: index) size = 1 and: [arg first = Object])				ifTrue: [typeInfo type: (self typeFor: argName)]				ifFalse: [arg do: [:t10 | t10 isMeta							ifTrue: [nil]							ifFalse: [typeInfo type: t10 fullName asSymbol]]].			argTypes add: typeInfo].	returnType := SMultiTypeInfo new.	((arg := argCollection last) size = 1 and: [arg first = Object])		ifFalse: [arg do: [:t11 | returnType type: t11 fullName asSymbol]].	methodInfo returnType: returnType.	methodInfo argTypes: argTypes.	^methodInfo</body><body package="SSG-Extensions2" selector="typeFor:">typeFor: argName 	| index lastPart |	argName = 'arg' ifTrue: [^#SUndefinedObject].	self class classDict at: argName asLowercase ifPresent: [:t4 | ^t4 name].	index := 1.	[index &lt;= argName size and: [(argName at: index) isLowercase]]		whileTrue: [index := index + 1].	lastPart := argName copyFrom: index to: argName size.	self class classDict at: lastPart asLowercase ifPresent: [:t5 | ^t5 name].	argName asLowercase = 'spec' ifTrue: [^#MetacelloAbstractVersionConstructor].	('.*(b|B)lock.*' match: argName)		ifTrue: [^#BlockClosure].	('.*(o|O)rderedCollection.*' match: argName)		ifTrue: [^#OrderedCollection].	('.*(a|A)rray.*' match: argName)		ifTrue: [^#Array].	('.*(d|D)ictionary.*' match: argName)		ifTrue: [^#Dictionary].	('.*(s|S)et.*' match: argName)		ifTrue: [^#Set].	('.*(b|B)ag.*' match: argName)		ifTrue: [^#Bag].	('.*(c|C)ollection.*' match: argName)		ifTrue: [^#Collection].	('.*(s|S)tring.*' match: argName)		ifTrue: [^#String].	('.*(s|S)ymbol.*' match: argName)		ifTrue: [^#Symbol].	^#SUndefinedObject</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCaseTest</class-id> <category>tests</category><body package="SSG-Extensions2" selector="typeInfo">typeInfo	| aTypeInfo |	(aTypeInfo := STypeInfo new type: (self fullSymbolOf: #SFoo)					-&gt; (Array with: (Array								with: #returnNum -&gt; (Array											with: (self fullSymbolOf: #SFoo)											with: (self fullSymbolOf: #Float)											with: #( )											with: false)								with: #returnFloat -&gt; (Array											with: (self fullSymbolOf: #SFoo)											with: (self fullSymbolOf: #Float)											with: #( )											with: false)								with: #score -&gt; (Array											with: (self fullSymbolOf: #SFoo)											with: (self fullSymbolOf: #SmallInteger)											with: #( )											with: true)								with: #return: -&gt; (Array											with: (self fullSymbolOf: #SFoo)											with: (self fullSymbolOf: #ByteString)											with: (Array with: (self fullSymbolOf: #ByteString))											with: false))							with: (Array with: #score: -&gt; (Array											with: (self fullSymbolOf: #SFoo)											with: (self fullSymbolOf: #SFoo)											with: (Array with: (self fullSymbolOf: #Float))											with: false)))) scalar: (self fullSymbolOf: #ByteString)		with: #('hello' ).	aTypeInfo scalar: (self fullSymbolOf: #SmallInteger)		with: #(5 ).	aTypeInfo scalar: (self fullSymbolOf: #Float)		with: #(7.3 ).	^aTypeInfo</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfoTest</class-id> <category>tests</category><body package="SSG-Extensions2" selector="nameOf:">nameOf: aClass	^aClass fullName asSymbol</body><body package="SSG-Extensions2" selector="testAsTypeInfoScalars">testAsTypeInfoScalars 	| aTypeInfo |	aTypeInfo := STypeInfo asTypeInfo: (self aSTypeCollectorClass profile: [SConference price: 95]					onPackagesMatching: 'SmallSuiteGenerator-Scenario').	self assertCollection: (aTypeInfo scalars values flatCollect: [:t2 | t2])		hasSameElements: #(95 0 100 ).	aTypeInfo := STypeInfo asTypeInfo: (self aSTypeCollectorClass profile: [(SFoo new) returnCollection; returnFloat; returnNum; returnString]					onPackagesMatching: 'SmallSuiteGenerator-Scenario').	self assertCollection: aTypeInfo scalars associations hasSameElements: (Array			with: (self nameOf: SmallInteger)					-&gt; #(0 4 )			with: (self nameOf: OrderedCollection)					-&gt; (Array with: OrderedCollection new)			with: (self nameOf: ByteString)					-&gt; #('Hello' )			with: (self nameOf: 2.3 class)					-&gt; #(2.3 ))</body><body package="SSG-Extensions2" selector="testAsTypeInfoSConferenceOnPackagesMatching">testAsTypeInfoSConferenceOnPackagesMatching	| aTypeInfo messages |	messages := (aTypeInfo := STypeInfo asTypeInfo: (self aSTypeCollectorClass profile: [SConference price: 95]							onPackagesMatching: 'SmallSuiteGenerator-Scenario')) messagesFrom: (self nameOf: SConference).	self assertCollection: (messages collect: #selector)		hasSameElements: #(#initialize #price: ).	self assert: ((messages flatCollect: [:t3 | t3 receiver types])			allSatisfy: [:t4 | t4 = (self nameOf: SConference)]).	self assert: ((aTypeInfo messagesFrom: (self nameOf: SEvent))			allSatisfy: #isUnary).	self assert: (aTypeInfo messagesFrom: (self nameOf: SParty)) isEmpty.	messages := aTypeInfo factoryMessagesFrom: (self nameOf: SConference).	self assertCollection: (messages collect: #selector)		hasSameElements: #(#price: ). </body><body package="SSG-Extensions2" selector="testAsTypeInfoSEventOnPackagesMatching">testAsTypeInfoSEventOnPackagesMatching 	| typeInfo messages methodInfo classNameSEvent classNameSConference classNameSParty classNameByteString classNameSmallInteger classNameSStudent |	classNameSEvent := self nameOf: SEvent.	classNameSConference := self nameOf: SConference.	classNameSParty := self nameOf: SParty.	classNameByteString := self nameOf: ByteString.	classNameSmallInteger := self nameOf: SmallInteger.	classNameSStudent := self nameOf: SStudent.	typeInfo := STypeInfo asTypeInfo: (self aSTypeCollectorClass					profile: 						[| aConference aPerson |						aConference := SConference new offerPrice: 95.						aPerson := SStudent new name: 'Mary'.						aConference canRegister: aPerson]					onPackagesMatching: 'SmallSuiteGenerator-Scenario').	self assert: (typeInfo types at: classNameSEvent) methodTypes size equals: 4.	self assert: (typeInfo types at: classNameSEvent) classMethodTypes isEmpty.	self assert: (typeInfo types at: classNameSConference) methodTypes size equals: 5.	self assert: (typeInfo types at: classNameSConference) classMethodTypes isEmpty.	self assert: ((typeInfo types at: classNameSParty) methodTypes allSatisfy: #isUnary).	self assert: (typeInfo types at: classNameSParty) classMethodTypes isEmpty.	messages := typeInfo messagesFrom: classNameSConference.	self assertCollection: (messages collect: #selector)		hasSameElements: #(#initialize #offerPrice: #canRegister: #price ).	self assert: ((messages flatCollect: [:mess | mess receiver types])			allSatisfy: [:t13 | t13 = classNameSConference]).	methodInfo := messages detect: [:mess | mess selector = #canRegister:].	self assertCollection: methodInfo returnType types hasSameElements: (Array with: (self nameOf: False)).	self assertCollection: methodInfo allArgTypes hasSameElements: (Array with: classNameSStudent).	self assertCollection: methodInfo allReceivers hasSameElements: (Array with: classNameSConference).	self assertCollection: typeInfo scalars keys hasSameElements: (Array			with: (self nameOf: SUndefinedObject basicNew class)			with: classNameSStudent			with: classNameSmallInteger			with: (self nameOf: False)			with: classNameByteString			with: (self nameOf: 2.3 class))</body><body package="SSG-Extensions2" selector="testAsTypeInfoSFoo">testAsTypeInfoSFoo	| profile typeInfo methodInfo classNameSFoo classNameOrdColl classNameFloat classNameByteString classNameSmallInt classNameDict |	classNameSFoo := self nameOf: SFoo.	classNameOrdColl := self nameOf: OrderedCollection.	classNameFloat := self nameOf: Float.	classNameByteString := self nameOf: ByteString.	classNameSmallInt := self nameOf: SmallInteger.	classNameDict := self nameOf: Dictionary.	profile := self aSTypeCollectorClass profile: [(SFoo new) return: Dictionary new; return: OrderedCollection new; returnFloat; returnString; returnCollection; returnNum; score; score: 5]				forClassNamed: classNameSFoo.	typeInfo := STypeInfo asTypeInfo: profile.	self assert: (typeInfo types at: classNameSFoo) methodTypes size equals: 8.	self assert: (typeInfo types at: classNameSFoo) classMethodTypes size equals: 0.	self assert: (typeInfo methodType: #initialize from: classNameSFoo) returnType type equals: classNameSFoo.	methodInfo := typeInfo methodType: #return: from: classNameSFoo.	self assertCollection: methodInfo returnType types hasSameElements: (Array with: classNameOrdColl with: classNameDict).	self assertCollection: methodInfo allArgTypes hasSameElements: (Array with: classNameOrdColl with: classNameDict).	self assert: (typeInfo methodType: #returnFloat from: classNameSFoo) returnType type equals: classNameFloat.	self assert: (typeInfo methodType: #returnCollection from: classNameSFoo) returnType type equals: classNameOrdColl.	self assert: (typeInfo methodType: #returnString from: classNameSFoo) returnType type equals: classNameByteString.	self assert: (typeInfo methodType: #returnNum from: classNameSFoo) returnType type equals: classNameSmallInt.	self assert: (typeInfo methodType: #score from: classNameSFoo) returnType type equals: classNameSmallInt.	methodInfo := typeInfo methodType: #score: from: classNameSFoo.	self assert: methodInfo returnType type equals: classNameSFoo.	self assertCollection: methodInfo allArgTypes hasSameElements: (Array with: classNameSmallInt).	self assert: (typeInfo factoryMessagesFrom: classNameSFoo) isEmpty.	self assertCollection: typeInfo scalars keys hasSameElements: (Array			with: classNameOrdColl			with: classNameDict			with: classNameByteString			with: classNameSmallInt			with: classNameFloat)</body><body package="SSG-Extensions2" selector="testAsTypeInfoSFooOnClass">testAsTypeInfoSFooOnClass	| profile typeInfo metohdInfo classNameSFoo |	classNameSFoo := self nameOf: SFoo.	profile := self aSTypeCollectorClass profile: [SFoo new return: OrderedCollection]				forClassNamed: classNameSFoo.	typeInfo := STypeInfo asTypeInfo: profile.	self assert: (typeInfo types at: classNameSFoo) methodTypes size equals: 7.	self assert: (typeInfo types at: classNameSFoo) classMethodTypes isEmpty.	self assert: (typeInfo methodType: #initialize from: classNameSFoo) returnType type equals: classNameSFoo.	metohdInfo := typeInfo methodType: #return: from: classNameSFoo.	self assertCollection: metohdInfo returnType types hasSameElements: (Array with: (self nameOf: OrderedCollection class)).	self assertCollection: metohdInfo allArgTypes hasSameElements: (Array with: (self nameOf: OrderedCollection class)).	self assertCollection: ((typeInfo messagesFrom: classNameSFoo)			collect: #selector)		hasSameElements: #(#returnFloat #returnCollection #initialize #returnNum #returnString #return: )</body><body package="SSG-Extensions2" selector="testAsTypeInfoSFooWithNil">testAsTypeInfoSFooWithNil 	| profile typeInfo methodInfo classNameSFoo |	classNameSFoo := self nameOf: SFoo.	profile := self aSTypeCollectorClass profile: [SFoo new return: nil]				forClassNamed: classNameSFoo.	typeInfo := STypeInfo asTypeInfo: profile.	self assert: (typeInfo types at: classNameSFoo) methodTypes size equals: 7.	self assert: (typeInfo types at: classNameSFoo) classMethodTypes isEmpty.	self assert: (typeInfo methodType: #initialize from: classNameSFoo) returnType type equals: classNameSFoo.	methodInfo := typeInfo methodType: #return: from: classNameSFoo.	self assertCollection: methodInfo returnType types hasSameElements: (Array with: (self nameOf: UndefinedObject)).	self assertCollection: methodInfo allArgTypes hasSameElements: (Array with: (self nameOf: UndefinedObject)).	self assertCollection: ((typeInfo messagesFrom: classNameSFoo)			collect: #selector)		hasSameElements: #(#returnFloat #returnCollection #initialize #returnNum #returnString #return: )</body><body package="SSG-Extensions2" selector="testAsTypeInfoSTeacherOnClass">testAsTypeInfoSTeacherOnClass	| typeInfo classNameSTeacher |	classNameSTeacher := self nameOf: SSTeacher.	typeInfo := STypeInfo asTypeInfo: (self aSTypeCollectorClass profile: [(SSTeacher name: 'Ann' with: 34) name; nickname; yearsWorkExperience; idTeacher; id]					forClassNamed: classNameSTeacher).	self assertCollection: ((typeInfo types at: classNameSTeacher) methodTypes values collect: #selector)		hasSameElements: #(#idTeacher #initialize #nickname #yearsWorkExperience ).	self assert: (typeInfo types at: classNameSTeacher) classMethodTypes isEmpty.	self assertCollection: ((typeInfo messagesFrom: classNameSTeacher)			collect: #selector)		hasSameElements: #(#initialize #nickname ).	self assertCollection: ((typeInfo accessMessagesFrom: classNameSTeacher)			collect: #selector)		hasSameElements: #(#idTeacher #yearsWorkExperience ).</body><body package="SSG-Extensions2" selector="testAsTypeInfoSTeacherOnPackagesMatching">testAsTypeInfoSTeacherOnPackagesMatching 	| typeInfo |	typeInfo := STypeInfo asTypeInfo: (self aSTypeCollectorClass profile: [(SSTeacher name: 'Ann' with: 34) name; nickname; yearsWorkExperience; idTeacher; id]					onPackagesMatching: 'SmallSuiteGenerator-Scenario').	self assertCollection: ((typeInfo types at: (self nameOf: SSTeacher)) methodTypes values collect: #selector)		hasSameElements: #(#idTeacher #initialize #nickname #yearsWorkExperience ).	self assertCollection: ((typeInfo factoryMessagesFrom: (self nameOf: SSTeacher))			collect: #selector)		hasSameElements: #(#name:with: ).	self assertCollection: ((typeInfo messagesFrom: (self nameOf: SSTeacher))			collect: #selector)		hasSameElements: #(#initialize #nickname #id: #nickname: #name: ).	self assertCollection: ((typeInfo accessMessagesFrom: (self nameOf: SSTeacher))			collect: #selector)		hasSameElements: #(#idTeacher #yearsWorkExperience #name #id ).</body><body package="SSG-Extensions2" selector="testFactoryMessages">testFactoryMessages	| typeInfo classNameSStudent | 	classNameSStudent := self nameOf: SStudent.	typeInfo := STypeInfo asTypeInfo: (self aSTypeCollectorClass profile: [SStudent name: 'Mary']					forClassNamed: classNameSStudent).	self assert: (typeInfo factoryMessagesFrom: classNameSStudent) isEmpty.	typeInfo := STypeInfo asTypeInfo: (self aSTypeCollectorClass profile: [SStudent name: 'Mary']					onPackagesMatching: 'SmallSuiteGenerator-Scenario').	self assertCollection: ((typeInfo factoryMessagesFrom: classNameSStudent)			collect: #selector)		hasSameElements: #(#name: ).	typeInfo := STypeInfo asTypeInfo: (self aSTypeCollectorClass profile: [SConference price: 95]					onPackagesMatching: 'SmallSuiteGenerator-Scenario').	self assertCollection: ((typeInfo factoryMessagesFrom: (self nameOf: SConference))			collect: #selector)		hasSameElements: #(#price: )</body></methods><methods><class-id>SmallSuiteGenerator.SObject</class-id> <category>accessing</category><body package="SSG-Extensions2" selector="classOf:">classOf: aString 	| aClass |	(aClass := self findClass: aString) ifEmpty: [self error: 'I cant find the class with name: ' , aString].	^aClass</body><body package="SSG-Extensions2" selector="findClass:">findClass: aString 	^Root allClasses select: [:aClass | aString = aClass fullName or: ['*.' , aString match: aClass fullName]]</body><body package="SSG-Extensions2" selector="fullNameOfClass:">fullNameOfClass: aString 	| aClass | 	(aClass := self findClass: aString) ifNotEmpty: [^aClass collect: [:each | each fullName]]		ifEmpty: [self error: 'I cant find the namespace for: ' , aString]</body><body package="SSG-Extensions2" selector="fullSymbolOf:">fullSymbolOf: aSymbol  	| aClass |	(aClass := self findClass: aSymbol asString) ifNotEmpty: [^aClass collect: [:each | each fullName asSymbol]]		ifEmpty: [self error: 'I cant find the namespace for: ' , aSymbol]</body></methods><methods><class-id>SmallSuiteGenerator.SObject</class-id> <category>as yet unclassified</category><body package="SSG-Extensions2" selector="initialize">initialize</body></methods><methods><class-id>Core.LimitedPrecisionReal</class-id> <category>As yet unclassified</category><body package="SSG-Extensions3" selector="isBigEndian">isBigEndian	&lt;primitive: 534&gt;	self primitiveFailed</body><body package="SSG-Extensions3" selector="isInfinity">isInfinity	self isSpecialValue ifTrue: [^self mantissaBitsAreZero].	^false</body><body package="SSG-Extensions3" selector="isLittleEndian">isLittleEndian	^self isBigEndian not</body><body package="SSG-Extensions3" selector="mantissaBitsAreZero">mantissaBitsAreZero	self subclassResponsibility</body></methods><methods><class-id>Core.Dictionary</class-id> <category>testing</category><body package="SSG-Extensions3" selector="=">= aDict	self == aDict ifTrue: [^true].	self species == aDict species ifFalse: [^false].	self size = aDict size ifFalse: [^false].	self keysAndValuesDo: [:t2 :t3 | (aDict at: t2 ifAbsent: [^false])			= t3			ifTrue: [nil]			ifFalse: [^false]].	^true</body></methods><methods><class-id>Core.Dictionary</class-id> <category>accessing</category><body package="SSG-Extensions3" selector="at:ifPresent:ifAbsent:">at: key ifPresent: aBlock ifAbsent: absentBlock 	| flag value |	flag := true.	value := self at: key ifAbsent: [flag := false].	flag ifTrue: [^aBlock cull: value].	^absentBlock value</body><body package="SSG-Extensions3" selector="at:ifPresent:ifAbsentPut:">at: key ifPresent: aBlock ifAbsentPut: absentBlock 	^self		at: key		ifPresent: aBlock		ifAbsent: [self at: key put: absentBlock value] </body></methods><methods><class-id>Core.Dictionary</class-id> <category>binary storage</category><body package="SSG-Extensions3" selector="representBinaryOn:">representBinaryOn: aStream 	| aMess |	aMess := MessageSend				receiver: self class				selector: #withAll:				argument: self associations asArray.	aStream expectCycles ifTrue: [^BinaryObjectStorage indexImportSendSelf -&gt; (Array with: #createSpecialObject: with: (BOSSSpecialObjectLoader message: aMess))].	^aMess</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>adding</category><body package="SSG-Extensions3" selector="add:afterIndex:">add: anObject afterIndex: anIndex  	(anIndex between: 0 and: self size)		ifFalse: [^self errorOutOfBounds].	self insert: anObject before: firstIndex + anIndex.	^anObject</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>enumerating</category><body package="SSG-Extensions3" selector="average">average	^self sum / self size</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>binary storage</category><body package="SSG-Extensions3" selector="representBinaryOn:">representBinaryOn: aStream	^MessageSend		receiver: self class		selector: #withAll:		argument: (self isEmpty				ifTrue: [#( )]				ifFalse: [self asArray])</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>enumerating</category><body package="SSG-Extensions3" selector="sum">sum  	^self inject: 0 into: [:sum :each | sum + each]</body></methods><methods><class-id>Core.ByteString</class-id> <category>binary storage</category><body package="SSG-Extensions3" selector="representBinaryOn:">representBinaryOn: aStream 	^BinaryObjectStorage indexImportByteString -&gt; self</body></methods><methods><class-id>Core.SmallInteger</class-id> <category>security</category><body package="SSG-Extensions3" selector="asBigEndianByteArray">asBigEndianByteArray	| t1 t2 |	self negative ifTrue: [self errorConvertingNegativeIntegerToBytes].	self &gt; 65535		ifTrue: 			[t1 := self bitShift: -16.			t2 := self bitAnd: 65535.			t1 &gt; 255 ifTrue: [^ByteArray					with: (t1 bitShift: -8)					with: (t1 bitAnd: 255)					with: (t2 bitShift: -8)					with: (t2 bitAnd: 255)].			^ByteArray				with: (t1 bitAnd: 255)				with: (t2 bitShift: -8)				with: (t2 bitAnd: 255)].	self &gt; 255 ifTrue: [^ByteArray with: (self bitShift: -8)			with: (self bitAnd: 255)].	^ByteArray with: (self bitAnd: 255) </body><body package="SSG-Extensions3" selector="specialLeftShift:">specialLeftShift: aNumber	aNumber = 0 ifFalse: [^(self bitAnd: (self class leftShiftArray at: aNumber))			bitShift: aNumber] </body></methods><methods><class-id>Core.Double</class-id> <category>comparing</category><body package="SSG-Extensions3" selector="mantissaBitsAreZero">mantissaBitsAreZero	| index index2 |	self isLittleEndian		ifTrue: 			[index := 1.			[index &lt;= 6]				whileTrue: 					[(self basicAt: index)						= 0 ifFalse: [^false].					index := index + 1].			^((self basicAt: 7)				bitAnd: 15)				= 0].	index2 := 3.	[index2 &lt;= 8]		whileTrue: 			[(self basicAt: index2)				= 0 ifFalse: [^false].			index2 := index2 + 1].	^((self basicAt: 2)		bitAnd: 15)		= 0</body></methods><methods><class-id>Core.False</class-id> <category>tt-utilities</category><body package="SSG-Extensions3" selector="textRepresentation">textRepresentation	^'F'</body></methods><methods><class-id>Core.SmallDouble</class-id> <category>comparing</category><body package="SSG-Extensions3" selector="mantissaBitsAreZero">mantissaBitsAreZero	^self asDegenerateDouble mantissaBitsAreZero</body></methods><methods><class-id>Core.Float</class-id> <category>comparing</category><body package="SSG-Extensions3" selector="mantissaBitsAreZero">mantissaBitsAreZero 	self isLittleEndian		ifTrue: 			[(self basicAt: 1)				= 0				ifTrue: 					[(self basicAt: 2)						= 0 ifTrue: [^((self basicAt: 3)							bitAnd: 127)							= 0].					^false].			^false].	(self basicAt: 4)		= 0		ifTrue: 			[(self basicAt: 3)				= 0 ifTrue: [^((self basicAt: 2)					bitAnd: 127)					= 0].			^false].	^false</body></methods><methods><class-id>Core.Float</class-id> <category>converting</category><body package="SSG-Extensions3" selector="specialValueExponent">specialValueExponent	^128 </body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>RBProgramNodeVisitor</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><class><name>Random</name><environment>Core</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>seed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>SObject</name><environment>SmallSuiteGenerator</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><class><name>SSimpleFitnessFunction</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SFitnessFunction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>profiler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><class><name>SmallTypeCollector</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>classDict </class-inst-vars><imports></imports><category>SmallSuiteGenerator-SmallType</category><attributes><package>SmallSuiteGenerator-SmallType</package></attributes></class><class><name>SequenceNode</name><environment>Kernel</environment><super>Kernel.ValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>temporaries statements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>SGAEngine</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>populationSize mutationOperator crossoverOperator numberOfStatements population logs typeInfo fitness selectionStrategy targetClassName numberOfGenerations lastMessage packageRegex initialPopulation typeInfoProfiler targetPackageRegex elitismRate crossoverRate stopIterations totalExecutionGA selectionStrategyTestCase </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><class><name>SSTestShifter</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>statements assertions typeInfo nextId fitness targetClassesNames maxNumberOfStatements validatedTargetClassName fitnessByClass parents children lastMessage selectionStrategy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><class><name>SSTestCase</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSTestShifter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>idPopulation previousOpenWindows summaryExecutionMethods generationNumber hasErrors summaryTargetClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><class><name>GenericException</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messageText originator initialContext firstUnwindContext handlerContext parameter proceedBlock isResumable signal searchContext </inst-vars><class-inst-vars>notifierString </class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>SUtilityTypeInfo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Utility</category><attributes><package>SmallSuiteGenerator-Tests-Utility</package></attributes></class><class><name>SGAEngineExample</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>False</name><environment>Core</environment><super>Core.Boolean</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SError</name><environment>SmallSuiteGenerator</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><class><name>Time</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hours minutes seconds </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>SSTestShifterTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SmallSuiteGenerator-Tests-Core</package></attributes></class><class><name>SAssertionTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpressionTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-AST</category><attributes><package>SmallSuiteGenerator-Tests-AST</package></attributes></class><class><name>STypeInfoTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Info</category><attributes><package>SmallSuiteGenerator-Tests-Info</package></attributes></class><class><name>SSTestRunner</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testCase invariants </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><class><name>SGAEngineTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>engine profiler utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-GA</category><attributes><package>SmallSuiteGenerator-Tests-GA</package></attributes></class><class><name>RBVariableNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>token </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>LimitedPrecisionReal</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SmallDouble</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>SStack</name><environment>SmallSuiteGenerator</environment><super>Core.LinkedList</super><private>false</private><indexed-type>none</indexed-type><inst-vars>firstLinkStack lastLinkStack </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario</category><attributes><package>SmallSuiteGenerator-Scenario</package></attributes></class><class><name>OrderedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>firstIndex lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>ByteSymbol</name><environment>Core</environment><super>Core.Symbol</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>SSTestCaseTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SmallSuiteGenerator-Tests-Core</package></attributes></class><class><name>SChangeTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSTestCaseTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SmallSuiteGenerator-Tests-Core</package></attributes></class><class><name>SInsertTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSTestCaseTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SmallSuiteGenerator-Tests-Core</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>ProbedCompiledMethod</name><environment>CraftedSmalltalk</environment><super>Kernel.CompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>original methodHolder probeStart </inst-vars><class-inst-vars>removedProbedMethodsHolder </class-inst-vars><imports>			OpcodePool.*			</imports><category>CraftedSt-VM</category><attributes><package>Debugger-Probes</package></attributes></class><class><name>STestCaseFactory</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>reportClass engine typeInfo targetClassName targetPackageRegex outputPackageName fitness numberOfIterations profiler setUpMethod tearDownMethod lastMessage asDict fitnessSeed initialSeed initialAsDict typeInfoSeed typeInfoOrigin firstExecution generatedClass </inst-vars><class-inst-vars>instance </class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><class><name>STestCaseFactoryVisualWorks</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.STestCaseFactory</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><class><name>InstructionStream</name><environment>Kernel</environment><super>Kernel.InstructionClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method pc </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Context</name><environment>Kernel</environment><super>Kernel.InstructionStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sender receiver stackp stack </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>AuxCodeInfoExtractor</name><environment>CraftedSmalltalk</environment><super>Kernel.InstructionStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>depth jumpStack maxDepth visited </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-VM</category><attributes><package>Debugger-Probes</package></attributes></class><class><name>STypeClassInfo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.STypeObjectInfo</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeName methodTypes classMethodTypes scalars </inst-vars><class-inst-vars>classMethodTypes </class-inst-vars><imports></imports><category>SmallSuiteGenerator-Info</category><attributes><package>SmallSuiteGenerator-Info</package></attributes></class><class><name>Double</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Link</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nextLink </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>LinkValue</name><environment>Core</environment><super>Core.Link</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>STypeInfo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>types classes noneAbstractClasses scalars blackList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Info</category><attributes><package>SmallSuiteGenerator-Info</package></attributes></class><class><name>Float</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Array</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>ByteString</name><environment>Core</environment><super>Core.ByteEncodedString</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>SmallInteger</name><environment>Core</environment><super>Core.Integer</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars>minVal maxVal maxBits maxBytes </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class></st-source>