<?xml version="1.0"?><st-source><!-- Name: SSG-ExtensionsBundleName: SSG-ExtensionsBundleStructure: a Store.BundleForParcelParcel: #('SSG-Extensions' )ParcelName: SSG-ExtensionsPrerequisiteParcels: #(#('SmallSuiteGenerator' '' ) )Date: 4:41:30 pm December 3, 2020 --><time-stamp>From VisualWorksÂ®, 7.4 of December 5, 2005 on December 3, 2020 at 4:41:30 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>OrderedDictionary</name><environment>Smalltalk</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>dictionary orderedKeys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SSG-Extensions</package></attributes></class><comment><class-id>OrderedDictionary</class-id><body>Missing comment</body></comment><class><name>SStateCoverage</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSimpleFitnessFunction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>class </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SSG-Extensions2</package></attributes></class><class><name>SVisitorNodes</name><environment>SmallSuiteGenerator</environment><super>Refactory.Browser.RBProgramNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isAbstractt </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Extensions2</category><attributes><package>SSG-Extensions2</package></attributes></class><shared-variable><name>PundleAccess</name><environment>SmallSuiteGenerator.STestCaseFactory</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>SSG-Extensions2</package></attributes></shared-variable><methods><class-id>OrderedDictionary</class-id> <category>testing</category><body package="SSG-Extensions" selector="isDictionary">isDictionary	^true</body></methods><methods><class-id>OrderedDictionary</class-id> <category>initialize-release</category><body package="SSG-Extensions" selector="initialize">initialize	dictionary := Dictionary new: 10.	orderedKeys := Array new: 10.</body></methods><methods><class-id>OrderedDictionary</class-id> <category>adding</category><body package="SSG-Extensions" selector="add:">add: anObject	| size |	size := dictionary size.	dictionary add: anObject.	dictionary size &gt; size		ifTrue: 			[orderedKeys size &gt; size ifFalse: [self growOrderedKeys].			orderedKeys at: size + 1 put: anObject key].	^anObject </body><body package="SSG-Extensions" selector="addAll:">addAll: aCollection 	aCollection associationsDo: [:anObject | self add: anObject].	^aCollection</body></methods><methods><class-id>OrderedDictionary</class-id> <category>accessing</category><body package="SSG-Extensions" selector="associationAt:">associationAt: aKey	^dictionary associationAt: aKey</body><body package="SSG-Extensions" selector="associations">associations	| index associations |	associations := Array new: self size.	index := 1.	self		associationsDo: 			[:t3 | 			associations at: index put: t3.			index := index + 1].	^associations</body><body package="SSG-Extensions" selector="associationsDo:">associationsDo: aBlock	self keysDo: [:each | aBlock value: (self associationAt: each)]</body><body package="SSG-Extensions" selector="at:">at: key	^dictionary at: key</body><body package="SSG-Extensions" selector="at:ifAbsent:">at: aKey ifAbsent: aBlock 	^dictionary at: aKey ifAbsent: aBlock</body><body package="SSG-Extensions" selector="at:ifAbsentPut:">at: aKey ifAbsentPut: anObject 	^self at: aKey ifAbsent: [self at: aKey put: anObject value]</body><body package="SSG-Extensions" selector="at:ifPresent:">at: key ifPresent: aBlock	^dictionary at: key ifPresent: aBlock</body><body package="SSG-Extensions" selector="at:put:">at: key put: anObject 	| oldSize |	oldSize := dictionary size.	dictionary at: key put: anObject.	dictionary size &gt; oldSize		ifTrue: 			[orderedKeys size &gt; oldSize ifFalse: [self growOrderedKeys].			orderedKeys at: oldSize + 1 put: key].	^anObject</body><body package="SSG-Extensions" selector="do:">do: aBlock 	self valuesDo: aBlock</body><body package="SSG-Extensions3" selector="encodeAsJSONDataUsing:">encodeAsJSONDataUsing: t1	| t2 |	t1 beginObject.	t2 := 0.	(orderedKeys reject: #isNil)		do: 			[:t3 | 			| t4 |			t2 := t2 + 1.			t4 := dictionary at: t3.			t2 &gt; 1 ifTrue: [t1 emitComma].			t1 encodeKey: t3 value: t4].	t1 endObject.</body><body package="SSG-Extensions" selector="growOrderedKeys">growOrderedKeys	orderedKeys := (Array new: ((orderedKeys size * 1.5) asInteger max: 10))				replaceFrom: 1				to: orderedKeys size				with: orderedKeys				startingAt: 1</body><body package="SSG-Extensions" selector="includesKey:">includesKey: aKey	^dictionary includesKey: aKey</body><body package="SSG-Extensions" selector="keys">keys	^orderedKeys copyFrom: 1 to: self size</body><body package="SSG-Extensions" selector="keysDo:">keysDo: aBlock	| index size |	index := 1.	size := self size.	[index &lt;= size]		whileTrue: 			[aBlock value: (orderedKeys at: index).			index := index + 1]</body><body package="SSG-Extensions" selector="orderedKeysIndexOf:">orderedKeysIndexOf: aKey	^ orderedKeys indexOf: aKey</body><body package="SSG-Extensions" selector="size">size	^dictionary size</body><body package="SSG-Extensions" selector="values">values 	^self associations collect: [:each | each value]</body></methods><methods><class-id>OrderedDictionary</class-id> <category>removing</category><body package="SSG-Extensions" selector="orderedKeysRemove:">orderedKeysRemove: aRemovedKey	| index |	index := self orderedKeysIndexOf: aRemovedKey.	"shift every remaining key after to the left by one"	orderedKeys		replaceFrom: index		to: self size		with: orderedKeys		startingAt: index + 1.	"one key was removed and the rest shifted, so nil what was the last	key slot before removing and shifting"	orderedKeys		at: self size + 1		put: nil.</body><body package="SSG-Extensions" selector="removeKey:">removeKey: aKey	| value |	value := dictionary removeKey: aKey.	self orderedKeysRemove: aKey.	^ value.</body></methods><methods><class-id>OrderedDictionary</class-id> <category>comparing</category><body package="SSG-Extensions" selector="=">= anObject  	self == anObject ifTrue: [^true].	(self species == anObject species and: [self size = anObject size])		ifFalse: [^false].	dictionary associationsDo: [:each | (anObject at: each key ifAbsent: [^false])			= each value			ifTrue: [nil]			ifFalse: [^false]].	^true</body><body package="SSG-Extensions" selector="hash">hash	^dictionary hash</body></methods><methods><class-id>OrderedDictionary</class-id> <category>enumerating</category><body package="SSG-Extensions" selector="collect:">collect: aBlock 	^self species newFrom: (self associations collect: [:assoc | assoc key -&gt; (aBlock value: assoc value)])</body><body package="SSG-Extensions" selector="keysAndValuesDo:">keysAndValuesDo: aBlock 	self keysDo: [:key | aBlock value: key value: (self at: key)].</body><body package="SSG-Extensions" selector="valuesDo:">valuesDo: aBlock  	self keysDo: [:each | aBlock value: (self at: each)]</body></methods><methods><class-id>OrderedDictionary class</class-id> <category>instance creation</category><body package="SSG-Extensions" selector="new">new	^super new initialize</body><body package="SSG-Extensions" selector="newFrom:">newFrom: aCollection	| inst |	inst := self new.	aCollection associationsDo: [:assoc | inst at: assoc key put: assoc value].	^inst</body></methods><methods><class-id>SmallSuiteGenerator.SStateCoverage</class-id> <category>As yet unclassified</category><body package="SSG-Extensions2" selector="class:">class: aClass 	class := aClass</body><body package="SSG-Extensions2" selector="computeFitness">computeFitness	^profiler stateCoverageFor: class</body><body package="SSG-Extensions2" selector="fitnessOf:withKey:">fitnessOf: tesCase withKey: aString 	tesCase fitness at: aString put: (profiler stateCoverageFor: class).	tesCase fitnessByClass at: aString put: profiler statementCoverage1</body><body package="SSG-Extensions2" selector="functionName">functionName	^'state-coverage'</body><body package="SSG-Extensions2" selector="setUp">setUp</body><body package="SSG-Extensions2" selector="tearDown">tearDown</body></methods><methods><class-id>SmallSuiteGenerator.SStateCoverage class</class-id> <category>As yet unclassified</category><body package="SSG-Extensions2" selector="for:">for: aClass	^self new class: aClass</body></methods><methods><class-id>SmallSuiteGenerator.SVisitorNodes</class-id> <category>initialize-release</category><body package="SSG-Extensions2" selector="isAbstract">isAbstract	^isAbstractt ifNil: [false]</body></methods><methods><class-id>SmallSuiteGenerator.SVisitorNodes</class-id> <category>visitor-double dispatching</category><body package="SSG-Extensions2" selector="acceptMessageNode:">acceptMessageNode: aNode	isAbstractt := aNode selector == #subclassResponsibility. </body></methods><methods><class-id>Core.ClassDescription</class-id> <category>binary storage</category><body package="SSG-Extensions" selector="package">package	^ Store.Registry containingPackageForClass: self</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>copying</category><body package="SSG-Extensions" selector="allButLast">allButLast	^self allButLast: 1</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>comparing</category><body package="SSG-Extensions" selector="beginsWith:">beginsWith: aSequenceableCollection	| index aColl |	self size &lt; aSequenceableCollection size ifTrue: [^false].	index := 1.	aColl := aSequenceableCollection size.	[index &lt;= aColl]		whileTrue: 			[(self at: index)				= (aSequenceableCollection at: index) ifFalse: [^false].			index := index + 1].	^true</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="SSG-Extensions" selector="combinations:atATimeDo:">combinations: kk atATimeDo: aBlock  	| aCollection |	aCollection := Array new: kk.	self		combinationsAt: 1		in: aCollection		after: 0		do: aBlock</body><body package="SSG-Extensions" selector="combinationsAt:in:after:do:">combinationsAt: jj in: aCollection after: nn do: aBlock  	| index size |	index := nn + 1.	size := self size.	[index &lt;= size]		whileTrue: 			[aCollection at: jj put: (self at: index).			jj = aCollection size				ifTrue: [aBlock value: aCollection]				ifFalse: [self						combinationsAt: jj + 1						in: aCollection						after: index						do: aBlock].			index := index + 1]</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>private</category><body package="SSG-Extensions" selector="randomShuffle">randomShuffle	^ self shuffleBy: SmallSuiteGenerator.SPlatform randomGenerator.</body><body package="SSG-Extensions" selector="safelyPickAny:ifNone:">safelyPickAny: aBlock ifNone: aNoneBlock	self randomShuffle do:[ :each|		[ ^ aBlock value: each. ] on: SmallSuiteGenerator.SError 		do:[ false ]. ].	aNoneBlock value.</body><body package="SSG-Extensions" selector="shuffleBy:">shuffleBy: aRandom	"Durstenfeld's version of the Fisher-Yates shuffle"	self size to: 2 by: -1 do: [ :i | 		self swap: i with: (aRandom nextInt: i) ]</body></methods><methods><class-id>Core.Set</class-id> <category>removing</category><body package="SSG-Extensions" selector="=">= aCollection 	self == aCollection ifTrue: [^true].	self species == aCollection species ifFalse: [^false].	self size = aCollection size ifFalse: [^false].	^self allSatisfy: [:t2 | aCollection includes: t2]</body></methods><methods><class-id>Core.Object class</class-id> <category>actions</category><body package="SSG-Extensions" selector="createMainMethodsFor:">createMainMethodsFor: aClass	aClass aClass: self.	aClass targetPackageRegex: self package name asString</body><body package="SSG-Extensions" selector="createTestCaseConfig">createTestCaseConfig	|aClass|	aClass := self getClassOf: ('GA' , self name , 'Test').	self createMainMethodsFor: aClass.	^ aClass</body></methods><methods><class-id>Core.Object class</class-id> <category>testing</category><body package="SSG-Extensions" selector="equalsTo:">equalsTo: anObject	^ self = anObject</body></methods><methods><class-id>Core.Object class</class-id> <category>actions</category><body package="SSG-Extensions" selector="getClassOf:">getClassOf: aString	| aClassName class |	aClassName := aString asSymbol.	class := SmallSuiteGenerator.SPlatform lookUpClass: aClassName.	class		ifNil: [ class := SmallSuiteGenerator.SPlatform				createTestCaseClass: aClassName				inPackage: SmallSuiteGenerator.SPlatform testCaseClass outputPackageName].	^ class</body></methods><methods><class-id>Core.Object</class-id> <category>comparing</category><body package="SSG-Extensions" selector="asLink">asLink	^LinkValue value: self</body></methods><methods><class-id>Core.Object</class-id> <category>copying</category><body package="SSG-Extensions" selector="aSLProfilerCoverage">aSLProfilerCoverage	^Spy1.SLProfilerCoverage</body></methods><methods><class-id>Core.Object</class-id> <category>controlling</category><body package="SSG-Extensions" selector="assert:description:">assert: aBlock description: aStringOrBlock 	aBlock value ifFalse: [self error: aStringOrBlock]</body><body package="SSG-Extensions" selector="aSTypeCollectorClass">aSTypeCollectorClass	^Spy1.SSTypeCollector</body><body package="SSG-Extensions" selector="aVariableNodeClass">aVariableNodeClass	^Refactory.Browser.RBVariableNode</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="SSG-Extensions" selector="className">className	^self class name asString</body></methods><methods><class-id>Core.Object</class-id> <category>instrumentation</category><body package="SSG-Extensions" selector="containUncleanedBlocks">containUncleanedBlocks	| semaphore process result timeOut |	result := self isUncleanedBlock.		semaphore := Semaphore new.	process := [ [ 		1 to: self class instSize do: [ :i | result := result or: [(self instVarAt: i) isUncleanedBlock ] ].		1 to: self basicSize do: [ :i | result := result or: [ (self basicAt: i) isUncleanedBlock ] ].		semaphore signal. ] on: Error		do: [ semaphore signal ]] 	forkAt: Processor userBackgroundPriority named: 'DepthProcess'.	timeOut := semaphore waitTimeoutMSecs: 1000.	timeOut ifTrue: [ 		process terminate.		self halt. ].	^ result</body></methods><methods><class-id>Core.Object</class-id> <category>copying</category><body package="SSG-Extensions" selector="deepCopy">deepCopy	^self dcopy</body></methods><methods><class-id>Core.Object</class-id> <category>instrumentation</category><body package="SSG-Extensions" selector="depthIsLowerThan:">depthIsLowerThan: aNumber		| semaphore process result timeOut |		result := false.		semaphore := Semaphore new.	process := [ [		result := self objectDepth &lt; aNumber.		semaphore signal. ] on: Error 	do: [ semaphore signal ] ] forkAt: Processor userBackgroundPriority named: 'DepthProcess'.	timeOut := semaphore waitTimeoutMSecs: 1000.	timeOut ifTrue: [		process terminate.		self halt. ].		^ result.</body></methods><methods><class-id>Core.Object</class-id> <category>printing</category><body package="SSG-Extensions" selector="isBlock">isBlock	^false</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="SSG-Extensions" selector="isDeprecated">isDeprecated	^false</body></methods><methods><class-id>Core.Object</class-id> <category>event accessing</category><body package="SSG-Extensions" selector="isNotNil">isNotNil	^true</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="SSG-Extensions" selector="mutateToChange">mutateToChange	^self</body></methods><methods><class-id>Core.Object</class-id> <category>class initialization</category><body package="SSG-Extensions" selector="perform:withEnoughArguments:">perform: selector withEnoughArguments: anArray 	| numArgs args |	numArgs := selector numArgs.	anArray size == numArgs ifTrue: [^self perform: selector withArguments: anArray asArray].	(args := Array new: numArgs)		replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^self perform: selector withArguments: args</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="SSG-Extensions" selector="storeOn:">storeOn: aStream 	"Append to the argument aStream a sequence of characters that is an expression 	whose evaluation creates an object similar to the receiver.  This is appropriate only	for smaller simpler objects.  It cannot handle arbitrary circular references of objects.	For large complex objects with circular references you should consider using the	Binary Object Storage System (BOSS) class (BinaryObjectStorage).	The general format for objects is		(class-name basicNew 			instVarAt: index put: variable;			basicAt: index put: element;			yourself)	or		((class-name basicNew: size )			instVarAt: index put: variable;			basicAt: index put: element;			yourself) "	aStream nextPut: $(.	self class isVariable		ifTrue: [aStream nextPutAll: '(';					store: self class;					nextPutAll: ' basicNew: ';					store: self basicSize;					nextPutAll: ') ']		ifFalse: [aStream store: self class; nextPutAll: ' basicNew'].	1 to: self class instSize do:		[:i |		aStream nextPutAll: ' instVarAt: ';			store: i;			nextPutAll: ' put: ';			store: (self instVarAt: i);			nextPut: $;].	1 to: self basicSize do:		[:i |		aStream nextPutAll: ' basicAt: ';			store: i;			nextPutAll: ' put: ';			store: (self basicAt: i);			nextPut: $;].	aStream nextPutAll: ' yourself)'</body></methods><methods><class-id>SUnit.TestCase</class-id> <category>backwards compatibility</category><body package="SSG-Extensions" selector="assertCollection:includesAll:">assertCollection: actualCollection includesAll: subCollection 	^self assert: (actualCollection includesAll: subCollection)		description: [actualCollection asString , ' does not include all in ' , subCollection asString]</body><body package="SSG-Extensions" selector="deny:equals:">deny: actual equals: expected	actual = expected ifTrue: [self signalFailure: actual printString , ' is not equal to ' , expected printString].	^self</body></methods><methods><class-id>SUnit.TestCase</class-id> <category>converting</category><body package="SSG-Extensions" selector="fullNameOfClass:">fullNameOfClass: aSymbol	#('Core.' 'Smalltalk.' 'SmallSuiteGenerator.' ) detect: [:t2 | (Smalltalk at: t2 , aSymbol ifAbsent: [nil]) isNil not]		ifFound: [:t3 | ^t3 , aSymbol asString].	self error: 'I cant find the namespace for: ' , aSymbol.</body><body package="SSG-Extensions" selector="fullSymbolOf:">fullSymbolOf: aSymbol	#('Core.' 'Smalltalk.' 'SmallSuiteGenerator.' ) detect: [:t2 | (Smalltalk at: t2 , aSymbol ifAbsent: [nil]) isNil not]		ifFound: [:t3 | ^(t3 , aSymbol) asSymbol].	self error: 'I cant find the namespace for: ' , aSymbol.</body></methods><methods><class-id>Kernel.Context</class-id> <category>accessing-debugger</category><body package="SSG-Extensions" selector="namedTempAt:">namedTempAt: index	^self tempAt: index</body></methods><methods><class-id>CraftedSmalltalk.AuxCodeInfoExtractor</class-id> <category>decoding</category><body package="SSG-Extensions" selector="run">run	[self atEnd]		whileFalse: 			[visited at: pc put: true.			self interpretNextInstructionFor: self.			pc &lt;= visited size ifTrue: [(visited at: pc)					ifTrue: [self endBranch]]]</body></methods><methods><class-id>Refactory.Browser.RBMessageNode</class-id> <category>visitor</category><body package="SSG-Extensions" selector="accept:">accept: aProgramNodeVisitor	^ aProgramNodeVisitor visitMessageNode: self</body></methods><methods><class-id>Core.Array</class-id> <category>printing</category><body package="SSG-Extensions" selector="printOn:">printOn: aStream 	"Append the string representation of the receiver to aStream."		| toMany |	toMany := aStream position + self maxPrint.	aStream nextPutAll: '#('.	self		do: 			[:t3 | 			aStream position &gt; toMany				ifTrue: 					[aStream nextPutAll: (#etc &lt;&lt; #dialogs &gt;&gt; '...etc...') asString , ')'.					^self].			t3 printOn: aStream]		separatedBy: [aStream space].	aStream space.	aStream nextPut: $).</body><body package="SSG-Extensions" selector="storeOn:">storeOn: aStream 	self isLiteral		ifTrue: 			[aStream nextPutAll: '#('.			aStream policy printCharactersLiterally: true while: [self do: [:t2 | t2 storeOn: aStream]					separatedBy: [aStream space]].			aStream space.			aStream nextPut: $)]		ifFalse: [super storeOn: aStream]</body></methods><methods><class-id>Core.Number</class-id> <category>testing</category><body package="SSG-Extensions" selector="mutateToChange">mutateToChange	^(self perform: (SmallSuiteGenerator.SPlatform randomGenerator selectAtRandom: #(#+ #- #* ))		with: (SmallSuiteGenerator.SPlatform randomGenerator selectAtRandom: (1 to: 100) asArray))		perform: (SmallSuiteGenerator.SPlatform randomGenerator selectAtRandom: #(#+ #- ))		with: 1</body></methods><methods><class-id>Core.Link</class-id> <category>accessing</category><body package="SSG-Extensions" selector="asLink">asLink	^self</body></methods><methods><class-id>Core.OrderedCollection class</class-id> <category>instance creation</category><body package="SSG-Extensions" selector="newFrom:">newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."	| newCollection |	newCollection := self new: aCollection size.	newCollection addAll: aCollection.	^newCollection</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>removing</category><body package="SSG-Extensions" selector="removeAt:">removeAt: index	^ self removeAtIndex: index	</body></methods><methods><class-id>Core.ByteSymbol</class-id> <category>testing</category><body package="SSG-Extensions" selector="mutateToChange">mutateToChange	| interval stringCopy |	interval := Character alphabet , $_ asString.	stringCopy := self ifEmpty: ['']				ifNotEmpty: [self copyFrom: 1 to: self size - 1].	^((SmallSuiteGenerator.SPlatform randomGenerator selectAtRandom: interval) asString , stringCopy , (SmallSuiteGenerator.SPlatform randomGenerator selectAtRandom: interval) asString) asSymbol</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>accessing</category><body package="SSG-Extensions" selector="ast">ast	^Refactory.Browser.RBParser parseMethod: self getSource</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>source code management</category><body package="SSG-Extensions" selector="fullClassName">fullClassName 	^ self mclass fullName asSymbol</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>testing</category><body package="SSG-Extensions" selector="isAbstract">isAbstract	^ self isShort and:[ self messages anySatisfy:[:m | m = #subclassResponsibility]].</body><body package="SSG-Extensions" selector="isReturnField">isReturnField	|c a b|	self isShort ifFalse:[ ^ false].	a := false.	b := false.	c := 0.	self withAllBlockMethodsDo:[ :meth |		|scanner |		scanner := InstructionStream on: meth.		scanner scanFor: [ :byte |			c isZero			ifTrue:[ a:= scanner isLoadInst.].			c =1 ifTrue:[ b:= scanner willReturn].			c := c+1.			false.		].	].	^ (c = 2 and:[ a]) and:[ b].</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>accessing</category><body package="SSG-Extensions" selector="origin">origin	^self mclass</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>dependents collection</category><body package="SSG-Extensions" selector="isNotNil">isNotNil	^false</body></methods><methods><class-id>Core.Time class</class-id> <category>TimeServicesApp(dbonly)</category><body package="SSG-Extensions" selector="new">new	^super new initialize</body></methods><methods><class-id>Core.Time</class-id> <category>TimeServicesApp(dbonly)</category><body package="SSG-Extensions" selector="initialize">initialize	hours := minutes := seconds := 0.</body></methods><methods><class-id>Core.Behavior</class-id> <category>accessing method dictionary</category><body package="SSG-Extensions" selector="allMethodsBelow:">allMethodsBelow: aClass	| aSet |	aSet := IdentitySet new.	self withAllSuperclasses		do: 			[:superClass | 			superClass = aClass ifTrue: [^aSet].			superClass methodDictionary do: [:compMethod | aSet add: compMethod]].	^aSet</body><body package="SSG-Extensions" selector="allSelectorsBelow:">allSelectorsBelow: aClass	| aSet |	aSet := IdentitySet new.	self withAllSuperclasses		do: 			[:t3 | 			t3 = aClass ifTrue: [^aSet].			t3 selectors do: [:t4 | aSet add: t4]].	^aSet</body></methods><methods><class-id>Core.Behavior</class-id> <category>creating method dictionary</category><body package="SSG-Extensions" selector="isAbstract">isAbstract	^false</body><body package="SSG-Extensions" selector="methodDictValues">methodDictValues	^ self  methodDictionary values</body></methods><methods><class-id>Kernel.InstructionStream</class-id> <category>testing</category><body package="SSG-Extensions" selector="isLoadInst">isLoadInst	| byte |	byte := self baseBytecodeAt: self pc.	^ byte between: OpLoadInst and: (OpLoadInst+MaxLoadInst)</body></methods><methods><class-id>Core.Symbol</class-id> <category>system primitives</category><body package="SSG-Extensions" selector="isBinary">isBinary	^ self precedence = 2</body></methods><methods><class-id>Core.Boolean</class-id> <category>testing</category><body package="SSG-Extensions" selector="mutateToChange">mutateToChange	^self not</body></methods><methods><class-id>CraftedSmalltalk.ProbedCompiledMethod</class-id> <category>copying</category><body package="SSG-Extensions" selector="deepCopy">deepCopy	^self dcopy</body><body package="SSG-Extensions" selector="isAbstract">isAbstract	^ original isAbstract</body></methods><methods><class-id>Core.GenericException</class-id> <category>private</category><body package="SSG-Extensions" selector="performHandler:">performHandler: aContext	| result oldHandler |	(handlerContext := aContext) == nil		ifTrue: 			[result := self defaultAction.			self isResumable				ifTrue: 					[handlerContext := initialContext.					firstUnwindContext := nil.					self unwind.					thisContext terminateTo: handlerContext.					handlerContext := nil]]		ifFalse: 			[oldHandler := handlerContext.			result := handlerContext handlerBlock cull: self.			handlerContext := oldHandler.			self unwind.			thisContext terminateTo: handlerContext].	^result</body></methods><methods><class-id>Core.String class</class-id> <category>instance creation</category><body package="SSG-Extensions" selector="cr">cr	"Answer a string containing a single carriage return character."	^ self with: Character cr</body></methods><methods><class-id>Core.String</class-id> <category>instance creation</category><body package="SSG-Extensions" selector="asClass">asClass	[^ Smalltalk at: self ]	on: Error	do: [ ^ nil ]</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="SSG-Extensions" selector="asString">asString	^self</body></methods><methods><class-id>Core.String</class-id> <category>action</category><body package="SSG-Extensions" selector="format:">format: collection	"Format the receiver by interpolating elements from collection, as in the following examples:" 	"('Five is {1}.' format: { 1 + 4}) &gt;&gt;&gt; 'Five is 5.'"	"('Five is {five}.' format: (Dictionary with: #five -&gt; 5)) &gt;&gt;&gt;  'Five is 5.'"	"('In {1} you can escape \{ by prefixing it with \\' format: {'strings'}) &gt;&gt;&gt; 'In strings you can escape { by prefixing it with \' "	"('In \{1\} you can escape \{ by prefixing it with \\' format: {'strings'}) &gt;&gt;&gt; 'In {1} you can escape { by prefixing it with \' "	^ self class		new: self size		streamContents: [ :result | 			| stream |			stream := self readStream.			[ stream atEnd ]				whileFalse: [ | currentChar |					(currentChar := stream next) == ${						ifTrue: [ | expression index |							expression := stream upTo: $}.							index := Integer readFrom: expression ifFail: [ expression ].							result nextPutAll: (collection at: index) asString ]						ifFalse: [ currentChar == $\								ifTrue: [ stream atEnd										ifFalse: [ result nextPut: stream next ] ]								ifFalse: [ result nextPut: currentChar ] ] ] ]</body><body package="SSG-Extensions" selector="fullClassName">fullClassName	|result|	result := NameSpace allInstances select: [:nameSpace | (nameSpace at: self ifAbsent: [ ]) ifNil: [false] ifNotNil: [true]] thenCollect: [:nameSpace |  (nameSpace at: self ifAbsent: [ ]) fullName ].	result ifNotEmpty: [ ^ result first ].	^ nil</body><body package="SSG-Extensions" selector="fullClassNameSymbol">fullClassNameSymbol	|className|	className := self fullClassName.	className ifNotNil: [ ^ className asSymbol ].	^ className	</body></methods><methods><class-id>Core.String</class-id> <category>testing</category><body package="SSG-Extensions" selector="mutateToChange">mutateToChange	| interval stringCopy |	interval := (41 to: 127) asArray.	stringCopy := self ifEmpty: ['']				ifNotEmpty: [self copyFrom: 1 to: self size - 1].	^((Character value: (SmallSuiteGenerator.SPlatform randomGenerator selectAtRandom: interval)) asString , stringCopy , (Character value: (SmallSuiteGenerator.SPlatform randomGenerator selectAtRandom: interval)) asString) asString</body></methods><methods><class-id>Core.String</class-id> <category>instance creation</category><body package="SSG-Extensions" selector="substrings:">substrings: separators	| t2 anArray t4 index size t7 |	anArray := (Array new: 10) writeStream.	index := 1.	size := self size.	[index &lt;= size]		whileTrue: 			[t4 := index.			t7 := self at: t4.			(separators includes: t7)				ifTrue: [t2						ifNotNil: 							[anArray nextPut: (self copyFrom: t2 to: t4 - 1).							t2 := nil]]				ifFalse: [t2 ifNil: [t2 := t4]].			index := index + 1].	t2 ifNotNil: [anArray nextPut: (self copyFrom: t2 to: self size)].	^anArray contents</body></methods><methods><class-id>Core.Metaclass</class-id> <category>accessing</category><body package="SSG-Extensions" selector="nameAsSymbol">nameAsSymbol	^self  fullName asSymbol</body></methods><methods><class-id>Core.Random</class-id> <category>private</category><body package="SSG-Extensions" selector="nextInt:">nextInt: anInteger	anInteger strictlyPositive ifFalse: [self error: 'Range must be positive'].	anInteger asFloat isInfinity ifTrue: [^(self next asFraction * anInteger) truncated + 1].	^(self next * anInteger) truncated + 1</body></methods><methods><class-id>Core.Random</class-id> <category>accessing</category><body package="SSG-Extensions" selector="seed:">seed: aSmallInteger	"Initialize the first random number."		seed := aSmallInteger</body></methods><methods><class-id>Core.Collection</class-id> <category>copying</category><body package="SSG-Extensions" selector="allButFirst">allButFirst	^self copyFrom: 2 to: self size</body></methods><methods><class-id>Core.Collection</class-id> <category>COMPATIBILITY-testing</category><body package="SSG-Extensions" selector="anyOne">anyOne	self emptyCheck.	self do: [:each | ^ each ]</body></methods><methods><class-id>Core.Collection</class-id> <category>copying</category><body package="SSG-Extensions" selector="copyFrom:to:">copyFrom: start to: stop	| newSize |	newSize := stop - start + 1.	^(self species withSize: newSize)		replaceFrom: 1		to: newSize		with: self		startingAt: start</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="SSG-Extensions" selector="detect:ifFound:">detect: aBlock ifFound: foundBlock	^self		detect: aBlock		ifFound: foundBlock		ifNone: [ 			"Do nothing on purpose"			 ]</body><body package="SSG-Extensions" selector="do:displayingProgress:">do: aBlock displayingProgress: anObject 	^self do: aBlock</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="SSG-Extensions" selector="fifth">fifth	^self at: 5</body><body package="SSG-Extensions" selector="fourth">fourth	^self at: 4</body></methods><methods><class-id>Core.Collection</class-id> <category>comparing</category><body package="SSG-Extensions" selector="includesAll:">includesAll: aList	aList isCollection		ifTrue: 			[aList size &lt;= self size ifTrue: [^aList allSatisfy: [:t2 | (aList occurrencesOf: t2)						&lt;= (self occurrencesOf: t2)]].			^false].	^false</body><body package="SSG-Extensions" selector="includesAny:">includesAny: aList	aList do: [:each | 			(self includes: each)				ifTrue: [^true].			nil].	^false</body></methods><methods><class-id>Core.Collection</class-id> <category>COMPATIBILITY-testing</category><body package="SSG-Extensions" selector="max">max	^self inject: self anyOne into: [:max :each | max max: each] </body></methods><methods><class-id>Core.Collection</class-id> <category>comparing</category><body package="SSG-Extensions" selector="min">min	^self inject: self anyOne into: [:min :each | min min: each]</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="SSG-Extensions" selector="pickAny">pickAny	^ self at: (SmallSuiteGenerator.SPlatform randomGenerator nextInt: self size)</body></methods><methods><class-id>Core.Collection</class-id> <category>copying</category><body package="SSG-Extensions" selector="reject:thenDo:">reject: rejectBlock thenDo: doBlock 	"Utility method to improve readability.	Do not create the intermediate collection."		self do: [ :each |		(rejectBlock value: each)			ifFalse: [ doBlock value: each ] ].</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="SSG-Extensions" selector="second">second	^self at: 2</body></methods><methods><class-id>Core.Collection</class-id> <category>copying</category><body package="SSG-Extensions" selector="sort:">sort: aBlock	^SortedCollection withAll: self sortBlock: aBlock	</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="SSG-Extensions" selector="third">third	^self at: 3</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="SSG-Extensions" selector="union:">union: aCollection	| set |	set := (self asSet) addAll: aCollection; yourself.	^self species withAll: set asArray</body></methods><methods><class-id>Refactory.Browser.RBSequenceNode</class-id> <category>visitor</category><body package="SSG-Extensions" selector="accept:">accept: aProgramNodeVisitor	^ aProgramNodeVisitor visitSequenceNode: self</body></methods><methods><class-id>Core.Semaphore</class-id> <category>communication</category><body package="SSG-Extensions" selector="waitTimeoutMSecs:">waitTimeoutMSecs: anInteger	^ (self waitWithTimeoutMs: anInteger) not</body></methods><methods><class-id>Core.LinkValue</class-id> <category>comparing</category><body package="SSG-Extensions" selector="=">= anotherLink	self species == anotherLink species		ifTrue: 			[self value = anotherLink value ifTrue: [^self nextLink == anotherLink nextLink].			^false].	^false </body></methods><methods><class-id>Core.Character class</class-id> <category>external accessing</category><body package="SSG-Extensions" selector="alphabet">alphabet	^'abcdefghijklmnopqrstuvwxyz' copy</body></methods><methods><class-id>Core.Character</class-id> <category>testing</category><body package="SSG-Extensions" selector="mutateToChange">mutateToChange	| newValue interval |	interval := (33 to: 127) asArray.	newValue := SmallSuiteGenerator.SPlatform randomGenerator selectAtRandom: interval.	[newValue == self asInteger]		whileTrue: [newValue := SmallSuiteGenerator.SPlatform randomGenerator selectAtRandom: interval].	^Character value: newValue</body></methods><methods><class-id>Core.Class</class-id> <category>accessing</category><body package="SSG-Extensions" selector="nameAsSymbol">nameAsSymbol	^self  fullName asSymbol</body></methods><methods><class-id>Kernel.SequenceNode</class-id> <category>probes</category><body package="SSG-Extensions" selector="probeInfoFor:doBefore:doAfter:">probeInfoFor: t1 doBefore: t2 doAfter: t3	| t4 t5 t6 t7 t8 |	sourcePosition last + 1 &lt; t1 first ifTrue: t3.	t7 := [^self probeRecordAtStart].	sourcePosition first &gt; t1 first ifTrue: t2.	sourcePosition first &gt; sourcePosition last ifTrue: [^self probeRecordAtStart].	(sourcePosition first = t1 first and: [self mapEntry notNil])		ifTrue: [^super probeRecordAtStart].	t8 := statements size.	t4 := 0.	t5 := 			[| t9 |			(t4 := t4 - 1) = 0 ifTrue: t7.			(t9 := (statements at: t4) probeRecordAtEnd) isNil ifFalse: [^t9].			t5 value].	^(t6 := 			[(t4 := t4 + 1) &gt; t8 ifTrue: t5.			^(statements at: t4)				probeInfoFor: t1				doBefore: t5				doAfter: t6]) value</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>evaluating</category><body package="SSG-Extensions" selector="cull:cull:">cull: firstArg cull: secondArg	self numArgs &lt; 2 ifTrue: [^self cull: firstArg].	^self value: firstArg value: secondArg</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>printing</category><body package="SSG-Extensions" selector="isBlock">isBlock	^true</body></methods><methods><class-id>Refactory.Browser.RBVariableNode</class-id> <category>accessing</category><body package="SSG-Extensions" selector="token">token	^token</body></methods><methods><class-id>SmallSuiteGenerator.SError</class-id> <category>signaling</category><body package="SSG-Extensions2" selector="signal:">signal: aMessage	SPlatform saveOnLog: aMessage.	self raiseSignal: aMessage.</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfoTest</class-id> <category>tests</category><body package="SSG-Extensions2" selector="nameOf:">nameOf: aClass	^aClass fullName asSymbol</body><body package="SSG-Extensions2" selector="testAsTypeInfoSFoo">testAsTypeInfoSFoo	| profile typeInfo methodInfo classNameSFoo classNameOrdColl classNameFloat classNameByteString classNameSmallInt classNameDict |	classNameSFoo := self nameOf: SFoo.	classNameOrdColl := self nameOf: OrderedCollection.	classNameFloat := self nameOf: Float.	classNameByteString := self nameOf: ByteString.	classNameSmallInt := self nameOf: SmallInteger.	classNameDict := self nameOf: Dictionary.	profile := self aSTypeCollectorClass profile: [(SFoo new) return: Dictionary new; return: OrderedCollection new; returnFloat; returnString; returnCollection; returnNum; score; score: 5]				forClassNamed: classNameSFoo.	typeInfo := STypeInfo asTypeInfo: profile.	self assert: (typeInfo types at: classNameSFoo) methodTypes size equals: 8.	self assert: (typeInfo types at: classNameSFoo) classMethodTypes size equals: 0.	self assert: (typeInfo methodType: #initialize from: classNameSFoo) returnType type equals: classNameSFoo.	methodInfo := typeInfo methodType: #return: from: classNameSFoo.	self assertCollection: methodInfo returnType types hasSameElements: (Array with: classNameOrdColl with: classNameDict).	self assertCollection: methodInfo allArgTypes hasSameElements: (Array with: classNameOrdColl with: classNameDict).	self assert: (typeInfo methodType: #returnFloat from: classNameSFoo) returnType type equals: classNameFloat.	self assert: (typeInfo methodType: #returnCollection from: classNameSFoo) returnType type equals: classNameOrdColl.	self assert: (typeInfo methodType: #returnString from: classNameSFoo) returnType type equals: classNameByteString.	self assert: (typeInfo methodType: #returnNum from: classNameSFoo) returnType type equals: classNameSmallInt.	self assert: (typeInfo methodType: #score from: classNameSFoo) returnType type equals: classNameSmallInt.	methodInfo := typeInfo methodType: #score: from: classNameSFoo.	self assert: methodInfo returnType type equals: classNameSFoo.	self assertCollection: methodInfo allArgTypes hasSameElements: (Array with: classNameSmallInt).	self assert: (typeInfo factoryMessagesFrom: classNameSFoo) isEmpty.	self assertCollection: typeInfo scalars keys hasSameElements: (Array			with: classNameOrdColl			with: classNameDict			with: classNameByteString			with: classNameSmallInt			with: classNameFloat)</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>actions</category><body package="SSG-Extensions2" selector="exportFitnessLog">exportFitnessLog 	STestCaseFactory vizClass exportLogOf: engine</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>configuration</category><body package="SSG-Extensions2" selector="fitness:">fitness: aFitness	fitness := aFitness</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>actions</category><body package="SSG-Extensions2" selector="generatedClass">generatedClass	generatedClass ifNotNil: [ ^ generatedClass ].	generatedClass := (self findClass: self targetClassName asString) first createTestCaseConfig.	^ generatedClass</body><body package="SSG-Extensions2" selector="moveClass:">moveClass: aClass  	| bundle package items t5 |	bundle := Store.Registry bundleNamed: 'SmallSuiteGenerator'.	package := Store.Registry packageNamedOrCreate: self outputPackageName.	Store.XMainChangeSet current moveWholeClass: aClass toPackage: package.	(t5 := (items := bundle containedItems) select: [:t6 | t6 name = self outputPackageName]) isEmpty ifFalse: [items remove: t5 first].	items add: package.	bundle containedItems: items</body><body package="SSG-Extensions2" selector="tearDown">tearDown		self uninstall.	self exportTests.	self exportFitnessLog.	SSTestShifter resetToDefaults.	SPlatform resetRandomGenerator.	SmallTypeCollector resetClassDict</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>accessing</category><body package="SSG-Extensions2" selector="allParentClassesInfoFrom:">allParentClassesInfoFrom: aClassName	| smalltalkClass result |	smalltalkClass := Smalltalk at: aClassName.	result := OrderedCollection new.	smalltalkClass		withAllSuperclasses do: [ :class | 			| info |			info := self classAt: class fullName asSymbol ifNone: [ nil ].			info ifNotNil: [ result add: info ] ].	^ result</body><body package="SSG-Extensions2" selector="blackList">blackList	^ self decode: blackList</body><body package="SSG-Extensions2" selector="blackList:">blackList: aList	blackList := self encode: aList.	self deleteBlackListMethods</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>adding</category><body package="SSG-Extensions2" selector="completeTypeInfo">completeTypeInfo	|aBlackList|	aBlackList := self blackList.	self types		keysDo: 			[:aClass | 			| typeColl realClassInfo |			typeColl := SmallTypeCollector new collectTypeFrom: (self classOf: aClass asString) first.			realClassInfo := self types at: aClass.			typeColl methodTypes keysAndValuesDo: [:key :value | ((self isMethodWith: key and: aClass in: aBlackList) not and: [key isUnary not and: [value argTypes allSatisfy: [:arg | arg types allSatisfy: [:t | (t = #'SmallSuiteGenerator.SUndefinedObject') not  ] ]]])					ifTrue: [realClassInfo methodTypes at: key							ifAbsentPut: 								[self updateArgsOf: value.								value returnType types ifEmpty: [value returnType type: #SUndefinedObject].								value receiver type: aClass.								value hasProfiler: false.								value executions: 0.5]]]].</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>accessing</category><body package="SSG-Extensions2" selector="decode:">decode: aList	|result|	result := Array withSize: aList size.	aList doWithIndex: [:list :index |		result at: index put: ((list at: 1) compiledMethodAt: (list at: 2))	].	 ^ result</body><body package="SSG-Extensions2" selector="deleteBlackListMethods">deleteBlackListMethods	self blackList do: [:compMethod |		|aClass selector|		selector := #methodTypes.		aClass := compMethod mclass .		aClass isMeta ifTrue: [ 			selector := #classMethodTypes.			aClass := aClass instanceBehavior ].		self types at: aClass fullName asSymbol			ifPresent: [:classInfo | 				(classInfo perform: selector)						removeKey: compMethod selector				 		ifAbsent: []			] 			ifAbsent: [].	]</body><body package="SSG-Extensions2" selector="encode:">encode: aList	|result|	result := Array withSize: aList size.	aList doWithIndex: [:compM :index |		result at: index put: (Array with: compM mclass with: compM selector)	].	 ^ result</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>actions</category><body package="SSG-Extensions2" selector="reset">reset	types values do: [ :type | type resetMethods ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>converting</category><body package="SSG-Extensions2" selector="updateArgsOf:">updateArgsOf: anObject 	anObject argTypes do: 		[:arg | 		(arg types anySatisfy: [:aType | self scalars keys includes: aType])			ifTrue: [nil]			ifFalse: [arg types do: [:aType | (aType substrings: '.') last = 'Object'						ifTrue: [nil]						ifFalse: [self scalars keys select: [:scalar | ((self classOf: aType asString) first allSubclasses collect: [:cls | cls fullName asSymbol])									includes: scalar]								thenDo: [:scalar | arg type: scalar]]]]].</body></methods><methods><class-id>SmallSuiteGenerator.SInspectorAssertion class</class-id> <category>instance creation</category><body package="SSG-Extensions2" selector="inspectorAssertionOf:">inspectorAssertionOf: assoc	|values|	values := assoc value class methodDictionary values.	^ (values select: #isReturnField)		collect:			[ :compiledMethod | 			self inspectorAssertionOf: assoc and: compiledMethod ]		thenSelect: [ :assertion | 			assertion isNotNil			 ] </body></methods><methods><class-id>SmallSuiteGenerator.SGAEngineTest</class-id> <category>as yet unclassified</category><body package="SSG-Extensions2" selector="profilerOf:">profilerOf: aString  	profiler beforeProfiling; gatherForPackages: (Store.Registry allPackages select: [:pkg | aString match: pkg name asString]); install; beforeProfiling.</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngineTest</class-id> <category>running</category><body package="SSG-Extensions2" selector="tearDown">tearDown	[profiler cleanInstrumentation]		on: Error do: [nil].	super tearDown.</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactoryVisualWorks</class-id> <category>actions</category><body package="SSG-Extensions2" selector="cleanInstrumentation">cleanInstrumentation</body><body package="SSG-Extensions2" selector="initializeProfiler">initializeProfiler	((profiler := self aSLProfilerCoverage profilerForPackagesMatching: self targetPackageRegex) allMethods select: #isNotMethodExtension)		do: #installGhosts displayingProgress: 'Instrumenting ' , self targetPackageRegex</body><body package="SSG-Extensions2" selector="uninstall">uninstall	profiler uninstall.</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>adding</category><body package="SSG-Extensions2" selector="differenceWith:usingSelector:">differenceWith: another usingSelector: aSymbol	| dict1 dict2 result |	result := OrderedCollection new.	dict1 := self perform: aSymbol.	dict2 := another perform: aSymbol.	dict2		keysAndValuesDo: [ :key :val1 | 			| val2 |			[ val2 := dict1 at: key.			val1 = val2				ifFalse: [ result add: (Array with: val2 with: val1) ] ]				on: KeyNotFoundError				do: [ result add: (Array with: nil with: val1) ] ].	^ result</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>accesing</category><body package="SSG-Extensions2" selector="isAbstract">isAbstract	abstract		ifNil: [ | aClass |			aClass := Smalltalk at: typeName.			abstract := (aClass methodDictionary asArray anySatisfy: [ :m | m isAbstract ])				or: [ aClass class methodDictionary asArray anySatisfy: [ :m | m isAbstract ] ] ].	^ abstract</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngineExample</class-id> <category>actions</category><body package="SSG-Extensions2" selector="runOnClass:withBlock:andFitness:">runOnClass: aClass withBlock: aBlock andFitness: aClassFitness 	| engine |	(engine := SGAEngine new) populationSize: 30; numberOfStatements: 15; blockToExecute: aBlock; targetClassName: aClass name.	engine typeInfo: (Spy1.SSTypeCollector profile: engine blockToExecute forClassNamed: aClass) asTypeInfo; fitness: aClassFitness; targetClassName: aClass name; numberOfIterations: 15; run.	^engine</body><body package="SSG-Extensions2" selector="runOnPackagesMatching:withBlock:andFitness:">runOnPackagesMatching: regex withBlock: aBlock andFitness: aClassFitness	| engine |	engine := SGAEngine new.	engine		populationSize: 30;		numberOfStatements: 15;		blockToExecute: aBlock.	engine		typeInfo:			(STypeInfo				asTypeInfo:					(Spy1.SSTypeCollector						profile: engine blockToExecute						onPackagesMatching: regex));		fitness: aClassFitness;		numberOfGenerations: 15;		run.	^ engine </body></methods><methods><class-id>SmallSuiteGenerator.SGANullViz class</class-id> <category>gt-inspector-extension</category><body package="SSG-Extensions2" selector="exportLogOf:">exportLogOf: engine</body></methods><methods><class-id>SmallSuiteGenerator.SSAbstractSettingMethods</class-id> <category>accessing</category><body package="SSG-Extensions2" selector="exportMethod:">exportMethod: aSelector	[ | method |	method := (self class compiledMethodAt: aSelector) getSource.	factory compile: method classified: 'running' ]		on: Error		do: [  ]</body></methods><methods><class-id>SmallSuiteGenerator.SAssertionTest</class-id> <category>tests</category><body package="SSG-Extensions2" selector="testAssertComparison">testAssertComparison	| test |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var0 := 1.			 _var1 := 1.			 _var2 := Point x: _var0 y: _var1.			 _var3 := Point x: _var1 y: _var0.').	test generateAssertions: (Array with: SComparisonAssertion).	self assert: test assertions size equals: 2.	self		assert: test assertions first printString		equals: 'self assert: _var0 equals: _var1 '.	self		assert: test assertions second printString		equals: 'self assert: _var2 equals: _var3 '</body><body package="SSG-Extensions2" selector="testAssertComparison2">testAssertComparison2	| test |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var0 := 1.			 _var1 := 2.			 _var2 := Point x: _var0 y: _var1.			 _var3 := Point x: _var1 y: _var0.').	test generateAssertions: (Array with: SComparisonAssertion).	self assert: test assertions size equals: 2.	self		assert: test assertions first printString		equals: 'self deny: _var0 equals: _var1 '.	self		assert: test assertions second printString		equals: 'self deny: _var2 equals: _var3 '</body><body package="SSG-Extensions2" selector="testAssertString">testAssertString	| test |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var0 := 1.			 _var1 := 2.			 _var3 := Point x: _var1 y: _var0.').	test generateAssertions: (Array with: SStringAssertion).	self assert: test assertions size equals: 1.	self		assert: test assertions first printString		equals: 'self assert: _var3 printString equals: ''2@1'' '</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCaseTest</class-id> <category>tests</category><body package="SSG-Extensions2" selector="typeInfo">typeInfo 	|typeInfo sfooSymbol smallIntegerSymbol byteStringSymbol smallFloatSymbol |	sfooSymbol := #SFoo fullClassNameSymbol.	smallIntegerSymbol := #SmallInteger fullClassNameSymbol.	byteStringSymbol := #ByteString fullClassNameSymbol.	smallFloatSymbol := #Float fullClassNameSymbol .	typeInfo := STypeInfo new		type:			sfooSymbol				-&gt;					(Array						with:							(Array								with: #returnNum -&gt; (Array																with: sfooSymbol																with: smallIntegerSymbol																with: #()																with: false)								with: #returnFloat -&gt; (Array																with: sfooSymbol																with: smallFloatSymbol																with: #()																with: false)								with: #score -&gt; (Array																with: sfooSymbol																with: smallIntegerSymbol																with: #()																with: true)								with: #return: -&gt; (Array																with: sfooSymbol																with: byteStringSymbol																with: (Array with: byteStringSymbol)																with: false))						with: (Array with: #score: -&gt; (Array																with: sfooSymbol																with: sfooSymbol																with: (Array with: smallFloatSymbol)																with: false))).	typeInfo scalar: byteStringSymbol with: #('hello').	typeInfo scalar: smallIntegerSymbol with: #(5).	typeInfo scalar: smallFloatSymbol with: #(7.3).	^ typeInfo</body></methods><methods><class-id>SmallSuiteGenerator.SSimpleFitnessFunction</class-id> <category>actions</category><body package="SSG-Extensions2" selector="updateSuperclasses">updateSuperclasses	superclasses := self aClass allSuperclasses collect: [:e | e name].	n := (n min: superclasses size - 1). "avoid add Object in superclasses"	superclasses := (superclasses first: n)</body></methods><methods><class-id>SmallSuiteGenerator.SSGParser</class-id> <category>parsing</category><body package="SSG-Extensions2" selector="acceptAssignmentNode:">acceptAssignmentNode: anAssignmentNode	^ SAssignment new		variable: (self visitNode: anAssignmentNode variable);		value: (self visitNode: anAssignmentNode value);		yourself</body><body package="SSG-Extensions2" selector="acceptCascadeNode:">acceptCascadeNode: aCascadeNode	| sCascade |	sCascade := SCascade new.	aCascadeNode messages		do: [ :each | sCascade addMessage: (self visitNode: each) ].	^ sCascade</body><body package="SSG-Extensions2" selector="acceptLiteralNode:">acceptLiteralNode: aLiteralNode	^ SLiteral value: aLiteralNode value</body><body package="SSG-Extensions2" selector="acceptMessageNode:">acceptMessageNode: aMessageNode	^ SMessage new		receiver: (self visitNode: aMessageNode receiver);		selector: aMessageNode selector;		args: (aMessageNode arguments collect: [ :arg | self visitNode: arg ])</body><body package="SSG-Extensions2" selector="acceptSequenceNode:">acceptSequenceNode: aSequenceNode	| seq |	seq := SSequense new.	aSequenceNode temporaries		do: [ :tmp | seq addTemporarie: (self visitNode: tmp) ].	aSequenceNode statements		do: [ :each | seq addMessage: (self visitNode: each) ].	^ seq</body><body package="SSG-Extensions2" selector="acceptVariableNode:">acceptVariableNode: aVariableNode	^ SVariable new		varName: (self variableName: aVariableNode name);		id: (self variableId: aVariableNode name);		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SSMetaInterpreter</class-id> <category>initialization</category><body package="SSG-Extensions2" selector="visitMessageNode:">visitMessageNode: aMessageNode	"aMessageNode asDoit generateWithSource		valueWithReceiver: nil		arguments: #()"	Compiler evaluate: aMessageNode formattedCode</body></methods><methods><class-id>SmallSuiteGenerator.SGAViz class</class-id> <category>gt-inspector-extension</category><body package="SSG-Extensions2" selector="exportLogOf:">exportLogOf: engine 	| file aStream separator |	file := 'fitnessEvolution.txt' asFilename.	separator := $,.	(aStream := file writeStream) nextPutAll: 'Generation number'; nextPut: separator; nextPutAll: 'bestFit'; nextPut: separator; nextPutAll: 'lowestFit'; nextPut: separator; nextPutAll: 'averageFit'; cr.	[engine logs do: [:t4 | aStream nextPutAll: t4 generationNumber asString; nextPut: separator; nextPutAll: t4 fittestTestCase fitness values first asString; nextPut: separator; nextPutAll: t4 lowestFit values first asString; nextPut: separator; nextPutAll: t4 averageFit values first asString; cr]]		valueNowOrOnUnwindDo: [aStream close] </body></methods><methods><class-id>SmallSuiteGenerator.SPlatformVisualWorks class</class-id> <category>logging</category><body package="SSG-Extensions2" selector="classConfigurationName">classConfigurationName	^superclass fullName , self implementationType</body><body package="SSG-Extensions2" selector="createTestCaseClass:inPackage:">createTestCaseClass: className inPackage: pkgName 	| t3 t5 pkg generatedClass |	(t3 := SystemUtils validateClassName: className for: nil) ifNil: [^nil].	generatedClass := ((t5 := self testCaseClass) classBuilder addRecord: (BehaviorBuilderRecord forName: t3 in: self environment)) superclass: t5; instVarString: ''; classVarString: ''; poolString: (t5 computeFullPoolString: ''); category: pkgName; beFixed; reviseSystem.	pkg := Store.Registry packageNamedOrCreate: pkgName.	Store.XMainChangeSet current moveWholeClass: generatedClass toPackage: pkg.	^generatedClass</body><body package="SSG-Extensions2" selector="implementationType">implementationType	^'VisualWorks'</body><body package="SSG-Extensions2" selector="rbParserClass">rbParserClass	^Refactory.Browser.RBParser</body><body package="SSG-Extensions2" selector="testCaseClass">testCaseClass	^SmallSuiteGenerator.SConfigGenerationTestCase</body></methods><methods><class-id>SmallSuiteGenerator.SInsertTest</class-id> <category>mutation-insert</category><body package="SSG-Extensions2" selector="testCopyWithANewMethodCallToAnArgumentOfTheTargetClass">testCopyWithANewMethodCallToAnArgumentOfTheTargetClass	| testCase targetClass studentClass newTestCase |	targetClass := 'SFoo' fullClassNameSymbol.	studentClass := 'SStudent' fullClassNameSymbol.	testCase := SSTestCase with: utility typeInfoSFoo4.	testCase		targetClassName: targetClass;		addFactoryMessage: targetClass;		addFactoryMessage: studentClass;		addFactoryMessage: studentClass;		addMessage: #return: from: targetClass.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			((Array new: 4)				at: 1 put: '_var0 := ' , targetClass asString , ' new';				at: 2 put: '_var1 := ' , studentClass asString , ' new';				at: 3 put: '_var2 := ' , studentClass asString , ' new';				at: 4 put: '_var3 := _var0 return: _var1 ';				yourself).	newTestCase := testCase		copyWithANewMethodCallToAnArgumentOfTheTargetClass.	newTestCase repairIds.	self		assertCollection: (newTestCase statements collect: #printString)		hasSameElements:			((Array new: 6)				at: 1 put: '_var0 := ' , targetClass asString , ' new';				at: 2 put: '_var1 := ' , studentClass asString , ' new';				at: 3 put: '_var2 := ' , studentClass asString , ' new';				at: 4 put: '_var3 := 2';				at: 5 put: '_var4 := _var1 scoreStudent: _var3 ';				at: 6 put: '_var5 := _var0 return: _var1 ';				yourself)</body><body package="SSG-Extensions2" selector="testCopyWithANewMethodCallToAnyValue">testCopyWithANewMethodCallToAnyValue	| testCase targetClass studentClass newTestCase |	targetClass := 'SFoo' fullClassNameSymbol.	studentClass := 'SStudent' fullClassNameSymbol.	testCase := SSTestCase with: utility typeInfoSFoo4.	testCase		targetClassName: targetClass;		addFactoryMessage: targetClass;		addFactoryMessage: studentClass;		addFactoryMessage: studentClass;		addMessage: #return: from: targetClass.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			((Array new: 4)				at: 1 put: '_var0 := ' , targetClass asString , ' new';				at: 2 put: '_var1 := ' , studentClass asString , ' new';				at: 3 put: '_var2 := ' , studentClass asString , ' new';				at: 4 put: '_var3 := _var0 return: _var1 ';				yourself).	newTestCase := testCase copyWithANewMethodCallToAnyValue.	newTestCase repairIds.	self		assertCollection: (newTestCase statements collect: #printString)		hasSameElements:			((Array new: 6)				at: 1 put: '_var0 := ' , targetClass asString , ' new';				at: 2 put: '_var1 := ' , studentClass asString , ' new';				at: 3 put: '_var2 := ' , studentClass asString , ' new';				at: 4 put: '_var3 := 2';				at: 5 put: '_var4 := _var2 scoreStudent: _var3 ';				at: 6 put: '_var5 := _var0 return: _var1 ';				yourself)</body></methods><methods><class-id>SmallSuiteGenerator.SFitnessFunction</class-id> <category>accessing</category><body package="SSG-Extensions2" selector="aClass">aClass	aClass ifNotNil: [ ^ aClass ].	aClass := Smalltalk at: targetClass.	^ aClass</body></methods><methods><class-id>SmallSuiteGenerator.SObject</class-id> <category>accessing</category><body package="SSG-Extensions2" selector="classOf:">classOf: aString 	| aClass |	(aClass := self findClass: aString) ifEmpty: [self error: 'I cant find the class with name: ' , aString].	^aClass</body><body package="SSG-Extensions2" selector="findClass:">findClass: aString 	^Root allClasses select: [:aClass | aString = aClass fullName or: ['*.' , aString match: aClass fullName]]</body><body package="SSG-Extensions2" selector="fullNameOfClass:">fullNameOfClass: aString 	| aClass | 	(aClass := self findClass: aString) ifNotEmpty: [^aClass collect: [:each | each fullName]]		ifEmpty: [self error: 'I cant find the namespace for: ' , aString]</body><body package="SSG-Extensions2" selector="fullSymbolOf:">fullSymbolOf: aSymbol  	|list|	list := self listOfFullSymbolOf: aSymbol.	list ifNotEmpty: [ ^ list first].	^ nil</body><body package="SSG-Extensions2" selector="listOfFullSymbolOf:">listOfFullSymbolOf: aSymbol  	| aClass |	(aClass := self findClass: aSymbol asString) ifNotEmpty: [^aClass collect: [:each | each fullName asSymbol]]		ifEmpty: [self error: 'I cant find the namespace for: ' , aSymbol]</body></methods><methods><class-id>SmallSuiteGenerator.SConfigGenerationTestCase class</class-id> <category>As yet unclassified</category><body package="SSG-Extensions2" selector="findClass:">findClass: aString		^ Root allClasses select: [:aclass | aString = aclass fullName or: ['*.' , aString match: aclass fullName]]</body></methods><methods><class-id>SmallSuiteGenerator.SConfigGenerationTestCase class</class-id> <category>settings</category><body package="SSG-Extensions2" selector="fitnessDictionary">fitnessDictionary	^ Dictionary new		at: #statement put: [ SStatementCoverage new ];		at: #method put: [ SMethodCoverage new ];		at: #multi			put: [ SMultiFitnessFunction methodAndStatementCoverage ];		at: #state put: [SStateCoverage for: self aClass];		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SPlatformPharo class</class-id> <category>accessing</category><body package="SSG-Extensions2" selector="classLogger">classLogger	"^ TinyLogger"</body><body package="SSG-Extensions2" selector="implementationType">implementationType	^ 'Pharo'"SystemVersion current type"</body></methods><methods><class-id>SmallSuiteGenerator.SPlatformPharo class</class-id> <category>settings</category><body package="SSG-Extensions2" selector="rbParserClass">rbParserClass	"^ RBParser"</body></methods><methods><class-id>SmallSuiteGenerator.SPlatformPharo class</class-id> <category>tests</category><body package="SSG-Extensions2" selector="testCaseClass">testCaseClass	"^ TestCase"</body></methods><methods><class-id>SmallSuiteGenerator.SUtilityTypeInfo</class-id> <category>examples</category><body package="SSG-Extensions2" selector="typeInfoSFoo1">typeInfoSFoo1	^(STypeInfo new) type: (self fullSymbolOf: #SFoo)			-&gt; (Array with: (Array						with: #returnNum -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #SmallInteger)									with: #( )									with: false)						with: #returnFloat -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #Float)									with: #( )									with: false)						with: #returnString -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #ByteString)									with: #( )									with: false)						with: #score -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #Float)									with: #( )									with: true)						with: #return: -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #ByteString)									with: (Array with: (self fullSymbolOf: #ByteString))									with: false))					with: (Array with: #score: -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #SFoo)									with: (Array with: (self fullSymbolOf: #Float))									with: false))); scalar: (self fullSymbolOf: #ByteString)		with: #('hello' ); scalar: (self fullSymbolOf: #SmallInteger)		with: #(5 ); scalar: (self fullSymbolOf: #Float)		with: #(7.3 )</body><body package="SSG-Extensions2" selector="typeInfoSFoo100">typeInfoSFoo100	| sfooSymbol stringSymbol floatSymbol intSymbol |	sfooSymbol := #SFoo fullClassNameSymbol.	stringSymbol := #ByteString fullClassNameSymbol.	floatSymbol := #Float fullClassNameSymbol.	intSymbol := #SmallInteger fullClassNameSymbol.		^ STypeInfo new		type:			sfooSymbol				-&gt;					(Array						with:							(Array								with: #returnNum -&gt; (Array 									with: sfooSymbol									with: intSymbol									with: #()									with: false)								with: #returnFloat -&gt; (Array 									with: sfooSymbol									with: floatSymbol									with: #()									with: false)								with: #returnString -&gt; (Array 									with: sfooSymbol									with: stringSymbol									with: #()									with: false)								with: #score -&gt; (Array 									with: sfooSymbol									with: floatSymbol 									with: #()									with: true)								with: #return: -&gt; (Array 									with: sfooSymbol									with: stringSymbol									with: (Array with: stringSymbol)									with: false))						with: (Array with: #score: -&gt; (Array 									with: sfooSymbol									with: sfooSymbol									with: (Array with: floatSymbol)									with: false)));		scalar: stringSymbol with: #('hello');		scalar: intSymbol with: #(5);		scalar: floatSymbol with: #(7.3 4.7)</body><body package="SSG-Extensions2" selector="typeInfoSFoo3">typeInfoSFoo3	^(STypeInfo new) type: (self fullSymbolOf: #SFoo)			-&gt; (Array with: (Array						with: #returnNum -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #SmallInteger)									with: #( )									with: false)						with: #returnFloat -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #Float)									with: #( )									with: false)						with: #returnString -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #ByteString)									with: #( )									with: false)						with: #score -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #SmallInteger)									with: #( )									with: true)						with: #score: -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #SFoo)									with: (Array with: (self fullSymbolOf: #SmallInteger))									with: false))					with: (Array with: #score: -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #SFoo)									with: (Array with: (self fullSymbolOf: #SmallInteger))									with: false))); scalar: (self fullSymbolOf: #ByteString)		with: #('Hello' ); scalar: (self fullSymbolOf: #SmallInteger)		with: #(4 ); scalar: (self fullSymbolOf: #Float)		with: #(2.3 )</body><body package="SSG-Extensions2" selector="typeInfoSFooOnPackage2">typeInfoSFooOnPackage2	^(STypeInfo new) type: (self fullSymbolOf: #SFoo)			-&gt; (Array with: (Array						with: #returnFloat -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #Float)									with: #( )									with: false)						with: #returnCollection -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #OrderedCollection)									with: #( )									with: false)						with: #initialize -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #SFoo)									with: #( )									with: false)						with: #score -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #SmallInteger)									with: #( )									with: true)						with: #score: -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #SFoo)									with: (Array with: (self fullSymbolOf: #SmallInteger))									with: false)						with: #return: -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #SStudent)									with: (Array with: (self fullSymbolOf: #SStudent))									with: false))					with: (Array with: #score: -&gt; (Array									with: (self fullSymbolOf: #SFoo)									with: (self fullSymbolOf: #SFoo)									with: (Array with: (self fullSymbolOf: #SmallInteger))									with: false))); type: (self fullSymbolOf: #SSPerson)			-&gt; #(#( ) #( ) ); type: (self fullSymbolOf: #SStack)			-&gt; #(#( ) #( ) ); type: (self fullSymbolOf: #SConference)			-&gt; #(#( ) #( ) ); type: (self fullSymbolOf: #SEvent)			-&gt; #(#( ) #( ) ); type: (self fullSymbolOf: #SSTeacher)			-&gt; #(#( ) #( ) ); type: (self fullSymbolOf: #SParty)			-&gt; #(#( ) #( ) ); type: (self fullSymbolOf: #SEventTest)			-&gt; #(#( ) #( ) ); scalar: (self fullSymbolOf: #SmallInteger)		with: #(15 ); scalar: (self fullSymbolOf: #Float)		with: #(2.3 ); scalar: (self fullSymbolOf: #OrderedCollection)		with: (Array with: OrderedCollection new); scalar: (self fullSymbolOf: #Array)		with: #(#(1 5 6 ) )</body></methods><methods><class-id>SmallSuiteGenerator.SmallTypeCollector</class-id> <category>action</category><body package="SSG-Extensions2" selector="blackList">blackList	^#('var' 'arg' 'anObject' 't[0-9]+' 'temp' )</body><body package="SSG-Extensions2" selector="classesOf:">classesOf: aString	^Root allClasses select: [:aClass | ('*' , aString asLowercase , '*' match: aClass fullName asLowercase)			and: [(aClass allSuperclasses includes: SUnit.TestCase) not and: [aClass isAbstract not]]]</body><body package="SSG-Extensions2" selector="cleanArgName:">cleanArgName: aString		[((aString beginsWith: 'an')		and: [(aString at: 3) isUppercase])		ifTrue: [^aString copyFrom: 3 to: aString size].	((aString beginsWith: 'a')		and: [(aString at: 2) isUppercase])		ifTrue: [^aString copyFrom: 2 to: aString size].	^aString]		on: Error do: [^aString]</body><body package="SSG-Extensions2" selector="collectArgTypesOf:">collectArgTypesOf: compMethod 	| argCollection |	(argCollection := (compMethod ast argumentNames				collect: 					[:argName | 					| cleanedArgName list |					cleanedArgName := self cleanArgName: argName asString.					(self blackList anySatisfy: [:blackList | blackList match: cleanedArgName])						ifTrue: [list := #( )]						ifFalse: [list := self classesOf: cleanedArgName].					list]) asOrderedCollection) add: #( ).	^self methodInfoIn: compMethod from: argCollection</body><body package="SSG-Extensions2" selector="collectTypeFrom:">collectTypeFrom: aClass	| classType |	aClass isMeta ifTrue: [^nil].	classType := STypeClassInfo newFrom: aClass name.	aClass methodDictionary values do: [:compMethods | classType addMethod: (self methodInfoIn: compMethods)].	aClass class methodDictionary values do: [:compMethod | classType addClassMethod: (self methodInfoIn: compMethod)].	^classType</body><body package="SSG-Extensions2" selector="methodInfoIn:">methodInfoIn: compMethod  	| methodInfo argTypes returnType |	(methodInfo := STypeMethodInfo new) selector: compMethod selector; isQuick: compMethod isQuick; scalars: Dictionary new; isDeprecated: compMethod isDeprecated; executions: 0.	argTypes := OrderedCollection new.	compMethod ast argumentNames do: 			[:argName | | typeInfo |			typeInfo := SMultiTypeInfo new.			(self listOfFullSymbolOf: (self typeFor: argName))				do: [:t7 | typeInfo type: t7].			argTypes add: typeInfo].	(returnType := SMultiTypeInfo new) type: compMethod mclass instanceBehavior fullName asSymbol.	methodInfo returnType: returnType.	methodInfo argTypes: argTypes.	^methodInfo</body><body package="SSG-Extensions2" selector="methodInfoIn:from:">methodInfoIn: compMethod from: argCollection    	| arg methodInfo argTypes returnType |	(methodInfo := STypeMethodInfo new) selector: compMethod selector; isQuick: compMethod isQuick; scalars: Dictionary new; isDeprecated: compMethod isDeprecated; executions: 0.	argTypes := OrderedCollection new.	compMethod ast argumentNames		doWithIndex: 			[:argName :index | | typeInfo |			typeInfo := SMultiTypeInfo new.			((arg := argCollection at: index) size = 1 and: [arg first = Object])				ifTrue: [typeInfo type: (self typeFor: argName)]				ifFalse: [arg do: [:t10 | t10 isMeta							ifTrue: [nil]							ifFalse: [typeInfo type: t10 fullName asSymbol]]].			argTypes add: typeInfo].	returnType := SMultiTypeInfo new.	((arg := argCollection last) size = 1 and: [arg first = Object])		ifFalse: [arg do: [:t11 | returnType type: t11 fullName asSymbol]].	methodInfo returnType: returnType.	methodInfo argTypes: argTypes.	^methodInfo</body><body package="SSG-Extensions2" selector="typeFor:">typeFor: argName 	| index lastPart |	argName = 'arg' ifTrue: [^#SUndefinedObject].	self class classDict at: argName asLowercase ifPresent: [:t4 | ^t4 name].	index := 1.	[index &lt;= argName size and: [(argName at: index) isLowercase]]		whileTrue: [index := index + 1].	lastPart := argName copyFrom: index to: argName size.	self class classDict at: lastPart asLowercase ifPresent: [:t5 | ^t5 name].	argName asLowercase = 'spec' ifTrue: [^#MetacelloAbstractVersionConstructor].	('.*(b|B)lock.*' match: argName)		ifTrue: [^#BlockClosure].	('.*(o|O)rderedCollection.*' match: argName)		ifTrue: [^#OrderedCollection].	('.*(a|A)rray.*' match: argName)		ifTrue: [^#Array].	('.*(d|D)ictionary.*' match: argName)		ifTrue: [^#Dictionary].	('.*(s|S)et.*' match: argName)		ifTrue: [^#Set].	('.*(b|B)ag.*' match: argName)		ifTrue: [^#Bag].	('.*(c|C)ollection.*' match: argName)		ifTrue: [^#Collection].	('.*(s|S)tring.*' match: argName)		ifTrue: [^#String].	('.*(s|S)ymbol.*' match: argName)		ifTrue: [^#Symbol].	^#SUndefinedObject</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>accessing</category><body package="SSG-Extensions2" selector="canAddStatement">canAddStatement	self printerClass hasLimit 		ifTrue: [			^ ((self length + 3) &lt; 40)].	^ true</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine</class-id> <category>actions</category><body package="SSG-Extensions2" selector="exportFitnessLog">exportFitnessLog	| file stream separator |	file := 'fitnessEvolution.txt' asFilename.	separator := $,.	(stream := file writeStream) nextPutAll: 'generation'; nextPut: separator; nextPutAll: 'bestFit'; nextPut: separator; nextPutAll: 'lowestFit'; nextPut: separator; nextPutAll: 'averageFit'; nextLine.	[self logs do: [:t4 | stream nextPutAll: t4 generationNumber asString; nextPut: separator; nextPutAll: t4 fittestTestCase fitness values first asString; nextPut: separator; nextPutAll: t4 lowestFit values first asString; nextPut: separator; nextPutAll: t4 averageFit values first asString; nextLine]]		valueNowOrOnUnwindDo: [stream close]</body><body package="SSG-Extensions2" selector="updateTypeInfoWith:">updateTypeInfoWith: aCollectionTestCase	fitness profiler uninstallClass: targetClassName.	self profilerForTargetClass.	aCollectionTestCase do: [:testCase | testCase runWithoutAssertionsAndLastStatement ].	self mergeTypeInfo: (STypeInfo asTypeInfo: typeInfoProfiler).	self uninstall.	fitness profiler updateClass: ((self initializeProfiler packages at: 1) classes at: targetClassName).	fitness profiler deleteCache.</body></methods><methods><class-id>SmallSuiteGenerator.SStack</class-id> <category>accessing</category><body package="SSG-Extensions2" selector="=">= aStack	self == aStack ifTrue: [^true].	self species == aStack species ifFalse: [^false].	^self hasEqualElements: aStack </body><body package="SSG-Extensions2" selector="addFirst:">addFirst: anObject  	| aLink |	aLink := anObject asLink.	self isEmpty ifTrue: [lastLink := aLink].	aLink nextLink: firstLink.	firstLink := aLink.	^aLink </body><body package="SSG-Extensions2" selector="addLast:">addLast: anObject   	| aLink |	aLink := anObject asLink.	self isEmpty		ifTrue: [firstLink := aLink]		ifFalse: [lastLink nextLink: aLink]. 	lastLink := aLink.	^aLink</body><body package="SSG-Extensions2" selector="hasEqualElements:">hasEqualElements: aCollection 	| size index |	(aCollection isKindOf: SequenceableCollection)		ifFalse: [^false].	(size := self size) = aCollection size ifFalse: [^false].	index := 1.	[index &lt;= size]		whileTrue: 			[(self at: index) value = (aCollection at: index) value ifFalse: [^false].			index := index + 1].	^true </body><body package="SSG-Extensions2" selector="removeFirst">removeFirst 	| aLink |	self emptyCheck.	aLink := firstLink.	firstLink == lastLink		ifTrue: 			[firstLink := nil. 			lastLink := nil]		ifFalse: [firstLink := aLink nextLink].	aLink nextLink: nil.	^aLink value </body><body package="SSG-Extensions2" selector="removeLast">removeLast 	| aLink |	self emptyCheck.	aLink := lastLink.	firstLink == lastLink		ifTrue: 			[firstLink := nil.			lastLink := nil]		ifFalse:  [ |aFirstLink|			aFirstLink := firstLink.			[aFirstLink nextLink == aLink] whileFalse: [aFirstLink := aFirstLink nextLink].			aFirstLink nextLink: nil.			lastLink := aFirstLink].	aLink nextLink: nil.	^aLink value </body></methods><methods><class-id>SmallSuiteGenerator.SChangeTest</class-id> <category>tests</category><body package="SSG-Extensions2" selector="testSelectorChange">testSelectorChange	| testCase newTestCase targetClass index |	targetClass := 'SFoo' fullClassNameSymbol.	testCase := SSTestCase with: utility typeInfoSFoo100.	testCase		targetClassName: targetClass;		addLiteral: #Float fullClassNameSymbol;		addFactoryMessage: targetClass;		addFactoryMessage: targetClass;		addMessage: #return: from: targetClass.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			((Array new: 5)				at: 1 put: '_var0 := 4.7';				at: 2 put: '_var1 := ' , targetClass asString , ' score: _var0 ';				at: 3 put: '_var2 := ' , targetClass asString , ' score: _var0 ';				at: 4 put: '_var3 := ''hello''';				at: 5 put: '_var4 := _var2 return: _var3 ';				yourself).	newTestCase := SSTestCase with: testCase typeInfo.	index := 5.	1 to: index - 1 do: [ :i | 		| stm |		stm := testCase statements at: i.		newTestCase addStatement: stm copy.		newTestCase assignId ].	newTestCase		addAlternativeSelectorFor: (testCase statements at: index) value.	self		assertCollection: (newTestCase statements collect: #printString)		hasSameElements:			((Array new: 5)				at: 1 put: '_var0 := 4.7';				at: 2 put: '_var1 := ' , targetClass asString , ' score: _var0 ';				at: 3 put: '_var2 := ' , targetClass asString , ' score: _var0 ';				at: 4 put: '_var3 := ''hello''';				at: 5 put: '_var4 := _var2 returnString';				yourself).	self assert: testCase validReferences</body></methods><methods><class-id>Core.LimitedPrecisionReal</class-id> <category>As yet unclassified</category><body package="SSG-Extensions3" selector="isBigEndian">isBigEndian	&lt;primitive: 534&gt;	self primitiveFailed</body><body package="SSG-Extensions3" selector="isInfinity">isInfinity	self isSpecialValue ifTrue: [^self mantissaBitsAreZero].	^false</body><body package="SSG-Extensions3" selector="isLittleEndian">isLittleEndian	^self isBigEndian not</body><body package="SSG-Extensions3" selector="mantissaBitsAreZero">mantissaBitsAreZero	self subclassResponsibility</body></methods><methods><class-id>Core.Dictionary</class-id> <category>testing</category><body package="SSG-Extensions3" selector="=">= aDict	self == aDict ifTrue: [^true].	self species == aDict species ifFalse: [^false].	self size = aDict size ifFalse: [^false].	self keysAndValuesDo: [:t2 :t3 | (aDict at: t2 ifAbsent: [^false])			= t3			ifTrue: [nil]			ifFalse: [^false]].	^true</body></methods><methods><class-id>Core.Dictionary</class-id> <category>accessing</category><body package="SSG-Extensions3" selector="at:ifPresent:ifAbsent:">at: key ifPresent: aBlock ifAbsent: absentBlock 	| flag value |	flag := true.	value := self at: key ifAbsent: [flag := false].	flag ifTrue: [^aBlock cull: value].	^absentBlock value</body><body package="SSG-Extensions3" selector="at:ifPresent:ifAbsentPut:">at: key ifPresent: aBlock ifAbsentPut: absentBlock 	^self		at: key		ifPresent: aBlock		ifAbsent: [self at: key put: absentBlock value] </body></methods><methods><class-id>Core.Dictionary</class-id> <category>binary storage</category><body package="SSG-Extensions3" selector="representBinaryOn:">representBinaryOn: aStream 	| aMess |	aMess := MessageSend				receiver: self class				selector: #withAll:				argument: self associations asArray.	aStream expectCycles ifTrue: [^BinaryObjectStorage indexImportSendSelf -&gt; (Array with: #createSpecialObject: with: (BOSSSpecialObjectLoader message: aMess))].	^aMess</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>adding</category><body package="SSG-Extensions3" selector="add:afterIndex:">add: anObject afterIndex: anIndex  	(anIndex between: 0 and: self size)		ifFalse: [^self errorOutOfBounds].	self insert: anObject before: firstIndex + anIndex.	^anObject</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>enumerating</category><body package="SSG-Extensions3" selector="average">average	^self sum / self size</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>binary storage</category><body package="SSG-Extensions3" selector="representBinaryOn:">representBinaryOn: aStream	^MessageSend		receiver: self class		selector: #withAll:		argument: (self isEmpty				ifTrue: [#( )]				ifFalse: [self asArray])</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>enumerating</category><body package="SSG-Extensions3" selector="sum">sum  	^self inject: 0 into: [:sum :each | sum + each]</body></methods><methods><class-id>Core.ByteString</class-id> <category>binary storage</category><body package="SSG-Extensions3" selector="representBinaryOn:">representBinaryOn: aStream 	^BinaryObjectStorage indexImportByteString -&gt; self</body></methods><methods><class-id>Core.Double</class-id> <category>comparing</category><body package="SSG-Extensions3" selector="mantissaBitsAreZero">mantissaBitsAreZero	| index index2 |	self isLittleEndian		ifTrue: 			[index := 1.			[index &lt;= 6]				whileTrue: 					[(self basicAt: index)						= 0 ifFalse: [^false].					index := index + 1].			^((self basicAt: 7)				bitAnd: 15)				= 0].	index2 := 3.	[index2 &lt;= 8]		whileTrue: 			[(self basicAt: index2)				= 0 ifFalse: [^false].			index2 := index2 + 1].	^((self basicAt: 2)		bitAnd: 15)		= 0</body></methods><methods><class-id>Core.SmallInteger</class-id> <category>security</category><body package="SSG-Extensions3" selector="asBigEndianByteArray">asBigEndianByteArray	| t1 t2 |	self negative ifTrue: [self errorConvertingNegativeIntegerToBytes].	self &gt; 65535		ifTrue: 			[t1 := self bitShift: -16.			t2 := self bitAnd: 65535.			t1 &gt; 255 ifTrue: [^ByteArray					with: (t1 bitShift: -8)					with: (t1 bitAnd: 255)					with: (t2 bitShift: -8)					with: (t2 bitAnd: 255)].			^ByteArray				with: (t1 bitAnd: 255)				with: (t2 bitShift: -8)				with: (t2 bitAnd: 255)].	self &gt; 255 ifTrue: [^ByteArray with: (self bitShift: -8)			with: (self bitAnd: 255)].	^ByteArray with: (self bitAnd: 255) </body><body package="SSG-Extensions3" selector="specialLeftShift:">specialLeftShift: aNumber	aNumber = 0 ifFalse: [^(self bitAnd: (self class leftShiftArray at: aNumber))			bitShift: aNumber] </body></methods><methods><class-id>Core.False</class-id> <category>tt-utilities</category><body package="SSG-Extensions3" selector="textRepresentation">textRepresentation	^'F'</body></methods><methods><class-id>Core.SmallDouble</class-id> <category>comparing</category><body package="SSG-Extensions3" selector="mantissaBitsAreZero">mantissaBitsAreZero	^self asDegenerateDouble mantissaBitsAreZero</body></methods><methods><class-id>Core.Float</class-id> <category>comparing</category><body package="SSG-Extensions3" selector="mantissaBitsAreZero">mantissaBitsAreZero 	self isLittleEndian		ifTrue: 			[(self basicAt: 1)				= 0				ifTrue: 					[(self basicAt: 2)						= 0 ifTrue: [^((self basicAt: 3)							bitAnd: 127)							= 0].					^false].			^false].	(self basicAt: 4)		= 0		ifTrue: 			[(self basicAt: 3)				= 0 ifTrue: [^((self basicAt: 2)					bitAnd: 127)					= 0].			^false].	^false</body></methods><methods><class-id>Core.Float</class-id> <category>converting</category><body package="SSG-Extensions3" selector="specialValueExponent">specialValueExponent	^128 </body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>RBProgramNodeVisitor</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><class><name>SObject</name><environment>SmallSuiteGenerator</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><class><name>STypeClassInfo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.STypeObjectInfo</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeName methodTypes classMethodTypes scalars abstract </inst-vars><class-inst-vars>classMethodTypes </class-inst-vars><imports></imports><category>SmallSuiteGenerator-Info</category><attributes><package>SmallSuiteGenerator-Info</package></attributes></class><class><name>STestCaseFactory</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>reportClass engine typeInfo targetClassName fitness numberOfIterations profiler lastMessage fitnessSeed initialSeed typeInfoSeed typeInfoOrigin firstExecution generatedClass </inst-vars><class-inst-vars>instance </class-inst-vars><imports></imports><category>SmallSuiteGenerator-Builder</category><attributes><package>SmallSuiteGenerator-Builder</package></attributes></class><class><name>RBMessageNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>receiver selector selectorParts arguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><class><name>STestCaseFactoryVisualWorks</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.STestCaseFactory</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Builder</category><attributes><package>SmallSuiteGenerator-Builder</package></attributes></class><class><name>Random</name><environment>Core</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>seed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SequenceNode</name><environment>Kernel</environment><super>Kernel.ValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>temporaries statements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Compiler-Program Objects</category><attributes><package>System-Compiler-Program Objects</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>ClassDescription</name><environment>Core</environment><super>Core.Behavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceVariables organization </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>SFitnessFunction</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>profiler targetClass aClass </inst-vars><class-inst-vars>operator </class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><class><name>SSimpleFitnessFunction</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SFitnessFunction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>weight superclasses n </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><class><name>SSGParser</name><environment>SmallSuiteGenerator</environment><super>Refactory.Browser.RBProgramNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Utility</category><attributes><package>SmallSuiteGenerator-Utility</package></attributes></class><class><name>GenericException</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>messageText originator initialContext firstUnwindContext handlerContext parameter proceedBlock isResumable signal searchContext </inst-vars><class-inst-vars>notifierString </class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>SError</name><environment>SmallSuiteGenerator</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><class><name>SGAEngineExample</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Examples</category><attributes><package>SmallSuiteGenerator-Examples</package></attributes></class><class><name>SGAEngine</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>populationSize mutationOperator crossoverOperator numberOfStatements population logs typeInfo fitness selectionStrategy targetClassName numberOfGenerations lastMessage packageRegex initialPopulation typeInfoProfiler targetPackageRegex elitismRate crossoverStrategy stopIterations totalExecutionGA selectionStrategyTestCase </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>SAssertionTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpressionTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-AST</category><attributes><package>SmallSuiteGenerator-Tests-AST</package></attributes></class><class><name>SGAEngineTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>engine profiler utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-GA</category><attributes><package>SmallSuiteGenerator-Tests-GA</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>False</name><environment>Core</environment><super>Core.Boolean</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SSMetaInterpreter</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>context type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><class><name>Time</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hours minutes seconds </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>RBVariableNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>token </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><class><name>SUtilityTypeInfo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Utility</category><attributes><package>SmallSuiteGenerator-Tests-Utility</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>LimitedPrecisionReal</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SmallDouble</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SStack</name><environment>SmallSuiteGenerator</environment><super>Core.LinkedList</super><private>false</private><indexed-type>none</indexed-type><inst-vars>firstLinkStack lastLinkStack </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario</category><attributes><package>SmallSuiteGenerator-Scenario</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Symbol</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>RBSequenceNode</name><environment>Refactory.Browser</environment><super>Refactory.Browser.RBProgramNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>leftBar rightBar statements periods temporaries </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parser</category><attributes><package>Browser-Parser</package></attributes></class><class><name>STypeInfo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>types classes noneAbstractClasses scalars blackList cacheMessagesFrom </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Info</category><attributes><package>SmallSuiteGenerator-Info</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>OrderedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>firstIndex lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>SSTestShifter</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>statements assertions typeInfo nextId maxNumberOfStatements lastMessage hasErrors targetClassName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><class><name>ByteSymbol</name><environment>Core</environment><super>Core.Symbol</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Semaphore</name><environment>Core</environment><super>Core.LinkedList</super><private>false</private><indexed-type>none</indexed-type><inst-vars>excessSignals </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Processes</category><attributes><package>Kernel-Processes</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>ProbedCompiledMethod</name><environment>CraftedSmalltalk</environment><super>Kernel.CompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>original methodHolder probeStart </inst-vars><class-inst-vars>removedProbedMethodsHolder </class-inst-vars><imports>			OpcodePool.*			</imports><category>CraftedSt-VM</category><attributes><package>Debugger-Probes</package></attributes></class><class><name>InstructionStream</name><environment>Kernel</environment><super>Kernel.InstructionClient</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method pc </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Context</name><environment>Kernel</environment><super>Kernel.InstructionStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sender receiver stackp stack </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>AuxCodeInfoExtractor</name><environment>CraftedSmalltalk</environment><super>Kernel.InstructionStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>depth jumpStack maxDepth visited </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-VM</category><attributes><package>Debugger-Probes</package></attributes></class><class><name>Double</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Link</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nextLink </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>LinkValue</name><environment>Core</environment><super>Core.Link</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>Float</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Array</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>ByteString</name><environment>Core</environment><super>Core.ByteEncodedString</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-String Support</category><attributes><package>Collections-String Support</package></attributes></class><class><name>SmallInteger</name><environment>Core</environment><super>Core.Integer</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars>minVal maxVal maxBits maxBytes </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SSAbstractSettingMethods</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testCase executeBlock factory </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Strategies</category><attributes><package>SmallSuiteGenerator-Strategies</package></attributes></class><class><name>SmallTypeCollector</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>classDict </class-inst-vars><imports></imports><category>SmallSuiteGenerator-SmallType</category><attributes><package>SmallSuiteGenerator-SmallType</package></attributes></class><class><name>SSTestCaseTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SmallSuiteGenerator-Tests-Core</package></attributes></class><class><name>SInsertTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSTestCaseTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SmallSuiteGenerator-Tests-Core</package></attributes></class><class><name>SChangeTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSTestCaseTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SmallSuiteGenerator-Tests-Core</package></attributes></class><class><name>STypeInfoTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Info</category><attributes><package>SmallSuiteGenerator-Tests-Info</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class></st-source>