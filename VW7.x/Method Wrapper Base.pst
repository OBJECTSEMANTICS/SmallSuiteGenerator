<?xml version="1.0"?><st-source><!-- Name: Method Wrapper BaseNotice: Copyright 1994 - 2013 John BrantThis utility is made available to use under the MIT license, as detailed below.Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Comment: This package has the abstract MethodWrapper class and everything the framework needs, plus concrete BlockMethodWrapper.  All other packages in the Method Wrappers bundle are specific applications of method wrappers.  See the bundle comment for references to the theory and use of wrappers.DbIdentifier: psql_public_cst_2007DbTrace: 87425DevelopmentPrerequisites: #(#(#any 'Refactory-Namespace' ''))PackageName: Method Wrapper BaseParcel: #('Method Wrapper Base')ParcelName: Method Wrapper BasePrerequisiteParcels: #(#('Refactory-Namespace' ''))PrintStringCache: (1.8,nross)Date: 3:10:28 am June 8, 2020 --><time-stamp>From VisualWorksÂ®, 7.4 of December 5, 2005 on June 8, 2020 at 3:10:28 am</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Wrappers</name><environment>Refactory</environment><private>false</private><imports>			private Refactory.Browser.*			private Smalltalk.*			</imports><category>Refactory-Method Wrappers</category><attributes><package>Method Wrapper Base</package></attributes></name-space><class><name>MethodWrapper</name><environment>Refactory.Wrappers</environment><super>Kernel.CompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>clientMethod selector </inst-vars><class-inst-vars>methods </class-inst-vars><imports></imports><category>Refactory-Method Wrappers</category><attributes><package>Method Wrapper Base</package></attributes></class><comment><class-id>Refactory.Wrappers.MethodWrapper</class-id><body>MethodWrappers can add "hidden" behavior to the ordinary method. They can change what is executed before or after the method. For example, a CountMethodWrapper would increment a counter when the method is called, and then forward the call onto the original method. While this class is not abstract (i.e., there are no subclassResponsibilities), these method wrappers don't do anything if you install them. Look at the subclasses for example uses.To create a new type of method wrapper, you must create a subclass of MethodWrapper and redefine the #beforeMethod and/or #afterMethod as necessary. If you only need to redefine the #beforeMethod, you can redefine the #valueFrom:arguments: method instead (see the CountMethodWrapper). This will give you some added performance since it doesn't need to create two blocks and send the #valueNowOrOnUnwindDo: message.To use a method wrapper, send the class a #on:inClass message. This will return a new method wrapper (or nil if this method shouldn't be wrapped). You can then install the method wrapper by sending the #install message and uninstall by sending the #uninstall message.WARNING: incorrectly using the wrappers can crash your image, so you should save your image before using them. Most problems occur as a result of installing them on methods that are called either in the #beforeMethod or #afterMethod. (Note: the #value method in Association (VariableBinding in VW2.5) is automatically called by the VM when you refer to a global, class, or pool variable so you should probably never wrap it. I advise against wrapping primitives also.)Instance Variables:clientMethod	&lt;CompiledMethod&gt;	the method that is being wrappedselector	&lt;Symbol&gt;	the selector that the method is listed under in the method dictionaryClass Instance Variables:methods	&lt;OrderedCollection of: MethodWrapper&gt;	prototype wrappers that are copied when installing new wrappers</body></comment><class><name>BlockMethodWrapper</name><environment>Refactory.Wrappers</environment><super>Refactory.Wrappers.MethodWrapper</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>beforeBlock afterBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Refactory-Method Wrappers</category><attributes><package>Method Wrapper Base</package></attributes></class><methods><class-id>Refactory.Wrappers.MethodWrapper</class-id> <category>private</category><body package="Method Wrapper Base" selector="arrayPosition">arrayPosition	self numArgs == 0 ifTrue: [^0].	^(1 to: self size)		detect: [:i | (self realAt: i) == #Array or: [(self realAt: i) == Array]]		ifNone: [self error: 'Cannot find position for Array']</body><body package="Method Wrapper Base" selector="at:">at: anIndex 	"Lie about what's in our literal frame. This has the bad side-effect that we 	can't view the correct information in inspectors, but the good news is that 	we stop infinite recursion. Good thing the VM doesn't use the basicAt: 	method :)."	| object |	object := super at: anIndex.	^object == self ifTrue: [clientMethod] ifFalse: [object]</body><body package="Method Wrapper Base" selector="basicAt:">basicAt: anIndex 	"Lie about what's in our literal frame. This has the bad side-effect that we 	can't view the correct information in inspectors, but the good news is that 	we stop infinite recursion. Good thing the VM doesn't use the basicAt: 	method :)."	| object |	object := super basicAt: anIndex.	^object == self ifTrue: [clientMethod] ifFalse: [object]</body><body package="Method Wrapper Base" selector="methodPosition">methodPosition	^(1 to: self size) detect: 			[:i | 			| each |			each := self realAt: i.			each == self class methodWrapperSymbol or: [each == self]]		ifNone: [self error: 'Cannot find position to insert wrapper']</body><body package="Method Wrapper Base" selector="realAt:">realAt: anIndex	^super basicAt: anIndex</body><body package="Method Wrapper Base" selector="sendingContext">sendingContext	| context |	context := thisContext.	[context == nil or: [context method == self]]		whileFalse: [context := context sender].	^context == nil		ifTrue: [nil]		ifFalse: [context sender]</body></methods><methods><class-id>Refactory.Wrappers.MethodWrapper</class-id> <category>initialize-release</category><body package="Method Wrapper Base" selector="class:selector:">class: aClass selector: aSelector 	| position |	self at: self methodPosition put: self.	position := self arrayPosition.	position == 0 ifFalse: [self at: position put: Array].	mclass := aClass.	selector := aSelector</body></methods><methods><class-id>Refactory.Wrappers.MethodWrapper</class-id> <category>accessing</category><body package="Method Wrapper Base" selector="attributeAt:ifAbsent:">attributeAt: key ifAbsent: exceptionBlock 	^clientMethod attributeAt: key ifAbsent: exceptionBlock</body><body package="Method Wrapper Base" selector="attributeMessages">attributeMessages	"On initial compilation of method wrapper templates for specific parameter numbers the clientMethod will be nil.  Various utilities, e.g. DefaultPackageNamespaces, may override compilation code to ask for attributeMessages during template creation.  Protect the call to return nil (which should be an acceptable drop-out value for all callers) in that case."	^clientMethod isNil ifFalse: [clientMethod attributeMessages]</body><body package="Method Wrapper Base" selector="attributeMessages:">attributeMessages: anArray	^clientMethod attributeMessages: anArray</body><body package="Method Wrapper Base" selector="attributes">attributes	^clientMethod attributes</body><body package="Method Wrapper Base" selector="attributes:">attributes: aDictionary	^clientMethod attributes: aDictionary</body><body package="Method Wrapper Base" selector="basicInstall">basicInstall	| definingClass method |	definingClass := mclass whichClassIncludesSelector: selector.	definingClass isNil ifTrue: [^self].	method := definingClass compiledMethodAt: selector.	method == self ifTrue: [^self].	clientMethod := method.	sourceCode := clientMethod sourcePointer.	mclass methodDictionary at: selector put: self</body><body package="Method Wrapper Base" selector="install">install	self basicInstall.	mclass flushVMmethodCacheEntriesFor: selector</body><body package="Method Wrapper Base" selector="resourceType">resourceType	^clientMethod isNil		ifTrue: [super resourceType]		ifFalse: [clientMethod resourceType]</body><body package="Method Wrapper Base" selector="selector">selector	^selector</body><body package="Method Wrapper Base" selector="uninstall">uninstall	mclass isNil ifTrue: [^self].	(mclass compiledMethodAt: selector ifAbsent: [nil]) == self ifTrue: [		mclass == clientMethod mclass			ifTrue: [				mclass methodDictionary at: selector put: clientMethod.				mclass flushVMmethodCacheEntriesFor: selector]			ifFalse: [mclass simplyRemoveSelector: selector]]</body><body package="Method Wrapper Base" selector="uninstallEverything">uninstallEverything	| originalMethod |	mclass isNil ifTrue: [^self].	(mclass compiledMethodAt: selector ifAbsent: [nil]) == self ifTrue: [		originalMethod := self unwrappedMethod.		mclass == originalMethod mclass			ifTrue: [mclass addSelector: selector withMethod: originalMethod]			ifFalse: [mclass simplyRemoveSelector: selector]]</body><body package="Method Wrapper Base" selector="unwrappedMethod">unwrappedMethod	^clientMethod unwrappedMethod</body></methods><methods><class-id>Refactory.Wrappers.MethodWrapper</class-id> <category>enumerating</category><body package="Method Wrapper Base" selector="withAllBlockMethodsDo:">withAllBlockMethodsDo: aBlock 	"Don't recurse into the literal for self, and evaluate for clientMethod so that we can find literals in 	clientMethods."	super withAllBlockMethodsDo: aBlock.	clientMethod withAllBlockMethodsDo: aBlock</body></methods><methods><class-id>Refactory.Wrappers.MethodWrapper</class-id> <category>evaluating</category><body package="Method Wrapper Base" selector="valueWithReceiver:arguments:">valueWithReceiver: anObject arguments: anArrayOfObjects 	"This is the general case where you want both a before and after method, but if you want just a 	before method, you might want to override this method for optimization."	self beforeMethod.	^[clientMethod valueWithReceiver: anObject arguments: anArrayOfObjects] 		ensure: [self afterMethod]</body></methods><methods><class-id>Refactory.Wrappers.MethodWrapper</class-id> <category>evaluating-before-after</category><body package="Method Wrapper Base" selector="afterMethod">afterMethod</body><body package="Method Wrapper Base" selector="beforeMethod">beforeMethod</body></methods><methods><class-id>Refactory.Wrappers.MethodWrapper class</class-id> <category>private</category><body package="Method Wrapper Base" selector="codeStringFor:">codeStringFor: numArgs 	| nameString tempsString |	nameString := 'value'.	tempsString := numArgs == 0 				ifTrue: ['t := #()']				ifFalse: ['(t := #Array new: ' , numArgs printString , ') '].	1 to: numArgs		do: 			[:i | 			nameString := nameString , 'value: t' , i printString , ' '.			tempsString := tempsString , (i == 1 ifTrue: [''] ifFalse: [';']) 						, ' at: ' , i printString 						, ' put: t' , i printString].	^nameString , '	| t |	' , tempsString , '.	^' 		, self methodWrapperSymbol printString 			, ' valueWithReceiver: self arguments: t'</body><body package="Method Wrapper Base" selector="createMethodFor:">createMethodFor: numArgs	| compiler method |	compiler := Compiler new.	compiler methodClass: self.	method := [compiler compile: (self codeStringFor: numArgs) in: self notifying: nil ifFail: []]		on: Notification		do: [:sig | sig resume].	^method generate</body><body package="Method Wrapper Base" selector="methodWrapperSymbol">methodWrapperSymbol	^#'The method wrapper should be inserted in this position'</body><body package="Method Wrapper Base" selector="primitives">primitives	^#(61	"at:put:"	71	"new:"	523	"valueWithReceiver:arguments:"	501)	"value"</body></methods><methods><class-id>Refactory.Wrappers.MethodWrapper class</class-id> <category>accessing</category><body package="Method Wrapper Base" selector="installWrappers:">installWrappers: aCollection 	aCollection do: [:each | each basicInstall]</body><body package="Method Wrapper Base" selector="methods">methods	^methods isNil ifTrue: [methods := Dictionary new] ifFalse: [methods]</body><body package="Method Wrapper Base" selector="nuke">nuke	"MethodWrapper nuke"	self uninstallAllWrappers.	self initialize</body><body package="Method Wrapper Base" selector="uninstallAllWrappers">uninstallAllWrappers	"Emergency method to uninstall everything"	"MethodWrapper uninstallAllWrappers"	self withAllSubclasses 		do: [:each | each allInstances do: [:inst | inst uninstallEverything]]</body></methods><methods><class-id>Refactory.Wrappers.MethodWrapper class</class-id> <category>class initialization</category><body package="Method Wrapper Base" selector="initialize">initialize	self == MethodWrapper 		ifTrue: [self allSubclasses do: [:each | each initialize]].	methods := Dictionary new</body></methods><methods><class-id>Refactory.Wrappers.MethodWrapper class</class-id> <category>instance creation</category><body package="Method Wrapper Base" selector="on:inClass:">on: aSelector inClass: aClass 	| wrapper |	(self canWrap: aSelector inClass: aClass) ifFalse: [^nil].	wrapper := (self methods at: aSelector numArgs				ifAbsentPut: [self createMethodFor: aSelector numArgs]) copy.	wrapper class: aClass selector: aSelector.	^wrapper</body></methods><methods><class-id>Refactory.Wrappers.MethodWrapper class</class-id> <category>testing</category><body package="Method Wrapper Base" selector="canWrap:inClass:">canWrap: aSelector inClass: aClass 	"Test if a method can be wrapped without causing infinite recursion."	| class method |	(aClass includesBehavior: MethodWrapper) ifTrue: [^false].	aClass == BlockClosure 		ifTrue: 			[(#(#valueAsUnwindBlockFrom: #ensure:) includes: aSelector) 				ifTrue: [^false]].	(aClass includesBehavior: DeferredBinding) ifTrue: [^false].	(aClass includesBehavior: VariableBinding) ifTrue: [^false].	class := aClass whichClassIncludesSelector: aSelector.	class isNil ifTrue: [^false].	method := class compiledMethodAt: aSelector ifAbsent: [nil].	^method notNil 		and: [(self primitives includes: method primitiveNumber) not]</body></methods><methods><class-id>Refactory.Wrappers.BlockMethodWrapper</class-id> <category>accessing</category><body package="Method Wrapper Base" selector="afterBlock">afterBlock	^afterBlock</body><body package="Method Wrapper Base" selector="afterBlock:">afterBlock: aBlockClosure 	afterBlock := aBlockClosure</body><body package="Method Wrapper Base" selector="beforeBlock">beforeBlock	^beforeBlock</body><body package="Method Wrapper Base" selector="beforeBlock:">beforeBlock: aBlockClosure 	beforeBlock := aBlockClosure</body></methods><methods><class-id>Refactory.Wrappers.BlockMethodWrapper</class-id> <category>initialize-release</category><body package="Method Wrapper Base" selector="class:selector:">class: aClass selector: aSelector 	super class: aClass selector: aSelector.	beforeBlock := [:receiver :arguments | ].	afterBlock := [:receiver :arguments | ]</body></methods><methods><class-id>Refactory.Wrappers.BlockMethodWrapper</class-id> <category>evaluating</category><body package="Method Wrapper Base" selector="valueWithReceiver:arguments:">valueWithReceiver: anObject arguments: anArrayOfObjects 	"This is the general case where you want both a before and after method, but if you want just a 	before method, you might want to override this method for optimization."	beforeBlock value: anObject value: anArrayOfObjects.	^[clientMethod valueWithReceiver: anObject arguments: anArrayOfObjects] 		ensure: [afterBlock value: anObject value: anArrayOfObjects]</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>Method Wrappers</category><body package="Method Wrapper Base" selector="rebindMethod:oldVariableNames:">rebindMethod: method oldVariableNames: varNames 	^super rebindMethod: method unwrappedMethod oldVariableNames: varNames</body></methods><methods><class-id>Kernel.CompiledCode</class-id> <category>accessing</category><body package="Method Wrapper Base" selector="unwrappedMethod">unwrappedMethod	^self</body></methods><initialize><class-id>Refactory.Wrappers.MethodWrapper</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>CompiledCode</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>bytes </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>ClassDescription</name><environment>Core</environment><super>Core.Behavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceVariables organization </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class></st-source>