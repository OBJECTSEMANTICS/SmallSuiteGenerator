<?xml version="1.0"?><st-source><!-- Name: SmallSuiteGeneratorBundleName: SmallSuiteGeneratorBundleStructure: a Store.BundleForParcelDevelopmentPrerequisites: #(#(#any 'SUnitToo(ls)' '' ) #(#any 'Spy' '' ) )Parcel: nilParcelName: SmallSuiteGeneratorPrerequisiteDescriptions: #(#(#name 'SUnitToo(ls)' #componentType #package ) #(#name 'Spy' #componentType #bundle ) )PrerequisiteParcels: #(#('SUnitToo(ls)' '' ) #('Spy' '' ) )Date: 10:10:15 AM December 3, 2019 --><time-stamp>From VisualWorksÂ®, 8.3 of July 28, 2017 on December 3, 2019 at 10:10:15 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>SmallSuiteGenerator</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>SmallSuiteGenerator</category><attributes><package>SmallSuiteGenerator</package></attributes></name-space><class><name>SGAMutationOperationTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>operation utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-GA</category><attributes><package>SmallSuiteGenerator-Tests-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGAMutationOperationTest</class-id><body>This class contains tests</body></comment><class><name>SObject</name><environment>SmallSuiteGenerator</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SObject</class-id><body>Superclass of almost all project classes, between them:	- AST classes used to create statements and assertions	- Core classes which configure the environment, manage assertions creation and so.	- GA classes that are responsible for testCase's fitness increasing. It means coverage augmentation.	- Info classes which transform the profiler result in nodes that are easier to use in the assertions and statements creation.	- Profiler classes which get classes' info types.</body></comment><class><name>SSTestShifter</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>statements assertions typeInfo nextId fitness targetClassesNames maxNumberOfStatements validatedTargetClassName randomGenerator fitnessByClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSTestShifter</class-id><body>SSTestShifter is responsible for creating, mutating and validating statements. It is responsible to for creating different kind of statements: primitive, factory messages, messages, accessor messages.Genetic algorithm's evolution depends this class' increasing fitness. For this reason it is one of the main classes and essential for the project.Instance Variables	assertions:						&amp;lt;OrderedCollection&amp;gt;	fitness:							&amp;lt;Dictionary&amp;gt;	fitnessByClass:					&amp;lt;Dictionary&amp;gt;	maxNumberOfStatements:		&amp;lt;SmallInteger&amp;gt;	nextId:							&amp;lt;SmallInteger&amp;gt;	randomGenerator:				&amp;lt;SRandomGenerator&amp;gt;	statements:						&amp;lt;OrderedCollection&amp;gt;	targetClassesNames:			&amp;lt;Set&amp;gt;	typeInfo:							&amp;lt;STypeInfo&amp;gt;	validatedTargetClassName:	&amp;lt;Boolean&amp;gt;</body></comment><class><name>SCoverageTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>utility fitness profiler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-GA</category><attributes><package>SmallSuiteGenerator-Tests-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SCoverageTest</class-id><body>This class contains tests</body></comment><class><name>STestCaseFactory</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>engine typeInfo targetClassName targetPackageRegex outputPackageName fitness numberOfIterations profiler </inst-vars><class-inst-vars>instance </class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.STestCaseFactory</class-id><body>STestCaseFactory is an abstract class that represents the project facade. It contains the main methods to run the project</body></comment><class><name>STestCaseFactoryVisualWorks</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.STestCaseFactory</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.STestCaseFactoryVisualWorks</class-id><body>STestCaseFactoryVisualWorks is a subclass that it is called when the project runs in VisualWorks</body></comment><class><name>SStatementCoverageTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SCoverageTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-GA</category><attributes><package>SmallSuiteGenerator-Tests-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SStatementCoverageTest</class-id><body>This class contains tests</body></comment><class><name>SSTestCase</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSTestShifter</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSTestCase</class-id><body>SSTestCase is a subclass that defines or initializes some instance variables which are util in the genetic algorithm evolution</body></comment><class><name>SMethodCoverageTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SCoverageTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-GA</category><attributes><package>SmallSuiteGenerator-Tests-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SMethodCoverageTest</class-id><body>This class contains tests</body></comment><class><name>SExpressionTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-AST</category><attributes><package>SmallSuiteGenerator-Tests-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SExpressionTest</class-id><body>This class contains tests</body></comment><class><name>SAssertionTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpressionTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-AST</category><attributes><package>SmallSuiteGenerator-Tests-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SAssertionTest</class-id><body>This class contains tests</body></comment><class><name>SFieldAccessMessageTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpressionTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-AST</category><attributes><package>SmallSuiteGenerator-Tests-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SFieldAccessMessageTest</class-id><body>This class contains tests</body></comment><class><name>SConfiguration</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>level randomGenerator seed configurationClass logName </class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SConfiguration</class-id><body>SConfiguration is responsible for defining or instantiating some classes or values used in the project.Furthermore, some configuration parameters are defined depending the environment, it means Pharo or VisualWorks</body></comment><class><name>SMessageTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpressionTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-AST</category><attributes><package>SmallSuiteGenerator-Tests-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SMessageTest</class-id><body>This class contains tests</body></comment><class><name>SFactoryMessageTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpressionTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-AST</category><attributes><package>SmallSuiteGenerator-Tests-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SFactoryMessageTest</class-id><body>This class contains tests</body></comment><class><name>SConfigurationPharo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SConfigurationPharo</class-id><body>SConfigurationPharo is a subclass called when the project environment is running in Pharo. Furthermore, it defines parameters used in Pharo.</body></comment><class><name>SLiteralTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpressionTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-AST</category><attributes><package>SmallSuiteGenerator-Tests-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SLiteralTest</class-id><body>This class contains tests</body></comment><class><name>SConfigurationVisualWorks</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SConfiguration</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SConfigurationVisualWorks</class-id><body>SConfigurationVisualWorks is a subclass called when the project environment is running in VisualWorks.</body></comment><class><name>SUtilityTypeInfo</name><environment>SmallSuiteGenerator</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Utility</category><attributes><package>SmallSuiteGenerator-Tests-Utility</package></attributes></class><comment><class-id>SmallSuiteGenerator.SUtilityTypeInfo</class-id><body>SUtilityTypeInfo is a class which declares typeInfos for tests. </body></comment><class><name>SGAObject</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>randomGenerator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGAObject</class-id><body>Abstract class of those nodes responsible for the genetic algorithm evolution:	- engine (like its name says, it is responsible to execute the algorithm in order to get the testCases with the highest fitness value)	- operations classes -&amp;gt; Responsible for executing crossover and mutation operation	- selection algorithm class -&amp;gt; It selects the fittest individuals testCases</body></comment><class><name>SFitnessFunction</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tagetPackagesRegex </inst-vars><class-inst-vars>operator </class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SFitnessFunction</class-id><body>SFitnessFunction is an abstract class that represents a fitness abstract function used in genetic algorithm evolution to determine how fit a testCase is.</body></comment><class><name>SGAEngine</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>populationSize mutationOperator crossoverOperator numberOfStatements population logs typeInfo fitness numberOfIterations selectionStrategy targetClassName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGAEngine</class-id><body>SGAEngine is responsible for executing the genetic algorithm, it means that it follows the phases to get a testCase population with the highest fitness score.The phases followed are:	1. Create an initial population 	2. Use the fitness function established to calculate the fitness score of each testCase in the population	3. Determine the selection strategy to select the fittest testCases and let them pass their statements to the next generation	4. Apply the crossover operation to get offsprings (new testCases) by exchanging the statements of parents (testCases). 	5. Apply mutation operation with a low random probability to modify some statements. Internal Representation and Key Implementation Points.Instance Variables	crossoverOperator:			&amp;lt;SGACrossoverOperator&amp;gt;	fitness:						&amp;lt;SFitnessFunction&amp;gt;	logs:							&amp;lt;OrderedCollection&amp;gt;	mutationOperator:			&amp;lt;SGAMutationOperator&amp;gt;	numberOfIterations:		&amp;lt;SmallInteger&amp;gt;	numberOfStatements:		&amp;lt;SmallInteger&amp;gt;	population:					&amp;lt;OrderedCollection&amp;gt;	populationSize:				&amp;lt;SmallInteger&amp;gt;	selectionStrategy:			&amp;lt;SGATournamentSelection&amp;gt;	targetClassName:			&amp;lt;ByteString&amp;gt;	typeInfo:						&amp;lt;STypeInfo&amp;gt;</body></comment><class><name>SGATournamentSelection</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>population tournamentSize fitness </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGATournamentSelection</class-id><body>SGATournamentSelection is responsible for select the fittest testCase based in their fitness.</body></comment><class><name>GAROMondrianViewBuilderTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Generated</category><attributes><package>SmallSuiteGenerator-Tests-Generated</package></attributes></class><class><name>SMultiFitnessFunction</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SFitnessFunction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fitness </inst-vars><class-inst-vars>multiFitnessFunction </class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SMultiFitnessFunction</class-id><body>SMultiFitnessFunciton is the fitness function that contains simple fitness function's collection.</body></comment><class><name>SGAEngineExample</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGAEngineExample</class-id><body>SGAEngineExample contains some examples to validate correct project functionality </body></comment><class><name>SGAOperation</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGAOperation</class-id><body>SGAOperation is an abstract class for operation nodes which are necessary to create a new population  	- crossover operation 	- mutation operation </body></comment><class><name>SGACrossoverOperation</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGAOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGACrossoverOperation</class-id><body>SGACrossoverOperation is the operation node that is responsible to create offsprings combining the statements of their parents.To create a new offspring it gets a random percent of statements of a testCase and the rest of another testCase. Furthermore, it checks the statements references (dependencies) and repairs them if it is necessary.For example if the parents are:	Parent1	_var0 := 1.	_var1 := 'hello'.		Parent2	_var0 := SFoo new.	_var1 := _var0 returnString.	The new offspring with a 50% of statements of each parent:	_var0 := 1.	_var1 := _var0 returnString.	Like it has an inconsistency because '_var0' in the first parent is of type SFoo, it is repaired. Then the new offspring resultant is:	_var0 := 1.	_var2 := SFoo new.	_var1 := _var2 returnString. </body></comment><class><name>SGAMutationOperation</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGAOperation</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mutationRate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGAMutationOperation</class-id><body>SGAMutationOperation is an operator which modifies some statements of the testCase. However this operation depends of a random probability to be applied.This operation can apply three different types of mutation: 		- remove -&amp;gt; It means that a statement choosen randomly can be removed of the testCase.	- change -&amp;gt; According to the statement choosen, it is modified in value or selector.	- insert -&amp;gt; A statement is added following one of these options: asRandomMessage, asMethodMessage or asParameter. The reason for these options is because statements are usually of different expressions.</body></comment><class><name>STestCaseFactoryExample</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.STestCaseFactoryExample</class-id><body>STestCaseFactoryExample contains some examples to run and validate the project functionality</body></comment><class><name>SSimpleFitnessFunction</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SFitnessFunction</super><private>false</private><indexed-type>none</indexed-type><inst-vars>profiler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSimpleFitnessFunction</class-id><body>SSimpleFitnessFunction is an abstract class of simple fitness function like: 		- SMethodCoverage -&amp;gt; It calculates the number of class methods executed	- SStatementCoverage -&amp;gt; It calculates the number of statements executed 	Instance Variables	profiler:		&amp;lt;SSTypeCollector&amp;gt;	</body></comment><class><name>SMethodCoverage</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSimpleFitnessFunction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SMethodCoverage</class-id><body>SMethodCoverage is responsible for calculating the method coverage in each testCase of a testSuite. It means that for each class defined in the testCase it calculates how many methods were executed.</body></comment><class><name>SStatementCoverage</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSimpleFitnessFunction</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SStatementCoverage</class-id><body>SStatementCoverage is responsible for calculating statement coverage of each testCase in the testSuite. It calculates how many statements were executed in each class defined of the testSuite. The number of statements refers to number of lines of code executed </body></comment><class><name>SGALog</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>generationNumber timeToProduceGeneration fittestTestCase mutationResult </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGALog</class-id><body>SGALog saves some important data about genetic algorithm evolution like: genetic algotithm's generation number, testCase with the highest fitness and time in which is produced the generation.In each iteration of the genetic algorithm a new instance of the class is created.Instance Variables	fittestTestCase:				&amp;lt;STestCase&amp;gt;	generationNumber:				&amp;lt;Smallnteger&amp;gt;	timeToProduceGeneration:		&amp;lt;SmallInteger&amp;gt;</body></comment><class><name>SSTypeCollector</name><environment>SmallSuiteGenerator</environment><super>Profiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scalars </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Profiler</category><attributes><package>SmallSuiteGenerator-Profiler</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSTypeCollector</class-id><body>SSTypeCollector is a subclass of Profiler that collects project typesInstance Variables	scalars:		&amp;lt;Dictionary&amp;gt;</body></comment><class><name>SSTypeCollectorClass</name><environment>SmallSuiteGenerator</environment><super>ClassSpy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Profiler</category><attributes><package>SmallSuiteGenerator-Profiler</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSTypeCollectorClass</class-id><body>SSTypeCollectorClass is a subclass of profiler Class that collects class types.</body></comment><class><name>SSTypeCollectorMethod</name><environment>SmallSuiteGenerator</environment><super>MethodSpy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>returnType argTypes receiverType executed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Profiler</category><attributes><package>SmallSuiteGenerator-Profiler</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSTypeCollectorMethod</class-id><body>SSTypeCollectorMethod is a subclass of profiler method that collects method types.Instance Variables	argTypes:			&amp;lt;Collection&amp;gt;	executed:			&amp;lt;False&amp;gt;	receiverType:	&amp;lt;SMultiTypeInfo&amp;gt;	returnType:		&amp;lt;SMultiTypeInfo&amp;gt;</body></comment><class><name>SSTypeCollectorPackage</name><environment>SmallSuiteGenerator</environment><super>PackageSpy</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Profiler</category><attributes><package>SmallSuiteGenerator-Profiler</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSTypeCollectorPackage</class-id><body>SSTypeCollectorPackage is a subclass of Package that collects packages types</body></comment><class><name>STypeInfo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>types classes noneAbstractClasses scalars </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Info</category><attributes><package>SmallSuiteGenerator-Info</package></attributes></class><comment><class-id>SmallSuiteGenerator.STypeInfo</class-id><body>STypeInfo is responsible for collecting the STypeCollector's main data and building a new instance from the collected data.It is composed of STypeClassInfo collection and each item likewise is formed by STypeMethodInfo collection.Instance Variables	types:						&amp;lt;Dictionary&amp;gt;	classes:					&amp;lt;Dictionary&amp;gt;	noneAbstractClasses:	&amp;lt;Collection&amp;gt;	scalars: 					&amp;lt;Dictionary&amp;gt;</body></comment><class><name>SRandom</name><environment>SmallSuiteGenerator</environment><super>Core.ParkMillerRandom</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SRandom</class-id><body>SRandom is a subclass of Random that is responsible for select an item of the collection or collect items randomly in a collection</body></comment><class><name>STypeObjectInfo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Info</category><attributes><package>SmallSuiteGenerator-Info</package></attributes></class><comment><class-id>SmallSuiteGenerator.STypeObjectInfo</class-id><body>STypeObjectInfo is an abstract class of info nodes: 			- type class -&amp;gt; Which collect type info data of a class in the profiler	- type method -&amp;gt; Collect types of the receiver, arguments and returnType of a method in the profiler</body></comment><class><name>SMultiTypeInfo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.STypeObjectInfo</super><private>false</private><indexed-type>none</indexed-type><inst-vars>types </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Info</category><attributes><package>SmallSuiteGenerator-Info</package></attributes></class><comment><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id><body>SMultiTypeInfo is a set of types.Instance Variables	types:		&amp;lt;Set&amp;gt;</body></comment><class><name>SError</name><environment>SmallSuiteGenerator</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SError</class-id><body>SError is a subclass of Error. It is used to represent error's conditions in test generation process.Additionally, it saves in a log all the errors gotten.</body></comment><class><name>STypeMethodInfo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.STypeObjectInfo</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selector returnType argTypes isQuick isDeprecated receiver </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Info</category><attributes><package>SmallSuiteGenerator-Info</package></attributes></class><comment><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id><body>STypeMethodInfo is an info type node for a method.Instance Variables	argTypes:			&amp;lt;Array&amp;gt;	isDeprecated:	&amp;lt;Boolean&amp;gt;	isQuick:			&amp;lt;Boolean&amp;gt;	receiver:			&amp;lt;SMultiTypeInfo&amp;gt;	returnType:		&amp;lt;SMultiTypeInfo&amp;gt;	selector:			&amp;lt;Symbol&amp;gt;</body></comment><class><name>STypeClassInfo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.STypeObjectInfo</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeName methodTypes classMethodTypes </inst-vars><class-inst-vars>classMethodTypes </class-inst-vars><imports></imports><category>SmallSuiteGenerator-Info</category><attributes><package>SmallSuiteGenerator-Info</package></attributes></class><comment><class-id>SmallSuiteGenerator.STypeClassInfo</class-id><body>STypeClassInfo is an info type node for a class.Instance Variables	classMethodTypes:	&amp;lt;Dictionary&amp;gt;	methodTypes:			&amp;lt;Dictionary&amp;gt;	typeName:				&amp;lt;Symbol&amp;gt;</body></comment><class><name>SSTestRunner</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testCase invariants </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSTestRunner</class-id><body>This class contains tests</body></comment><class><name>SFoo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>score </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario</category><attributes><package>SmallSuiteGenerator-Scenario</package></attributes></class><comment><class-id>SmallSuiteGenerator.SFoo</class-id><body>SFoo is a proof class created to test project functionality</body></comment><class><name>SEventTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario</category><attributes><package>SmallSuiteGenerator-Scenario</package></attributes></class><comment><class-id>SmallSuiteGenerator.SEventTest</class-id><body>This class contains tests</body></comment><class><name>SExpression</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>returnType id randomGenerator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-AST</category><attributes><package>SmallSuiteGenerator-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SExpression</class-id><body>Superclass of all nodes for 	- expressions (they represent nodes which are used to create messages),	- messages (concerned with: assertion messages, factory messages, access messages and mesasges that modify the behavior of a class)	Instance Variables	id:		               &amp;lt;Integer&amp;gt; 	randomGenerator:		&amp;lt;SRandom&amp;gt;	returnType:		      &amp;lt;Symbol&amp;gt;</body></comment><class><name>SEvent</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>discount price </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario</category><attributes><package>SmallSuiteGenerator-Scenario</package></attributes></class><comment><class-id>SmallSuiteGenerator.SEvent</class-id><body>SEVent is a proof class created to test project functionalityInstance Variables	discount:		&amp;lt;Object&amp;gt;	price:			&amp;lt;Object&amp;gt;</body></comment><class><name>SAbstractMessage</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>receiver selector args </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-AST</category><attributes><package>SmallSuiteGenerator-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SAbstractMessage</class-id><body>Abstract class of nodes for	- messages (access messages and messages that update the state of a class)	- factory methods (to represent the class creation messages),	- assertion messages (to represent assertion messages that match with an according requirement)Instance Variables	args:		    &amp;lt;Collection&amp;gt;	receiver:		 &amp;lt;Symbol&amp;gt;	selector:		 &amp;lt;Symbol&amp;gt;</body></comment><class><name>SParty</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SEvent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>date </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario</category><attributes><package>SmallSuiteGenerator-Scenario</package></attributes></class><comment><class-id>SmallSuiteGenerator.SParty</class-id><body>SParty is a proof class created to test project functionalityInstance Variables	date:		&amp;lt;Object&amp;gt;</body></comment><class><name>SSPerson</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name id nickname </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario</category><attributes><package>SmallSuiteGenerator-Scenario</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSPerson</class-id><body>SSPerson is a proof class created to test project functionality</body></comment><class><name>SMessage</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SAbstractMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-AST</category><attributes><package>SmallSuiteGenerator-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SMessage</class-id><body>SMessage is a node which represents method calls that not return an instance variable of a class. They are a little more complex. It can receive arguments also.For example: 	1.			_var1 returnCollection.			_var1 -&amp;gt; Receiver which points to SFoo's factoryMessage.		#returnCollection -&amp;gt; selector of the method.			2. 		_var1 return: _var2.				_var1 -&amp;gt; Receiver		#return: -&amp;gt; selector		_var2 -&amp;gt; Argument of type ByteString</body></comment><class><name>SSTeacher</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSPerson</super><private>false</private><indexed-type>none</indexed-type><inst-vars>yearsWorkExperience idTeacher </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario</category><attributes><package>SmallSuiteGenerator-Scenario</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSTeacher</class-id><body>SSTeacher is a proof class created to test project functionality</body></comment><class><name>SAssertionMessage</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SAbstractMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-AST</category><attributes><package>SmallSuiteGenerator-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SAssertionMessage</class-id><body>Superclass of assertion messages nodes for 	- comparison assertion (it compares an object with other)	- inspector assertion (it compares the result of a method executed with a value)	- primitive assertion (it compares the primitive values)	- string assertion (it compares the way to represent an object as string with a string)</body></comment><class><name>SPrimitiveAssertion</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SAssertionMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-AST</category><attributes><package>SmallSuiteGenerator-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SPrimitiveAssertion</class-id><body>A SPrimitiveAssertion collects instances of the class if the execution context's values are primitives.For example: 		List with items classified as primitive: 		Array with: '_var1' -&amp;gt; 'hello'		with: '_var2' -&amp;gt; 2		with: '_var3' -&amp;gt; (3@5).	It returns items like: 		self assert: _var1 equals: 'hello'.		self assert: _var2 equals: 2.</body></comment><class><name>SConference</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SEvent</super><private>false</private><indexed-type>none</indexed-type><inst-vars>date speaker offerPrice </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario</category><attributes><package>SmallSuiteGenerator-Scenario</package></attributes></class><comment><class-id>SmallSuiteGenerator.SConference</class-id><body>SConference is a proof class created to test project functionalityInstance Variables	date:				&amp;lt;Object&amp;gt;	offerPrice:		&amp;lt;Object&amp;gt;	speaker:			&amp;lt;Object&amp;gt;</body></comment><class><name>SStringAssertion</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SAssertionMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-AST</category><attributes><package>SmallSuiteGenerator-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SStringAssertion</class-id><body>A SStringAssertion select execution context's values that their class implement some method of printing like: 'printOn:', 'asString'. From the resulting collection each item is used to create an instance of the class using #printString as selector.For example: 		List with classes' items which have implemented printing methods: 		Array with: '_var1' -&amp;gt; 'hello'		with: '_var2' -&amp;gt; 2.3		with: '_var3' -&amp;gt; (3@5).	It returns items like: 		self assert: _var1 printString equals: ''hello''.		self assert: _var2 printString equals: '2.3'.		self assert: _var3 printString equals: (2@3).</body></comment><class><name>SAbstractClass</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario2</category><attributes><package>SmallSuiteGenerator-Scenario2</package></attributes></class><comment><class-id>SmallSuiteGenerator.SAbstractClass</class-id><body>SAbstractClass is a proof abstract class created to test project functionality</body></comment><class><name>SSubclassChild</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SAbstractClass</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario2</category><attributes><package>SmallSuiteGenerator-Scenario2</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSubclassChild</class-id><body>SSubclassChild is a proof class created to test project functionality</body></comment><class><name>SAssignment</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>variable value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-AST</category><attributes><package>SmallSuiteGenerator-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SAssignment</class-id><body>SAssignment is a node which is compossed by a variable and an expression.For example: 	1.			_var0 := 1.			_var0 -&amp;gt; Variable.		1 -&amp;gt; value (in this case a literal).			2. 		_var1 := SFoo new.				_var1 -&amp;gt; Varaible		SFoo new -&amp;gt; an instance of factoryMessage</body></comment><class><name>SStudent</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSPerson</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scoreStudent idStudent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario2</category><attributes><package>SmallSuiteGenerator-Scenario2</package></attributes></class><comment><class-id>SmallSuiteGenerator.SStudent</class-id><body>SStudent is a proof class created to test project functionality</body></comment><class><name>SMutatorTestCaseTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SmallSuiteGenerator-Tests-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SMutatorTestCaseTest</class-id><body>This class contains tests</body></comment><class><name>SSTestCaseTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SmallSuiteGenerator-Tests-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSTestCaseTest</class-id><body>This class contains tests</body></comment><class><name>SComparisonAssertion</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SAssertionMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-AST</category><attributes><package>SmallSuiteGenerator-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SComparisonAssertion</class-id><body>A SComparisonAssertion selects the execution context values that are comparable.Collection's items of the same class are compared and for each one is created a new instance of this class with the selector depending the result of the comparison.For example: 	List with items that are comparable: 		Array with: '_var1'-&amp;gt; 9		with: '_var2' -&amp;gt; 5		with: '_var3' -&amp;gt; 9		with: '_var4' -&amp;gt; 'hello'.	It returns items like: 		self deny: _var1 equals: _var2.		self assert: _var1 equals: _var3.		</body></comment><class><name>SRemoveTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSTestCaseTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SmallSuiteGenerator-Tests-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SRemoveTest</class-id><body>This class contains tests</body></comment><class><name>SConfigurationTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SmallSuiteGenerator-Tests-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SConfigurationTest</class-id><body>This class contains tests</body></comment><class><name>SFactoryMessage</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SAbstractMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-AST</category><attributes><package>SmallSuiteGenerator-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SFactoryMessage</class-id><body>SFactoryMessage is a node that represents the class' creation with methods of meta class.For example: 	1.			SStack newStack.			#SStack -&amp;gt; It's the receiver 		#newStack -&amp;gt; It's a method of meta class.			2. 		SFoo score: _var1.				#SFoo -&amp;gt; Receiver		#score: -&amp;gt; Message of receiver		_var1 -&amp;gt; Argument 			3. 		SFoo new.				#SFoo new -&amp;gt; Receiver		#new -&amp;gt; Default selector</body></comment><class><name>SSTestShifterTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SmallSuiteGenerator-Tests-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSTestShifterTest</class-id><body>This class contains tests</body></comment><class><name>SInsertTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSTestCaseTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SmallSuiteGenerator-Tests-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SInsertTest</class-id><body>This class contains tests</body></comment><class><name>SRandomTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SmallSuiteGenerator-Tests-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SRandomTest</class-id><body>This class contains tests</body></comment><class><name>SLiteral</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-AST</category><attributes><package>SmallSuiteGenerator-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SLiteral</class-id><body>SLiteral is a node which is compossed by a value that is included in typeInfo scalars.For example: 	1.			10				10 -&amp;gt; SmallInteger.			2. 		'hello'				'hello' -&amp;gt; ByteString.</body></comment><class><name>SChangeTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SSTestCaseTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SmallSuiteGenerator-Tests-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SChangeTest</class-id><body>This class contains tests</body></comment><class><name>SExtensionsTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Core</category><attributes><package>SmallSuiteGenerator-Tests-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SExtensionsTest</class-id><body>This class contains tests</body></comment><class><name>SInspectorAssertion</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SAssertionMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-AST</category><attributes><package>SmallSuiteGenerator-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SInspectorAssertion</class-id><body>A SInspectorAssertion selects methods categorized as returnField and creates an instance for each one if the execution result is primitive.For example: 		List with classes' items categorized as returnField: 		Array with: '_var2' -&amp;gt; (2@10).	It returns items like: 		self assert: _var2 x equals: 2.		self assert: _var2 y equals: 10.</body></comment><class><name>SClassInfoTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Info</category><attributes><package>SmallSuiteGenerator-Tests-Info</package></attributes></class><comment><class-id>SmallSuiteGenerator.SClassInfoTest</class-id><body>This class contains tests</body></comment><class><name>SFieldAccessMessage</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SAbstractMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-AST</category><attributes><package>SmallSuiteGenerator-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SFieldAccessMessage</class-id><body>SFieldAccessMessage is a node which represents method calls that return an instance variable of a class.For example: 	1.			_var1 x.			_var1 -&amp;gt; Receiver which points to Point's factoryMessage.		#x -&amp;gt; selector of the method</body></comment><class><name>SMultiTypeInfoTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Info</category><attributes><package>SmallSuiteGenerator-Tests-Info</package></attributes></class><comment><class-id>SmallSuiteGenerator.SMultiTypeInfoTest</class-id><body>This class contains tests</body></comment><class><name>STypeInfoTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Info</category><attributes><package>SmallSuiteGenerator-Tests-Info</package></attributes></class><comment><class-id>SmallSuiteGenerator.STypeInfoTest</class-id><body>This class contains tests</body></comment><class><name>SVariable</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>varName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-AST</category><attributes><package>SmallSuiteGenerator-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SVariable</class-id><body>SVariable is a node which is represented by a name and id.For example: 	1.			_var2				_var -&amp;gt; Name of variable.		2 -&amp;gt; Id of variable			2. 		_int3				'_int' -&amp;gt; Name		3 -&amp;gt; Id</body></comment><class><name>SMethodInfoTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Info</category><attributes><package>SmallSuiteGenerator-Tests-Info</package></attributes></class><comment><class-id>SmallSuiteGenerator.SMethodInfoTest</class-id><body>This class contains tests</body></comment><class><name>SSelf</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SVariable</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-AST</category><attributes><package>SmallSuiteGenerator-AST</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSelf</class-id><body>SSelf is a node which is part of the assertion message.</body></comment><class><name>SMultiFitnessFunctionTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>function utility fitnessFunctions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-GA</category><attributes><package>SmallSuiteGenerator-Tests-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SMultiFitnessFunctionTest</class-id><body>This class contains tests</body></comment><class><name>SSExecutionContext</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>values </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.SSExecutionContext</class-id><body>SSExecutionContext takes a snapshot of the SSTestRunner's instance context. It saves the tempNames of variables and values as dictionaryInstance Variables	values:		&amp;lt;Dictionary&amp;gt;</body></comment><class><name>SGAEngineTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>engine profiler utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-GA</category><attributes><package>SmallSuiteGenerator-Tests-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGAEngineTest</class-id><body>This class contains tests</body></comment><class><name>SGACrossoverOperationTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mutationOperation operation utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-GA</category><attributes><package>SmallSuiteGenerator-Tests-GA</package></attributes></class><comment><class-id>SmallSuiteGenerator.SGACrossoverOperationTest</class-id><body>This class contains tests</body></comment><class><name>STestCaseFactoryPharo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.STestCaseFactory</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><comment><class-id>SmallSuiteGenerator.STestCaseFactoryPharo</class-id><body>STestCaseFactoryPharo is a subclass that it is called when the project runs in Pharo</body></comment><methods><class-id>SmallSuiteGenerator.SGAMutationOperationTest</class-id> <category>running</category><body package="SmallSuiteGenerator-Tests-GA">setUp	super setUp.	operation := SGAMutationOperation new		randomGenerator: SConfiguration newRandomGenerator.	utility := SUtilityTypeInfo new</body></methods><methods><class-id>SmallSuiteGenerator.SGAMutationOperationTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-GA">testMutation	| testCase mutatedTestCase |	testCase := SSTestCase with: utility typeInfoSStack3.	testCase numMaxStatements: 10.	testCase		addTargetClassName: #SStack;		generateStatements.	mutatedTestCase := operation mutate: testCase.	mutatedTestCase := operation mutate: mutatedTestCase.	self assert: mutatedTestCase validReferences</body><body package="SmallSuiteGenerator-Tests-GA">testMutationSSteacher	| typeInfo testCase mutatedTestCase |	typeInfo := utility typeInfoSSTeacher1.	testCase := SSTestCase with: typeInfo.	testCase		addTargetClassName: #SSTeacher;		generateStatements.	mutatedTestCase := operation mutate: testCase.	mutatedTestCase := operation mutate: mutatedTestCase.	self assert: mutatedTestCase validReferences</body><body package="SmallSuiteGenerator-Tests-GA">testMutationSStudentManual	| testCase mutatedTestCase testSuite |	testSuite := utility testSuiteSStudentManual.	testCase := testSuite first.	"testCase generateStatements."	mutatedTestCase := operation mutate: testCase.	mutatedTestCase := operation mutate: mutatedTestCase.	self assert: mutatedTestCase validReferences.	testCase := testSuite second.	"testCase generateStatements."	mutatedTestCase := operation mutate: testCase.	mutatedTestCase := operation mutate: mutatedTestCase.	self assert: mutatedTestCase validReferences</body><body package="SmallSuiteGenerator-Tests-GA">testMutationSStudentWithValidReferences	| testCase mutatedTestCase testSuite |	testSuite := utility testSuiteSStudentManual.	testCase := testSuite third.	"testCase generateStatements."	mutatedTestCase := operation mutate: testCase.	mutatedTestCase := operation mutate: mutatedTestCase.	self assert: mutatedTestCase validReferences.	testCase := testSuite third.	"testCase generateStatements."	mutatedTestCase := operation mutate: testCase.	mutatedTestCase := operation mutate: mutatedTestCase.	self assert: mutatedTestCase validReferences</body></methods><methods><class-id>SmallSuiteGenerator.SObject class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Core">new	"Answer a newly created and initialized instance."	^ super new initialize</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>initalize</category><body package="SmallSuiteGenerator-Core">initialize	super initialize.	statements := OrderedCollection new.	assertions := OrderedCollection new.	fitness := Dictionary new.	fitnessByClass := Dictionary new.	nextId := 0.	maxNumberOfStatements := 10.	targetClassesNames := Set new.	validatedTargetClassName := false.	randomGenerator := SConfiguration newRandomGenerator</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>repairing</category><body package="SmallSuiteGenerator-Core">alternativeFactoryMessage: aFactoryMessage before: aExpression	| returnType |	returnType := aFactoryMessage returnType.	^ (typeInfo factoryMessagesFrom: returnType)		detect: [ :meth | 			meth returnType = returnType				and: [ meth selector ~= aFactoryMessage selector ] ]		ifFound: [ :meth | self factoryMessageUsing: meth before: aExpression ]		ifNone: [ SFactoryMessage default: returnType ]</body><body package="SmallSuiteGenerator-Core">alternativeFieldAccessMessage: aFieldAccessMessage	| returnType receiver |	receiver := aFieldAccessMessage receiver.	returnType := aFieldAccessMessage returnType.	(self pickAccessorsOf: receiver returnType)		detect: [ :meth | 			meth returnType = returnType				and: [ meth selector ~= aFieldAccessMessage selector ] ]		ifFound:			[ :meth | ^ SFieldAccessMessage newFromReceiver: receiver andMethod: meth ].	self		error:			'There is no alternative for fieldAccessMessage of selector: '				, aFieldAccessMessage selector</body><body package="SmallSuiteGenerator-Core">alternativeMessage: aMessage before: expression	| returnType receiver |	receiver := aMessage receiver.	returnType := aMessage returnType.	(self pickMessagesOf: receiver returnType)		detect: [ :meth | 			meth returnType = returnType				and: [ meth selector ~= aMessage selector ] ]		ifFound: [ :meth | ^ self messageUsing: meth and: receiver before: expression ].	self		error:			'There is no alternative for message of selector: '				, aMessage selector</body><body package="SmallSuiteGenerator-Core">alternativeOfVariable: aVariable before: aExpression	| returnType |	self statementOfVarName: aVariable printString.	returnType := aVariable returnType.	(self statementsOfType: returnType before: aExpression)		detect: [ :stm | stm reference ~= aVariable ]		ifFound: [ :stm | ^ stm reference ].	^ (self addStatementOfType: returnType before: aExpression) reference</body><body package="SmallSuiteGenerator-Core">buildArgs: argTypes before: aStatement	argTypes		ifNotNil: [ | prevTypes scalarsKeys |			prevTypes := (self subStatementsFrom: 1 toPrevIndexOf: aStatement)				collect: #returnType				thenSelect: [ :aType | aType isNil not ].			scalarsKeys := typeInfo scalars keys asOrderedCollection.			argTypes				do: [ :arg | 					self						addArgument: arg						before: aStatement						considering: prevTypes						and: scalarsKeys ] ]</body><body package="SmallSuiteGenerator-Core">error: string	^ SError signal: string</body><body package="SmallSuiteGenerator-Core">factoryMessageUsing: method before: aStatement	self buildArgs: method argTypes before: aStatement.	^ SFactoryMessage		method: method		previousStatements: (self subStatementsFrom: 1 toPrevIndexOf: aStatement)</body><body package="SmallSuiteGenerator-Core">invariant	self typeInfo		ifNil:			[ self error: 'TypeInfo is nil. Set the testCase with a typeInfo' ]</body><body package="SmallSuiteGenerator-Core">literal: aClassName	^ self newLiteral: aClassName</body><body package="SmallSuiteGenerator-Core">messageUsing: method and: receiver before: aStatement	self buildArgs: method argTypes before: aStatement.	^ SMessage		newFromReceiver: receiver copy		method: method		andPreviousStatements: (self subStatementsFrom: 1 toPrevIndexOf: aStatement)</body><body package="SmallSuiteGenerator-Core">messagesVariablesFrom: aClassName	| varExpressions |	varExpressions := self		messagesVariablesWhichContain: aClassName		before: nil.	varExpressions		ifEmpty: [ typeInfo classes				at: aClassName				ifPresent: [ (typeInfo classes at: aClassName) subclasses						detect: [ :aClass | 							varExpressions := self								messagesVariablesWhichContain: aClass name								before: nil.							varExpressions isNotEmpty ] ]				ifAbsent: [ typeInfo scalars						at: aClassName						ifPresent: [ varExpressions := self								messagesVariablesWhichContain: aClassName								before: nil.							varExpressions isNotEmpty ] ] ].	^ varExpressions</body><body package="SmallSuiteGenerator-Core">newStatementOfType: aType before: aStatement	(randomGenerator		collectAtRandom:			#(#newFactoryMessage:before: #newLiteral: #newFieldAccessMessageOfType:before: #newMessageOfType:before:))		do: [ :message | 			[ ^ self				perform: message				withEnoughArguments: (Array with: aType with: aStatement) ]				on: SError				do: [ "try with the next one" ] ].	self error: 'Cannot create expression of returnType: ' , aType</body><body package="SmallSuiteGenerator-Core">perform: selector inStatement: stm	^ stm		perform: selector		withArguments: (Array with: stm copy with: self)</body><body package="SmallSuiteGenerator-Core">randomIndexToAdd: aExpression before: aStatement	| refIndexes anIndex |	anIndex := statements indexOf: aStatement.	anIndex = 0		ifTrue: [ ^ self numberStatements ].	refIndexes := self referencesIndexes: aExpression.	anIndex := anIndex - 1.	refIndexes		ifNotEmpty: [ | ini end maxIndex |			maxIndex := refIndexes max.			ini := anIndex min: maxIndex.			end := anIndex max: maxIndex.			^ randomGenerator selectAtRandom: (ini to: end) ].	anIndex = 0		ifTrue: [ ^ anIndex ].	^ randomGenerator selectAtRandom: (1 to: anIndex)</body><body package="SmallSuiteGenerator-Core">referencesIndexes: expression	^ expression variablesWithId allButFirst		collect:			[ :var | statements indexOf: (self statementOfVarName: var printString) ]</body><body package="SmallSuiteGenerator-Core">repair: expression	[ self statementAt: expression ]		on: SError		do: [ ^ self statements copy				flatCollect: [ :stm | self repairReferenceTo: expression of: stm ] ].	self error: expression printString , ' does not exist.'</body><body package="SmallSuiteGenerator-Core">repairReferenceTo: removedExpression of: expression	| references exprsToDelete |	references := expression pickUpReferences: removedExpression.	exprsToDelete := OrderedCollection new.	references		do: [ :reference | 			[ self repair: reference of: expression ]				on: SError				do: [ exprsToDelete add: reference ] ].	^ exprsToDelete</body><body package="SmallSuiteGenerator-Core">replace: exprToReplace by: otherExpression on: expression	(self statementAt: expression)		replaceExpression: exprToReplace		by: otherExpression</body><body package="SmallSuiteGenerator-Core">satisfyTypes: types before: aStatement	| scalarsKeys scalarTypes nonScalarTypes |	scalarsKeys := typeInfo scalars keys asOrderedCollection.	scalarTypes := OrderedCollection new.	nonScalarTypes := OrderedCollection new.	types		do: [ :aType | 			(scalarsKeys includes: aType)				ifTrue: [ scalarTypes add: aType ]				ifFalse: [ nonScalarTypes add: aType ] ].	nonScalarTypes		do: [ :aType | self addStatementOfType: aType before: aStatement ].	^ scalarTypes</body><body package="SmallSuiteGenerator-Core">statementsOfType: aType before: expression	(statements includes: expression)		ifFalse: [ self				error: 'Statement: ' , expression printString , 'is not found in testCase.' ].	^ (self subStatementsFrom: 1 toPrevIndexOf: expression)		select: [ :stm | stm returnType = aType ]</body><body package="SmallSuiteGenerator-Core">subStatementsFrom: start toPrevIndexOf: aStatement	| stop |	stop := statements indexOf: aStatement.	stop = 0		ifTrue: [ ^ statements ].	start &lt;= stop		ifFalse: [ ^ self				error:					start printString , ' (indexIni) is greater than ' , stop printString						, ' (indexPos).' ].	^ statements copyFrom: start to: stop - 1</body><body package="SmallSuiteGenerator-Core">updateNextId	nextId = 0		ifTrue: [ nextId := statements size ]</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>inserting</category><body package="SmallSuiteGenerator-Core">addAssignment: anExpression	| assignment |	assignment := self newAssignment: anExpression.	self addStatement: assignment.	^ assignment</body><body package="SmallSuiteGenerator-Core">addFactoryMessage	| variables |	variables := self objectVariables.	variables		ifEmpty: [ (randomGenerator collectAtRandom: typeInfo noneAbstractClasses)				do: [ :aClass | 					[ ^ self addFactoryMessage: aClass name ]						on: SError						do: [  ] ].			self error: 'Cannot create a factoryMessage.' ]		ifNotEmpty: [ ^ self				addFactoryMessage: (randomGenerator selectAtRandom: variables) returnType ]</body><body package="SmallSuiteGenerator-Core">addFactoryMessage: symbol	^ self addAssignment: (self newFactoryMessage: symbol before: nil)</body><body package="SmallSuiteGenerator-Core">addFactoryMessage: aClassName ofSelector: aSelector	^ [ self		addAssignment:			(self				factoryMessageUsing: (typeInfo classMethodType: aSelector from: aClassName)				before: nil) ]		on: SError		do: [ self addFactoryMessage: aClassName ]</body><body package="SmallSuiteGenerator-Core">addFieldAccessMessage	| receiver methods |	receiver := self pickAnObjectVariable.	methods := self pickAccessorsOf: receiver returnType.	methods		ifNotEmpty: [ ^ self				addFieldAccessMessage: (randomGenerator selectAtRandom: methods)				withReceiver: receiver ].	self error: 'Cannot create a field access message.'</body><body package="SmallSuiteGenerator-Core">addFieldAccessMessage: aSelector from: aClassName	| receiver anAccessor |	anAccessor := (self pickAccessorsOf: aClassName)		detect: [ :accessor | accessor selector = aSelector ]		ifNone: [ nil ].	anAccessor		ifNil: [ self				error:					'None field access message of selector: ' , aSelector						, ' matches with: ' , aClassName ].	receiver := self pickOrCreateObjectVariableOf: aClassName.	^ self addFieldAccessMessage: anAccessor withReceiver: receiver</body><body package="SmallSuiteGenerator-Core">addFieldAccessMessage: method withReceiver: receiver	^ self		addAssignment: (SFieldAccessMessage newFromReceiver: receiver copy andMethod: method)</body><body package="SmallSuiteGenerator-Core">addLiteral	^ self addLiteral: self randomLiteralClassName</body><body package="SmallSuiteGenerator-Core">addLiteral: aClassName	^ self addAssignment: (self newLiteral: aClassName)</body><body package="SmallSuiteGenerator-Core">addMessage	| receiver methods |	receiver := self pickAnObjectVariable.	methods := self pickMessagesOf: receiver returnType.	methods		ifEmpty: [ self				error: 'There are no method typeInfos for: ' , receiver returnType , '.' ]		ifNotEmpty: [ ^ self				addMessage: (randomGenerator selectAtRandom: methods)				withReceiver: receiver ]</body><body package="SmallSuiteGenerator-Core">addMessage: aSelector from: aClassName	| receiver aMethod |	aMethod := (self pickMessagesOf: aClassName)		, (typeInfo factoryMessagesFrom: aClassName)		detect: [ :aMessage | aMessage selector = aSelector ]		ifNone: [ nil ].	aMethod		ifNil: [ self				error:					'None message of selector: ' , aSelector , ' matches with: '						, aClassName ].	receiver := self pickOrCreateObjectVariableOf: aClassName.	^ self addMessage: aMethod withReceiver: receiver</body><body package="SmallSuiteGenerator-Core">addMessage: method withReceiver: receiver	^ self		addAssignment: (self messageUsing: method and: receiver before: nil)</body><body package="SmallSuiteGenerator-Core">addStatement: anExpression	statements add: anExpression</body><body package="SmallSuiteGenerator-Core">addStatement: newExpression after: aStatement	| anIndex |	anIndex := statements indexOf: aStatement.	anIndex = 0		ifTrue: [ self addStatement: newExpression ]		ifFalse: [ anIndex := randomGenerator				selectAtRandom: (anIndex to: self numberStatements).			statements add: newExpression afterIndex: anIndex ].	^ newExpression</body><body package="SmallSuiteGenerator-Core">addStatement: newExpression before: aStatement	"I add a newExpression before aStatement"	statements		add: newExpression		afterIndex: (self randomIndexToAdd: newExpression before: aStatement)</body><body package="SmallSuiteGenerator-Core">addStatementOfType: aType before: expression	| newExpression |	newExpression := self		newAssignment: (self newStatementOfType: aType before: expression).	self addStatement: newExpression before: expression.	^ newExpression</body><body package="SmallSuiteGenerator-Core">addStatements: collStatements	self		assert: statements isEmpty		description: 'statements must be empty'.	statements addAll: collStatements</body><body package="SmallSuiteGenerator-Core">insertAsParameter: expression after: aStatement	(randomGenerator		collectAtRandom:			(statements				copyFrom: (statements indexOf: aStatement) + 1				to: self numberStatements))		do: [ :stm | 			[ ^ stm replaceArgBy: expression ]				on: SError				do: [  ] ].	self		error: 'Cannot insert any parameter by: ' , expression printString</body><body package="SmallSuiteGenerator-Core">insertExpression: expression after: aStatement	^ self		addStatement: (self newAssignment: expression)		after: aStatement</body><body package="SmallSuiteGenerator-Core">insertExpressionRandomly	(randomGenerator		collectAtRandom:			#(#insertRandomMessage:using: #insertMethodMessage:using: #insertAsParameter:using:))		do: [ :selector | 			[ ^ self insertStatementOfSelector: selector ]				on: SError				do: [  ] ]</body><body package="SmallSuiteGenerator-Core">insertStatement	| l stop alpha count random |	l := 1.	count := 0.	stop := self numberStatements.	alpha := 0.5.	random := SConfiguration randomGenerator.	[ l &lt; stop and: [ random next &lt;= (alpha raisedTo: count) ] ]		whileTrue: [ self insertExpressionRandomly.			l := l + 1.			count := count + 1 ]</body><body package="SmallSuiteGenerator-Core">insertStatementOfSelector: selector	(randomGenerator collectAtRandom: statements copy)		do: [ :stm | 			[ ^ self perform: selector inStatement: stm ]				on: SError				do: [  ] ].	self		error: 'Cannot insert statement of selector: ' , selector printString</body><body package="SmallSuiteGenerator-Core">randomLiteralClassName	^ [ randomGenerator		selectAtRandom: typeInfo scalars keys asOrderedCollection ]		on: Error		do: [ self				error: 'TypeInfo does not have scalars. Set scalars on typeInfo.' ]</body><body package="SmallSuiteGenerator-Core">repair: exprToReplace of: expression	| aType replacement |	aType := exprToReplace returnType.	replacement := (randomGenerator		collectAtRandom: (self subStatementsFrom: 1 toPrevIndexOf: expression))		detect:			[ :stm | stm reference ~= exprToReplace and: [ stm returnType = aType ] ]		ifNone: [ self addStatementOfType: aType before: expression ].	self replace: exprToReplace by: replacement on: expression</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>printing</category><body package="SmallSuiteGenerator-Core">printDescriptiveComment	^ self printSummaryFitness , (String with: Character cr)		, self printSummaryFitnessByClass</body><body package="SmallSuiteGenerator-Core">printFunctionByClassName: dict on: stream	(dict associations select: [ :assoc | assoc value &gt; 0 ])		do: [ :assoc | 			stream				nextPutAll: assoc key;				nextPut: $:;				nextPutAll: assoc value printString;				nextPut: $%;				nextPutAll: (String with: Character cr) ]</body><body package="SmallSuiteGenerator-Core">printStatements	^ statements collect: #printString</body><body package="SmallSuiteGenerator-Core">printSummaryFitness	^ String		streamContents: [ :stream | 			stream				nextPutAll: '"Fitness: ';				nextPut: Character cr.			fitness				associationsDo: [ :assoc | 					stream						nextPutAll: assoc key;						nextPutAll: ': ';						nextPutAll: assoc value printString;						nextPut: Character cr ].			stream nextPutAll: '"' ]</body><body package="SmallSuiteGenerator-Core">printSummaryFitnessByClass	^ String		streamContents: [ :stream | 			stream				nextPutAll: '"This test covers: ';				nextPut: Character cr.			fitnessByClass				associationsDo: [ :assoc | 					stream						nextPutAll: assoc key;						nextPutAll: (String with: Character cr).					self printFunctionByClassName: assoc value on: stream ].			stream				nextPutAll: '"';				nextPutAll: (String with: Character cr) ]</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>As yet unclassified</category><body package="SmallSuiteGenerator-Core">printSummaryFitnessByClass	^ String		streamContents: [ :stream | 			stream				nextPutAll: '"This test covers: ';				nextPut: Character cr.			fitnessByClass				associationsDo: [ :assoc | 					stream						nextPutAll: assoc key;						nextPutAll: (String with: Character cr).					self printFunctionByClassName: assoc value on: stream ].			stream				nextPutAll: '"';				nextPutAll: (String with: Character cr) ]</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Core">allVarNames	^ statements collect: [ :stm | stm reference printString ]</body><body package="SmallSuiteGenerator-Core">assertions	^ assertions</body><body package="SmallSuiteGenerator-Core">assignId	| idToAssign assignedIds |	assignedIds := self assignedIds.	[ assignedIds includes: nextId ] whileTrue: [ nextId := nextId + 1 ].	idToAssign := nextId.	nextId := nextId + 1.	^ idToAssign</body><body package="SmallSuiteGenerator-Core">assignedIds	^ statements collect: #id</body><body package="SmallSuiteGenerator-Core">defaultNumberStatements	^ 54</body><body package="SmallSuiteGenerator-Core">fitness	^ fitness</body><body package="SmallSuiteGenerator-Core">fitnessByClass	^ fitnessByClass</body><body package="SmallSuiteGenerator-Core">maxNumberOfStatements	^ maxNumberOfStatements</body><body package="SmallSuiteGenerator-Core">maxNumberOfStatements: anObject	maxNumberOfStatements := anObject</body><body package="SmallSuiteGenerator-Core">numMaxStatements	^ maxNumberOfStatements</body><body package="SmallSuiteGenerator-Core">numMaxStatements: anObject	maxNumberOfStatements := anObject</body><body package="SmallSuiteGenerator-Core">numberStatements	^ statements size</body><body package="SmallSuiteGenerator-Core">randomGenerator: anObject	randomGenerator := anObject</body><body package="SmallSuiteGenerator-Core">statementAt: statement	statements		detect: [ :stm | stm = statement ]		ifFound: [ :stm | ^ stm ].	self		error: 'Statement: ' , statement printString , ' is not found in testCase.'</body><body package="SmallSuiteGenerator-Core">statementOfVarName: aString	statements		detect: [ :stm | stm reference printString = aString ]		ifFound: [ :stm | ^ stm ].	self error: 'Statement of varName: ' , aString , 'is not found.'</body><body package="SmallSuiteGenerator-Core">statements	^ statements</body><body package="SmallSuiteGenerator-Core">targetClassesNames	^ targetClassesNames</body><body package="SmallSuiteGenerator-Core">typeInfo	^ typeInfo</body><body package="SmallSuiteGenerator-Core">typeInfo: anObject	typeInfo := anObject</body><body package="SmallSuiteGenerator-Core">validReferences	| references |	references := Set new.	^ statements		detect: [ :stm | 			| variables |			variables := stm variablesWithId asSet.			references add: stm reference.			(references includesAll: variables)				ifFalse: [ true ]				ifTrue: [ references addAll: variables.					false ] ]		ifFound: [ false ]		ifNone: [ true ]</body><body package="SmallSuiteGenerator-Core">validTargetClassName: aClassName	(validatedTargetClassName		and: [ (targetClassesNames includes: aClassName) not				and: [ | classInfo |					classInfo := typeInfo classAt: aClassName ifNone: [  ].					classInfo isNil not and: [ classInfo allMethods isNotEmpty ] ] ])		ifTrue: [ self addTargetClassName: aClassName ].	((targetClassesNames includes: aClassName) not		or: [ typeInfo isAbstractClass: aClassName ])		ifTrue: [ self error: 'Class: ' , aClassName , ' is not able to be used.' ]		ifFalse: [ validatedTargetClassName := true ]</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>modifying</category><body package="SmallSuiteGenerator-Core">changeMessageNotUnderstood: aSelector from: aClassName	^ false</body><body package="SmallSuiteGenerator-Core">changeStatement	(randomGenerator collectAtRandom: statements)		do: [ :stm | 			[ ^ self changeStatement: stm ]				on: SError				do: [  ] ]</body><body package="SmallSuiteGenerator-Core">changeStatement: aStatement	| statementChanged |	statementChanged := aStatement copy		repairOn: self		changing: aStatement.	(self statementAt: aStatement) replaceBy: statementChanged.	^ statementChanged</body><body package="SmallSuiteGenerator-Core">changeStatementOfClassName: aClassName	| varExpressions changed |	varExpressions := self messagesVariablesFrom: aClassName.	changed := false.	"if the expression can't be replaced by another, then it will be removed"	varExpressions		do: [ :var | 			| changedStm origStm |			origStm := self statementOfVarName: var printString.			changedStm := self changeStatement: origStm.			changedStm = origStm				ifTrue: [ self removeStatementNoRepairing: origStm ]				ifFalse: [ changed := true ] ].	^ changed</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>actions</category><body package="SmallSuiteGenerator-Core">analyze	" we delegate the responsibility to a test runner, in the future we would like to add new ways to run the tests "	^ SSTestRunner new evaluate: self</body><body package="SmallSuiteGenerator-Core">generateAssertions	^ self		generateAssertions:			(Array				with: SComparisonAssertion				with: SInspectorAssertion				with: SPrimitiveAssertion				with: SStringAssertion)</body><body package="SmallSuiteGenerator-Core">generateAssertions: classAssertions	"	it analyze each kind of assertion an generate a set of assertion based on the test case -- double dispatch	"	| executionContext |	executionContext := self analyze.	assertions := classAssertions		flatCollect: [ :assertion | assertion for: executionContext ]</body><body package="SmallSuiteGenerator-Core">generateStatements	self		assert: typeInfo types isNotEmpty		description: 'TypeInfo does not contain info at all.'.	[ self numberStatements &lt; self maxNumberOfStatements ]		whileTrue: [ "self addMessage"			[ self addMessage ]				on: SError				do: [  ] ]</body><body package="SmallSuiteGenerator-Core">generateStatements: anInteger	self maxNumberOfStatements: anInteger.	self generateStatements</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>querying</category><body package="SmallSuiteGenerator-Core">factoryMessageVariablesBefore: aStatement	^ (self subStatementsFrom: 1 toPrevIndexOf: aStatement)		select: [ :stm | stm value isFactoryMessage ]		thenCollect: [ :stm | stm variable ]</body><body package="SmallSuiteGenerator-Core">involvedClasses	^ (self objectVariables collect: [ :var | var returnType ]) asSet</body><body package="SmallSuiteGenerator-Core">messagesVariablesWhichContain: aClassName before: aStatement	^ (self subStatementsFrom: 1 toPrevIndexOf: aStatement)		select: [ :stm | stm referenceTo: aClassName ]		thenCollect: [ :stm | stm variable ]</body><body package="SmallSuiteGenerator-Core">objectVariables	^ statements		select: [ :stm | 			| res |			res := self typeInfo classAt: stm returnType ifNone: [ nil ].			res isNil not ]		thenCollect: [ :stm | stm variable ]</body><body package="SmallSuiteGenerator-Core">pickAccessorsOf: aType	^ typeInfo accessMessagesFrom: aType</body><body package="SmallSuiteGenerator-Core">pickAnObjectVariable	| variables |	variables := self objectVariables.	variables		ifEmpty: [ self addFactoryMessage.			variables := self objectVariables ].	^ randomGenerator selectAtRandom: variables</body><body package="SmallSuiteGenerator-Core">pickMessagesOf: aType	^ typeInfo messagesFrom: aType</body><body package="SmallSuiteGenerator-Core">pickObjectVariableOf: aClassName	(randomGenerator		collectAtRandom: (self subStatementsFrom: 1 toPrevIndexOf: nil))		detect: [ :stm | stm returnType = aClassName ]		ifFound: [ :stm | ^ stm reference ]		ifNone: [  ].	self error: 'Does not exist a statement of type: ' , aClassName</body><body package="SmallSuiteGenerator-Core">pickOrCreateObjectVariableOf: aClassName	^ [ self pickObjectVariableOf: aClassName ]		on: SError		do: [ (self addFactoryMessage: aClassName) variable ]</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Core">newAssignment: anExpression	[ ^ SAssignment		name:			(SVariable new				varName: '_var';				id: self assignId;				returnType: anExpression returnType;				yourself)		value: anExpression copy ]		on: MessageNotUnderstood		do:			[ :error | self error: anExpression printString , ' is not an expression.' ]</body><body package="SmallSuiteGenerator-Core">newFactoryMessage: aClassName before: aStatement	| methods |	typeInfo		classAt: aClassName		ifNone: [ self				error:					'Error to create factoryMessage of: ' , aClassName						, ' because it is not found in typeInfo.' ].	self validTargetClassName: aClassName.	methods := typeInfo factoryMessagesFrom: aClassName.	^ methods		ifEmpty: [ SFactoryMessage default: aClassName ]		ifNotEmpty: [ self newFactoryMessageUsing: aClassName and: aStatement ]</body><body package="SmallSuiteGenerator-Core">newFactoryMessageUsing: aClassName and: aStatement	| methods |	methods := typeInfo factoryMessagesFrom: aClassName.	(randomGenerator collectAtRandom: methods)		do: [ :method | 			[ self buildArgs: method argTypes before: aStatement.			^ SFactoryMessage				method: method				class: aClassName				previousStatements: (self subStatementsFrom: 1 toPrevIndexOf: aStatement) ]				on: SError				do: [  ] ].	self error: 'Error to create a factoryMessage of: ' , aClassName</body><body package="SmallSuiteGenerator-Core">newFieldAccessMessageOfType: aType andReceiver: receiver	(self pickAccessorsOf: receiver returnType)		detect: [ :aMethod | aMethod returnType includes: aType ]		ifFound: [ :aMethod | 			^ SFieldAccessMessage				newFromReceiver: receiver copy				andMethod: aMethod ]		ifNone: [ self				error:					'Cannot create a field access message of type: ' , aType						, ' and receiver of type: ' , receiver returnType ]</body><body package="SmallSuiteGenerator-Core">newFieldAccessMessageOfType: aType before: aStatement	(self factoryMessageVariablesBefore: aStatement)		do: [ :receiver | 			[ ^ self newFieldAccessMessageOfType: aType andReceiver: receiver ]				on: SError				do: [  ] ].	self error: 'Cannot create a field access message of type: ' , aType</body><body package="SmallSuiteGenerator-Core">newLiteral: aClassName	typeInfo scalars		at: aClassName		ifPresent: [ :values | 			values				ifEmpty: [ self error: 'Scalar of type: ' , aClassName , ' is empty.' ].			(aClassName includesAll: 'BlockClosure')				ifTrue: [ self error: 'Can not create a literal of BlockClosure' ].			^ SLiteral new				returnType: aClassName;				value: (randomGenerator selectAtRandom: values asOrderedCollection) ].	self error: 'Scalars dont include: ' , aClassName</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>As yet unclassified</category><body package="SmallSuiteGenerator-Core">newLiteral: aClassName	typeInfo scalars		at: aClassName		ifPresent: [ :values | 			values				ifEmpty: [ self error: 'Scalar of type: ' , aClassName , ' is empty.' ].			(aClassName includesAll: 'BlockClosure')				ifTrue: [ self error: 'Can not create a literal of BlockClosure' ].			^ SLiteral new				returnType: aClassName;				value: (randomGenerator selectAtRandom: values asOrderedCollection) ].	self error: 'Scalars dont include: ' , aClassName</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Core">newMessageOfType: aType before: aStatement	(self factoryMessageVariablesBefore: aStatement)		do: [ :receiver | 			[ ^ self newMessageOfType: aType using: receiver before: aStatement ]				on: SError				do: [  ] ].	self		error:			'Cannot create a message of type: ' , aType printString				,					'. A possible reason is because there is none factoryMessage which has a message of this return type.'</body><body package="SmallSuiteGenerator-Core">newMessageOfType: aType using: receiver before: aStatement	(self pickMessagesOf: receiver returnType)		detect: [ :aMethod | aMethod returnType includes: aType ]		ifFound: [ :aMethod | 			[ ^ self messageUsing: aMethod and: receiver before: aStatement ]				on: SError				do: [  ] ].	^ self		error:			'Error to create a message of type: ' , aType				, ' with receiver of type: ' , receiver returnType</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>removing</category><body package="SmallSuiteGenerator-Core">changeStatementOfVarName: varName	^ self changeStatement: (self statementOfVarName: varName)</body><body package="SmallSuiteGenerator-Core">removeExpression: expression	| exprsToRemove |	self removeFromStatements: expression.	exprsToRemove := self repair: expression.	exprsToRemove do: [ :expr | self removeExpression: expr ]</body><body package="SmallSuiteGenerator-Core">removeExpressionWithoutRepairing: expression	self removeFromStatements: expression.	[ self statementAt: expression ]		on: SError		do: [ (self statements copy				flatCollect:					[ :stm | (stm pickUpReferences: expression) ifNotEmpty: [ Array with: stm ] ])				do: [ :stm | self removeExpressionWithoutRepairing: stm ] ]</body><body package="SmallSuiteGenerator-Core">removeFromStatements: expression	[ statements remove: expression ]		on: Error		do: [ self error: expression printString , ' is not found.' ]</body><body package="SmallSuiteGenerator-Core">removeStatement	"If other statements refer the statement to remove, then this reference is replaced with another value out of the set which has the same type"	statements ifEmpty: [ ^ #() ].	self		removeStatement:			(statements				at:					(randomGenerator selectAtRandom: (1 to: self numberStatements) asArray))</body><body package="SmallSuiteGenerator-Core">removeStatement: anExpression	self removeExpression: (self statementAt: anExpression)</body><body package="SmallSuiteGenerator-Core">removeStatementNoRepairing: aStatement	"remove all statements that reference to statement because this cant be fixed"	self removeExpressionWithoutRepairing: (self statementAt: aStatement)</body><body package="SmallSuiteGenerator-Core">removeStatementOfVarName: varName	^ self removeStatement: (self statementOfVarName: varName) copy</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>adding</category><body package="SmallSuiteGenerator-Core">addArgument: arg before: aStatement considering: prevTypes and: scalarNames	| res |	res := arg types anySatisfy: [ :type | prevTypes includes: type ].	res		ifFalse: [ (randomGenerator collectAtRandom: arg types)				detect: [ :missType | 					[ (scalarNames includes: missType)						ifTrue: [ self								addStatement: (self newAssignment: (self newLiteral: missType))								before: aStatement ]						ifFalse: [ self								addAssignment: (self newFactoryMessage: missType before: aStatement) ].					true ]						on: SError						do: [ false ] ]				ifNone: [ self						error: 'It is not possible to meet the arguments of this method call' ] ]</body><body package="SmallSuiteGenerator-Core">addTargetClassName: aSymbol	typeInfo types		at: aSymbol		ifAbsent: [ self error: 'Class name: ' , aSymbol , ' is not found in typeInfo' ].	targetClassesNames add: aSymbol</body><body package="SmallSuiteGenerator-Core">addTargetClassNames: symbols	symbols do: [ :symbol | self addTargetClassName: symbol ]</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifter</class-id> <category>parsing</category><body package="SmallSuiteGenerator-Core">parseTree	^ self parseTreeWith: self statements</body><body package="SmallSuiteGenerator-Core">parseTreeWith: statementCollection	| node temporaries rbParserClass |	statementCollection		ifEmpty: [ self error: 'testCase does not have statements' ].	rbParserClass := SConfiguration rbParserClass.	node := rbParserClass parseExpression: '[]'.	temporaries := self allVarNames		collect: [ :varName | rbParserClass parseExpression: varName ].	node body temporaries: temporaries.	statementCollection		do: [ :stm | 			| aNode |			[ aNode := rbParserClass parseExpression: stm printString.			node body addNode: aNode ]				on: Error				do: [  ] ].	^ node</body><body package="SmallSuiteGenerator-Core">parseTreeWithAssertions	^ self parseTreeWith: self statements , self assertions</body></methods><methods><class-id>SmallSuiteGenerator.SCoverageTest</class-id> <category>running</category><body package="SmallSuiteGenerator-Tests-GA">fitnessClass	^ self subclassResponsibility</body><body package="SmallSuiteGenerator-Tests-GA">installOn: aPackageName	fitness tagetPackagesRegex: aPackageName.	(S2CInstrumentator onPackagesMatching: aPackageName)		applyOn: profiler.	fitness profiler: profiler.	profiler injectCodeToMethods</body><body package="SmallSuiteGenerator-Tests-GA">setUp	utility := SUtilityTypeInfo new.	fitness := self fitnessClass new.	profiler := SBProfiler new	"fitness tagetPackagesRegex: 'SmallSuiteGenerator-Scenario'"</body><body package="SmallSuiteGenerator-Tests-GA">tearDown	</body><body package="SmallSuiteGenerator-Tests-GA">uninstall	profiler cleanInstrumentation.	S2Profiler clean</body></methods><methods><class-id>SmallSuiteGenerator.SCoverageTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-GA">fitnessOf: aTestCase	^ aTestCase fitness at: fitness functionName</body><body package="SmallSuiteGenerator-Tests-GA">testCase: typeInfo withNumStatements: aNumber andTargetClassName: symbol	^ (SSTestCase with: typeInfo)		numMaxStatements: aNumber;		addTargetClassName: symbol;		generateStatements</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>actions</category><body package="SmallSuiteGenerator-Core">checkInvariants	self		assert: typeInfo isNil not		description: 'Please provide type information of the target project'.	self		assert: targetPackageRegex isNil not		description: 'Please provide a regex that match the packages under analysis'</body><body package="SmallSuiteGenerator-Core">cleanInstrumentation	self subclassResponsibility</body><body package="SmallSuiteGenerator-Core">createTestCases	self checkInvariants.	self setUp.	self run.	self tearDown</body><body package="SmallSuiteGenerator-Core">export: aTestCase with: aSelector	| aClassName class |	aClassName := ('GA' , self targetClassName , 'Test') asSymbol.	class := SConfiguration lookUpClass: aClassName.	class		ifNil: [ class := SConfiguration				createTestCaseClass: aClassName				inPackage: self outputPackageName ].	self moveClass: class.	[ aTestCase generateAssertions.	class		compile:			(SConfiguration rbParserClass				parseMethod:					aSelector , aTestCase printDescriptiveComment						, aTestCase parseTreeWithAssertions body formattedCode)				formattedCode ]		on: Error		do: [ | carReturn |			carReturn := String with: Character cr.			class				compile:					aSelector , carReturn , 'self should:'						, aTestCase parseTree formattedCode , carReturn						, ' raise:Error.' , carReturn ]</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>As yet unclassified</category><body package="SmallSuiteGenerator-Core">export: aTestCase with: aSelector	| aClassName class |	aClassName := ('GA' , self targetClassName , 'Test') asSymbol.	class := SConfiguration lookUpClass: aClassName.	class		ifNil: [ class := SConfiguration				createTestCaseClass: aClassName				inPackage: self outputPackageName ].	self moveClass: class.	[ aTestCase generateAssertions.	class		compile:			(SConfiguration rbParserClass				parseMethod:					aSelector , aTestCase printDescriptiveComment						, aTestCase parseTreeWithAssertions body formattedCode)				formattedCode ]		on: Error		do: [ | carReturn |			carReturn := String with: Character cr.			class				compile:					aSelector , carReturn , 'self should:'						, aTestCase parseTree formattedCode , carReturn						, ' raise:Error.' , carReturn ]</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>actions</category><body package="SmallSuiteGenerator-Core">exportTests	| index |	index := 1.	engine population		do: [ :test | 			self export: test with: 'test' , index printString.			index := index + 1 ]</body><body package="SmallSuiteGenerator-Core">initializeProfiler	self subclassResponsibility</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>as yet unclassified</category><body package="SmallSuiteGenerator-Core">moveClass: aClass	</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>actions</category><body package="SmallSuiteGenerator-Core">run	engine run</body><body package="SmallSuiteGenerator-Core">setUp	self initializeProfiler.	fitness profiler: profiler.	engine fitness: fitness.	engine numberOfIterations: numberOfIterations.	engine typeInfo: self typeInfo.	engine targetClassName: self targetClassName</body><body package="SmallSuiteGenerator-Core">tearDown	self cleanInstrumentation.	self exportTests</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Core">classesForRegex: regexExpressions	^ (regexExpressions		flatCollect: [ :regex | 			RPackage organizer packages				select: [ :p | regex match: p name printString ] ]) asSet		flatCollect: #definedClasses</body><body package="SmallSuiteGenerator-Core">engine	^ SGAEngine new		populationSize: 30;		numberOfStatements: 30;		numberOfIterations: 15;		yourself</body><body package="SmallSuiteGenerator-Core">engineDefault	^ SGAEngine new		populationSize: 30;		fitness: fitness;		numberOfStatements: 30;		numberOfIterations: 20;		yourself</body><body package="SmallSuiteGenerator-Core">outputPackageName	^ outputPackageName</body><body package="SmallSuiteGenerator-Core">outputPackageName: anObject	outputPackageName := anObject</body><body package="SmallSuiteGenerator-Core">targetClassName	^ targetClassName</body><body package="SmallSuiteGenerator-Core">targetClassName: aSymbol	targetClassName := aSymbol</body><body package="SmallSuiteGenerator-Core">targetPackageRegex	^ targetPackageRegex</body><body package="SmallSuiteGenerator-Core">targetPackageRegex: anObject	targetPackageRegex := anObject</body><body package="SmallSuiteGenerator-Core">typeInfo	^ typeInfo</body><body package="SmallSuiteGenerator-Core">typeInfo: aTypeInfo	typeInfo := aTypeInfo</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>configuration</category><body package="SmallSuiteGenerator-Core">fitness: aFitness	fitness := aFitness</body><body package="SmallSuiteGenerator-Core">numberOfStatements: aInt	engine numberOfStatements: aInt</body><body package="SmallSuiteGenerator-Core">populationSize: int	engine populationSize: int</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Core">seed: aNumber	SConfiguration seed: aNumber</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>visualization</category><body package="SmallSuiteGenerator-Core">fitnessValues	| nameFunctions |	self		assert: (engine isNil not and: [ engine logs isNotEmpty ])		description: 'Run the generation before'.	nameFunctions := Array with: engine fitness functionName.	^ nameFunctions asSet		collect: [ :nameFunction | 			nameFunction				-&gt;					(engine logs						withIndexCollect: [ :log :index | log fittestTestCase fitness at: nameFunction ]) ]</body><body package="SmallSuiteGenerator-Core">visualize	| p g d |	p := RTPalette c3.	g := RTGrapher new.	self fitnessValues		doWithIndex: [ :assocation :index | 			d := RTData new.			d connectColor: (p at: index).			d noDot.			d points: assocation value.			d label: assocation key printString.			d y: #yourself.			g add: d ].	g legend addText: 'Fitness evolution'.	g open</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Core">initialize	super initialize.	targetClassName := nil.	targetPackageRegex := nil.	fitness := SMethodCoverage new.	engine := self engineDefault.	numberOfIterations := 20.	outputPackageName := 'SmallSuiteGenerator-Tests-Generated'</body><body package="SmallSuiteGenerator-Core">numberOfIterations: aNumber	numberOfIterations := aNumber</body></methods><methods><class-id>SmallSuiteGenerator.SStatementCoverageTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-GA">fitnessClass	^ SStatementCoverage</body><body package="SmallSuiteGenerator-Tests-GA">testCoverageClassSEvent	| testCase valueFitness |	testCase := SSTestCase with: utility typeInfoSEvent2.	testCase		addTargetClassName: #SEvent;		addFactoryMessage: #SEvent;		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 75.0 ])	"75.0 = (6/8) * 100 round: 2"</body><body package="SmallSuiteGenerator-Tests-GA">testCoverageClassSFoo	| testCase valueFitness |	testCase := SSTestCase with: utility typeInfoSFoo4.	testCase		addTargetClassName: #SFoo;		addFactoryMessage: #SFoo;		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 71.43 ])	"71.43 = (10/14) * 100 round: 2"</body><body package="SmallSuiteGenerator-Tests-GA">testCoverageOnClassSSTeacher	| testCase valueFitness |	testCase := self		testCase: utility typeInfoSFoo4		withNumStatements: 20		andTargetClassName: #SFoo.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 75.0 ])	"75.0 = (6/8) * 100 round: 2"</body><body package="SmallSuiteGenerator-Tests-GA">testCoverageOnClassSStack	| testCase valueFitness |	testCase := self		testCase: utility typeInfoSStack3		withNumStatements: 20		andTargetClassName: #SStack.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 73.68 ])	"73.68 = (14/19) * 100 round: 2"</body><body package="SmallSuiteGenerator-Tests-GA">testCoverageOnClassSStudent	| testCase valueFitness |	testCase := self		testCase: utility typeInfosSStudent first		withNumStatements: 20		andTargetClassName: #SStudent.	self installOn: 'SmallSuiteGenerator-Scenario2'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 75.0 ])	"75.0 = (6/8) * 100 round: 2"</body><body package="SmallSuiteGenerator-Tests-GA">testCoverageOnPackagesSEvent	| testCase valueFitness |	testCase := SSTestCase with: utility typeInfoSEventOnPackage1.	" (STON fromString: utility typeInfoStringSEvent)."	testCase		addTargetClassName: #SEvent;		addFactoryMessage: #SEvent;		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 75.0 ])</body><body package="SmallSuiteGenerator-Tests-GA">testCoverageOnPackagesSFoo	| testCase valueFitness |	testCase := SSTestCase with: utility typeInfoSFooOnPackage2.	"(STON fromString: utility typeInfoStringSFoo2)."	testCase		addTargetClassName: #SFoo;		addFactoryMessage: #SFoo;		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 71.43 ])	"71.43 = (10/14) * 100 round: 2"</body><body package="SmallSuiteGenerator-Tests-GA">testCoverageOnPackagesSSTeacher	| testCase |	testCase := SSTestCase with: utility typeInfoSSTeacherOnPackage2.	"(STON fromString: utility typeInfoStringSSTeacher2)."	testCase		addTargetClassName: #SSTeacher;		addFactoryMessage: #SSTeacher;		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	self assert: (self fitnessOf: testCase) &lt;= 75.0</body><body package="SmallSuiteGenerator-Tests-GA">testCoverageOnPackagesSStack	| testCase valueFitness |	testCase := SSTestCase with: utility typeInfoSStackOnPackage1.	"(STON fromString: utility typeInfoStringSStack2)"	testCase		addTargetClassName: #SStack;		addFactoryMessage: #SStack;		generateStatements: 19.	testCase inspect.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 73.68 ])	"73.68 = (14/19) * 100 round: 2"</body><body package="SmallSuiteGenerator-Tests-GA">testCoverageOnPackagesSStudent	| testCase valueFitness |	testCase := SSTestCase with: utility typeInfoSStudentOnPackage1.	"(STON fromString: utility typeInfoStringSStudent1)."	testCase		addTargetClassName: #SStudent;		addFactoryMessage: #SStudent;		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario2'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 75.0 ])</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCase</class-id> <category>actions</category><body package="SmallSuiteGenerator-Core">computeFitness: fitnessClass	| valueFitness |	valueFitness := fitnessClass computeFitness: self.	[ fitness addAll: valueFitness ]		on: MessageNotUnderstood		do: [ fitness add: valueFitness ]</body><body package="SmallSuiteGenerator-Core">length	^ self numberStatements</body><body package="SmallSuiteGenerator-Core">run	" we delegate the responsibility to a test runner, in the future we would like to add new ways to run the tests "	^ SSTestRunner new run: self</body><body package="SmallSuiteGenerator-Core">runWithoutAssertions	" we delegate the responsibility to a test runner, in the future we would like to add new ways to run the tests "	^ SSTestRunner new runWithoutAssertions: self</body><body package="SmallSuiteGenerator-Core">setUp	</body><body package="SmallSuiteGenerator-Core">tearDown	</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCase</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Core">= other	^ self class = other class and: [ statements = other statements ]</body><body package="SmallSuiteGenerator-Core">hash	^ self statements hash</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCase</class-id> <category>copying</category><body package="SmallSuiteGenerator-Core">copy	| copy |	copy := SSTestCase with: typeInfo copy.	copy addTargetClassNames: targetClassesNames.	statements do: [ :stm | copy addStatement: stm copy ].	copy updateNextId.	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCase</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Core">initialize	super initialize</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCase class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Core">with: aTypeInfo	| testCase |	testCase := self new.	testCase typeInfo: aTypeInfo.	^ testCase</body></methods><methods><class-id>SmallSuiteGenerator.SMethodCoverageTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-GA">testCoverageClassSEvent	| testCase valueFitness |	testCase := self		testCase: utility typeInfoSEvent2		withNumStatements: 20		andTargetClassName: #SEvent.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 83.33 ])	"83.33 = (5/6) * 100 round: 2"</body><body package="SmallSuiteGenerator-Tests-GA">testCoverageClassSFoo	| testCase valueFitness |	testCase := self		testCase: utility typeInfoSFoo4		withNumStatements: 20		andTargetClassName: #SFoo.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 77.78 ])	"77.78 = (7/9) * 100 round: 2"</body><body package="SmallSuiteGenerator-Tests-GA">testCoverageOnClassSSTeacher	| testCase valueFitness |	testCase := self		testCase: utility typeInfoSSTeacher3		withNumStatements: 20		andTargetClassName: #SSTeacher.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 60.0 ])	"60.0 = (3/5) * 100 round: 2"</body><body package="SmallSuiteGenerator-Tests-GA">testCoverageOnClassSStack	| testCase valueFitness |	testCase := self		testCase: utility typeInfoSStack3		withNumStatements: 20		andTargetClassName: #SStack.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 57.14 ])	"57.14 = (4/7) * 100 round: 2"</body><body package="SmallSuiteGenerator-Tests-GA">testCoverageOnClassSStudent	| testCase valueFitness |	testCase := self		testCase: utility typeInfosSStudent first		withNumStatements: 20		andTargetClassName: #SStudent.	self installOn: 'SmallSuiteGenerator-Scenario2'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 80.0 ])	"80.0 = (4/5) * 100 round: 2"</body><body package="SmallSuiteGenerator-Tests-GA">testCoverageOnPackagesSEvent	| testCase valueFitness |	testCase := self		testCase: utility typeInfoSEventOnPackage1		withNumStatements: 20		andTargetClassName: #SEvent.	" (STON fromString: utility typeInfoStringSEvent)"	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 83.33 ])</body><body package="SmallSuiteGenerator-Tests-GA">testCoverageOnPackagesSFoo	| testCase valueFitness |	testCase := SSTestCase with: utility typeInfoSFooOnPackage2.	"(STON fromString: utility typeInfoStringSFoo2)"	testCase		addTargetClassName: #SFoo;		addFactoryMessage: #SFoo;		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 77.78 ])	"77.78 = (7/9) * 100 round: 2"</body><body package="SmallSuiteGenerator-Tests-GA">testCoverageOnPackagesSSTeacher	| testCase valueFitness |	testCase := SSTestCase with: utility typeInfoSSTeacherOnPackage2.	"(STON fromString: utility typeInfoStringSSTeacher2)."	testCase		addTargetClassName: #SSTeacher;		addFactoryMessage: #SSTeacher;		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 77.78 ])	"77.78 = (7/9) * 100 round: 2"</body><body package="SmallSuiteGenerator-Tests-GA">testCoverageOnPackagesSStack	| testCase valueFitness |	testCase := SSTestCase with: utility typeInfoSStackOnPackage1.	"(STON fromString: utility typeInfoStringSStack2)."	testCase		addTargetClassName: #SStack;		addFactoryMessage: #SStack;		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 57.14 ])	"57.14 = (4/7) * 100 round: 2"</body><body package="SmallSuiteGenerator-Tests-GA">testCoverageOnPackagesSStudent	| testCase valueFitness |	testCase := SSTestCase with: utility typeInfoSStudentOnPackage1.	"(STON fromString: utility typeInfoStringSStudent1)."	testCase		addTargetClassName: #SStudent;		addFactoryMessage: #SStudent;		generateStatements: 19.	self installOn: 'SmallSuiteGenerator-Scenario2'.	fitness compute: (Array with: testCase).	self uninstall.	valueFitness := self fitnessOf: testCase.	self assert: (valueFitness &gt; 0 and: [ valueFitness &lt;= 80.0 ])</body></methods><methods><class-id>SmallSuiteGenerator.SMethodCoverageTest</class-id> <category>running</category><body package="SmallSuiteGenerator-Tests-GA">fitnessClass	^ SMethodCoverage</body></methods><methods><class-id>SmallSuiteGenerator.SExpressionTest</class-id> <category>running</category><body package="SmallSuiteGenerator-Tests-AST">setUp	super setUp.	utility := SUtilityTypeInfo new</body></methods><methods><class-id>SmallSuiteGenerator.SExpressionTest</class-id> <category>parsing</category><body package="SmallSuiteGenerator-Tests-AST">parse: anExpresion	| sequence |	sequence := SConfiguration rbParserClass parseExpression: anExpresion.	^ sequence statements		collect: [ :assig | 			SAssignment new				variable: (SVariable name: assig variable name asString);				value: (self parseMessage: assig value);				yourself ]</body><body package="SmallSuiteGenerator-Tests-AST">parseMessage: aRBMessageNode	aRBMessageNode isLiteralNode		ifTrue: [ ^ SLiteral value: aRBMessageNode value ].	^ SMessage new		receiver: (SVariable name: aRBMessageNode receiver name);		selector: aRBMessageNode selector;		args:			(aRBMessageNode arguments				collect: [ :arg | self parseVariableOrValue: arg ]) yourself</body><body package="SmallSuiteGenerator-Tests-AST">parseVariableOrValue: aRBVariableOrLiteral	^ aRBVariableOrLiteral isVariable		ifTrue: [ SVariable name: aRBVariableOrLiteral name ]		ifFalse: [ SLiteral value: aRBVariableOrLiteral value ]</body></methods><methods><class-id>SmallSuiteGenerator.SAssertionTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-AST">testAssertComparison	| test |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var0 := 1.			 _var1 := 1.			 _var2 := Point x: _var0 y: _var1.			 _var3 := Point x: _var1 y: _var0.').	test generateAssertions: (Array with: SComparisonAssertion).	self assert: test assertions size equals: 2.	self		assert: test assertions first printString		equals: 'self assert: _var0 equals: _var1.'.	self		assert: test assertions second printString		equals: 'self assert: _var2 equals: _var3.'</body><body package="SmallSuiteGenerator-Tests-AST">testAssertComparison2	| test |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var0 := 1.			 _var1 := 2.			 _var2 := Point x: _var0 y: _var1.			 _var3 := Point x: _var1 y: _var0.').	test generateAssertions: (Array with: SComparisonAssertion).	self assert: test assertions size equals: 2.	self		assert: test assertions first printString		equals: 'self deny: _var0 equals: _var1.'.	self		assert: test assertions second printString		equals: 'self deny: _var2 equals: _var3.'</body><body package="SmallSuiteGenerator-Tests-AST">testAssertInspector	| test |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var0 := 1.			 _var1 := 2.			 _var3 := Point x: _var1 y: _var0.').	test generateAssertions: (Array with: SInspectorAssertion).	self assert: test assertions size equals: 2.	self		assertCollection: (test assertions collect: #printString)		hasSameElements: #('self assert: _var3 x equals: 2.' 'self assert: _var3 y equals: 1.')</body><body package="SmallSuiteGenerator-Tests-AST">testAssertPrimitive	| test |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var0 := 1.			 _var1 := 2.			 _var3 := Point x: _var1 y: _var0.').	test generateAssertions: (Array with: SPrimitiveAssertion).	self assert: test assertions size equals: 2.	self		assert: test assertions first printString		equals: 'self assert: _var0 equals: 1.'.	self		assert: test assertions second printString		equals: 'self assert: _var1 equals: 2.'</body><body package="SmallSuiteGenerator-Tests-AST">testAssertString	| test |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var0 := 1.			 _var1 := 2.			 _var3 := Point x: _var1 y: _var0.').	test generateAssertions: (Array with: SStringAssertion).	self assert: test assertions size equals: 1.	self		assert: test assertions first printString		equals: 'self assert: _var3 printString equals: ''(2@1)''.'</body><body package="SmallSuiteGenerator-Tests-AST">testExecutionContext	| test context |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var0 := 1.			 _var1 := 2.			 _var2 := Point x: _var0 y: _var1.').	context := test analyze.	self assert: (context at: '_var0') equals: 1.	self assert: (context at: '_var1') equals: 2.	self assert: (context at: '_var2') equals: 1 @ 2</body></methods><methods><class-id>SmallSuiteGenerator.SFieldAccessMessageTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-AST">testCopy	| expression copy |	expression := SFieldAccessMessage new		receiver:			(SVariable new				id: 0;				returnType: #SStack);		selector: #firstLinkStack.	self assert: expression printString equals: '_var0 firstLinkStack'.	copy := expression copy.	copy value receiver varName: '_sstack'.	copy value receiver id: 4.	self assert: copy printString equals: '_sstack4 firstLinkStack'.	copy value selector: #lastLinkStack.	self assert: copy printString equals: '_sstack4 lastLinkStack'.	self assert: expression printString equals: '_var0 firstLinkStack'</body><body package="SmallSuiteGenerator-Tests-AST">testInsertAsParameterUsing	| testCase expression insertedExpression |	testCase := SSTestCase with: utility typeInfoSStack4.	testCase addFactoryMessage: #SStack ofSelector: #newStackWith:.	expression := testCase		addFieldAccessMessage: #firstLinkStack		from: #SStack.	testCase addLiteral: #SmallInteger.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := #(1 4 5 ).' '_var1 := SStack newStackWith: _var0.' '_var2 := _var1 firstLinkStack.' '_var3 := 5.').	testCase addMessage: #push: from: #SStack.	insertedExpression := expression		insertAsParameter: expression		using: testCase.	self		assert: insertedExpression printString		equals: '_var4 := _var1 push: _var2.'</body><body package="SmallSuiteGenerator-Tests-AST">testInsertRandomMessageUsing	| testCase aExpression |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: #SFoo;		addFactoryMessage: #SFoo.	aExpression := testCase addFieldAccessMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := 7.3.' '_var1 := SFoo score: _var0.' '_var2 := _var1 score.').	aExpression insertRandomMessage: aExpression using: testCase.	self		assertCollection: (testCase statements collect: #printString)		includesAll:			#('_var0 := 7.3.' '_var1 := SFoo score: _var0.' '_var2 := _var1 score.' '_var3 := _var1 score.')</body></methods><methods><class-id>SmallSuiteGenerator.SConfiguration class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Core">fileLogger: fileName	self configurationClass fileLogger: fileName</body><body package="SmallSuiteGenerator-Core">newRandomGenerator	^ SRandom seed: self seed</body><body package="SmallSuiteGenerator-Core">seed: aNumber	seed := aNumber</body></methods><methods><class-id>SmallSuiteGenerator.SConfiguration class</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Core">classConfigurationName	^ self subclassResponsibility</body><body package="SmallSuiteGenerator-Core">classTestCaseFactory	^ self configurationClass classTestCaseFactory</body><body package="SmallSuiteGenerator-Core">configurationClass	configurationClass		ifNil: [ configurationClass := self subclasses				detect: [ :aClass | 					[ Smalltalk at: aClass classConfigurationName.					true ]						on: Error						do: [ false ] ]				ifNone: [ nil ].			configurationClass				ifNil: [ self error: 'Error to look a configurationClass' ] ].	^ configurationClass</body><body package="SmallSuiteGenerator-Core">defaultLogName	^ 'SmallSuiteLogger.log'</body><body package="SmallSuiteGenerator-Core">defaultSeed	^ 100</body><body package="SmallSuiteGenerator-Core">implementationType	^ self subclassResponsibility</body><body package="SmallSuiteGenerator-Core">initLevelToPrint	level := 10</body><body package="SmallSuiteGenerator-Core">levelToPrint	^ level</body><body package="SmallSuiteGenerator-Core">logName	^ logName ifNil: [ self defaultLogName ]</body><body package="SmallSuiteGenerator-Core">logName: string	logName := string</body><body package="SmallSuiteGenerator-Core">randomGenerator	randomGenerator ifNil: [ randomGenerator := SRandom seed: self seed ].	^ randomGenerator</body><body package="SmallSuiteGenerator-Core">randomGenerator: sRandom	randomGenerator := sRandom</body><body package="SmallSuiteGenerator-Core">seed	seed ifNil: [ seed := self defaultSeed ].	^ seed</body></methods><methods><class-id>SmallSuiteGenerator.SConfiguration class</class-id> <category>logging</category><body package="SmallSuiteGenerator-Core">cleanAllLogs	self configurationClass cleanAllLogs</body><body package="SmallSuiteGenerator-Core">clearLog	self configurationClass clearLog</body><body package="SmallSuiteGenerator-Core">saveOnLog: message	self configurationClass saveOnLog: message</body></methods><methods><class-id>SmallSuiteGenerator.SConfiguration class</class-id> <category>tests</category><body package="SmallSuiteGenerator-Core">createTestCaseClass: aClassName inPackage: aPackageName	^ self configurationClass		createTestCaseClass: aClassName		inPackage: aPackageName</body><body package="SmallSuiteGenerator-Core">testCaseClass	^ self configurationClass testCaseClass</body></methods><methods><class-id>SmallSuiteGenerator.SConfiguration class</class-id> <category>as yet unclassified</category><body package="SmallSuiteGenerator-Core">lookUpClass: aClassName	^ Smalltalk at: aClassName ifAbsent: [ nil ]</body><body package="SmallSuiteGenerator-Core">rbParserClass	^ self configurationClass rbParserClass</body></methods><methods><class-id>SmallSuiteGenerator.SConfiguration class</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Core">resetConfigurationClass	configurationClass := nil</body></methods><methods><class-id>SmallSuiteGenerator.SConfiguration class</class-id> <category>actions</category><body package="SmallSuiteGenerator-Core">reduceLevel	level ifNil: [ self initLevelToPrint ].	level := level - 1</body></methods><methods><class-id>SmallSuiteGenerator.SMessageTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-AST">testCopy	| message copy |	message := SMessage new		receiver:			(SVariable new				id: 1;				returnType: #SFoo);		selector: #return:;		args:			(Array				with:					(SVariable new						id: 2;						returnType: #ByteString));		returnType: #ByteString.	self assert: message printString equals: '_var1 return: _var2'.	copy := message copy.	copy value args first id: 5.	self assert: copy printString equals: '_var1 return: _var5'.	copy value receiver varName: '_sfoo'.	copy value receiver id: 4.	self assert: copy printString equals: '_sfoo4 return: _var5'.	copy value selector: #returnValue:.	self assert: copy printString equals: '_sfoo4 returnValue: _var5'.	self assert: message printString equals: '_var1 return: _var2'</body><body package="SmallSuiteGenerator-Tests-AST">testInsertAsParameterUsing	| testCase aExpression insertedExpression |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: #SFoo;		addFactoryMessage: #SFoo;		addLiteral: #ByteString.	aExpression := testCase addMessage: #returnString from: #SFoo.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := 7.3.' '_var1 := SFoo score: _var0.' '_var2 := ''hello''.' '_var3 := _var1 returnString.').	testCase addMessage: #return: from: #SFoo.	insertedExpression := aExpression		insertAsParameter: aExpression		using: testCase.	self		assert:			(#('_var4 := _var1 return: _var3.')				includes: insertedExpression printString)</body><body package="SmallSuiteGenerator-Tests-AST">testInsertMethodMessageUsing	| testCase message |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: #SFoo.	message := testCase addMessage: #return: from: #SFoo.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := 7.3.' '_var1 := SFoo score: _var0.' '_var2 := ''hello''.' '_var3 := _var1 return: _var2.').	message insertMethodMessage: message using: testCase.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := 7.3.' '_var1 := SFoo score: _var0.' '_var2 := ''hello''.' '_var3 := _var1 return: _var2.' '_var4 := _var1 return: _var2.')</body></methods><methods><class-id>SmallSuiteGenerator.SFactoryMessageTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-AST">testCopy	| expression copy |	expression := SFactoryMessage new		receiver: (SVariable name: #SFoo);		selector: #score:;		args: (Array with: (SVariable new id: 0));		yourself.	self assert: expression printString equals: 'SFoo score: _var0'.	copy := expression copy.	self assert: copy printString equals: expression printString.	copy value args first id: 1.	self assert: copy printString equals: 'SFoo score: _var1'.	copy value receiver varName: #SStudent.	self assert: copy printString equals: 'SStudent score: _var1'.	copy value selector: #name:.	self assert: copy printString equals: 'SStudent name: _var1'.	self assert: expression printString equals: 'SFoo score: _var0'</body><body package="SmallSuiteGenerator-Tests-AST">testInsertAsParameterUsing	| testCase expression insertedExpression |	testCase := SSTestCase with: utility typeInfoSFoo2.	testCase addTargetClassName: #SFoo.	expression := testCase addFactoryMessage: #SFoo.	testCase addMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := SFoo new.' '_var1 := _var0 return: _var0.').	insertedExpression := expression		insertAsParameter: expression		using: testCase.	self		assert:			(#('_var1 := _var0 return: _var0.')				includes: insertedExpression printString)</body><body package="SmallSuiteGenerator-Tests-AST">testInsertMethodMessageUsing	| testCase expression |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: #SFoo.	expression := testCase addFactoryMessage: #SFoo.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 7.3.' '_var1 := SFoo score: _var0.').	self		should: [ expression insertMethodMessage: expression using: testCase ]		raise: SError</body><body package="SmallSuiteGenerator-Tests-AST">testInsertRandomMessageUsing	| testCase factoryMessage |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: #SFoo.	factoryMessage := testCase addFactoryMessage: #SFoo.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 7.3.' '_var1 := SFoo score: _var0.').	factoryMessage insertRandomMessage: factoryMessage using: testCase.	self		assertCollection: (testCase statements collect: #printString)		includesAll:			#('_var0 := 7.3.' '_var2 := SFoo score: _var0.' '_var1 := SFoo score: _var0.')</body></methods><methods><class-id>SmallSuiteGenerator.SConfigurationPharo class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Core">fileLogger: fileName	self logName: fileName.	^ self classLogger		ifNotNil: [ self instanceLogger fileLoggers ifEmpty: [ self createFileLogger ].			self instanceLogger fileLoggers				detect: [ :fileLogger | fileLogger fileName = fileName ]				ifNone: [ self createFileLogger.					self fileLogger: fileName ] ]		ifNil: [ nil ]</body></methods><methods><class-id>SmallSuiteGenerator.SConfigurationPharo class</class-id> <category>logging</category><body package="SmallSuiteGenerator-Core">cleanAllLogs	self instanceLogger removeAllLoggers</body><body package="SmallSuiteGenerator-Core">clearLog	self instanceLogger clearLog</body><body package="SmallSuiteGenerator-Core">saveOnLog: string	self defaultFileLogger record: string</body></methods><methods><class-id>SmallSuiteGenerator.SConfigurationPharo class</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Core">classConfigurationName	^ superclass name , self implementationType</body><body package="SmallSuiteGenerator-Core">classLogger	^ TinyLogger</body><body package="SmallSuiteGenerator-Core">classTestCaseFactory	^ STestCaseFactoryPharo</body><body package="SmallSuiteGenerator-Core">implementationType	^ SystemVersion current type</body><body package="SmallSuiteGenerator-Core">instanceLogger	^ self classLogger default</body></methods><methods><class-id>SmallSuiteGenerator.SConfigurationPharo class</class-id> <category>actions</category><body package="SmallSuiteGenerator-Core">clearFileLog: string	self instanceLogger fileLoggers		detect: [ :fileLogger | fileLogger fileName = string ]		ifFound: [ :fileLogger | fileLogger clearLog ]</body><body package="SmallSuiteGenerator-Core">createFileLogger	self instanceLogger ensureFileLoggerNamed: self logName</body><body package="SmallSuiteGenerator-Core">defaultFileLogger	self classLogger		ifNotNil: [ self instanceLogger fileLoggers ifEmpty: [ self createFileLogger ].			^ self instanceLogger fileLoggers				detect: [ :fileLogger | fileLogger fileName = self logName ] ]</body></methods><methods><class-id>SmallSuiteGenerator.SConfigurationPharo class</class-id> <category>tests</category><body package="SmallSuiteGenerator-Core">createTestCaseClass: aClassName inPackage: aPackageName	^ self testCaseClass		subclass: aClassName		instanceVariableNames: ''		classVariableNames: ''		package: aPackageName</body><body package="SmallSuiteGenerator-Core">testCaseClass	^ TestCase</body></methods><methods><class-id>SmallSuiteGenerator.SConfigurationPharo class</class-id> <category>as yet unclassified</category><body package="SmallSuiteGenerator-Core">rbParserClass	^ RBParser</body></methods><methods><class-id>SmallSuiteGenerator.SLiteralTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-AST">testCopy	| literal copy |	literal := (SLiteral value: 'hello') returnType: #ByteString.	self assert: literal printString equals: '''hello'''.	copy := literal copy.	copy value: 'world'.	self assert: copy printString equals: '''world'''</body><body package="SmallSuiteGenerator-Tests-AST">testEqual	| literal |	literal := SLiteral value: 1.	self assert: (SLiteral value: 1) equals: literal.	literal value: 3.	self deny: (SLiteral value: -3) equals: literal.	literal value: #().	self assert: (SLiteral value: #()) equals: literal.	literal value: SStudent new.	self assert: (SLiteral value: SStudent new) equals: literal</body><body package="SmallSuiteGenerator-Tests-AST">testInsertAsParameterUsing	| testCase expression insertedExpression |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: #SFoo;		addLiteral: #ByteString.	expression := testCase addLiteral: #ByteString.	testCase addFactoryMessage: #SFoo.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := ''hello''.' '_var1 := ''hello''.' '_var2 := 7.3.' '_var3 := SFoo score: _var2.').	testCase addMessage: #return: from: #SFoo.	insertedExpression := expression		insertAsParameter: expression		using: testCase.	self		assert: insertedExpression printString		equals: '_var4 := _var3 return: _var1.'</body><body package="SmallSuiteGenerator-Tests-AST">testInsertParameterOn	| testCase expression insertedExpression |	testCase := SSTestCase with: utility typeInfoSFoo4.	testCase		addTargetClassName: #SFoo;		addLiteral: #SStudent;		addMessage: #return: from: #SFoo.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := ' , SStudent new storeString , '.'				with: '_var1 := SFoo new.'				with: '_var2 := _var1 return: _var0.').	expression := testCase addLiteral: #SStudent.	self		should: [ insertedExpression := expression				insertAsParameter: expression				using: testCase ]		raise: SError.	testCase addMessage: #return: from: #SFoo.	self		shouldnt: [ insertedExpression := expression				insertAsParameter: expression				using: testCase ]		raise: SError.	self		assert: insertedExpression printString		equals: '_var4 := _var1 return: _var3.'</body><body package="SmallSuiteGenerator-Tests-AST">testReferenceTo	| literal |	literal := SLiteral value: 1.	self assert: ((SLiteral new value: 1) referenceTo: #SmallInteger).	literal value: SStudent new.	self		assert: ((SLiteral new value: SStudent new) referenceTo: #SStudent)</body></methods><methods><class-id>SmallSuiteGenerator.SConfigurationVisualWorks class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Core">fileLogger: fileName	</body></methods><methods><class-id>SmallSuiteGenerator.SConfigurationVisualWorks class</class-id> <category>logging</category><body package="SmallSuiteGenerator-Core">cleanAllLogs	</body><body package="SmallSuiteGenerator-Core">clearLog	</body><body package="SmallSuiteGenerator-Core">saveOnLog: string	</body></methods><methods><class-id>SmallSuiteGenerator.SConfigurationVisualWorks class</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Core">classTestCaseFactory	^ STestCaseFactoryVisualWorks</body></methods><methods><class-id>SmallSuiteGenerator.SUtilityTypeInfo</class-id> <category>examples</category><body package="SmallSuiteGenerator-Tests-Utility">typeInfoArrayedCollection	^ STypeInfo new		type:			#ArrayedCollection				-&gt;					(Array						with:							(Array								with: #add -&gt; #(#AthensCairoCanvas #nil #() false)								with: #size -&gt; #(#AthensCairoCanvas #nil #() false))						with: #());		scalar: #ByteString with: #('hello')</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoOnPackage1	"the first typeInfo is about a class has as argument other class from other package"	^ STypeInfo new		type:			#SEvent				-&gt;					(Array						with:							(Array								with: #canRegister: -&gt; #(#SConference #False #(#SStudent) false)								with: #price -&gt; #(#SConference #SmallInteger #() false))						with: #());		type:			#SConference				-&gt;					(Array						with:							(Array								with: #initialize -&gt; #(#SConference #SConference #() false)								with: #offerPrice -&gt; #(#SConference #SmallInteger #() true)								with: #offerPrice: -&gt; #(#SConference #SConference #(#SmallInteger) false)								with: #discount -&gt; #(#SConference #SmallInteger #() true))						with: #());		scalar: #SmallInteger with: #(95 100);		scalar: #False with: #(false);		scalar: #SStudent with: (Array with: (SStudent new name: 'Mary'))</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoOnPackage2	"the first typeInfo is about a class has as argument other class from other package"	^ STypeInfo new		type:			#SEvent				-&gt;					(Array						with:							(Array								with: #price: -&gt; #(#SConference #SConference #(#SmallInteger) false))						with:							(Array								with: #price: -&gt; #(#SConference #SConference #(#SmallInteger) false)));		type:			#SConference				-&gt;					(Array						with: (Array with: #initialize -&gt; #(#SConference #SConference #() false))						with: #());		scalar: #SmallInteger with: #(95)</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoOnPackage3	"the first typeInfo is about a class has as argument other class from other package"	"review and modify"	^ STypeInfo new		type:			#SSTeacher				-&gt;					(Array						with:							(OrderedCollection new								add: #name: -&gt; #(#SSTeacher #SSTeacher #(#ByteString) false);								add: #id: -&gt; #(#SSTeacher #SSTeacher #(#SmallInteger) false);								add: #nickname: -&gt; #(#SSTeacher #SSTeacher #(#ByteString) false);								add: #initialize -&gt; #(#SSTeacher #SSTeacher #() false);								add: #nickname -&gt; #(#SSTeacher #ByteString #() false);								add: #name -&gt; #(#SSTeacher #ByteString #() true);								add: #id -&gt; #(#SSTeacher #SmallInteger #() true);								add: #yearsWorkExperience -&gt; #(#SSTeacher #SmallInteger #() true);								add: #idTeacher -&gt; #(#SSTeacher #SmallInteger #() true);								yourself)						with:							(Array								with:									#name:with:										-&gt; #(#SSTeacher #SSTeacher #(#ByteString #SmallInteger) false)));		type:			#SConference				-&gt;					(Array						with:							(Array								with: #initialize -&gt; #(#SConference #SConference #() false)								with: #offerPrice -&gt; #(#SConference #SmallInteger #() true)								with: #offerPrice: -&gt; #(#SConference #SConference #(#SmallInteger) false)								with: #discount -&gt; #(#SConference #SmallInteger #() true))						with: #());		scalar: #SmallInteger with: #(95);		scalar: #False with: #(false);		scalar: #SStudent with: (Array with: (SStudent new name: 'Mary'));		scalar: #ByteString with: #('Mary')</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoOnPackage4	"the first typeInfo is about a class has as argument other class from other package"	"review and modify"	^ STypeInfo new		type:			#SEvent				-&gt;					(Array						with:							(Array								with: #price: -&gt; #(#SConference #SConference #(#SmallInteger) false))						with:							(Array								with: #price: -&gt; #(#SConference #SConference #(#SmallInteger) false)));		type:			#SConference				-&gt;					(Array						with: (Array with: #initialize -&gt; #(#SConference #SConference #() false))						with: #());		type: #SParty -&gt; #(#() #());		scalar: #SmallInteger with: #(95)</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoSAbstractClass	^ STypeInfo new		type:			#SAbstractClass				-&gt;					(Array						with: (Array with: #id -&gt; #(#SAbstractClass #SmallInteger #() false))						with: #());		scalar: #SmallInteger with: #(1)</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoSEvent1	^ STypeInfo new		type:			#SEvent				-&gt;					(Array						with:							(Array								with: #initialize -&gt; #(#SEvent #SEvent #() false)								with: #discount -&gt; #(#SEvent #SmallInteger #() true)								with: #discount: -&gt; #(#SEvent #SEvent #(#SmallInteger) false)								with: #price -&gt; #(#SEvent #SmallInteger #() true)								with: #price: -&gt; #(#SEvent #SEvent #(#SmallInteger) false))						with: (Array with: #price: -&gt; #(#SEvent #SEvent #(#SmallInteger) false)));		scalar: #SmallInteger with: #(8)</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoSEvent2	^ STypeInfo new		type:			#SEvent				-&gt;					(Array						with:							(Array								with: #initialize -&gt; #(#SEvent #SEvent #() false)								with: #discount -&gt; #(#SEvent #SmallInteger #() true)								with: #price -&gt; #(#SEvent #SmallInteger #() true))						with: (Array with: #price: -&gt; #(#SEvent #SEvent #(#SmallInteger) false)));		scalar: #SmallInteger with: #(0 15)</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoSEventOnPackage1	^ STypeInfo new		type:			#SEvent				-&gt;					(Array						with:							(Array								with: #price -&gt; #(#SEvent #SmallInteger #() false)								with: #discount -&gt; #(#SEvent #SmallInteger #() true)								with: #initialize -&gt; #(#SEvent #SEvent #() false)								with: #price: -&gt; #(#SEvent #SEvent #(#SmallInteger) false))						with: (Array with: #price: -&gt; #(#SEvent #SEvent #(#SmallInteger) false)));		type: #SSTeacher -&gt; #(#() #());		type: #SSPerson -&gt; #(#() #());		type: #SStack -&gt; #(#() #());		type: #SConference -&gt; #(#() #());		type: #SFoo -&gt; #(#() #());		type: #SParty -&gt; #(#() #());		type: #SEventTest -&gt; #(#() #());		scalar: #SmallInteger with: #(15 0)</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoSFoo1	^ STypeInfo new		type:			#SFoo				-&gt;					(Array						with:							(Array								with: #returnNum -&gt; #(#SFoo #SmallInteger #() false)								with: #returnFloat -&gt; #(#SFoo #SmallFloat64 #() false)								with: #returnString -&gt; #(#SFoo #ByteString #() false)								with: #score -&gt; #(#SFoo #SmallFloat64 #() true)								with: #return: -&gt; #(#SFoo #ByteString #(#ByteString) false))						with: (Array with: #score: -&gt; #(#SFoo #SFoo #(#SmallFloat64) false)));		scalar: #ByteString with: #('hello');		scalar: #SmallInteger with: #(5);		scalar: #SmallFloat64 with: #(7.3)</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoSFoo2	^ STypeInfo new		type:			#SFoo				-&gt;					(Array						with: (Array with: #return: -&gt; #(#SFoo #SFoo #(#SFoo) false))						with: #())</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoSFoo3	^ STypeInfo new		type:			#SFoo				-&gt;					(Array						with:							(Array								with: #returnNum -&gt; #(#SFoo #SmallInteger #() false)								with: #returnFloat -&gt; #(#SFoo #SmallFloat64 #() false)								with: #returnString -&gt; #(#SFoo #ByteString #() false)								with: #score -&gt; #(#SFoo #SmallInteger #() true)								with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false))						with: (Array with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false)));		scalar: #ByteString with: #('Hello');		scalar: #SmallInteger with: #(4);		scalar: #SmallFloat64 with: #(2.3)</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoSFoo4	^ STypeInfo new		type:			#SFoo				-&gt;					(Array						with:							(Array								with: #initialize -&gt; #(#SFoo #SFoo #() false)								with: #return: -&gt; #(#SFoo #SStudent #(#SStudent) false))						with: #());		scalar: #SStudent with: (Array with: SStudent new)</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoSFoo5	^ STypeInfo new		type:			#SFoo				-&gt;					(Array						with:							(Array								with: #return: -&gt; #(#SFoo #OrderedCollection #(#OrderedCollection) false))						with: #());		scalar: #OrderedCollection			with:			(Array				with:					(OrderedCollection new						addAll: #(1 4 5);						yourself))</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoSFooEmpty	^ STypeInfo new type: #SFoo -&gt; (Array with: #() with: #())</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoSFooOnPackage1	^ STypeInfo new		type:			#SFoo				-&gt;					(Array						with:							(Array								with: #returnCollection -&gt; #(#SFoo #OrderedCollection #() false)								with: #returnString -&gt; #(#SFoo #ByteString #() false)								with: #score -&gt; #(#SFoo #SmallInteger #() true)								with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false)								with: #return: -&gt; #(#SFoo #SStudent #(#SStudent) false))						with: (Array with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false)));		type:			#SSPerson				-&gt;					(Array						with:							(Array								with: #id: -&gt; #(#SStudent #SStudent #(#SmallInteger) false)								with: #nickname: -&gt; #(#SStudent #SStudent #(#ByteString) false)								with: #name: -&gt; #(#SStudent #SStudent #(#ByteString) false))						with: (Array with: #name: -&gt; #(#SStudent #SStudent #(#ByteString) false)));		type: #SStack -&gt; #(#() #());		type: #SConference -&gt; #(#() #());		type: #SEvent -&gt; #(#() #());		type: #SSTeacher -&gt; #(#() #());		type: #SParty -&gt; #(#() #());		type: #SEventTest -&gt; #(#() #());		scalar: #SmallInteger with: #(5 1 4);		scalar: #ByteString with: #('Emily' 'Hello');		scalar: #OrderedCollection			with: (Array with: OrderedCollection new);		scalar: #SStudent			with:			(Array				with:					((SStudent name: 'Emily')						nickname;						scoreStudent;						yourself))</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoSFooOnPackage2	^ STypeInfo new		type:			#SFoo				-&gt;					(Array						with:							(Array								with: #returnFloat -&gt; #(#SFoo #SmallFloat64 #() false)								with: #returnCollection -&gt; #(#SFoo #OrderedCollection #() false)								with: #initialize -&gt; #(#SFoo #SFoo #() false)								with: #score -&gt; #(#SFoo #SmallInteger #() true)								with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false)								with: #return: -&gt; #(#SFoo #SStudent #(#SStudent) false))						with: (Array with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false)));		type: #SSPerson -&gt; #(#() #());		type: #SStack -&gt; #(#() #());		type: #SConference -&gt; #(#() #());		type: #SEvent -&gt; #(#() #());		type: #SSTeacher -&gt; #(#() #());		type: #SParty -&gt; #(#() #());		type: #SEventTest -&gt; #(#() #());		scalar: #SmallInteger with: #(15);		scalar: #SmallFloat64 with: #(2.3);		scalar: #OrderedCollection			with: (Array with: OrderedCollection new);		scalar: #Array with: #(#(1 5 6))</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoSFooOnPackage3	^ STypeInfo new		type:			#SSPerson				-&gt;					(Array						with:							(Array								with: #id: -&gt; #(#SStudent #SStudent #(#SmallInteger) false)								with: #nickname: -&gt; #(#SStudent #SStudent #(#ByteString) false)								with: #name: -&gt; #(#SStudent #SStudent #(#ByteString) false))						with:							(Array								with:									#name:with:										-&gt; #(#SStudent #SStudent #(#ByteString #SMallInteger) false)));		type:			#SFoo				-&gt;					(Array						with:							(Array								with: #initialize -&gt; #(#SFoo #SFoo #() false)								with: #return: -&gt; #(#SFoo #Dictionary #(#Dictionary) false))						with: #());		type:			#SStack				-&gt;					(Array						with: (Array with: #push: -&gt; #(#SStack #SStudent #(#SStudent) false))						with: #());		type: #SConference -&gt; #(#() #());		type: #SEvent -&gt; #(#() #());		type: #SParty -&gt; #(#() #());		type: #SSTeacher -&gt; #(#() #());		type: #SEventTest -&gt; #(#() #());		scalar: #SStudent			with:			(Array				with: (SStudent name: 'Mery' with: 5)				with: (SStudent name: 'Josh' with: 2)				with: (SStudent name: 'Lian'));		scalar: #Dictionary			with:			(Array				with:					(Dictionary new						at: 1							put:							(SStack new								push: (SStudent name: 'Josh' with: 2);								push: (SStudent name: 'Lian');								yourself);						at: 2							put:							(OrderedCollection new								add: (SStudent name: 'Mery' with: 5);								yourself);						yourself));		scalar: #SmallInteger with: #(5 1 2);		scalar: #ByteString with: #('Josh' 'Lian' 'Mery')</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoSSPerson1	^ STypeInfo new		type:			#SSPerson				-&gt;					(Array						with:							(Array								with: #name -&gt; #(#SSPerson #ByteString #() true)								with: #id -&gt; #(#SSPerson #SmallInteger #() false))						with:							(Array								with:									#name:with:										-&gt; #(#SSPerson #SSPerson #(#ByteString #SmallInteger) false)));		scalar: #SmallInteger with: #(50);		scalar: #ByteString with: #('Ann')</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoSSTeacher1	^ STypeInfo new		type:			#SSTeacher				-&gt;					(Array						with:							(Array								with: #initialize -&gt; #(#SSTeacher #SSTeacher #() false)								with: #yearsWorkExperience -&gt; #(#SSTeacher #SmallInteger #() true)								with:									#yearsWorkExperience:										-&gt; #(#SSTeacher #SSTeacher #(#SmallInteger) false))						with: #());		scalar: #SmallInteger with: #(0 100);		scalar: #ByteString with: #('teacher_Ann')</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoSSTeacher2	^ STypeInfo new		type:			#SSTeacher				-&gt;					(Array						with:							(Array								with: #initialize -&gt; #(#SSTeacher #SSTeacher #() false)								with: #idTeacher -&gt; #(#SSTeacher #SmallInteger #() true)								with:									#yearsWorkExperience:										-&gt; #(#SSTeacher #SSTeacher #(#SmallInteger) false)								with: #nickname -&gt; #(#SSTeacher #ByteString #() false))						with: #());		scalar: #SmallInteger with: #(1 29 -7 9);		scalar: #ByteString with: #('teacher_Amy' 'teacher_Mark')</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoSSTeacher3	^ STypeInfo new		type:			#SSTeacher				-&gt;					(Array						with:							(Array								with: #initialize -&gt; #(#SSTeacher #SSTeacher #() false)								with: #yearsWorkExperience -&gt; #(#SSTeacher #SmallInteger #() false)								with: #nickname -&gt; #(#SSTeacher #ByteString #() false))						with: #());		scalar: #SmallInteger with: #(1 10);		scalar: #ByteString with: #('teacher_Amy' 'teacher_Mark')</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoSSTeacher4	^ STypeInfo new		type:			#SSTeacher				-&gt;					(Array						with:							(Array								with: #initialize -&gt; #(#SSTeacher #SSTeacher #() false)								with: #idTeacher -&gt; #(#SSTeacher #SmallInteger #() true)								with: #yearsWorkExperience -&gt; #(#SSTeacher #SSTeacher #() true))						with: #());		scalar: #SmallInteger with: #(1 29 9);		scalar: #ByteString with: #('teacher_Amy' 'teacher_Mark')</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoSSTeacherOnPackage1	^ STypeInfo new		type:			#SSPerson				-&gt;					(Array						with:							(Array								with: #id: -&gt; #(#SSTeacher #SSTeacher #(#SmallInteger) false)								with: #nickname: -&gt; #(#SSTeacher #SSTeacher #(#ByteString) false)								with: #name -&gt; #(#SSTeacher #ByteString #() true)								with: #id -&gt; #(#SSTeacher #SmallInteger #() true)								with: #name: -&gt; #(#SSTeacher #SSTeacher #(#ByteString) false))						with:							(Array								with:									#name:with:										-&gt; #(#SSTeacher #SSTeacher #(#ByteString #SmallInteger) false)));		type:			#SSTeacher				-&gt;					(Array						with:							(Array								with: #initialize -&gt; #(#SSTeacher #SSTeacher #() false)								with: #idTeacher -&gt; #(#SSTeacher #SmallInteger #() true)								with:									#yearsWorkExperience:										-&gt; #(#SSTeacher #SSTeacher #(#SmallInteger) false)								with: #nickname -&gt; #(#SSTeacher #ByteString #() false))						with: #());		type: #SStack -&gt; #(#() #());		type: #SConference -&gt; #(#() #());		type: #SEvent -&gt; #(#() #());		type: #SFoo -&gt; #(#() #());		type: #SParty -&gt; #(#() #());		type: #SEventTest -&gt; #(#() #());		scalar: #SmallInteger with: #(0 100 34);		scalar: #ByteString with: #('Ann' 'teacher_Ann')</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoSSTeacherOnPackage2	^ STypeInfo new		type:			#SSTeacher				-&gt;					(Array						with:							(Array								with: #initialize -&gt; #(#SSTeacher #SSTeacher #() false)								with: #nickname -&gt; #(#SSTeacher #SSTeacher #() false)								with: #yearsWorkExperience -&gt; #(#SSTeacher #SmallInteger #() true))						with: #());		type: #SSPerson -&gt; #(#() #());		type: #SStack -&gt; #(#() #());		type: #SConference -&gt; #(#() #());		type: #SEvent -&gt; #(#() #());		type: #SFoo -&gt; #(#() #());		type: #SParty -&gt; #(#() #());		type: #SEventTest -&gt; #(#() #());		scalar: #SmallInteger with: #(0);		scalar: #ByteString with: #('teacher_1')</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoSStack1	^ STypeInfo new		type:			#SStack				-&gt;					(Array						with:							(Array								with: #firstLinkStack -&gt; #(#SStack #SmallInteger #() true)								with: #pop -&gt; #(#SStack #SmallInteger #() false)								with: #push: -&gt; #(#SStack #SmallInteger #(#SmallInteger) false))						with: (Array with: #newStackWith: -&gt; #(#SStack #SStack #(#Array) false)));		scalar: #Array with: #(#(2 4 6 1));		scalar: #SmallInteger with: #(1 2 4 6 8)</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoSStack2	^ STypeInfo new		type:			#SStack				-&gt;					(Array						with:							(Array								with: #lastLinkStack -&gt; #(#SStack #SmallInteger #() true)								with: #pop -&gt; #(#SStack #SmallInteger #() false)								with: #top -&gt; #(#SStack #SmallInteger #() false))						with:							(Array								with: #newStack -&gt; #(#SStack #SStack #() false)								with: #newStackWith: -&gt; #(#SStack #SStack #(#Array) false)));		scalar: #Array with: #(#(2 4 6 1) #(5 7 9 0));		scalar: #SmallInteger with: #(1 2 5 8 9)</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoSStack3	^ STypeInfo new		type:			#SStack				-&gt;					(Array						with:							(Array								with: #pop -&gt; #(#SStack #SmallInteger #() false)								with: #push: -&gt; #(#SStack #SmallInteger #(#SmallInteger) false)								with: #top -&gt; #(#SStack #SmallInteger #() false))						with: (Array with: #newStackWith: -&gt; #(#SStack #SStack #(#Array) false)));		scalar: #Array with: (Array with: #(2 4 6 1));		scalar: #SmallInteger with: #(7 5 9 1)</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoSStack4	^ STypeInfo new		type:			#SStack				-&gt;					(Array						with:							(Array								with: #firstLinkStack -&gt; #(#SStack #SmallInteger #() true)								with: #lastLinkStack -&gt; #(#SStack #SmallInteger #() true)								with: #pop -&gt; #(#SStack #SmallInteger #() false)								with: #push: -&gt; #(#SStack #SmallInteger #(#SmallInteger) false)								with: #top -&gt; #(#SStack #SmallInteger #() false))						with:							(Array								with: #newStack -&gt; #(#SStack #SStack #() false)								with: #newStackWith: -&gt; #(#SStack #SStack #(#Array) false)));		scalar: #SmallInteger with: #(5);		scalar: #Array with: #(#(1 4 5))</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoSStackOnPackage1	^ STypeInfo new		type:			#SStack				-&gt;					(Array						with:							(Array								with: #pop -&gt; #(#SStack #SmallInteger #() false)								with: #push: -&gt; #(#SStack #SmallInteger #(#SmallInteger) false)								with: #top -&gt; #(#SStack #SmallInteger #() false))						with: (Array with: #newStackWith: -&gt; #(#SStack #SStack #(#Array) false)));		type: #SSPerson -&gt; #(#() #());		type: #SSTeacher -&gt; #(#() #());		type: #SConference -&gt; #(#() #());		type: #SEvent -&gt; #(#() #());		type: #SFoo -&gt; #(#() #());		type: #SParty -&gt; #(#() #());		type: #SEventTest -&gt; #(#() #());		scalar: #SmallInteger with: #(1 2 4 6 8);		scalar: #Array with: #(#(2 4 6 1))</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoSStackOnPackage2	^ STypeInfo new		type:			#SSPerson				-&gt;					(Array						with:							(Array								with: #id: -&gt; #(#SStudent #SStudent #(#SmallInteger) false)								with: #nickname: -&gt; #(#SStudent #SStudent #(#ByteString) false)								with: #name: -&gt; #(#SStudent #SStudent #(#ByteString) false))						with:							(Array								with:									#name:with:										-&gt; #(#SStudent #SStudent #(#ByteString #SMallInteger) false)));		type:			#SStack				-&gt;					(Array						with:							(Array								with: #push: -&gt; #(#SStack #OrderedCollection #(#OrderedCollection) false))						with: #());		type: #SFoo -&gt; #(#() #());		type: #SConference -&gt; #(#() #());		type: #SEvent -&gt; #(#() #());		type: #SParty -&gt; #(#() #());		type: #SSTeacher -&gt; #(#() #());		type: #SEventTest -&gt; #(#() #());		scalar: #SStudent			with:			(Array				with: (SStudent name: 'Josh' with: 2)				with: (SStudent name: 'Mery' with: 5)				with: (SStudent name: 'Lian'));		scalar: #OrderedCollection			with:			(Array				with:					(OrderedCollection new						add: (SStudent name: 'Mery' with: 5);						yourself)				with:					(OrderedCollection new						add: (SStudent name: 'Lian');						add: (SStudent name: 'Josh' with: 2);						yourself));		scalar: #SmallInteger with: #(5 1 2);		scalar: #ByteString with: #('Josh' 'Lian' 'Mery')</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoSStudentOnPackage1	^ STypeInfo new		type:			#SStudent				-&gt;					(Array						with:							(Array								with: #initialize -&gt; #(#SStudent #SStudent #() false)								with: #idStudent -&gt; #(#SStudent #SmallInteger #() true)								with: #scoreStudent -&gt; #(#SStudent #SmallInteger #() true)								with: #scoreStudent: -&gt; #(#SStudent #SmallInteger #(#SmallInteger) false))						with: #());		type: #SAbstractClass -&gt; #(#() #());		scalar: #SmallInteger with: #(10 1)</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoStringSEvent	"(SSTypeCollector				profile: [ (SEvent price: 15)						price;						discount ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario')"	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : { },			#classMethodTypes : { }		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : { },			#classMethodTypes : { }		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : {				#price : STypeMethodInfo {					#selector : #price,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SEvent ]				},				#discount : STypeMethodInfo {					#selector : #discount,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SEvent ]				},				#initialize : STypeMethodInfo {					#selector : #initialize,					#returnType : SMultiTypeInfo [ #SEvent ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SEvent ]				},				#''price:'' : STypeMethodInfo {					#selector : #''price:'',					#returnType : SMultiTypeInfo [ #SEvent ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SEvent ]				}			},			#classMethodTypes : {				#''price:'' : STypeMethodInfo {					#selector : #''price:'',					#returnType : SMultiTypeInfo [ #SEvent ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SEvent ]				}			}		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : { },			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : { },			#classMethodTypes : { }		}	},	#scalars : {		#SmallInteger : [			15,			0		]	}}'</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoStringSFoo2	"SSTypeCollector				profile: [ (SFoo score: 15)						returnCollection;						returnFloat;						score;						return: #(1 5 6) ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario'"	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : { },			#classMethodTypes : { }		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : { },			#classMethodTypes : { }		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : { },			#classMethodTypes : { }		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : { },			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : {				#returnFloat : STypeMethodInfo {					#selector : #returnFloat,					#returnType : SMultiTypeInfo [ #SmallFloat64 ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#''score:'' : STypeMethodInfo {					#selector : #''score:'',					#returnType : SMultiTypeInfo [ #SFoo ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#initialize : STypeMethodInfo {					#selector : #initialize,					#returnType : SMultiTypeInfo [ #SFoo ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#returnCollection : STypeMethodInfo {					#selector : #returnCollection,					#returnType : SMultiTypeInfo [ #OrderedCollection ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#''return:'' : STypeMethodInfo {					#selector : #''return:'',					#returnType : SMultiTypeInfo [ #Array ],					#argTypes : [						SMultiTypeInfo [ #Array ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#score : STypeMethodInfo {					#selector : #score,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				}			},			#classMethodTypes : {				#''score:'' : STypeMethodInfo {					#selector : #''score:'',					#returnType : SMultiTypeInfo [ #SFoo ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				}			}		}	},	#scalars : {		#OrderedCollection : [			OrderedCollection [ ]		],		#Array : [			[				1,				5,				6			]		],		#SmallInteger : [			15		],		#SmallFloat64 : [			2.3		]	}}'</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoStringSFoo3	"SSTypeCollector profile:[ (SFoo score: 4)				score;				returnCollection;				returnString;				score: 5;				return:					((SStudent name: 'Emily')						nickname;						scoreStudent;						yourself) ] onPackagesMatching: 'SmallSuiteGenerator-Scenario'."	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : { },			#classMethodTypes : { }		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : {				#''id:'' : STypeMethodInfo {					#selector : #''id:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#''nickname:'' : STypeMethodInfo {					#selector : #''nickname:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#''name:'' : STypeMethodInfo {					#selector : #''name:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				}			},			#classMethodTypes : {				#''name:'' : STypeMethodInfo {					#selector : #''name:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				}			}		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : { },			#classMethodTypes : { }		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : { },			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : {				#''score:'' : STypeMethodInfo {					#selector : #''score:'',					#returnType : SMultiTypeInfo [ #SFoo ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#initialize : STypeMethodInfo {					#selector : #initialize,					#returnType : SMultiTypeInfo [ #SFoo ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#returnCollection : STypeMethodInfo {					#selector : #returnCollection,					#returnType : SMultiTypeInfo [ #OrderedCollection ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#returnString : STypeMethodInfo {					#selector : #returnString,					#returnType : SMultiTypeInfo [ #ByteString ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#''return:'' : STypeMethodInfo {					#selector : #''return:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #SStudent ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#score : STypeMethodInfo {					#selector : #score,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				}			},			#classMethodTypes : {				#''score:'' : STypeMethodInfo {					#selector : #''score:'',					#returnType : SMultiTypeInfo [ #SFoo ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				}			}		}	},	#scalars : {		#OrderedCollection : [			OrderedCollection [ ]		],		#SmallInteger : [			5,			1,			4		],		#ByteString : [			''Emily'',			''Hello''		],		#SStudent : [			SStudent {				#name : ''Emily'',				#id : 1,				#nickname : ''Emily'',				#scoreStudent : 1			}		]	}}'</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoStringSFoo6	"SSTypeCollector profile: [ SFoo new return: (Dictionary new at: 1 put: (SStack new push: (SStudent  name: 'Lian' with: 1); push: (SStudent name: 'Josh' with: 2); yourself ); at: 2 put: (OrderedCollection new add: (SStudent name: 'Mery' with: 5); yourself); yourself ) ] onPackagesMatching: 'SmallSuiteGenerator-Scenario'."	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : {				#''push:'' : STypeMethodInfo {					#selector : #''push:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #SStudent ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStack ]				}			},			#classMethodTypes : { }		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : {				#''id:'' : STypeMethodInfo {					#selector : #''id:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#''nickname:'' : STypeMethodInfo {					#selector : #''nickname:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#''name:'' : STypeMethodInfo {					#selector : #''name:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				}			},			#classMethodTypes : {				#''name:with:'' : STypeMethodInfo {					#selector : #''name:with:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ],						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				}			}		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : { },			#classMethodTypes : { }		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : { },			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : {				#initialize : STypeMethodInfo {					#selector : #initialize,					#returnType : SMultiTypeInfo [ #SFoo ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				},				#''return:'' : STypeMethodInfo {					#selector : #''return:'',					#returnType : SMultiTypeInfo [ #Dictionary ],					#argTypes : [						SMultiTypeInfo [ #Dictionary ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SFoo ]				}			},			#classMethodTypes : { }		}	},	#scalars : {		#Dictionary : [			{				1 : SStack [					SStudent {						#name : ''Josh'',						#id : 2,						#nickname : ''Josh'',						#scoreStudent : 1,						#idStudent : 1					},					SStudent {						#name : ''Lian'',						#id : 1,						#nickname : ''Lian'',						#scoreStudent : 1,						#idStudent : 1					}				],				2 : OrderedCollection [					SStudent {						#name : ''Mery'',						#id : 5,						#nickname : ''Mery'',						#scoreStudent : 1,						#idStudent : 1					}				]			}		],		#ByteString : [			''Josh'',			''Lian'',			''Mery''		],		#SmallInteger : [			5,			1,			2		],		#SStudent : [			@65,			@68,			@66		]	}}'</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoStringSSTeacher1	"SSTypeCollector		profile: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario'."	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : { },			#classMethodTypes : { }		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : {				#''id:'' : STypeMethodInfo {					#selector : #''id:'',					#returnType : SMultiTypeInfo [ #SSTeacher ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#''nickname:'' : STypeMethodInfo {					#selector : #''nickname:'',					#returnType : SMultiTypeInfo [ #SSTeacher ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#name : STypeMethodInfo {					#selector : #name,					#returnType : SMultiTypeInfo [ #ByteString ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#id : STypeMethodInfo {					#selector : #id,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#''name:'' : STypeMethodInfo {					#selector : #''name:'',					#returnType : SMultiTypeInfo [ #SSTeacher ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				}			},			#classMethodTypes : {				#''name:with:'' : STypeMethodInfo {					#selector : #''name:with:'',					#returnType : SMultiTypeInfo [ #SSTeacher ],					#argTypes : [						SMultiTypeInfo [ #ByteString ],						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				}			}		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : { },			#classMethodTypes : { }		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : {				#yearsWorkExperience : STypeMethodInfo {					#selector : #yearsWorkExperience,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#initialize : STypeMethodInfo {					#selector : #initialize,					#returnType : SMultiTypeInfo [ #SSTeacher ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#idTeacher : STypeMethodInfo {					#selector : #idTeacher,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#nickname : STypeMethodInfo {					#selector : #nickname,					#returnType : SMultiTypeInfo [ #ByteString ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				}			},			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : { },			#classMethodTypes : { }		}	},	#scalars : {		#ByteString : [			''Ann'',			''teacher_Ann''		],		#SmallInteger : [			0,			100,			34		]	}}'</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoStringSSTeacher2	"SSTypeCollector				profile: [ SSTeacher new						nickname;						yearsWorkExperience ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario'"	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : { },			#classMethodTypes : { }		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : { },			#classMethodTypes : { }		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : { },			#classMethodTypes : { }		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : {				#yearsWorkExperience : STypeMethodInfo {					#selector : #yearsWorkExperience,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#initialize : STypeMethodInfo {					#selector : #initialize,					#returnType : SMultiTypeInfo [ #SSTeacher ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				},				#nickname : STypeMethodInfo {					#selector : #nickname,					#returnType : SMultiTypeInfo [ #ByteString ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SSTeacher ]				}			},			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : { },			#classMethodTypes : { }		}	},	#scalars : {		#ByteString : [			''teacher_1''		],		#SmallInteger : [			0		]	}}'</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoStringSStack1	"SSTypeCollector profile: [ SStack new push: (OrderedCollection new add: (SStudent  name: 'Lian' with: 1); add: (SStudent name: 'Josh' with: 2); yourself); push: (OrderedCollection new add: (SStudent name: 'Mery' with: 5); yourself); yourself ] onPackagesMatching: 'SmallSuiteGenerator-Scenario'."	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : {				#''push:'' : STypeMethodInfo {					#selector : #''push:'',					#returnType : SMultiTypeInfo [ #OrderedCollection ],					#argTypes : [						SMultiTypeInfo [ #OrderedCollection ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStack ]				}			},			#classMethodTypes : { }		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : {				#''id:'' : STypeMethodInfo {					#selector : #''id:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#''nickname:'' : STypeMethodInfo {					#selector : #''nickname:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#''name:'' : STypeMethodInfo {					#selector : #''name:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				}			},			#classMethodTypes : {				#''name:with:'' : STypeMethodInfo {					#selector : #''name:with:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #ByteString ],						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				}			}		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : { },			#classMethodTypes : { }		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : { },			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : { },			#classMethodTypes : { }		}	},	#scalars : {		#OrderedCollection : [			OrderedCollection [				SStudent {					#name : ''Mery'',					#id : 5,					#nickname : ''Mery'',					#scoreStudent : 1,					#idStudent : 1				}			],			OrderedCollection [				SStudent {					#name : ''Lian'',					#id : 1,					#nickname : ''Lian'',					#scoreStudent : 1,					#idStudent : 1				},				SStudent {					#name : ''Josh'',					#id : 2,					#nickname : ''Josh'',					#scoreStudent : 1,					#idStudent : 1				}			]		],		#ByteString : [			''Josh'',			''Lian'',			''Mery''		],		#SmallInteger : [			5,			1,			2		],		#SStudent : [			@56,			@59,			@58		]	}}'</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoStringSStack2	"SSTypeCollector				profile: [ (SStack newStackWith: #(2 4 6 1))						push: 8;						pop;						top ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario'"	^ 'STypeInfo {	#types : {		#SStack : STypeClassInfo {			#typeName : #SStack,			#methodTypes : {				#''push:'' : STypeMethodInfo {					#selector : #''push:'',					#returnType : SMultiTypeInfo [ #SmallInteger ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStack ]				},				#pop : STypeMethodInfo {					#selector : #pop,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStack ]				},				#top : STypeMethodInfo {					#selector : #top,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStack ]				}			},			#classMethodTypes : {				#''newStackWith:'' : STypeMethodInfo {					#selector : #''newStackWith:'',					#returnType : SMultiTypeInfo [ #SStack ],					#argTypes : [						SMultiTypeInfo [ #Array ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStack ]				}			}		},		#SSPerson : STypeClassInfo {			#typeName : #SSPerson,			#methodTypes : { },			#classMethodTypes : { }		},		#SConference : STypeClassInfo {			#typeName : #SConference,			#methodTypes : { },			#classMethodTypes : { }		},		#SEvent : STypeClassInfo {			#typeName : #SEvent,			#methodTypes : { },			#classMethodTypes : { }		},		#SSTeacher : STypeClassInfo {			#typeName : #SSTeacher,			#methodTypes : { },			#classMethodTypes : { }		},		#SParty : STypeClassInfo {			#typeName : #SParty,			#methodTypes : { },			#classMethodTypes : { }		},		#SEventTest : STypeClassInfo {			#typeName : #SEventTest,			#methodTypes : { },			#classMethodTypes : { }		},		#SFoo : STypeClassInfo {			#typeName : #SFoo,			#methodTypes : { },			#classMethodTypes : { }		}	},	#scalars : {		#Array : [			[				2,				4,				6,				1			]		],		#SmallInteger : [			1,			2,			4,			6,			8		]	}}'</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfoStringSStudent1	"SSTypeCollector				profile: [ SStudent new						idStudent;						scoreStudent: 10;						scoreStudent ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario2'"	^ 'STypeInfo {	#types : {		#SAbstractClass : STypeClassInfo {			#typeName : #SAbstractClass,			#methodTypes : { },			#classMethodTypes : { }		},		#SStudent : STypeClassInfo {			#typeName : #SStudent,			#methodTypes : {				#initialize : STypeMethodInfo {					#selector : #initialize,					#returnType : SMultiTypeInfo [ #SStudent ],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#idStudent : STypeMethodInfo {					#selector : #idStudent,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#scoreStudent : STypeMethodInfo {					#selector : #scoreStudent,					#returnType : SMultiTypeInfo [ #SmallInteger ],					#isQuick : true,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				},				#''scoreStudent:'' : STypeMethodInfo {					#selector : #''scoreStudent:'',					#returnType : SMultiTypeInfo [ #SStudent ],					#argTypes : [						SMultiTypeInfo [ #SmallInteger ]					],					#isQuick : false,					#isDeprecated : false,					#receiver : SMultiTypeInfo [ #SStudent ]				}			},			#classMethodTypes : { }		}	},	#scalars : {		#SmallInteger : [			10,			1		]	}}'</body><body package="SmallSuiteGenerator-Tests-Utility">typeInfosSStudent	^ OrderedCollection new		add:			(STypeInfo new				type:					#SStudent						-&gt;							(Array								with:									(Array										with: #initialize -&gt; #(#SStudent #SStudent #() false)										with: #scoreStudent -&gt; #(#SStudent #SmallInteger #() true)										with: #scoreStudent: -&gt; #(#SStudent #SStudent #(#SmallInteger) false)										with: #idStudent -&gt; #(#SStudent #SmallInteger #() true))								with: #());				scalar: #SmallInteger with: #(1);				scalar: #ByteString with: #('student_Jane'));		add:			(STypeInfo new				type:					#SStudent						-&gt;							(Array								with:									(Array										with: #scoreStudent: -&gt; #(#SStudent #SStudent #(#SmallInteger) false)										with: #nickname -&gt; #(#SStudent #ByteString #() false))								with: #());				scalar: #SmallInteger with: #(1 6 8);				scalar: #ByteString with: #('Jane' 'Ann' 'Peter'));		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SUtilityTypeInfo</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-Utility">testSuiteOf: aCollection withTargetClassName: symbol	self		assert: aCollection size &gt;= 2		description: 'list must have at least two or more testCases.'.	^ OrderedCollection new		add:			((SSTestCase with: aCollection first)				addTargetClassName: symbol;				generateStatements);		add:			((SSTestCase with: aCollection second)				addTargetClassName: symbol;				generateStatements);		yourself</body><body package="SmallSuiteGenerator-Tests-Utility">testSuiteSSTeacher	^ self		testSuiteOf:			(Array				with: self typeInfoSSTeacher1				with: self typeInfoSSTeacher2				with: self typeInfoSSTeacher3)		withTargetClassName: #SSTeacher</body><body package="SmallSuiteGenerator-Tests-Utility">testSuiteSStack	^ self		testSuiteOf:			(Array				with: self typeInfoSStack1				with: self typeInfoSStack2				with: self typeInfoSStack3				with: self typeInfoSStack4)		withTargetClassName: #SStack</body><body package="SmallSuiteGenerator-Tests-Utility">testSuiteSStudent	^ self		testSuiteOf: self typeInfosSStudent		withTargetClassName: #SStudent</body><body package="SmallSuiteGenerator-Tests-Utility">testSuiteSStudentManual	^ OrderedCollection new		add:			((SSTestCase with: self typeInfosSStudent first)				addTargetClassName: #SStudent;				addFactoryMessage: #SStudent ofSelector: #new;				addLiteral: #ByteString;				addFieldAccessMessage: #idStudent from: #SStudent;				addMessage: #scoreStudent: from: #SStudent;				addFactoryMessage: #SStudent ofSelector: #new;				addFieldAccessMessage: #scoreStudent from: #SStudent;				yourself);		add:			((SSTestCase with: self typeInfosSStudent first)				addTargetClassName: #SStudent;				addLiteral: #SmallInteger;				addFactoryMessage: #SStudent ofSelector: #new;				addMessage: #scoreStudent: from: #SStudent;				addFactoryMessage: #SStudent ofSelector: #new;				addFieldAccessMessage: #idStudent from: #SStudent;				yourself);		add:			((SSTestCase with: self typeInfosSStudent first)				addTargetClassName: #SStudent;				addFactoryMessage: #SStudent ofSelector: #new;				addLiteral: #SmallInteger;				addMessage: #scoreStudent: from: #SStudent;				addLiteral: #SmallInteger;				addFactoryMessage: #SStudent ofSelector: #new;				yourself);		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SGAObject</class-id> <category>accessing</category><body package="SmallSuiteGenerator-GA">randomGenerator: sRandom	"The argument must be an instance of Random"	randomGenerator := sRandom</body></methods><methods><class-id>SmallSuiteGenerator.SFitnessFunction</class-id> <category>accessing</category><body package="SmallSuiteGenerator-GA">tagetPackagesRegex	^ tagetPackagesRegex</body><body package="SmallSuiteGenerator-GA">tagetPackagesRegex: anObject	tagetPackagesRegex := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SFitnessFunction</class-id> <category>actions</category><body package="SmallSuiteGenerator-GA">compute: testCaseCollection	^ self subclassResponsibility</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine</class-id> <category>actions</category><body package="SmallSuiteGenerator-GA">computeFitness	fitness compute: population</body><body package="SmallSuiteGenerator-GA">createNewPopulation	| newPopulation TB |	TB := self pickBestTest.	newPopulation := OrderedCollection new.	selectionStrategy load: population copy.	selectionStrategy fitness: fitness.	[ newPopulation size &lt; self populationSize		and: [ selectionStrategy population size &gt;= 2 ] ]		whileTrue: [ | P1 P2 O1 O2 fp fo lp lo child options |			P1 := selectionStrategy pickOne.			P2 := selectionStrategy pickOne.			self shouldCrossOver				ifTrue: [ child := crossoverOperator crossover: P1 with: P2.					O1 := child first.					O2 := child second ]				ifFalse: [ O1 := P1.					O2 := P2 ].			mutationOperator mutate: O1.			mutationOperator mutate: O2.			fitness compute: (Array with: O1 with: O2).			options := (Array				with: O1				with: O2				with: P1				with: P2)				asSortedCollection: [ :a :b | 					(self fitnessFor: a) = (self fitnessFor: b)						ifTrue: [ a length &lt; b length ]						ifFalse: [ (self fitnessFor: a) &gt; (self fitnessFor: b) ] ].			newPopulation addAll: (options first: 2) ].	population := newPopulation</body><body package="SmallSuiteGenerator-GA">createRandomPopulation	^ (1 to: 30)		collect: [ :val | 			| value test |			value := SConfiguration randomGenerator next * 30 + 1.			test := SSTestCase with: typeInfo.			test				addTargetClassName: self targetClassName;				addFactoryMessage: self targetClassName;				generateStatements: value.			test ]</body><body package="SmallSuiteGenerator-GA">fitnessFor: aTestCase	^ aTestCase fitness at: fitness functionName</body><body package="SmallSuiteGenerator-GA">mutate: testCase	^ mutationOperator mutate: testCase</body><body package="SmallSuiteGenerator-GA">pickBestTest	| best |	best := population first.	population		do: [ :test | 			| valA valB |			valA := self fitnessFor: best.			valB := self fitnessFor: test.			valB &gt; valA				ifTrue: [ best := test ] ].	^ best</body><body package="SmallSuiteGenerator-GA">run	population := self createRandomPopulation.	self computeFitness.	(1 to: numberOfIterations)		do: [ :iteration | 			logs				add:					(SGALog new						generationNumber: iteration;						fittestTestCase: self pickBestTest;						timeToProduceGeneration: Time now asSeconds;						yourself).			self createNewPopulation ]		displayingProgress: [ :iteration | 'Evolving - Iteration' , iteration printString ]</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine</class-id> <category>As yet unclassified</category><body package="SmallSuiteGenerator-GA">run	population := self createRandomPopulation.	self computeFitness.	(1 to: numberOfIterations)		do: [ :iteration | 			logs				add:					(SGALog new						generationNumber: iteration;						fittestTestCase: self pickBestTest;						timeToProduceGeneration: Time now asSeconds;						yourself).			self createNewPopulation ]		displayingProgress: [ :iteration | 'Evolving - Iteration' , iteration printString ]</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine</class-id> <category>actions</category><body package="SmallSuiteGenerator-GA">shouldCrossOver	^ SConfiguration randomGenerator next &lt; (3 / 4)</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine</class-id> <category>accessing</category><body package="SmallSuiteGenerator-GA">clean	fitness ifNotNil: [ fitness tearDown ]</body><body package="SmallSuiteGenerator-GA">crossoverOperator: aCrossoverOperator	crossoverOperator := aCrossoverOperator.	crossoverOperator randomGenerator: randomGenerator</body><body package="SmallSuiteGenerator-GA">fitness	^ fitness</body><body package="SmallSuiteGenerator-GA">fitness: aFitness	fitness := aFitness</body><body package="SmallSuiteGenerator-GA">logs	^ logs copy</body><body package="SmallSuiteGenerator-GA">logs1	^ logs</body><body package="SmallSuiteGenerator-GA">mutationRate: aFloat	mutationOperator mutationRate: aFloat</body><body package="SmallSuiteGenerator-GA">numberOfIterations: anObject	numberOfIterations := anObject</body><body package="SmallSuiteGenerator-GA">numberOfStatements	^ numberOfStatements</body><body package="SmallSuiteGenerator-GA">numberOfStatements: aInt	numberOfStatements := aInt</body><body package="SmallSuiteGenerator-GA">population	^ population</body><body package="SmallSuiteGenerator-GA">populationSize	^ populationSize</body><body package="SmallSuiteGenerator-GA">populationSize: aInteger	populationSize := aInteger</body><body package="SmallSuiteGenerator-GA">targetClassName	^ targetClassName</body><body package="SmallSuiteGenerator-GA">targetClassName: anObject	targetClassName := anObject</body><body package="SmallSuiteGenerator-GA">typeInfo	^ typeInfo</body><body package="SmallSuiteGenerator-GA">typeInfo: aTypeInfo	typeInfo := aTypeInfo</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine</class-id> <category>testing</category><body package="SmallSuiteGenerator-GA">checkFitness	self		assert: [ fitness notNil ]		description: 'Need to set a fitnessBlock'</body><body package="SmallSuiteGenerator-GA">checkIfReadyToRun	self checkTypeInfo.	self checkFitness.	self checkLogs</body><body package="SmallSuiteGenerator-GA">checkLogs	self assert: [ logs isEmpty ] description: 'Already been run'</body><body package="SmallSuiteGenerator-GA">checkTypeInfo	self assert: [ typeInfo notNil ] description: 'Set a typeInfo'</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine</class-id> <category>initialization</category><body package="SmallSuiteGenerator-GA">initialize	super initialize.	self initializeMutationOperator.	self initializeCrossoverOperator.	logs := OrderedCollection new.	randomGenerator := SConfiguration newRandomGenerator.	populationSize := 100.	numberOfIterations := 100.	selectionStrategy := SGATournamentSelection new.	self initializeMutationOperator.	self initializeCrossoverOperator</body><body package="SmallSuiteGenerator-GA">initializeCrossoverOperator	crossoverOperator := SGACrossoverOperation new.	crossoverOperator randomGenerator: randomGenerator</body><body package="SmallSuiteGenerator-GA">initializeMutationOperator	mutationOperator := SGAMutationOperation new.	mutationOperator mutationRate: (1 / 3) asFloat.	mutationOperator randomGenerator: randomGenerator</body></methods><methods><class-id>SmallSuiteGenerator.SGATournamentSelection</class-id> <category>actions</category><body package="SmallSuiteGenerator-GA">fitnessFor: aTestCase	^ aTestCase fitness at: fitness functionName</body><body package="SmallSuiteGenerator-GA">pickOne	"Return the best testCase from tournamentSize testCase randomly chosen from the population"	| sample selected |	sample := (randomGenerator collectAtRandom: population)		first: (tournamentSize min: population size).	sample := sample		asSortedCollection: [ :a :b | (self fitnessFor: a) &lt; (self fitnessFor: b) ].	selected := sample last.	population remove: selected.	^ selected</body></methods><methods><class-id>SmallSuiteGenerator.SGATournamentSelection</class-id> <category>accessing</category><body package="SmallSuiteGenerator-GA">fitness	^ fitness</body><body package="SmallSuiteGenerator-GA">fitness: aFitness	fitness := aFitness</body><body package="SmallSuiteGenerator-GA">load: aTestCaseCollection	population := aTestCaseCollection asOrderedCollection	"copy"</body><body package="SmallSuiteGenerator-GA">population	^ population</body></methods><methods><class-id>SmallSuiteGenerator.SGATournamentSelection</class-id> <category>initialization</category><body package="SmallSuiteGenerator-GA">initialize	population := OrderedCollection new.	tournamentSize := 5.	randomGenerator := SConfiguration newRandomGenerator</body></methods><methods><class-id>SmallSuiteGenerator.GAROMondrianViewBuilderTest</class-id> <category>As yet unclassified</category><body package="SmallSuiteGenerator-Tests-Generated">test1	"Fitness: method-coverage: 4.35"	"This test covers: Number of classes: 367Number of methods: 3737Number of tested methods: 159Number of test methods: 757% coverage: 4.35Average methods per test: 0.21"	| _var0 _var1 _var2 _var3 _var4 _var5 |	_var0 := Roassal.ROMondrianViewBuilder new.	_var1 := Roassal.ROEvent.	_var2 := Roassal.ROMondrianViewBuilder new.	_var3 := Roassal.ROEvent.	_var4 := Roassal.ROElement on: _var3.	_var5 := _var2 homogenerizeShapeOf: _var4.	self assert: _var0 title equals: 'Roassal visualization'.	self assert: _var2 title equals: 'Roassal visualization'.	self assert: _var5 title equals: 'Roassal visualization'.	self assert: _var1 printString equals: 'Roassal.ROEvent'.	self assert: _var3 printString equals: 'Roassal.ROEvent'.	self assert: _var4 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'</body><body package="SmallSuiteGenerator-Tests-Generated">test10	"Fitness: method-coverage: 4.35"	"This test covers: Number of classes: 367Number of methods: 3737Number of tested methods: 159Number of test methods: 757% coverage: 4.35Average methods per test: 0.21"	| _var0 _var1 _var2 _var3 _var4 _var5 _var6 |	_var0 := Roassal.ROMondrianViewBuilder new.	_var1 := Roassal.ROEvent.	_var2 := Roassal.ROElement on: _var1.	_var3 := _var0 homogenerizeShapeOf: _var2.	_var4 := _var3 createNewInteractionBuilder.	_var5 := _var3 zOrdering.	_var6 := _var5 setZindexOf: _var2.	self assert: _var0 title equals: 'Roassal visualization'.	self assert: _var3 title equals: 'Roassal visualization'.	self assert: _var4 title equals: 'Roassal visualization'.	self assert: _var1 printString equals: 'Roassal.ROEvent'.	self assert: _var2 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'</body><body package="SmallSuiteGenerator-Tests-Generated">test11	"Fitness: method-coverage: 4.35"	"This test covers: Number of classes: 367Number of methods: 3737Number of tested methods: 159Number of test methods: 757% coverage: 4.35Average methods per test: 0.21"	| _var0 _var1 _var2 _var3 _var4 _var5 _var6 _var7 _var8 _var9 |	_var0 := Roassal.ROEvent.	_var1 := Roassal.ROElement on: _var0.	_var2 := Roassal.ROMondrianViewBuilder new.	_var3 := _var2 homogenerizeShapeOf: _var1.	_var4 := _var3 createNewInteractionBuilder.	_var5 := _var4 getShape.	_var6 := _var4 getShape.	_var7 := _var1 on: _var0.	_var8 := _var2 unsetShape.	_var9 := _var3 initialize.	self assert: _var2 title equals: 'Roassal visualization'.	self assert: _var3 title equals: 'Roassal visualization'.	self assert: _var4 title equals: 'Roassal visualization'.	self assert: _var5 borderWidth equals: 1.	self assert: _var6 borderWidth equals: 1.	self assert: _var8 title equals: 'Roassal visualization'.	self assert: _var9 title equals: 'Roassal visualization'.	self assert: _var0 printString equals: 'Roassal.ROEvent'.	self assert: _var1 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'.	self assert: _var7 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'</body><body package="SmallSuiteGenerator-Tests-Generated">test12	"Fitness: method-coverage: 4.35"	"This test covers: Number of classes: 367Number of methods: 3737Number of tested methods: 159Number of test methods: 757% coverage: 4.35Average methods per test: 0.21"	| _var0 _var1 _var2 _var3 _var4 _var5 _var6 _var7 _var8 _var9 |	_var0 := Roassal.ROEvent.	_var1 := Roassal.ROElement on: _var0.	_var2 := Roassal.ROMondrianViewBuilder new.	_var3 := _var2 homogenerizeShapeOf: _var1.	_var4 := _var3 createNewInteractionBuilder.	_var5 := _var3 zOrdering.	_var6 := _var5 setZindexOf: _var1.	_var7 := _var4 horizontalLineLayout.	_var8 := _var7 deltaFor: _var1.	_var9 := _var5 initialize.	self assert: _var2 title equals: 'Roassal visualization'.	self assert: _var3 title equals: 'Roassal visualization'.	self assert: _var4 title equals: 'Roassal visualization'.	self assert: _var8 y equals: 0.	self assert: _var8 x equals: 0.	self assert: _var0 printString equals: 'Roassal.ROEvent'.	self assert: _var1 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'.	self assert: _var8 printString equals: '0 @ 0'</body><body package="SmallSuiteGenerator-Tests-Generated">test13	"Fitness: method-coverage: 4.35"	"This test covers: Number of classes: 367Number of methods: 3737Number of tested methods: 159Number of test methods: 757% coverage: 4.35Average methods per test: 0.21"	| _var0 _var1 _var2 _var3 _var4 _var5 _var6 _var7 _var8 |	_var0 := Roassal.ROMondrianViewBuilder new.	_var1 := Roassal.ROEvent.	_var2 := Roassal.ROMondrianViewBuilder new.	_var3 := Roassal.ROEvent.	_var4 := Roassal.ROMondrianViewBuilder new.	_var5 := Roassal.ROMondrianViewBuilder new.	_var6 := Roassal.ROEvent.	_var7 := Roassal.ROElement on: _var1.	_var8 := _var0 homogenerizeShapeOf: _var7.	self assert: _var0 title equals: 'Roassal visualization'.	self assert: _var2 title equals: 'Roassal visualization'.	self assert: _var4 title equals: 'Roassal visualization'.	self assert: _var5 title equals: 'Roassal visualization'.	self assert: _var8 title equals: 'Roassal visualization'.	self assert: _var1 printString equals: 'Roassal.ROEvent'.	self assert: _var3 printString equals: 'Roassal.ROEvent'.	self assert: _var6 printString equals: 'Roassal.ROEvent'.	self assert: _var7 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'</body><body package="SmallSuiteGenerator-Tests-Generated">test14	"Fitness: method-coverage: 4.35"	"This test covers: Number of classes: 367Number of methods: 3737Number of tested methods: 159Number of test methods: 757% coverage: 4.35Average methods per test: 0.21"	| _var0 _var1 _var2 _var3 _var4 _var5 _var6 _var7 _var8 _var9 _var10 _var11 |	_var0 := Roassal.ROMondrianViewBuilder new.	_var1 := Roassal.ROEvent.	_var2 := Roassal.ROElement on: _var1.	_var3 := _var0 homogenerizeShapeOf: _var2.	_var4 := _var0 createNewInteractionBuilder.	_var5 := _var3 horizontalLineLayout.	_var6 := _var5 deltaFor: _var2.	_var7 := _var3 getShape.	_var8 := Roassal.ROMondrianViewBuilder new.	_var9 := Roassal.ROEvent.	_var10 := Roassal.ROElement on: _var9.	_var11 := _var8 homogenerizeShapeOf: _var10.	self assert: _var0 title equals: 'Roassal visualization'.	self assert: _var3 title equals: 'Roassal visualization'.	self assert: _var4 title equals: 'Roassal visualization'.	self assert: _var6 y equals: 0.	self assert: _var6 x equals: 0.	self assert: _var7 borderWidth equals: 1.	self assert: _var8 title equals: 'Roassal visualization'.	self assert: _var11 title equals: 'Roassal visualization'.	self assert: _var1 printString equals: 'Roassal.ROEvent'.	self assert: _var2 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'.	self assert: _var6 printString equals: '0 @ 0'.	self assert: _var9 printString equals: 'Roassal.ROEvent'.	self assert: _var10 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'</body><body package="SmallSuiteGenerator-Tests-Generated">test15	"Fitness: method-coverage: 4.35"	"This test covers: Number of classes: 367Number of methods: 3737Number of tested methods: 159Number of test methods: 757% coverage: 4.35Average methods per test: 0.21"	| _var0 _var1 _var2 _var3 |	_var0 := Roassal.ROMondrianViewBuilder new.	_var1 := Roassal.ROEvent.	_var2 := Roassal.ROElement on: _var1.	_var3 := _var0 homogenerizeShapeOf: _var2.	self assert: _var0 title equals: 'Roassal visualization'.	self assert: _var3 title equals: 'Roassal visualization'.	self assert: _var1 printString equals: 'Roassal.ROEvent'.	self assert: _var2 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'</body><body package="SmallSuiteGenerator-Tests-Generated">test16	"Fitness: method-coverage: 4.35"	"This test covers: Number of classes: 367Number of methods: 3737Number of tested methods: 159Number of test methods: 757% coverage: 4.35Average methods per test: 0.21"	| _var0 _var1 _var2 _var3 |	_var0 := Roassal.ROMondrianViewBuilder new.	_var1 := Roassal.ROEvent.	_var2 := Roassal.ROElement on: _var1.	_var3 := Core.OrderedCollection new.	self assert: _var0 title equals: 'Roassal visualization'.	self assert: _var1 printString equals: 'Roassal.ROEvent'.	self assert: _var2 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'.	self assert: _var3 printString equals: 'OrderedCollection ()'</body><body package="SmallSuiteGenerator-Tests-Generated">test17	"Fitness: method-coverage: 4.35"	"This test covers: Number of classes: 367Number of methods: 3737Number of tested methods: 159Number of test methods: 757% coverage: 4.35Average methods per test: 0.21"	| _var0 _var1 _var2 _var3 _var4 _var5 _var6 |	_var0 := Roassal.ROMondrianViewBuilder new.	_var1 := Roassal.ROEvent.	_var2 := Roassal.ROElement on: _var1.	_var3 := _var0 homogenerizeShapeOf: _var2.	_var4 := _var3 createNewInteractionBuilder.	_var5 := _var3 zOrdering.	_var6 := _var5 setZindexOf: _var2.	self assert: _var0 title equals: 'Roassal visualization'.	self assert: _var3 title equals: 'Roassal visualization'.	self assert: _var4 title equals: 'Roassal visualization'.	self assert: _var1 printString equals: 'Roassal.ROEvent'.	self assert: _var2 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'</body><body package="SmallSuiteGenerator-Tests-Generated">test18	"Fitness: method-coverage: 4.35"	"This test covers: Number of classes: 367Number of methods: 3737Number of tested methods: 159Number of test methods: 757% coverage: 4.35Average methods per test: 0.21"	| _var0 _var1 _var2 _var3 _var4 _var5 _var6 |	_var0 := Roassal.ROMondrianViewBuilder new.	_var1 := Roassal.ROEvent.	_var2 := Roassal.ROElement on: _var1.	_var3 := _var0 homogenerizeShapeOf: _var2.	_var4 := _var3 createNewInteractionBuilder.	_var5 := _var3 zOrdering.	_var6 := _var5 setZindexOf: _var2.	self assert: _var0 title equals: 'Roassal visualization'.	self assert: _var3 title equals: 'Roassal visualization'.	self assert: _var4 title equals: 'Roassal visualization'.	self assert: _var1 printString equals: 'Roassal.ROEvent'.	self assert: _var2 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'</body><body package="SmallSuiteGenerator-Tests-Generated">test19	"Fitness: method-coverage: 4.35"	"This test covers: Number of classes: 367Number of methods: 3737Number of tested methods: 159Number of test methods: 757% coverage: 4.35Average methods per test: 0.21"	| _var0 _var1 _var2 _var3 |	_var0 := Roassal.ROMondrianViewBuilder new.	_var1 := Roassal.ROEvent.	_var2 := Roassal.ROElement on: _var1.	_var3 := Core.OrderedCollection new.	self assert: _var0 title equals: 'Roassal visualization'.	self assert: _var1 printString equals: 'Roassal.ROEvent'.	self assert: _var2 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'.	self assert: _var3 printString equals: 'OrderedCollection ()'</body><body package="SmallSuiteGenerator-Tests-Generated">test2	"Fitness: method-coverage: 4.35"	"This test covers: Number of classes: 367Number of methods: 3737Number of tested methods: 159Number of test methods: 757% coverage: 4.35Average methods per test: 0.21"	| _var0 _var1 _var2 _var3 _var4 _var5 |	_var0 := Roassal.ROMondrianViewBuilder new.	_var1 := Roassal.ROEvent.	_var2 := Roassal.ROMondrianViewBuilder new.	_var3 := Roassal.ROEvent.	_var4 := Roassal.ROElement on: _var3.	_var5 := _var2 homogenerizeShapeOf: _var4.	self assert: _var0 title equals: 'Roassal visualization'.	self assert: _var2 title equals: 'Roassal visualization'.	self assert: _var5 title equals: 'Roassal visualization'.	self assert: _var1 printString equals: 'Roassal.ROEvent'.	self assert: _var3 printString equals: 'Roassal.ROEvent'.	self assert: _var4 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'</body><body package="SmallSuiteGenerator-Tests-Generated">test20	"Fitness: method-coverage: 4.35"	"This test covers: Number of classes: 367Number of methods: 3737Number of tested methods: 159Number of test methods: 757% coverage: 4.35Average methods per test: 0.21"	| _var0 _var1 _var2 _var3 _var4 |	_var0 := Roassal.ROEvent.	_var1 := Roassal.ROMondrianViewBuilder new.	_var2 := Roassal.ROEvent.	_var3 := Roassal.ROElement on: _var2.	_var4 := Core.OrderedCollection new.	self assert: _var1 title equals: 'Roassal visualization'.	self assert: _var0 printString equals: 'Roassal.ROEvent'.	self assert: _var2 printString equals: 'Roassal.ROEvent'.	self assert: _var3 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'.	self assert: _var4 printString equals: 'OrderedCollection ()'</body><body package="SmallSuiteGenerator-Tests-Generated">test21	"Fitness: method-coverage: 4.35"	"This test covers: Number of classes: 367Number of methods: 3737Number of tested methods: 159Number of test methods: 757% coverage: 4.35Average methods per test: 0.21"	| _var0 _var1 _var2 _var3 _var4 _var5 _var6 _var7 _var8 |	_var0 := Roassal.ROMondrianViewBuilder new.	_var1 := Roassal.ROEvent.	_var2 := Core.Collection.	_var3 := Roassal.ROElement on: _var1.	_var4 := Roassal.ROElement on: _var1.	_var5 := _var0 homogenerizeShapeOf: _var4.	_var6 := _var0 createNewInteractionBuilder.	_var7 := _var6 zOrdering.	_var8 := _var7 setZindexOf: _var4.	self assert: _var0 title equals: 'Roassal visualization'.	self assert: _var5 title equals: 'Roassal visualization'.	self assert: _var6 title equals: 'Roassal visualization'.	self assert: _var1 printString equals: 'Roassal.ROEvent'.	self assert: _var2 printString equals: 'Collection'.	self assert: _var3 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'.	self assert: _var4 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'</body><body package="SmallSuiteGenerator-Tests-Generated">test22	"Fitness: method-coverage: 4.35"	"This test covers: Number of classes: 367Number of methods: 3737Number of tested methods: 159Number of test methods: 757% coverage: 4.35Average methods per test: 0.21"	| _var0 _var1 _var2 _var3 _var4 _var5 _var6 _var7 _var8 |	_var0 := Roassal.ROMondrianViewBuilder new.	_var1 := Roassal.ROEvent.	_var2 := Roassal.ROElement on: _var1.	_var3 := _var0 homogenerizeShapeOf: _var2.	_var4 := _var3 createNewInteractionBuilder.	_var5 := _var4 zOrdering.	_var6 := Roassal.ROEvent.	_var7 := Roassal.ROElement on: _var6.	_var8 := _var0 homogenerizeShapeOf: _var7.	self assert: _var0 title equals: 'Roassal visualization'.	self assert: _var3 title equals: 'Roassal visualization'.	self assert: _var4 title equals: 'Roassal visualization'.	self assert: _var8 title equals: 'Roassal visualization'.	self assert: _var1 printString equals: 'Roassal.ROEvent'.	self assert: _var2 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'.	self assert: _var6 printString equals: 'Roassal.ROEvent'.	self assert: _var7 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'</body><body package="SmallSuiteGenerator-Tests-Generated">test23	"Fitness: method-coverage: 4.35"	"This test covers: Number of classes: 367Number of methods: 3737Number of tested methods: 159Number of test methods: 757% coverage: 4.35Average methods per test: 0.21"	| _var0 _var1 _var2 _var3 _var4 _var5 |	_var0 := Roassal.ROMondrianViewBuilder new.	_var1 := Roassal.ROEvent.	_var2 := Roassal.ROMondrianViewBuilder new.	_var3 := Roassal.ROEvent.	_var4 := Roassal.ROElement on: _var3.	_var5 := _var2 homogenerizeShapeOf: _var4.	self assert: _var0 title equals: 'Roassal visualization'.	self assert: _var2 title equals: 'Roassal visualization'.	self assert: _var5 title equals: 'Roassal visualization'.	self assert: _var1 printString equals: 'Roassal.ROEvent'.	self assert: _var3 printString equals: 'Roassal.ROEvent'.	self assert: _var4 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'</body><body package="SmallSuiteGenerator-Tests-Generated">test24	"Fitness: method-coverage: 4.35"	"This test covers: Number of classes: 367Number of methods: 3737Number of tested methods: 159Number of test methods: 757% coverage: 4.35Average methods per test: 0.21"	| _var0 _var1 _var2 _var3 _var4 _var5 _var6 _var7 _var8 _var9 _var10 _var11 _var12 |	_var0 := Roassal.ROMondrianViewBuilder new.	_var1 := Roassal.ROEvent.	_var2 := Roassal.ROElement on: _var1.	_var3 := _var0 homogenerizeShapeOf: _var2.	_var4 := _var3 createNewInteractionBuilder.	_var5 := _var4 zOrdering.	_var6 := _var5 setZindexOf: _var2.	_var7 := _var3 horizontalLineLayout.	_var8 := _var7 deltaFor: _var2.	_var9 := _var6 initialize.	_var10 := Roassal.ROEvent.	_var11 := Roassal.ROElement on: _var10.	_var12 := _var0 homogenerizeShapeOf: _var11.	self assert: _var0 title equals: 'Roassal visualization'.	self assert: _var3 title equals: 'Roassal visualization'.	self assert: _var4 title equals: 'Roassal visualization'.	self assert: _var8 y equals: 0.	self assert: _var8 x equals: 0.	self assert: _var12 title equals: 'Roassal visualization'.	self assert: _var1 printString equals: 'Roassal.ROEvent'.	self assert: _var2 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'.	self assert: _var8 printString equals: '0 @ 0'.	self assert: _var10 printString equals: 'Roassal.ROEvent'.	self assert: _var11 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'</body><body package="SmallSuiteGenerator-Tests-Generated">test25	"Fitness: method-coverage: 4.35"	"This test covers: Number of classes: 367Number of methods: 3737Number of tested methods: 159Number of test methods: 757% coverage: 4.35Average methods per test: 0.21"	| _var0 _var1 _var2 _var3 _var4 _var5 _var6 _var7 _var8 |	_var0 := Roassal.ROMondrianViewBuilder new.	_var1 := Roassal.ROEvent.	_var2 := Roassal.ROElement on: _var1.	_var3 := _var0 homogenerizeShapeOf: _var2.	_var4 := _var3 applyLayout.	_var5 := Core.Point x: 63.0845 y: 21.	_var6 := _var2 translateTo: _var5.	_var7 := _var0 initFrame.	_var8 := 'Roassal visualization'.	self assert: _var0 title equals: 'Roassal visualization'.	self assert: _var3 title equals: 'Roassal visualization'.	self assert: _var4 title equals: 'Roassal visualization'.	self assert: _var5 y equals: 21.	self assert: _var5 x equals: 63.0845.	self assert: _var7 title equals: 'Roassal visualization'.	self assert: _var8 equals: 'Roassal visualization'.	self assert: _var1 printString equals: 'Roassal.ROEvent'.	self assert: _var2 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'.	self assert: _var5 printString equals: '63.0845 @ 21'.	self assert: _var6 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'</body><body package="SmallSuiteGenerator-Tests-Generated">test26	"Fitness: method-coverage: 4.35"	"This test covers: Number of classes: 367Number of methods: 3737Number of tested methods: 159Number of test methods: 757% coverage: 4.35Average methods per test: 0.21"	| _var0 _var1 _var2 _var3 _var4 _var5 _var6 _var7 _var8 |	_var0 := Roassal.ROMondrianViewBuilder new.	_var1 := Roassal.ROEvent.	_var2 := Roassal.ROElement on: _var1.	_var3 := _var0 homogenerizeShapeOf: _var2.	_var4 := _var3 applyLayout.	_var5 := Core.Point x: 63.0845 y: 21.	_var6 := _var2 translateTo: _var5.	_var7 := _var0 initFrame.	_var8 := 'Roassal visualization'.	self assert: _var0 title equals: 'Roassal visualization'.	self assert: _var3 title equals: 'Roassal visualization'.	self assert: _var4 title equals: 'Roassal visualization'.	self assert: _var5 y equals: 21.	self assert: _var5 x equals: 63.0845.	self assert: _var7 title equals: 'Roassal visualization'.	self assert: _var8 equals: 'Roassal visualization'.	self assert: _var1 printString equals: 'Roassal.ROEvent'.	self assert: _var2 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'.	self assert: _var5 printString equals: '63.0845 @ 21'.	self assert: _var6 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'</body><body package="SmallSuiteGenerator-Tests-Generated">test27	"Fitness: method-coverage: 4.35"	"This test covers: Number of classes: 367Number of methods: 3737Number of tested methods: 159Number of test methods: 757% coverage: 4.35Average methods per test: 0.21"	| _var0 _var1 _var2 _var3 |	_var0 := Roassal.ROMondrianViewBuilder new.	_var1 := Roassal.ROEvent.	_var2 := Roassal.ROElement on: _var1.	_var3 := _var0 homogenerizeShapeOf: _var2.	self assert: _var0 title equals: 'Roassal visualization'.	self assert: _var3 title equals: 'Roassal visualization'.	self assert: _var1 printString equals: 'Roassal.ROEvent'.	self assert: _var2 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'</body><body package="SmallSuiteGenerator-Tests-Generated">test28	"Fitness: method-coverage: 4.35"	"This test covers: Number of classes: 367Number of methods: 3737Number of tested methods: 159Number of test methods: 757% coverage: 4.35Average methods per test: 0.21"	| _var0 _var1 _var2 _var3 |	_var0 := Roassal.ROMondrianViewBuilder new.	_var1 := Roassal.ROEvent.	_var2 := Roassal.ROElement on: _var1.	_var3 := _var0 homogenerizeShapeOf: _var2.	self assert: _var0 title equals: 'Roassal visualization'.	self assert: _var3 title equals: 'Roassal visualization'.	self assert: _var1 printString equals: 'Roassal.ROEvent'.	self assert: _var2 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'</body><body package="SmallSuiteGenerator-Tests-Generated">test29self should:[| _var0 _var1 _var2 _var3 _var4 _var5 |_var0 := Roassal.ROMondrianViewBuilder new._var1 := Roassal.ROEvent._var2 := Roassal.ROElement on: _var1._var3 := _var0 unsetShape._var4 := _var0 initialize._var5 := (Core.OrderedCollection new)			add: ROElement basicNew yourself;			add: ROElement basicNew yourself;			yourself] raise:Error.</body><body package="SmallSuiteGenerator-Tests-Generated">test3	"Fitness: method-coverage: 4.35"	"This test covers: Number of classes: 367Number of methods: 3737Number of tested methods: 159Number of test methods: 757% coverage: 4.35Average methods per test: 0.21"	| _var0 _var1 _var2 _var3 _var4 _var5 _var6 |	_var0 := Roassal.ROMondrianViewBuilder new.	_var1 := Roassal.ROEvent.	_var2 := Roassal.ROElement on: _var1.	_var3 := _var0 homogenerizeShapeOf: _var2.	_var4 := _var0 createNewInteractionBuilder.	_var5 := _var0 zOrdering.	_var6 := _var5 setZindexOf: _var2.	self assert: _var0 title equals: 'Roassal visualization'.	self assert: _var3 title equals: 'Roassal visualization'.	self assert: _var4 title equals: 'Roassal visualization'.	self assert: _var1 printString equals: 'Roassal.ROEvent'.	self assert: _var2 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'</body><body package="SmallSuiteGenerator-Tests-Generated">test30self should:[| _var0 _var1 _var2 _var3 _var4 _var5 |_var0 := Roassal.ROMondrianViewBuilder new._var1 := Roassal.ROEvent._var2 := Roassal.ROElement on: _var1._var3 := _var0 unsetShape._var4 := _var0 initialize._var5 := (Core.OrderedCollection new)			add: ROElement basicNew yourself;			add: ROElement basicNew yourself;			yourself] raise:Error.</body><body package="SmallSuiteGenerator-Tests-Generated">test4	"Fitness: method-coverage: 4.35"	"This test covers: Number of classes: 367Number of methods: 3737Number of tested methods: 159Number of test methods: 757% coverage: 4.35Average methods per test: 0.21"	| _var0 _var1 _var2 _var3 _var4 _var5 _var6 |	_var0 := Roassal.ROMondrianViewBuilder new.	_var1 := Roassal.ROEvent.	_var2 := Roassal.ROElement on: _var1.	_var3 := _var0 homogenerizeShapeOf: _var2.	_var4 := _var3 createNewInteractionBuilder.	_var5 := _var3 zOrdering.	_var6 := _var5 setZindexOf: _var2.	self assert: _var0 title equals: 'Roassal visualization'.	self assert: _var3 title equals: 'Roassal visualization'.	self assert: _var4 title equals: 'Roassal visualization'.	self assert: _var1 printString equals: 'Roassal.ROEvent'.	self assert: _var2 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'</body><body package="SmallSuiteGenerator-Tests-Generated">test5	"Fitness: method-coverage: 4.35"	"This test covers: Number of classes: 367Number of methods: 3737Number of tested methods: 159Number of test methods: 757% coverage: 4.35Average methods per test: 0.21"	| _var0 _var1 _var2 _var3 _var4 |	_var0 := Roassal.ROMondrianViewBuilder new.	_var1 := Roassal.ROMondrianViewBuilder new.	_var2 := Roassal.ROEvent.	_var3 := Roassal.ROElement on: _var2.	_var4 := _var1 homogenerizeShapeOf: _var3.	self assert: _var0 title equals: 'Roassal visualization'.	self assert: _var1 title equals: 'Roassal visualization'.	self assert: _var4 title equals: 'Roassal visualization'.	self assert: _var2 printString equals: 'Roassal.ROEvent'.	self assert: _var3 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'</body><body package="SmallSuiteGenerator-Tests-Generated">test6	"Fitness: method-coverage: 4.35"	"This test covers: Number of classes: 367Number of methods: 3737Number of tested methods: 159Number of test methods: 757% coverage: 4.35Average methods per test: 0.21"	| _var0 _var1 _var2 _var3 _var4 _var5 |	_var0 := Roassal.ROMondrianViewBuilder new.	_var1 := Roassal.ROMondrianViewBuilder new.	_var2 := Roassal.ROMondrianViewBuilder new.	_var3 := Roassal.ROEvent.	_var4 := Roassal.ROElement on: _var3.	_var5 := _var1 homogenerizeShapeOf: _var4.	self assert: _var0 title equals: 'Roassal visualization'.	self assert: _var1 title equals: 'Roassal visualization'.	self assert: _var2 title equals: 'Roassal visualization'.	self assert: _var5 title equals: 'Roassal visualization'.	self assert: _var3 printString equals: 'Roassal.ROEvent'.	self assert: _var4 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'</body><body package="SmallSuiteGenerator-Tests-Generated">test7	"Fitness: method-coverage: 4.35"	"This test covers: Number of classes: 367Number of methods: 3737Number of tested methods: 159Number of test methods: 757% coverage: 4.35Average methods per test: 0.21"	| _var0 _var1 _var2 _var3 _var4 _var5 _var6 |	_var0 := Roassal.ROMondrianViewBuilder new.	_var1 := Roassal.ROEvent.	_var2 := Roassal.ROElement on: _var1.	_var3 := _var0 homogenerizeShapeOf: _var2.	_var4 := _var3 createNewInteractionBuilder.	_var5 := _var3 zOrdering.	_var6 := _var5 setZindexOf: _var2.	self assert: _var0 title equals: 'Roassal visualization'.	self assert: _var3 title equals: 'Roassal visualization'.	self assert: _var4 title equals: 'Roassal visualization'.	self assert: _var1 printString equals: 'Roassal.ROEvent'.	self assert: _var2 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'</body><body package="SmallSuiteGenerator-Tests-Generated">test8	"Fitness: method-coverage: 4.35"	"This test covers: Number of classes: 367Number of methods: 3737Number of tested methods: 159Number of test methods: 757% coverage: 4.35Average methods per test: 0.21"	| _var0 _var1 _var2 _var3 _var4 _var5 _var6 |	_var0 := Roassal.ROMondrianViewBuilder new.	_var1 := Roassal.ROEvent.	_var2 := Roassal.ROElement on: _var1.	_var3 := _var0 homogenerizeShapeOf: _var2.	_var4 := _var3 createNewInteractionBuilder.	_var5 := _var3 zOrdering.	_var6 := _var5 setZindexOf: _var2.	self assert: _var0 title equals: 'Roassal visualization'.	self assert: _var3 title equals: 'Roassal visualization'.	self assert: _var4 title equals: 'Roassal visualization'.	self assert: _var1 printString equals: 'Roassal.ROEvent'.	self assert: _var2 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'</body><body package="SmallSuiteGenerator-Tests-Generated">test9	"Fitness: method-coverage: 4.35"	"This test covers: Number of classes: 367Number of methods: 3737Number of tested methods: 159Number of test methods: 757% coverage: 4.35Average methods per test: 0.21"	| _var0 _var1 _var2 _var3 _var4 _var5 _var6 |	_var0 := Roassal.ROMondrianViewBuilder new.	_var1 := Roassal.ROEvent.	_var2 := Roassal.ROElement on: _var1.	_var3 := _var0 homogenerizeShapeOf: _var2.	_var4 := _var3 createNewInteractionBuilder.	_var5 := _var3 zOrdering.	_var6 := _var5 setZindexOf: _var2.	self assert: _var0 title equals: 'Roassal visualization'.	self assert: _var3 title equals: 'Roassal visualization'.	self assert: _var4 title equals: 'Roassal visualization'.	self assert: _var1 printString equals: 'Roassal.ROEvent'.	self assert: _var2 printString		equals: 'a Roassal.ROElement&lt;Roassal.ROEvent&gt;'</body></methods><methods><class-id>SmallSuiteGenerator.SMultiFitnessFunction</class-id> <category>actions</category><body package="SmallSuiteGenerator-GA">compute: aTestCase	"^ fitness associations inject: 0 into:[:assoc :acum |  				acum +  ((assoc first compute: aTestCase)* (assoc second))s]."	</body></methods><methods><class-id>SmallSuiteGenerator.SMultiFitnessFunction</class-id> <category>accessing</category><body package="SmallSuiteGenerator-GA">add: aFitness weight: aFloat	fitness at: aFitness put: aFloat</body></methods><methods><class-id>SmallSuiteGenerator.SMultiFitnessFunction</class-id> <category>initialization</category><body package="SmallSuiteGenerator-GA">initialize	super initialize.	fitness := Dictionary new</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngineExample</class-id> <category>examples - onPackages</category><body package="SmallSuiteGenerator-GA">exampleSSTeacherOnPackageWithSMethodCoverage	| engine classFitness |	classFitness := SMethodCoverage.	engine := self		runOnPackagesMatching: 'SmallSuiteGenerator-Examples'		withBlock: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName)				&lt;=					(engine logs last fittestTestCase fitness						at: classFitness functionName).	engine clean</body><body package="SmallSuiteGenerator-GA">exampleSSTeacherOnPackageWithSStatementCoverage	| engine classFitness |	classFitness := SStatementCoverage.	engine := self		runOnPackagesMatching: 'SmallSuiteGenerator-Examples'		withBlock: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName)				&lt;=					(engine logs last fittestTestCase fitness						at: classFitness functionName).	engine clean</body><body package="SmallSuiteGenerator-GA">exampleSStackOnPackageWithSMethodCoverage	| engine classFitness |	classFitness := SMethodCoverage.	engine := self		runOnPackagesMatching: 'SmallSuiteGenerator-Examples'		withBlock: [ (SStack newStackWith: #(2 4 6 1))				push: 8;				pop;				top ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName)				&lt;=					(engine logs last fittestTestCase fitness						at: classFitness functionName).	engine clean</body><body package="SmallSuiteGenerator-GA">exampleSStackOnPackageWithSStatementCoverage	| engine classFitness |	classFitness := SMethodCoverage.	engine := self		runOnPackagesMatching: 'SmallSuiteGenerator-Examples'		withBlock: [ (SStack newStackWith: #(2 4 6 1))				push: 8;				pop;				top ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName)				&lt;=					(engine logs last fittestTestCase fitness						at: classFitness functionName).	engine clean</body><body package="SmallSuiteGenerator-GA">exampleSStudentOnPackageWithSMethodCoverage	| engine classFitness |	classFitness := SMethodCoverage.	engine := self		runOnPackagesMatching: 'SmallSuiteGenerator-Scenario2'		withBlock: [ (SStudent name: 'Ann' with: 34)				nickname;				idStudent;				scoreStudent: 45;				scoreStudent ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName)				&lt;=					(engine logs last fittestTestCase fitness						at: classFitness functionName).	engine clean</body><body package="SmallSuiteGenerator-GA">exampleSStudentOnPackageWithSStatementCoverage	| engine classFitness |	classFitness := SStatementCoverage.	engine := self		runOnPackagesMatching: 'SmallSuiteGenerator-Scenario2'		withBlock: [ (SStudent name: 'Ann' with: 34)				nickname;				idStudent;				scoreStudent: 45;				scoreStudent ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName)				&lt;=					(engine logs last fittestTestCase fitness						at: classFitness functionName).	engine clean</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngineExample</class-id> <category>examples - onClass</category><body package="SmallSuiteGenerator-GA">exampleSSTeacherOnClassWithSMethodCoverage	| engine classFitness |	classFitness := SMethodCoverage.	engine := self		runOnClass: SSTeacher		withBlock: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName) &gt;= 20.	"20 = (1/5) * 100"	self		assert:			(engine logs last fittestTestCase fitness				at: classFitness functionName)		equals: 80.	"80 = (4/5) * 100"	engine clean</body><body package="SmallSuiteGenerator-GA">exampleSSTeacherOnClassWithSStatementCoverage	| engine classFitness |	classFitness := SStatementCoverage.	engine := self		runOnClass: SSTeacher		withBlock: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		andFitness: classFitness.	self		assert:			(engine logs last fittestTestCase fitness				at: classFitness functionName) &gt;= 37.5.	"37.5 = (3/8) * 100"	self		assert:			(engine logs last fittestTestCase fitness				at: classFitness functionName) &gt;= 87.5.	"87.5 = (7/8) * 100"	engine clean</body><body package="SmallSuiteGenerator-GA">exampleSStackOnClassWithSMethodCoverage	| engine classFitness |	classFitness := SMethodCoverage.	engine := self		runOnClass: SStack		withBlock: [ (SStack newStackWith: #(2 4 6 1))				push: 8;				pop;				top ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName) &gt;= 14.28.	"14.28 = (1/7) * 100 round: 2"	self		assert:			(engine logs last fittestTestCase fitness				at: classFitness functionName) &gt;= 57.14.	"57.14 = (4/7) * 100 round: 2"	engine clean</body><body package="SmallSuiteGenerator-GA">exampleSStackOnClassWithSStatementCoverage	| engine classFitness |	classFitness := SStatementCoverage.	engine := self		runOnClass: SStack		withBlock: [ (SStack newStackWith: #(2 4 6 1))				push: 8;				pop;				top ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName) &gt;= 21.05.	"21.05 = (4/19) * 100 round: 2"	self		assert:			(engine logs last fittestTestCase fitness				at: classFitness functionName) &gt;= 73.68.	"73.68 = (14/19) * 100 round: 2"	engine clean</body><body package="SmallSuiteGenerator-GA">exampleSStudentOnClassWithSMethodCoverage	| engine classFitness |	classFitness := SMethodCoverage.	engine := self		runOnClass: SStudent		withBlock: [ (SStudent name: 'Ann' with: 34)				nickname;				idStudent;				scoreStudent: 45;				scoreStudent ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName) &gt;= 20.	self		assert:			(engine logs last fittestTestCase fitness				at: classFitness functionName)		equals: 100.	engine clean</body><body package="SmallSuiteGenerator-GA">exampleSStudentOnClassWithSStatementCoverage	| engine classFitness |	classFitness := SStatementCoverage.	engine := self		runOnClass: SStudent		withBlock: [ (SStudent name: 'Ann' with: 34)				nickname;				idStudent;				scoreStudent: 45;				scoreStudent ]		andFitness: classFitness.	self		assert:			(engine logs first fittestTestCase fitness				at: classFitness functionName) &gt;= 37.5.	self		assert:			(engine logs last fittestTestCase fitness				at: classFitness functionName)		equals: 100.	engine clean</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngineExample</class-id> <category>actions</category><body package="SmallSuiteGenerator-GA">runOnClass: aClass withBlock: aBlock andFitness: aClassFitness	| engine |	engine := SGAEngine new.	engine		populationSize: 30;		numberOfStatements: 15;		blockToExecute: aBlock;		targetClassName: aClass name.	engine		typeInfo:			(SSTypeCollector profile: engine blockToExecute onClass: aClass)				asTypeInfo;		fitness: aClassFitness;		targetClassName: aClass name;		numberOfIterations: 15;		run.	^ engine</body><body package="SmallSuiteGenerator-GA">runOnPackagesMatching: regex withBlock: aBlock andFitness: aClassFitness	| engine |	engine := SGAEngine new.	engine		populationSize: 30;		numberOfStatements: 15;		blockToExecute: aBlock.	engine		typeInfo:			(SSTypeCollector				profile: engine blockToExecute				onPackagesMatching: regex) asTypeInfo;		fitness: aClassFitness;		numberOfIterations: 15;		run.	^ engine</body></methods><methods><class-id>SmallSuiteGenerator.SGAOperation</class-id> <category>initialization</category><body package="SmallSuiteGenerator-GA">initialize	randomGenerator := SConfiguration newRandomGenerator</body></methods><methods><class-id>SmallSuiteGenerator.SGACrossoverOperation</class-id> <category>validation</category><body package="SmallSuiteGenerator-GA">checkReferencesOf: testCase withDescription: aString	self		assert: testCase validReferences		description: aString , ' must have valid references'</body></methods><methods><class-id>SmallSuiteGenerator.SGACrossoverOperation</class-id> <category>accessing</category><body package="SmallSuiteGenerator-GA">alpha	^ (randomGenerator selectAtRandom: (0.1 to: 0.9 by: 0.1)) round: 1</body></methods><methods><class-id>SmallSuiteGenerator.SGACrossoverOperation</class-id> <category>actions</category><body package="SmallSuiteGenerator-GA">crossover: testCaseA with: testCaseB	| alpha offSpring1 offSpring2 |	self checkReferencesOf: testCaseA withDescription: 'testCase'.	self checkReferencesOf: testCaseB withDescription: 'testCase'.	"join typeInfo of testCaseA with testCaseB"	testCaseA typeInfo joinWith: testCaseB typeInfo.	alpha := self alpha.	"first alpha(P1) and last (1-alpha)(P2)"	offSpring1 := self offSpringOf: testCaseA and: testCaseB using: alpha.	self checkReferencesOf: offSpring1 withDescription: 'offspring'.	"first alpha(P2) and last (1-alpha)(P1)"	offSpring2 := self offSpringOf: testCaseB and: testCaseA using: alpha.	self checkReferencesOf: offSpring2 withDescription: 'offspring'.	^ Array with: offSpring1 with: offSpring2</body><body package="SmallSuiteGenerator-GA">offSpringOf: parentA and: parentB using: alpha	| sizeA sizeB offSpring limit |	sizeA := parentA numberStatements.	sizeB := parentB numberStatements.	offSpring := SSTestCase with: parentA typeInfo copy.	offSpring typeInfo joinWith: parentB typeInfo.	offSpring		addTargetClassNames: parentA targetClassesNames;		addTargetClassNames: parentB targetClassesNames.	limit := (sizeA * alpha) asInteger.	offSpring		addStatements: (parentA statements copyFrom: 1 to: limit) copy.	(parentB statements copyFrom: (alpha * sizeB) asInteger + 1 to: sizeB)		do: [ :aStm | 			[ aStm insertOn: offSpring ]				on: SError				do: [  ] ].	^ offSpring</body></methods><methods><class-id>SmallSuiteGenerator.SGAMutationOperation</class-id> <category>accessing</category><body package="SmallSuiteGenerator-GA">mutationRate: aFloat	mutationRate := aFloat</body></methods><methods><class-id>SmallSuiteGenerator.SGAMutationOperation</class-id> <category>actions</category><body package="SmallSuiteGenerator-GA">doMutate: aTestCase	randomGenerator next &lt;= mutationRate		ifTrue: [ aTestCase removeStatement ].	randomGenerator next &lt;= mutationRate		ifTrue: [ aTestCase changeStatement ].	randomGenerator next &lt;= mutationRate		ifTrue: [ aTestCase insertStatement ]</body><body package="SmallSuiteGenerator-GA">mutate: aTestCase	| newTestCase |	newTestCase := aTestCase copy.	self doMutate: newTestCase.	^ newTestCase</body></methods><methods><class-id>SmallSuiteGenerator.SGAMutationOperation</class-id> <category>initialization</category><body package="SmallSuiteGenerator-GA">initialize	super initialize.	self mutationRate: (1 / 3) asFloat</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactoryExample</class-id> <category>accessing</category><body package="SmallSuiteGenerator-GA">clean	Spy2 clean.	S2Profiler remove</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactoryExample</class-id> <category>examples - onPackages</category><body package="SmallSuiteGenerator-GA">exampleEmptyBlockOnPackages	| facade |	self clean.	facade := SConfiguration classTestCaseFactory.	^ facade new		typeInfo:			(SSTypeCollector				profile: [  ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario');		fitness: SMethodCoverage new;		targetClassName: #SFoo;		targetPackageRegex: 'SmallSuiteGenerator-Scenario';		outputPackageName: 'SmallSuiteGenerator-Tests-Generated';		createTestCases;		visualize;		yourself</body><body package="SmallSuiteGenerator-GA">exampleSSTeacherOnPackages	| typeInfo facade |	self clean.	facade := SConfiguration classTestCaseFactory.	typeInfo := SSTypeCollector		profile: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario'.	^ facade new		typeInfo: typeInfo;		fitness:			(SMultiFitnessFunction new				with: SMethodCoverage new;				with: SStatementCoverage new);		targetClassName: #SSTeacher;		targetPackageRegex: 'SmallSuiteGenerator-Scenario';		outputPackageName: 'SmallSuiteGenerator-Tests-Generated';		createTestCases;		visualize;		yourself</body><body package="SmallSuiteGenerator-GA">exampleSStackOnPackages	| typeInfo facade |	self clean.	facade := SConfiguration classTestCaseFactory.	typeInfo := SSTypeCollector		profile: [ (SStack newStackWith: #(1 5 3 2))				pop;				top;				push: 4 ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario'.	^ facade new		typeInfo: typeInfo;		fitness: SStatementCoverage new;		targetClassName: #SStack;		targetPackageRegex: 'SmallSuiteGenerator-Scenario';		outputPackageName: 'SmallSuiteGenerator-Tests-Generated';		createTestCases;		visualize;		yourself</body><body package="SmallSuiteGenerator-GA">exampleWithWrongRegexToRun	| typeInfo facade |	self clean.	facade := SConfiguration classTestCaseFactory.	typeInfo := SSTypeCollector		profile: [ (SStudent name: 'Ann' with: 34)				nickname;				idStudent ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario'.	^ facade new		typeInfo: typeInfo;		fitness:			(SMultiFitnessFunction new				with: SMethodCoverage new;				with: SStatementCoverage new);		targetClassName: #SStudent;		targetPackageRegex: 'SmallSuiteGenerator-Scenario';		outputPackageName: 'SmallSuiteGenerator-Tests-Generated';		createTestCases;		visualize;		yourself</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactoryExample</class-id> <category>examples - onClass</category><body package="SmallSuiteGenerator-GA">exampleSSTeacherOnClass	| typeInfo facade |	self clean.	facade := SConfiguration classTestCaseFactory.	typeInfo := SSTypeCollector		profile: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		onClass: SSTeacher.	^ facade new		typeInfo: typeInfo;		fitness: SMethodCoverage new;		targetClassName: #SSTeacher;		targetPackageRegex: 'SmallSuiteGenerator-Scenario';		outputPackageName: 'SmallSuiteGenerator-Tests-Generated';		createTestCases;		visualize;		yourself</body><body package="SmallSuiteGenerator-GA">exampleSStackOnClass	| typeInfo facade |	self clean.	facade := SConfiguration classTestCaseFactory.	typeInfo := SSTypeCollector		profile: [ (SStack newStackWith: #(1 5 3 2))				pop;				top;				push: 4 ]		onClass: SStack.	^ facade new		typeInfo: typeInfo;		fitness:			(SMultiFitnessFunction new				with: SMethodCoverage new;				with: SStatementCoverage new);		targetClassName: #SStack;		targetPackageRegex: 'SmallSuiteGenerator-Scenario';		outputPackageName: 'SmallSuiteGenerator-Tests-Generated';		createTestCases;		visualize;		yourself</body><body package="SmallSuiteGenerator-GA">exampleSStudentOnClass	| typeInfo facade |	self clean.	facade := SConfiguration classTestCaseFactory.	typeInfo := SSTypeCollector		profile: [ (SStudent name: 'Ann' with: 34)				nickname;				idStudent;				scoreStudent: 45;				scoreStudent ]		onClass: SStudent.	^ facade new		typeInfo: typeInfo;		fitness: SStatementCoverage new;		targetClassName: #SStudent;		targetPackageRegex: 'SmallSuiteGenerator-Scenario';		outputPackageName: 'SmallSuiteGenerator-Tests-Generated';		createTestCases;		visualize;		yourself</body><body package="SmallSuiteGenerator-GA">exampleWithSubclassToRun	| typeInfo facade |	self clean.	facade := SConfiguration classTestCaseFactory.	typeInfo := SSTypeCollector		profile: [ (SStudent name: 'Ann' with: 34)				nickname;				idStudent;				scoreStudent: 45;				scoreStudent ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario2'.	^ facade new		typeInfo: typeInfo;		fitness:			(SMultiFitnessFunction new				with: SMethodCoverage new;				with: SStatementCoverage new);		targetClassName: #SStudent;		targetPackageRegex: 'SmallSuiteGenerator-Scenario2';		outputPackageName: 'SmallSuiteGenerator-Tests-Generated';		createTestCases;		visualize;		yourself</body><body package="SmallSuiteGenerator-GA">exampleWithWrongClassToRun	| typeInfo facade |	self clean.	facade := SConfiguration classTestCaseFactory.	typeInfo := SSTypeCollector		profile: [ (SStudent name: 'Ann' with: 34)				nickname;				idStudent;				scoreStudent: 45;				scoreStudent ]		onClass: SFoo.	^ facade new		typeInfo: typeInfo;		fitness: SStatementCoverage new;		targetClassName: #SStudent;		targetPackageRegex: 'SmallSuiteGenerator-Scenario2';		outputPackageName: 'SmallSuiteGenerator-Tests-Generated';		createTestCases;		visualize;		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SSimpleFitnessFunction</class-id> <category>accesing</category><body package="SmallSuiteGenerator-GA">functionName	^ self subclassResponsibility</body><body package="SmallSuiteGenerator-GA">profiler: aProfiler	profiler := aProfiler</body></methods><methods><class-id>SmallSuiteGenerator.SSimpleFitnessFunction</class-id> <category>actions</category><body package="SmallSuiteGenerator-GA">compute: testCaseCollection	self setUp.	self run: testCaseCollection.	self tearDown</body><body package="SmallSuiteGenerator-GA">run: testCaseCollection	^ self subclassResponsibility</body><body package="SmallSuiteGenerator-GA">setUp	</body><body package="SmallSuiteGenerator-GA">tearDown	</body></methods><methods><class-id>SmallSuiteGenerator.SMethodCoverage</class-id> <category>actions</category><body package="SmallSuiteGenerator-GA">run: testCaseCollection	| string |	string := self functionName.	testCaseCollection		do: [ :testCase | 			profiler cleanBlocksOfMethods.			testCase runWithoutAssertions.			testCase fitness at: string put: profiler methodCoverage.			testCase fitnessByClass at: string put: profiler methodCoverage1 ]</body><body package="SmallSuiteGenerator-GA">setUp	</body><body package="SmallSuiteGenerator-GA">tearDown	</body></methods><methods><class-id>SmallSuiteGenerator.SMethodCoverage</class-id> <category>accesing</category><body package="SmallSuiteGenerator-GA">functionName	^ 'method-coverage'</body></methods><methods><class-id>SmallSuiteGenerator.SStatementCoverage</class-id> <category>actions</category><body package="SmallSuiteGenerator-GA">computeFitness	^ profiler statementCoverage</body><body package="SmallSuiteGenerator-GA">run: testCaseCollection	| string |	string := self functionName.	testCaseCollection		do: [ :testCase | 			profiler cleanBlocksOfMethods.			testCase runWithoutAssertions.			testCase fitness at: string put: profiler statementCoverage.			testCase fitnessByClass at: string put: profiler statementCoverage1 ]</body><body package="SmallSuiteGenerator-GA">setUp	</body><body package="SmallSuiteGenerator-GA">tearDown	</body></methods><methods><class-id>SmallSuiteGenerator.SStatementCoverage</class-id> <category>accesing</category><body package="SmallSuiteGenerator-GA">functionName	^ 'block-coverage'</body></methods><methods><class-id>SmallSuiteGenerator.SGALog</class-id> <category>accessing</category><body package="SmallSuiteGenerator-GA">fitness	^ fittestTestCase fitness</body><body package="SmallSuiteGenerator-GA">fittestTestCase	^ fittestTestCase</body><body package="SmallSuiteGenerator-GA">fittestTestCase: anTestCase	fittestTestCase := anTestCase</body><body package="SmallSuiteGenerator-GA">generationNumber	^ generationNumber</body><body package="SmallSuiteGenerator-GA">generationNumber: anObject	generationNumber := anObject</body><body package="SmallSuiteGenerator-GA">mutationResult	^ mutationResult</body><body package="SmallSuiteGenerator-GA">mutationResult: mutationTestingResult	self		assert: mutationResult isEmpty		description: 'The analysis of mutants has already been calculated'.	[ mutationResult		at: 'noEvaluatedMutants'			put: mutationTestingResult numberOfEvaluatedMutants;		at: 'noKilledOrTerminatedMutants'			put: mutationTestingResult numberOfKilledOrTerminatedMutants;		at: 'noAliveMutants'			put: mutationTestingResult numberOfAliveMutants;		at: 'mutationScore' put: mutationTestingResult mutationScore ]		on: Exception		do: [ nil ]</body><body package="SmallSuiteGenerator-GA">timeToProduceGeneration	^ timeToProduceGeneration</body><body package="SmallSuiteGenerator-GA">timeToProduceGeneration: anInteger	timeToProduceGeneration := anInteger</body></methods><methods><class-id>SmallSuiteGenerator.SGALog</class-id> <category>printing</category><body package="SmallSuiteGenerator-GA">printOn: str	super printOn: str.	str		nextPut: $&lt;;		nextPutAll: fittestTestCase statements printString;		nextPut: $&gt;</body></methods><methods><class-id>SmallSuiteGenerator.SGALog</class-id> <category>initialization</category><body package="SmallSuiteGenerator-GA">initialize	mutationResult := Dictionary new</body></methods><methods><class-id>SmallSuiteGenerator.SSTypeCollector</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Profiler">asTypeInfo	| typeInfo |	typeInfo := STypeInfo new.	self allClasses		do: [ :aSpyClass | 			aSpyClass className = 'BlockClosure'				ifFalse: [ aSpyClass fillTypesOn: typeInfo ] ].	typeInfo scalars: scalars copy.	^ typeInfo</body></methods><methods><class-id>SmallSuiteGenerator.SSTypeCollector</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Profiler">addScalar: anObject	| value |	value := scalars		at: (self class typeNameOf: anObject class)		ifAbsentPut: [ Set new ].	value add: anObject</body><body package="SmallSuiteGenerator-Profiler">initialize	super initialize.	scalars := Dictionary new</body><body package="SmallSuiteGenerator-Profiler">isScalar: anObject	(anObject class name includesAll: 'BlockClosure')		ifTrue: [ ^ true ].	self allClassesAsDictionary		at: (self class typeNameOf: anObject class)		ifAbsent: [ ^ true ].	^ false</body></methods><methods><class-id>SmallSuiteGenerator.SSTypeCollector</class-id> <category>As yet unclassified</category><body package="SmallSuiteGenerator-Profiler">isScalar: anObject	(anObject class name includesAll: 'BlockClosure')		ifTrue: [ ^ true ].	self allClassesAsDictionary		at: (self class typeNameOf: anObject class)		ifAbsent: [ ^ true ].	^ false</body></methods><methods><class-id>SmallSuiteGenerator.SSTypeCollector</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Profiler">scalars	^ scalars</body></methods><methods><class-id>SmallSuiteGenerator.SSTypeCollector class</class-id> <category>hooks</category><body package="SmallSuiteGenerator-Profiler">profile: aBlock onPackagesMatching: regex	^ (self new profile: aBlock onPackagesMatching: regex) asTypeInfo</body><body package="SmallSuiteGenerator-Profiler">spyClassForPackage	^ SSTypeCollectorPackage</body><body package="SmallSuiteGenerator-Profiler">typeNameOf: anObject	^ anObject name</body></methods><methods><class-id>SmallSuiteGenerator.SSTypeCollectorClass</class-id> <category>converting</category><body package="SmallSuiteGenerator-Profiler">fillTypesOn: aTypeInfo	| aTypeClass instanceMethods classMethods |	aTypeClass := STypeClassInfo newFrom: self typeName.	instanceMethods := (self methods reject: #isTest)		select: #wasExecuted.	classMethods := (self metaclassSpy methods reject: #isTest)		select:			[ :clsMethod | clsMethod wasExecuted and: [ clsMethod isValidReturnTypeWithReceiver ] ].	aTypeClass		addMethods: (instanceMethods collect: #asTypeInfo);		addClassMethods: (classMethods collect: #asTypeInfo).	aTypeInfo addClassInfo: aTypeClass</body></methods><methods><class-id>SmallSuiteGenerator.SSTypeCollectorClass</class-id> <category>defaults</category><body package="SmallSuiteGenerator-Profiler">typeName	^ self className</body></methods><methods><class-id>SmallSuiteGenerator.SSTypeCollectorClass class</class-id> <category>hooks</category><body package="SmallSuiteGenerator-Profiler">spyClassForMethod	^ SSTypeCollectorMethod</body></methods><methods><class-id>SmallSuiteGenerator.SSTypeCollectorMethod</class-id> <category>hooks</category><body package="SmallSuiteGenerator-Profiler">beforeRun: methodName with: listOfArguments in: receiver	self initArgsTypesWith: listOfArguments.	self saveReceiver: receiver.	listOfArguments do: [ :arg | self checkIfArgIsScalar: arg ].	executed := true</body><body package="SmallSuiteGenerator-Profiler">checkIfArgIsScalar: arg	(self profiler isScalar: arg)		ifTrue: [ self profiler addScalar: arg ]</body><body package="SmallSuiteGenerator-Profiler">initArgsTypesWith: args	| classNames |	classNames := args collect: [ :arg | self typeName: arg class ].	argTypes		ifNil: [ classNames				ifNotEmpty: [ argTypes := classNames						collect: [ :aName | SMultiTypeInfo new: aName ] ] ]		ifNotNil: [ self mergeArgsTypes: classNames ]</body><body package="SmallSuiteGenerator-Profiler">initialize	super initialize.	returnType := SMultiTypeInfo new.	receiverType := SMultiTypeInfo new.	executed := false</body><body package="SmallSuiteGenerator-Profiler">mergeArgsTypes: args	argTypes		with: args		do: [ :argType :otherArgType | argType type: otherArgType ]</body><body package="SmallSuiteGenerator-Profiler">returnValue: value	returnType type: (self typeName: value class).	self checkIfArgIsScalar: value</body><body package="SmallSuiteGenerator-Profiler">saveReceiver: anObject	receiverType		type:			(anObject isClass				ifTrue: [ self typeName: anObject ]				ifFalse: [ self typeName: anObject class ])</body><body package="SmallSuiteGenerator-Profiler">wasExecuted	^ executed</body></methods><methods><class-id>SmallSuiteGenerator.SSTypeCollectorMethod</class-id> <category>as yet unclassified</category><body package="SmallSuiteGenerator-Profiler">typeName: anObject	^ SSTypeCollector typeNameOf: anObject</body></methods><methods><class-id>SmallSuiteGenerator.SSTypeCollectorMethod</class-id> <category>converting</category><body package="SmallSuiteGenerator-Profiler">asTypeInfo	^ STypeMethodInfo new		selector: selector;		receiver: self receiverType;		returnType: self returnType;		argTypes: self argTypes;		isQuick: self isQuick;		isDeprecated: originalMethod isDeprecated</body></methods><methods><class-id>SmallSuiteGenerator.SSTypeCollectorMethod</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Profiler">argTypes	^ argTypes</body><body package="SmallSuiteGenerator-Profiler">receiverType	^ receiverType</body><body package="SmallSuiteGenerator-Profiler">returnType	^ returnType</body></methods><methods><class-id>SmallSuiteGenerator.SSTypeCollectorMethod</class-id> <category>testing</category><body package="SmallSuiteGenerator-Profiler">isValidReturnTypeWithReceiver	^ self receiverType types = self returnType types</body></methods><methods><class-id>SmallSuiteGenerator.SSTypeCollectorPackage class</class-id> <category>hooks</category><body package="SmallSuiteGenerator-Profiler">spyClassForClass	^ SSTypeCollectorClass</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>actions</category><body package="SmallSuiteGenerator-Info">exportDataCSV: neoCSVWriter withFilter: aSymbol	types		do: [ :type | type exportDataCSV: neoCSVWriter withFilter: aSymbol ]</body><body package="SmallSuiteGenerator-Info">joinScalars: aDict	aDict associations		do: [ :assoc | 			scalars				at: assoc key				ifPresent: [ :values | scalars at: assoc key put: (values union: assoc value) ]				ifAbsentPut: [ assoc value ] ]</body><body package="SmallSuiteGenerator-Info">joinWith: otherTypeInfo	otherTypeInfo types		do: [ :aTypeClass | self addClassInfo: aTypeClass ].	self joinScalars: otherTypeInfo scalars</body><body package="SmallSuiteGenerator-Info">scalar: aClassName with: aValue	scalars at: aClassName put: aValue asSet asArray</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Info">accessMessagesFrom: aClassName	^ types		flatCollect: [ :aClassType | 			aClassType accessMessages				select: [ :aMessage | aMessage receiver types includes: aClassName ] ]</body><body package="SmallSuiteGenerator-Info">classAt: aClassName	^ types at: aClassName</body><body package="SmallSuiteGenerator-Info">classAt: aClassName ifNone: aBlock	^ types at: aClassName ifAbsent: aBlock</body><body package="SmallSuiteGenerator-Info">classes	classes ifNil: [ classes := Dictionary new ].	types		keysDo: [ :aClassName | 			classes				at: aClassName				ifAbsentPut: (SConfiguration lookUpClass: aClassName) ].	^ classes</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>As yet unclassified</category><body package="SmallSuiteGenerator-Info">classes	classes ifNil: [ classes := Dictionary new ].	types		keysDo: [ :aClassName | 			classes				at: aClassName				ifAbsentPut: (SConfiguration lookUpClass: aClassName) ].	^ classes</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Info">messagesFrom: aClassName	^ types		flatCollect: [ :aClassType | 			aClassType messages				select: [ :aMessage | aMessage receiver types includes: aClassName ] ]</body><body package="SmallSuiteGenerator-Info">noneAbstractClasses	noneAbstractClasses		ifNil: [ noneAbstractClasses := self classes associations				select: [ :assoc | (self isAbstractClass: assoc key) not ]				thenCollect: [ :assoc | assoc value ] ].	^ noneAbstractClasses</body><body package="SmallSuiteGenerator-Info">reportFrequencyByFilter	| report |	report := Dictionary new.	STypeMethodInfo selectorsFilter , #(#others #all)		do: [ :aSelector | 			report				at: aSelector				put:					(types						inject: 0						into: [ :sum :type | sum + (type reportFrequencyByFilter: aSelector) ]) ].	^ report</body><body package="SmallSuiteGenerator-Info">scalars	^ scalars</body><body package="SmallSuiteGenerator-Info">scalars: aDictionary	aDictionary		associationsDo: [ :assoc | self scalar: assoc key with: assoc value ]</body><body package="SmallSuiteGenerator-Info">types	^ types</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>adding</category><body package="SmallSuiteGenerator-Info">addClassInfo: aTypeClassInfo	"aTypeClassInfo typeInfo: self."	types		at: aTypeClassInfo typeName		ifPresent: [ :aTypeClass | aTypeClass joinWith: aTypeClassInfo ]		ifAbsentPut: aTypeClassInfo</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>lookup</category><body package="SmallSuiteGenerator-Info">classMethodType: aSelector from: aClassName	aSelector = #new		ifTrue: [ ^ self defaultFactoryMessageFrom: aClassName ].	(self factoryMessagesFrom: aClassName)		detect: [ :aMessage | aMessage selector = aSelector ]		ifFound: [ :aMessage | ^ aMessage ].	self		error:			'ClassMethodType of selector: ' , aSelector				, ' is not found in class: ' , aClassName</body><body package="SmallSuiteGenerator-Info">factoryMessagesFrom: aClassName	^ types		flatCollect: [ :aClassType | 			aClassType factoryMessages				select: [ :aMessage | aMessage receiver types includes: aClassName ] ]</body><body package="SmallSuiteGenerator-Info">methodType: aSelector from: aClassName	types		do: [ :aTypeClassInfo | 			aTypeClassInfo messagesAndAccessMessages				detect: [ :aMessage | 					(aMessage isFromReceiver: aClassName)						and: [ aMessage selector = aSelector ] ]				ifFound: [ :aMessage | ^ aMessage ]				ifNone: [ false ] ].	^ self		error:			'MethodType of selector: ' , aSelector , ' is not found in class: '				, aClassName</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>accessing structure variables</category><body package="SmallSuiteGenerator-Info">defaultFactoryMessageFrom: aClassName	(self messagesFrom: aClassName)		detect: [ :message | message selector = #initialize ]		ifFound: [ ^ STypeMethodInfo				type:					#new						-&gt;							(Array								with: aClassName								with: aClassName								with: #()								with: false) ].	self		error:			'ClassMethodType of selector new cannot be applied at class: '				, aClassName</body><body package="SmallSuiteGenerator-Info">type: aAssoc	self addClassInfo: (STypeClassInfo type: aAssoc)</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Info">= other	^ self class = other class		and: [ types = other types				and: [ | otherScalars |					otherScalars := other scalars.					scalars keys = otherScalars keys						and: [ (scalars values collect: #size)								= (otherScalars values collect: #size) ] ] ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>copying</category><body package="SmallSuiteGenerator-Info">copy	| copy |	copy := STypeInfo new.	types		do: [ :aClassTypeInfo | copy addClassInfo: aClassTypeInfo copy ].	copy scalars: scalars copy.	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>error handling</category><body package="SmallSuiteGenerator-Info">error: aString	^ SError signal: aString</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Info">initialize	super initialize.	types := Dictionary new.	scalars := Dictionary new</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Info">isAbstractClass: symbol	| aClass |	aClass := self classes at: symbol.	^ (aClass methods select: #isAbstract) isNotEmpty</body></methods><methods><class-id>SmallSuiteGenerator.SRandom</class-id> <category>enumerating</category><body package="SmallSuiteGenerator-Core">collectAtRandom: collection	| indexes |	indexes := self shuffleCollection: collection size.	^ indexes		inject: OrderedCollection new		into: [ :result :index | 			result add: (collection at: index).			result ]</body><body package="SmallSuiteGenerator-Core">selectAtRandom: collection	^ collection at: (self nextInt: collection size)</body><body package="SmallSuiteGenerator-Core">shuffleCollection: stop	| numbers |	numbers := (1 to: stop) asArray.	stop to: 2 by: -1 do: [ :i | numbers swap: i with: (self nextInt: i) ].	^ numbers</body></methods><methods><class-id>SmallSuiteGenerator.SRandom class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Core">seed: anObject	^ self new seed: anObject</body></methods><methods><class-id>SmallSuiteGenerator.STypeObjectInfo</class-id> <category>actions</category><body package="SmallSuiteGenerator-Info">joinWith: otherObject	self subclassResponsibility</body></methods><methods><class-id>SmallSuiteGenerator.STypeObjectInfo class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Info">instance	^ self new</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>actions</category><body package="SmallSuiteGenerator-Info">joinWith: otherTypeReturn	otherTypeReturn types do: [ :aType | self type: aType ]</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Info">commonSuperclass	| commonSuperclass |	types ifEmpty: [ ^ '' ].	commonSuperclass := SConfiguration lookUpClass: types anyOne.	commonSuperclass ifNil: [ ^ '' ].	types		do: [ :aType | 			| otherClass |			otherClass := SConfiguration lookUpClass: aType.			otherClass ifNil: [ ^ '' ].			(commonSuperclass isClass and: [ commonSuperclass name = #Object ])				ifTrue: [ ^ #Object ].			commonSuperclass := commonSuperclass				commonSuperclassWith: otherClass ].	^ commonSuperclass name</body><body package="SmallSuiteGenerator-Info">type	^ types		ifEmpty: [ nil ]		ifNotEmpty: [ SConfiguration newRandomGenerator selectAtRandom: self types ]</body><body package="SmallSuiteGenerator-Info">types	^ types asArray</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>metrics</category><body package="SmallSuiteGenerator-Info">hasOnlyOneType	^ types size &lt;= 1</body><body package="SmallSuiteGenerator-Info">isBlockSymbol	^ types size = 2		and: [ (types anySatisfy: [ :t | t = #BlockClosure ])				and: [ types anySatisfy: [ :t | t = #ByteSymbol ] ] ]</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Info">= other	^ self class = other class and: [ self types = other types ]</body><body package="SmallSuiteGenerator-Info">equals: other	self types size = other types size		ifFalse: [ ^ false ].	self types asOrderedCollection		with: other types asOrderedCollection		do: [ :a :b | 			a = b				ifFalse: [ ^ false ] ].	^ true</body><body package="SmallSuiteGenerator-Info">hash	^ self types hash</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Info">fromSton: stonReader	stonReader parseListDo: [ :each :index | self type: each ]</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>accessing structure variables</category><body package="SmallSuiteGenerator-Info">type: aClassName	aClassName ~= #nil		ifTrue: [ types add: aClassName ]</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>ston persistence</category><body package="SmallSuiteGenerator-Info">stonOn: stonWriter	stonWriter		writeObject: self		streamShortList: [ :array | self types do: [ :type | array add: type ] ]</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>testing</category><body package="SmallSuiteGenerator-Info">includes: aType	^ self types includes: aType</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>copying</category><body package="SmallSuiteGenerator-Info">copy	| copy |	copy := self class instance.	types do: [ :aType | copy type: aType ].	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Info">initialize	types := Set new</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfo class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Info">new: aType	^ self new type: aType</body></methods><methods><class-id>SmallSuiteGenerator.SError</class-id> <category>signaling</category><body package="SmallSuiteGenerator-Core">signal: message	SConfiguration saveOnLog: message.	super signal: message</body></methods><methods><class-id>SmallSuiteGenerator.SError class</class-id> <category>exceptioninstantiator</category><body package="SmallSuiteGenerator-Core">signal: anObject	^ self new signal: anObject</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id> <category>metrics</category><body package="SmallSuiteGenerator-Info">isSimpleTyped	"	- one type of receiver only one type for each argument	"	^ (Array		with: receiver hasOnlyOneType		with: returnType hasOnlyOneType		with: (argTypes isNil or: [ argTypes allSatisfy: #hasOnlyOneType ]))		allSatisfy: #yourself</body><body package="SmallSuiteGenerator-Info">isSimpleTyped10	"		"	^ (Array		with: receiver hasOnlyOneType		with:			(returnType hasOnlyOneType not				and: [ returnType commonSuperclass = 'Object' ])		with:			(argTypes notNil				and: [ argTypes anySatisfy: [ :t | t hasOnlyOneType not ] ])		with:			(argTypes notNil				and: [ argTypes						allSatisfy: [ :t | 							t hasOnlyOneType								or: [ t isBlockSymbol not and: [ t commonSuperclass = 'Object' ] ] ] ]))		allSatisfy: #yourself</body><body package="SmallSuiteGenerator-Info">isSimpleTyped11	"		"	^ (Array		with: receiver hasOnlyOneType not		with: returnType hasOnlyOneType not		with: (argTypes isNil or: [ argTypes allSatisfy: #hasOnlyOneType ])		with: (receiver equals: returnType) not) allSatisfy: #yourself</body><body package="SmallSuiteGenerator-Info">isSimpleTyped12	"		"	^ (Array		with:			(receiver hasOnlyOneType not				and: [ receiver commonSuperclass ~= 'Object' ])		with: returnType hasOnlyOneType not		with:			(argTypes notNil				and: [ argTypes anySatisfy: [ :t | t hasOnlyOneType not ] ])		with:			(argTypes notNil				and: [ argTypes						allSatisfy: [ :t | 							t hasOnlyOneType								or: [ t isBlockSymbol not and: [ t commonSuperclass = 'Object' ] ] ] ]))		allSatisfy: #yourself</body><body package="SmallSuiteGenerator-Info">isSimpleTyped2	"	- this guy return the type that he receive 	"	^ (Array		with: receiver hasOnlyOneType not		with: returnType hasOnlyOneType not		with: (receiver equals: returnType)		with: (argTypes isNil or: [ argTypes allSatisfy: #hasOnlyOneType ]))		allSatisfy: #yourself</body><body package="SmallSuiteGenerator-Info">isSimpleTyped3	"	- this guy return the type that he receive 	"	^ (Array		with: receiver hasOnlyOneType not		with: receiver commonSuperclass ~= 'Object'		with: returnType hasOnlyOneType		with: (argTypes isNil or: [ argTypes allSatisfy: #hasOnlyOneType ]))		allSatisfy: #yourself</body><body package="SmallSuiteGenerator-Info">isSimpleTyped4	"		"	^ (Array		with: receiver hasOnlyOneType		with: returnType hasOnlyOneType		with:			(argTypes notNil				and: [ argTypes anySatisfy: [ :t | t hasOnlyOneType not ] ])		with:			(argTypes notNil				and: [ argTypes						allSatisfy: [ :t | t hasOnlyOneType or: [ t isBlockSymbol ] ] ]))		allSatisfy: #yourself</body><body package="SmallSuiteGenerator-Info">isSimpleTyped5	"		"	^ (Array		with: receiver hasOnlyOneType		with: returnType hasOnlyOneType		with:			(argTypes notNil				and: [ argTypes anySatisfy: [ :t | t hasOnlyOneType not ] ])		with:			(argTypes notNil				and: [ argTypes						allSatisfy: [ :t | 							t hasOnlyOneType								or: [ t isBlockSymbol not and: [ t commonSuperclass = 'Object' ] ] ] ]))		allSatisfy: #yourself</body><body package="SmallSuiteGenerator-Info">isSimpleTyped6	"		"	^ (Array		with: receiver hasOnlyOneType		with: returnType hasOnlyOneType		with:			(argTypes notNil				and: [ argTypes anySatisfy: [ :t | t hasOnlyOneType not ] ])		with:			(argTypes notNil				and: [ argTypes						allSatisfy: [ :t | t hasOnlyOneType or: [ t commonSuperclass ~= 'Object' ] ] ]))		allSatisfy: #yourself</body><body package="SmallSuiteGenerator-Info">isSimpleTyped7	"		"	^ (Array		with: receiver hasOnlyOneType		with:			(returnType hasOnlyOneType not				and: [ returnType commonSuperclass = 'Object' ])		with: (argTypes isNil or: [ argTypes allSatisfy: #hasOnlyOneType ]))		allSatisfy: #yourself</body><body package="SmallSuiteGenerator-Info">isSimpleTyped8	"		"	^ (Array		with: receiver hasOnlyOneType		with:			(returnType hasOnlyOneType not				and: [ returnType commonSuperclass ~= 'Object' ])		with: (argTypes isNil or: [ argTypes allSatisfy: #hasOnlyOneType ]))		allSatisfy: #yourself</body><body package="SmallSuiteGenerator-Info">isSimpleTyped9	"		"	^ (Array		with:			(receiver hasOnlyOneType not				and: [ receiver commonSuperclass ~= 'Object' ])		with:			(returnType hasOnlyOneType not				and: [ returnType commonSuperclass ~= 'Object' ])		with:			(argTypes notNil				and: [ argTypes anySatisfy: [ :t | t hasOnlyOneType not ] ])		with:			(argTypes notNil				and: [ argTypes						allSatisfy: [ :t | t hasOnlyOneType or: [ t commonSuperclass ~= 'Object' ] ] ]))		allSatisfy: #yourself</body><body package="SmallSuiteGenerator-Info">returnTypeFor: aReceiver	^ self isSimpleTyped2		ifTrue: [ "it is the same than his father" aReceiver returnType ]		ifFalse: [ "it return one random" self returnType type ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id> <category>actions</category><body package="SmallSuiteGenerator-Info">joinWith: otherTypeMethod	argTypes		ifNotNil: [ argTypes				with: otherTypeMethod argTypes				do: [ :argType :otherArgType | argType joinWith: otherArgType ] ].	returnType joinWith: otherTypeMethod returnType</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Info">allArgTypes	argTypes ifNil: [ ^ #() ].	^ argTypes flatCollect: [ :arg | arg types ]</body><body package="SmallSuiteGenerator-Info">allReceivers	^ receiver types</body><body package="SmallSuiteGenerator-Info">argTypes	^ argTypes</body><body package="SmallSuiteGenerator-Info">argTypes: anObject	argTypes := anObject</body><body package="SmallSuiteGenerator-Info">dataCSV	^ Array		with: selector		withAll:			(OrderedCollection new				add: receiver types asArray;				add: receiver commonSuperclass;				add:					(argTypes						ifNil: [ #() ]						ifNotNil: [ (argTypes collect: [ :argType | argType types asArray ]) asArray ]);				add:					(argTypes						ifNil: [ '' ]						ifNotNil: [ argTypes collect: [ :argType | argType commonSuperclass ] ]);				add: returnType types asArray;				add: returnType commonSuperclass;				yourself)</body><body package="SmallSuiteGenerator-Info">isDeprecated	^ isDeprecated</body><body package="SmallSuiteGenerator-Info">isDeprecated: anObject	isDeprecated := anObject</body><body package="SmallSuiteGenerator-Info">isQuick	^ isQuick</body><body package="SmallSuiteGenerator-Info">isQuick: aBoolean	isQuick := aBoolean</body><body package="SmallSuiteGenerator-Info">receiver	^ receiver</body><body package="SmallSuiteGenerator-Info">receiver: anObject	receiver := anObject</body><body package="SmallSuiteGenerator-Info">returnType	^ returnType</body><body package="SmallSuiteGenerator-Info">returnType: anObject	returnType := anObject</body><body package="SmallSuiteGenerator-Info">selector	^ selector</body><body package="SmallSuiteGenerator-Info">selector: anObject	selector := anObject</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id> <category>testing</category><body package="SmallSuiteGenerator-Info">isFromReceiver: aClassName	^ receiver types includes: aClassName</body><body package="SmallSuiteGenerator-Info">isWithReturnType: aClassName	^ returnType types includes: aClassName</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id> <category>copying</category><body package="SmallSuiteGenerator-Info">copy	| copy |	copy := self class instance.	copy		selector: selector;		isQuick: isQuick;		isDeprecated: isDeprecated;		returnType: returnType copy;		argTypes: argTypes copy;		receiver: receiver copy.	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Info">= other	^ self class = other class		and: [ selector = other selector				and: [ receiver = other receiver						and: [ returnType = other returnType								and: [ argTypes = other argTypes and: [ isQuick = other isQuick ] ] ] ] ]</body><body package="SmallSuiteGenerator-Info">hash	^ selector hash		bitXor:			(receiver hash				bitXor: (returnType hash bitXor: (argTypes hash bitXor: isQuick hash)))</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id> <category>adding</category><body package="SmallSuiteGenerator-Info">addType: aType	argTypes do: [ :arg | arg type: aType ].	returnType type: aType</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Info">initialize	argTypes := #().	isQuick := false.	returnType := SMultiTypeInfo new.	receiver := SMultiTypeInfo new.	isDeprecated := false</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo class</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Info">selectorsFilter	^ self selectors		select: [ :aSelector | aSelector beginsWith: 'isSimpleTyped' ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeMethodInfo class</class-id> <category>accessing structure variables</category><body package="SmallSuiteGenerator-Info">type: aAssoc	| aValue |	aValue := aAssoc value.	^ self new		selector: aAssoc key;		receiver: (SMultiTypeInfo new: aValue first);		returnType: (SMultiTypeInfo new: aValue second);		argTypes: (aValue third collect: [ :aType | SMultiTypeInfo new: aType ]);		isQuick: aValue fourth	";		isDeprecated: aValue fifth"</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>accessing - read only</category><body package="SmallSuiteGenerator-Info">allMethods	^ methodTypes values , classMethodTypes values</body><body package="SmallSuiteGenerator-Info">classMethodOf: aSelector	^ classMethodTypes at: aSelector</body><body package="SmallSuiteGenerator-Info">methodOf: aSelector	^ methodTypes at: aSelector</body><body package="SmallSuiteGenerator-Info">reportFrequencyByFilter: aSelector	^ (self filteredMethodsBy: aSelector) size</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>actions</category><body package="SmallSuiteGenerator-Info">exportDataCSV: neoCSVWriter withFilter: aSymbol	self		writeDataCSV: neoCSVWriter		using: (self filteredMethodsBy: aSymbol)</body><body package="SmallSuiteGenerator-Info">joinWith: otherTypeClass	otherTypeClass methodTypes do: [ :aMethod | self addMethod: aMethod ].	otherTypeClass classMethodTypes		do: [ :aMethod | self addClassMethod: aMethod ]</body><body package="SmallSuiteGenerator-Info">typeClassMethod: aAssoc	self addClassMethod: (STypeMethodInfo type: aAssoc)</body><body package="SmallSuiteGenerator-Info">typeMethod: aAssoc	self addMethod: (STypeMethodInfo type: aAssoc)</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Info">classMethodTypes	^ classMethodTypes</body><body package="SmallSuiteGenerator-Info">filteredMethodsBy: aSymbol	^ (STypeMethodInfo selectorsFilter includes: aSymbol)		ifTrue: [ self allMethods select: aSymbol ]		ifFalse: [ self remainingOrAllMethods: aSymbol ]</body><body package="SmallSuiteGenerator-Info">methodTypes	^ methodTypes</body><body package="SmallSuiteGenerator-Info">remainingOrAllMethods: aSymbol	^ aSymbol = #others		ifTrue: [ | methods |			methods := self allMethods.			STypeMethodInfo selectorsFilter				do: [ :key | methods := methods reject: key ].			methods ]		ifFalse: [ self allMethods ]</body><body package="SmallSuiteGenerator-Info">typeName	^ typeName</body><body package="SmallSuiteGenerator-Info">typeName: anObject	typeName := anObject</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>private</category><body package="SmallSuiteGenerator-Info">accessMessages	^ self messagesAndAccessMessages select: #isQuick</body><body package="SmallSuiteGenerator-Info">factoryMessages	^ classMethodTypes values reject: [ :m | m selector = #basicNew ]</body><body package="SmallSuiteGenerator-Info">factoryMessagesFrom: aClassName	^ self factoryMessages		select: [ :factMessage | 			(factMessage isFromReceiver: aClassName)				and: [ factMessage isWithReturnType: aClassName ] ]</body><body package="SmallSuiteGenerator-Info">messages	^ self messagesAndAccessMessages reject: #isQuick</body><body package="SmallSuiteGenerator-Info">messagesAndAccessMessages	^ methodTypes values		select:			[ :methType | methType isDeprecated not and: [ methType returnType isNil not ] ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>adding</category><body package="SmallSuiteGenerator-Info">addClassMethod: methodTypeInfo	"methodTypeInfo typeInfo: typeInfo."	classMethodTypes		at: methodTypeInfo selector		ifPresent: [ :methInfo | methInfo joinWith: methodTypeInfo ]		ifAbsentPut: methodTypeInfo</body><body package="SmallSuiteGenerator-Info">addClassMethods: methodTypeInfos	methodTypeInfos		do: [ :aMethodType | self addClassMethod: aMethodType ]</body><body package="SmallSuiteGenerator-Info">addMethod: methodTypeInfo	"methodTypeInfo typeInfo: typeInfo."	methodTypes		at: methodTypeInfo selector		ifPresent: [ :methInfo | methInfo joinWith: methodTypeInfo ]		ifAbsentPut: [ methodTypeInfo ]</body><body package="SmallSuiteGenerator-Info">addMethods: methodTypeInfos	methodTypeInfos do: [ :aMethodType | self addMethod: aMethodType ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Info">= other	^ self class = other class		and: [ typeName = other typeName				and: [ methodTypes = other methodTypes						and: [ classMethodTypes = other classMethodTypes ] ] ]</body><body package="SmallSuiteGenerator-Info">hash	^ typeName hash		bitXor: (methodTypes hash bitXor: classMethodTypes hash)</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>copying</category><body package="SmallSuiteGenerator-Info">copy	| copy |	copy := self class instance.	methodTypes do: [ :methodType | copy addMethod: methodType copy ].	classMethodTypes		do: [ :classMethodType | copy addClassMethod: classMethodType copy ].	copy typeName: typeName.	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>writing</category><body package="SmallSuiteGenerator-Info">writeDataCSV: neoCSVWriter using: methods	methods		do: [ :aMethod | 			neoCSVWriter				nextPut: (Array with: typeName printString) , aMethod dataCSV ]</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Info">initialize	methodTypes := Dictionary new.	classMethodTypes := Dictionary new</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Info">newFrom: aClassName	^ self new typeName: aClassName</body></methods><methods><class-id>SmallSuiteGenerator.STypeClassInfo class</class-id> <category>accessing structure variables</category><body package="SmallSuiteGenerator-Info">type: aAssoc	| dataOfAllMethods inst dataMethods dataClassMethods |	inst := self new typeName: aAssoc key.	dataOfAllMethods := aAssoc value.	dataMethods := dataOfAllMethods first.	dataClassMethods := dataOfAllMethods second.	dataMethods do: [ :data | inst typeMethod: data ].	dataClassMethods do: [ :data | inst typeClassMethod: data ].	^ inst</body></methods><methods><class-id>SmallSuiteGenerator.SSTestRunner</class-id> <category>running</category><body package="SmallSuiteGenerator-Core">evaluate: aSTestCase	| node |	node := aSTestCase parseTree.	node body		addNode:			(SConfiguration rbParserClass				parseExpression: '^ self analyze: thisContext').	self compile: node.	^ self performTest</body><body package="SmallSuiteGenerator-Core">run: aSTestCase	self compile: aSTestCase parseTreeWithAssertions.	self setTestSelector: #performTest.	^ self run</body><body package="SmallSuiteGenerator-Core">runWithoutAssertions: aSTestCase	self compile: aSTestCase parseTree.	self setTestSelector: #performTest.	^ self run</body></methods><methods><class-id>SmallSuiteGenerator.SSTestRunner</class-id> <category>as yet unclassified</category><body package="SmallSuiteGenerator-Core">performTest	| _var0 _var1 _var2 _var3 _var4 _var5 |_var0 := Roassal.ROMondrianViewBuilder new._var1 := Roassal.ROEvent._var2 := Roassal.ROElement on: _var1._var3 := _var0 unsetShape._var4 := _var0 initialize._var5 := (Core.OrderedCollection new)			add: ROElement basicNew yourself;			add: ROElement basicNew yourself;			yourself.^self analyze: thisContext</body></methods><methods><class-id>SmallSuiteGenerator.SSTestRunner</class-id> <category>compiling</category><body package="SmallSuiteGenerator-Core">compile: aBlock	self class		compile:			'performTest	' , aBlock body formattedCode</body><body package="SmallSuiteGenerator-Core">compile: aBlock withName: symbol on: aClass	aClass		compile:			symbol asString , (String with: Character cr)				, aBlock body formattedCode</body></methods><methods><class-id>SmallSuiteGenerator.SSTestRunner</class-id> <category>test - instrumentation</category><body package="SmallSuiteGenerator-Core">analyze: aSmalltalkContext	"it takes an snapshot of the thisContext object"	| sContext |	sContext := SSExecutionContext new.	aSmalltalkContext tempNames		doWithIndex:			[ :varName :index | sContext at: varName put: (aSmalltalkContext namedTempAt: index) ].	^ sContext</body></methods><methods><class-id>SmallSuiteGenerator.SSTestRunner</class-id> <category>As yet unclassified</category><body package="SmallSuiteGenerator-Core">analyze: aSmalltalkContext	"it takes an snapshot of the thisContext object"	| sContext |	sContext := SSExecutionContext new.	aSmalltalkContext tempNames		doWithIndex:			[ :varName :index | sContext at: varName put: (aSmalltalkContext namedTempAt: index) ].	^ sContext</body></methods><methods><class-id>SmallSuiteGenerator.SSTestRunner</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Core">initialize	invariants := OrderedCollection new</body></methods><methods><class-id>SmallSuiteGenerator.SFoo</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Scenario">return: aType	^ aType</body><body package="SmallSuiteGenerator-Scenario">score	^ score</body><body package="SmallSuiteGenerator-Scenario">score: aNumber	score := aNumber</body></methods><methods><class-id>SmallSuiteGenerator.SFoo</class-id> <category>handling</category><body package="SmallSuiteGenerator-Scenario">returnCollection	| a |	a := OrderedCollection new.	^ a</body><body package="SmallSuiteGenerator-Scenario">returnFloat	| a |	a := 2.3.	^ a</body><body package="SmallSuiteGenerator-Scenario">returnNum	| a |	a := 4.	^ a</body><body package="SmallSuiteGenerator-Scenario">returnString	| a |	a := 'Hello'.	^ a</body></methods><methods><class-id>SmallSuiteGenerator.SFoo</class-id> <category>initailize-release</category><body package="SmallSuiteGenerator-Scenario">initialize	score := 0</body></methods><methods><class-id>SmallSuiteGenerator.SFoo class</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Scenario">score: aNumber	| ins |	ins := self new score: aNumber.	^ ins</body></methods><methods><class-id>SmallSuiteGenerator.SEventTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Scenario">testDiscount	| event |	event := SEvent new.	event price: 80.	event discount: 20.	self assert: event discount equals: 20.	self assert: event price equals: 64</body><body package="SmallSuiteGenerator-Scenario">testDiscountWithZeroPrice	| event |	event := SEvent new.	event discount: 20.	self assert: event discount equals: 0.	self assert: event price equals: 0</body><body package="SmallSuiteGenerator-Scenario">testPrice	| event |	event := SEvent new.	event price: 80.	self assert: event price equals: 80</body></methods><methods><class-id>SmallSuiteGenerator.SExpression</class-id> <category>mutation</category><body package="SmallSuiteGenerator-AST">insertAsParameter: aExpression using: aTestCase	^ aTestCase insertAsParameter: self copy after: aExpression</body><body package="SmallSuiteGenerator-AST">insertMethodMessage: expression using: aTestCase	self		error: 'cannot be inserted the methodMessage: ' , expression printString</body><body package="SmallSuiteGenerator-AST">insertOn: aTestCase	</body><body package="SmallSuiteGenerator-AST">insertRandomMessage: expression using: aTestCase	self		error: 'cannot be inserted the randomMessage: ' , expression printString</body><body package="SmallSuiteGenerator-AST">pickUpReferences: aExpression	^ #()</body><body package="SmallSuiteGenerator-AST">repairOn: aTestCase changing: aExpression	</body><body package="SmallSuiteGenerator-AST">replaceArgBy: expression	self		error: 'cannot be inserted: ' , expression printString , ' as parameter'</body><body package="SmallSuiteGenerator-AST">variablesWithId	^ #()</body></methods><methods><class-id>SmallSuiteGenerator.SExpression</class-id> <category>accessing</category><body package="SmallSuiteGenerator-AST">id	^ id</body><body package="SmallSuiteGenerator-AST">id: anObject	id := anObject</body><body package="SmallSuiteGenerator-AST">randomGenerator: anObject	randomGenerator := anObject</body><body package="SmallSuiteGenerator-AST">reference	^ self</body><body package="SmallSuiteGenerator-AST">referenceTo: aClassName	^ false</body><body package="SmallSuiteGenerator-AST">replaceBy: otherExpression	self subclassResponsibility</body><body package="SmallSuiteGenerator-AST">returnType	^ returnType</body><body package="SmallSuiteGenerator-AST">returnType: anObject	returnType := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SExpression</class-id> <category>testing</category><body package="SmallSuiteGenerator-AST">isFactoryMessage	^ false</body></methods><methods><class-id>SmallSuiteGenerator.SExpression</class-id> <category>error handling</category><body package="SmallSuiteGenerator-AST">error: aString	^ SError signal: aString</body></methods><methods><class-id>SmallSuiteGenerator.SExpression</class-id> <category>comparing</category><body package="SmallSuiteGenerator-AST">= other	^ self class = other class		and: [ self id = other id and: [ returnType = other returnType ] ]</body><body package="SmallSuiteGenerator-AST">hash	^ self id hash bitXor: self returnType hash</body><body package="SmallSuiteGenerator-AST">isPrimitive: anObject	^ (anObject isKindOf: Number)		or: [ (anObject isKindOf: Boolean) or: [ anObject isKindOf: String ] ]</body></methods><methods><class-id>SmallSuiteGenerator.SExpression</class-id> <category>actions</category><body package="SmallSuiteGenerator-AST">replaceExpression: expression by: newExpression	</body></methods><methods><class-id>SmallSuiteGenerator.SExpression</class-id> <category>copying</category><body package="SmallSuiteGenerator-AST">copy	^ self class new		id: self id;		returnType: self returnType</body></methods><methods><class-id>SmallSuiteGenerator.SExpression</class-id> <category>initialization</category><body package="SmallSuiteGenerator-AST">initialize	randomGenerator := SConfiguration randomGenerator</body></methods><methods><class-id>SmallSuiteGenerator.SExpression class</class-id> <category>error handling</category><body package="SmallSuiteGenerator-AST">error: string	^ SError signal: string</body></methods><methods><class-id>SmallSuiteGenerator.SExpression class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-AST">isPrimitive: anObject	^ self new isPrimitive: anObject</body></methods><methods><class-id>SmallSuiteGenerator.SEvent</class-id> <category>testing</category><body package="SmallSuiteGenerator-Scenario">canRegister: aPerson	^ aPerson canRegister: self</body></methods><methods><class-id>SmallSuiteGenerator.SEvent</class-id> <category>as yet unclassified</category><body package="SmallSuiteGenerator-Scenario">price: aNumber	price := aNumber</body></methods><methods><class-id>SmallSuiteGenerator.SEvent</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Scenario">discount	^ discount</body><body package="SmallSuiteGenerator-Scenario">discount: aNumber	price &gt; 0		ifTrue: [ discount := aNumber ]</body><body package="SmallSuiteGenerator-Scenario">price	^ price - (discount * price / 100)</body></methods><methods><class-id>SmallSuiteGenerator.SEvent</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Scenario">initialize	price := 0.	discount := 0</body></methods><methods><class-id>SmallSuiteGenerator.SEvent class</class-id> <category>as yet unclassified</category><body package="SmallSuiteGenerator-Scenario">price: aNumber	^ self new price: aNumber</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage</class-id> <category>accessing</category><body package="SmallSuiteGenerator-AST">args	^ args</body><body package="SmallSuiteGenerator-AST">args: anObject	args := anObject</body><body package="SmallSuiteGenerator-AST">id	^ receiver id</body><body package="SmallSuiteGenerator-AST">receiver	^ receiver</body><body package="SmallSuiteGenerator-AST">receiver: anObject	receiver := anObject</body><body package="SmallSuiteGenerator-AST">replaceBy: otherExpression	receiver replaceBy: otherExpression receiver.	self selector: otherExpression selector.	self args size = otherExpression args size		ifTrue: [ self args				with: otherExpression args				do: [ :arg :newArg | arg replaceBy: newArg ] ]		ifFalse: [ self args: otherExpression args deepCopy ]</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage</class-id> <category>As yet unclassified</category><body package="SmallSuiteGenerator-AST">replaceBy: otherExpression	receiver replaceBy: otherExpression receiver.	self selector: otherExpression selector.	self args size = otherExpression args size		ifTrue: [ self args				with: otherExpression args				do: [ :arg :newArg | arg replaceBy: newArg ] ]		ifFalse: [ self args: otherExpression args deepCopy ]</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage</class-id> <category>accessing</category><body package="SmallSuiteGenerator-AST">selector	^ selector</body><body package="SmallSuiteGenerator-AST">selector: anObject	selector := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage</class-id> <category>mutation</category><body package="SmallSuiteGenerator-AST">changeArgsFrom: expression in: aTestCase	args isEmpty		ifTrue: [ ^ self error: 'Cannot change args from: ' , self selector ].	args do: [ :arg | arg repairOn: aTestCase changing: expression ]</body><body package="SmallSuiteGenerator-AST">changeReceiverFrom: expression in: aTestCase	receiver repairOn: aTestCase changing: expression</body><body package="SmallSuiteGenerator-AST">insertRandomMessage: expression using: aTestCase	^ aTestCase insertExpression: self copy after: expression</body><body package="SmallSuiteGenerator-AST">pickUpReferences: aExpression	^ (receiver pickUpReferences: aExpression)		, (args flatCollect: [ :arg | arg pickUpReferences: aExpression ])</body><body package="SmallSuiteGenerator-AST">repairOn: aTestCase changing: expression	(randomGenerator		collectAtRandom: #(#changeReceiverFrom:in: #changeSelectorFrom:in: #changeArgsFrom:in:))		do: [ :aSelector | 			[ ^ self				perform: aSelector				withArguments: (Array with: expression with: aTestCase) ]				on: SError				do: [  ] ].	self error: 'Cannot change the statement: ' , expression printString</body><body package="SmallSuiteGenerator-AST">replaceArgBy: expression	args		ifEmpty: [ self error: self printString , ' does not have args to replace.' ].	args		do: [ :arg | 			[ ^ arg replaceArgBy: expression ]				on: SError				do: [  ] ].	self		error: 'Cannot replace any argument by: ' , expression printString</body><body package="SmallSuiteGenerator-AST">variablesWithId	^ receiver variablesWithId		, (args flatCollect: [ :arg | arg variablesWithId ])</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage</class-id> <category>override</category><body package="SmallSuiteGenerator-AST">changeSelectorFrom: aExpression in: aTestCase	^ self subclassResponsibility</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage</class-id> <category>printing</category><body package="SmallSuiteGenerator-AST">printOn: aStream	receiver printOn: aStream.	aStream nextPut: Character space.	self printSelectors: aStream</body><body package="SmallSuiteGenerator-AST">printSelectors: aStream	args		ifEmpty: [ aStream nextPutAll: self selector ]		ifNotEmpty: [ | withColon index stop |			withColon := self selector includes: $:.			index := 0.			stop := self args size.			(self selector substrings: ':')				with: self args				do: [ :selectorPart :arg | 					index := index + 1.					aStream nextPutAll: selectorPart.					withColon						ifTrue: [ aStream nextPutAll: ': ' ].					aStream nextPutAll: arg printString.					(index &lt; stop and: [ withColon ])						ifTrue: [ aStream nextPut: Character space ] ] ]</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage</class-id> <category>actions</category><body package="SmallSuiteGenerator-AST">replaceExpression: anExpression by: newExpression	receiver replaceExpression: anExpression by: newExpression.	args		do: [ :arg | arg replaceExpression: anExpression by: newExpression ]</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage</class-id> <category>comparing</category><body package="SmallSuiteGenerator-AST">= other	^ super = other		and: [ args = other args				and: [ receiver = other receiver and: [ selector = other selector ] ] ]</body><body package="SmallSuiteGenerator-AST">hash	^ super hash xor: (receiver hash xor: (selector hash xor: args hash))</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage</class-id> <category>copying</category><body package="SmallSuiteGenerator-AST">copy	| copy |	copy := super copy.	copy		args: args deepCopy;		receiver: receiver copy;		selector: selector copy.	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage</class-id> <category>initialization</category><body package="SmallSuiteGenerator-AST">initialize	super initialize.	args := OrderedCollection new: 2</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage class</class-id> <category>creation</category><body package="SmallSuiteGenerator-AST">args: aMethodTypeInfo with: statements	| dict randomGenerator |	(statements isEmpty or: [ aMethodTypeInfo argTypes isNil ])		ifTrue: [ ^ #() ].	randomGenerator := SConfiguration randomGenerator.	dict := Dictionary new.	(randomGenerator collectAtRandom: statements)		do: [ :stm | dict at: stm returnType put: stm variable copy ].	^ aMethodTypeInfo argTypes		collect: [ :aTypeReturn | 			| ft |			ft := (randomGenerator collectAtRandom: aTypeReturn types)				detect: [ :type | dict at: type ifPresent: [ true ] ifAbsent: [ false ] ]				ifNone: [ nil ].	"lack to update types of MultiTypeInfo"			ft				ifNil: [ self						error:							'Cannot build the method call: ' , aMethodTypeInfo selector								, ', even it was tried to build the argument first' ].			dict at: ft ]</body></methods><methods><class-id>SmallSuiteGenerator.SParty</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Scenario">date	^ date</body><body package="SmallSuiteGenerator-Scenario">date: anObject	date := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SSPerson</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Scenario">age: aNumber	^ aNumber</body><body package="SmallSuiteGenerator-Scenario">id	^ id</body><body package="SmallSuiteGenerator-Scenario">id: anObject	id := anObject</body><body package="SmallSuiteGenerator-Scenario">identifier	^ name , id printString</body><body package="SmallSuiteGenerator-Scenario">name	^ name</body><body package="SmallSuiteGenerator-Scenario">name: anObject	name := anObject</body><body package="SmallSuiteGenerator-Scenario">nickname	self subclassResponsibility</body><body package="SmallSuiteGenerator-Scenario">nickname: anObject	nickname := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SSPerson</class-id> <category>testing</category><body package="SmallSuiteGenerator-Scenario">canRegister: aConference	^ aConference price - aConference offerPrice		&gt; (aConference price * 0.05)</body></methods><methods><class-id>SmallSuiteGenerator.SSPerson</class-id> <category>as yet unclassified</category><body package="SmallSuiteGenerator-Scenario">fullIdentifier	^ name , '_' , nickname , '_' , id printString</body></methods><methods><class-id>SmallSuiteGenerator.SSPerson class</class-id> <category>as yet unclassified</category><body package="SmallSuiteGenerator-Scenario">name: aString	| inst |	inst := self new		name: aString;		id: 1;		nickname: aString.	^ inst</body><body package="SmallSuiteGenerator-Scenario">name: aString with: aNumber	| inst |	inst := self new		name: aString;		id: aNumber;		nickname: aString.	^ inst</body></methods><methods><class-id>SmallSuiteGenerator.SMessage</class-id> <category>mutation</category><body package="SmallSuiteGenerator-AST">insertMethodMessage: aExpression using: aTestCase	^ self insertRandomMessage: aExpression using: aTestCase</body><body package="SmallSuiteGenerator-AST">insertOn: aTestCase	^ aTestCase addMessage: self selector from: self receiver returnType</body></methods><methods><class-id>SmallSuiteGenerator.SMessage</class-id> <category>override</category><body package="SmallSuiteGenerator-AST">changeSelectorFrom: aExpression in: aTestCase	| otherMessage |	otherMessage := aTestCase		alternativeMessage: self		before: aExpression.	self selector: otherMessage selector.	self args: otherMessage args</body></methods><methods><class-id>SmallSuiteGenerator.SMessage class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-AST">newFromReceiver: aReceiver method: aMethod andPreviousStatements: statements	^ SMessage new		returnType: (aMethod returnTypeFor: aReceiver);		selector: aMethod selector;		receiver: aReceiver;		args: (self args: aMethod with: statements);		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SSTeacher</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Scenario">idTeacher	^ idTeacher</body><body package="SmallSuiteGenerator-Scenario">nickname	^ 'teacher_' , (nickname ifNil: [ '1' ])</body><body package="SmallSuiteGenerator-Scenario">yearsWorkExperience	^ yearsWorkExperience</body><body package="SmallSuiteGenerator-Scenario">yearsWorkExperience: anObject	yearsWorkExperience := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SSTeacher</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Scenario">initialize	idTeacher := 100 + (id ifNil: [ 0 ]).	yearsWorkExperience := 0</body></methods><methods><class-id>SmallSuiteGenerator.SAssertionMessage</class-id> <category>override</category><body package="SmallSuiteGenerator-AST">changeSelectorFrom: aExpression in: aTestCase	"not sure what it should return"	</body></methods><methods><class-id>SmallSuiteGenerator.SAssertionMessage</class-id> <category>printing</category><body package="SmallSuiteGenerator-AST">printOn: stream	super printOn: stream.	stream nextPut: $.</body></methods><methods><class-id>SmallSuiteGenerator.SAssertionMessage</class-id> <category>initialization</category><body package="SmallSuiteGenerator-AST">initialize	super initialize.	receiver := SSelf new</body></methods><methods><class-id>SmallSuiteGenerator.SAssertionMessage class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-AST">for: aExecutionContext	^ self subclassResponsibility</body></methods><methods><class-id>SmallSuiteGenerator.SPrimitiveAssertion class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-AST">for: anExecutionContext	^ anExecutionContext associations		select: [ :assoc | self isPrimitive: assoc value ]		thenCollect: [ :assoc | 			self new				selector: #assert:equals:;				args:					(Array						with: (SVariable name: assoc key)						with: (SLiteral new value: assoc value));				yourself ]</body></methods><methods><class-id>SmallSuiteGenerator.SConference</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Scenario">date	^ date</body><body package="SmallSuiteGenerator-Scenario">date: anObject	date := anObject</body><body package="SmallSuiteGenerator-Scenario">offerPrice	^ offerPrice</body><body package="SmallSuiteGenerator-Scenario">offerPrice: aNumber	offerPrice := aNumber</body><body package="SmallSuiteGenerator-Scenario">speaker	^ speaker</body><body package="SmallSuiteGenerator-Scenario">speaker: anObject	speaker := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SConference</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Scenario">initialize	price := 100.	discount := 0.	offerPrice := price.	date := Date today</body></methods><methods><class-id>SmallSuiteGenerator.SStringAssertion class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-AST">for: anExecutionContext	^ (anExecutionContext associations		reject: [ :assoc | self isPrimitive: assoc value ])		collect: [ :assoc | self stringAssertionsOf: assoc ]		thenSelect: [ :stringAssertion | stringAssertion isNil not ]</body><body package="SmallSuiteGenerator-AST">stringAssertionsOf: assoc	| aValue |	aValue := assoc value.	^ (aValue class allSelectorsBelow: Object)		detect: [ :aSelector | aSelector = #printOn: or: [ aSelector = #asString ] ]		ifFound: [ | fieldValue |			[ fieldValue := aValue perform: #printString.			self new				selector: #assert:equals:;				args:					(Array						with:							(SMessage new								receiver: (SVariable name: assoc key);								selector: #printString;								yourself)						with: (SLiteral new value: fieldValue));				yourself ]				on: Error				do: [ Transcript						show: aValue class name , ' cant answer printString without error' ] ]		ifNone: [ nil ]</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractClass</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Scenario2">id	^ id</body><body package="SmallSuiteGenerator-Scenario2">id: anObject	id := anObject</body><body package="SmallSuiteGenerator-Scenario2">identifier	^ self subclassResponsibility</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractClass</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Scenario2">initialize	id := 1</body></methods><methods><class-id>SmallSuiteGenerator.SSubclassChild</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Scenario2">identifier	^ self className , '_' , self id asString</body></methods><methods><class-id>SmallSuiteGenerator.SAssignment</class-id> <category>mutation</category><body package="SmallSuiteGenerator-AST">insertAsParameter: aExpression using: aTestCase	^ variable insertAsParameter: aExpression using: aTestCase</body><body package="SmallSuiteGenerator-AST">insertMethodMessage: aExpression using: aTestCase	^ value insertMethodMessage: aExpression using: aTestCase</body><body package="SmallSuiteGenerator-AST">insertOn: aTestCase	^ value insertOn: aTestCase</body><body package="SmallSuiteGenerator-AST">insertRandomMessage: aExpression using: aTestCase	^ value insertRandomMessage: aExpression using: aTestCase</body><body package="SmallSuiteGenerator-AST">pickUpReferences: aExpression	^ value pickUpReferences: aExpression</body><body package="SmallSuiteGenerator-AST">repairOn: aTestCase changing: expression	self reference = expression reference		ifTrue: [ value repairOn: aTestCase changing: expression ]</body><body package="SmallSuiteGenerator-AST">replaceArgBy: expression	value replaceArgBy: expression</body><body package="SmallSuiteGenerator-AST">variablesWithId	^ variable variablesWithId , value variablesWithId</body></methods><methods><class-id>SmallSuiteGenerator.SAssignment</class-id> <category>accessing</category><body package="SmallSuiteGenerator-AST">id	^ variable id</body><body package="SmallSuiteGenerator-AST">reference	^ variable</body><body package="SmallSuiteGenerator-AST">referenceTo: aClassName	^ value referenceTo: aClassName</body><body package="SmallSuiteGenerator-AST">replaceBy: aExpression	self reference = aExpression reference		ifTrue: [ value replaceBy: aExpression value ]</body><body package="SmallSuiteGenerator-AST">value: anObject	value := anObject</body><body package="SmallSuiteGenerator-AST">variable	^ variable</body><body package="SmallSuiteGenerator-AST">variable: anObject	variable := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SAssignment</class-id> <category>evaluating</category><body package="SmallSuiteGenerator-AST">value	^ value</body></methods><methods><class-id>SmallSuiteGenerator.SAssignment</class-id> <category>printing</category><body package="SmallSuiteGenerator-AST">printOn: aStream	variable printOn: aStream.	aStream nextPutAll: ' := '.	value printOn: aStream.	aStream nextPut: $.</body></methods><methods><class-id>SmallSuiteGenerator.SAssignment</class-id> <category>actions</category><body package="SmallSuiteGenerator-AST">replaceExpression: expression by: newExpression	value replaceExpression: expression by: newExpression</body></methods><methods><class-id>SmallSuiteGenerator.SAssignment</class-id> <category>comparing</category><body package="SmallSuiteGenerator-AST">= other	^ super = other		and: [ variable = other variable and: [ value = other value ] ]</body><body package="SmallSuiteGenerator-AST">hash	^ super hash xor: (variable hash xor: value hash)</body></methods><methods><class-id>SmallSuiteGenerator.SAssignment</class-id> <category>copying</category><body package="SmallSuiteGenerator-AST">copy	| copy |	copy := super copy.	copy		variable: variable copy;		value: value copy.	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.SAssignment class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-AST">name: aVariable value: anExpression	^ self new		variable: aVariable;		value: anExpression;		returnType: anExpression returnType;		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SStudent</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Scenario2">idStudent	^ idStudent</body><body package="SmallSuiteGenerator-Scenario2">nickname	^ 'student_' , (nickname ifNil: [ '1' ])</body><body package="SmallSuiteGenerator-Scenario2">scoreStudent	^ scoreStudent</body><body package="SmallSuiteGenerator-Scenario2">scoreStudent: aNumber	scoreStudent := aNumber</body></methods><methods><class-id>SmallSuiteGenerator.SStudent</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Scenario2">initialize	id := 1.	scoreStudent := 1.	idStudent := id</body></methods><methods><class-id>SmallSuiteGenerator.SMutatorTestCaseTest</class-id> <category>running</category><body package="SmallSuiteGenerator-Tests-Core">setUp	utility := SUtilityTypeInfo new</body></methods><methods><class-id>SmallSuiteGenerator.SMutatorTestCaseTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-Core">testRemoveArgsMethod	| testCase expression numExprsBefore numExprsAfter |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: #SFoo;		addMessage: #return: from: #SFoo.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := 7.3.' '_var1 := SFoo score: _var0.' '_var2 := ''hello''.' '_var3 := _var1 return: _var2.').	numExprsBefore := testCase numberStatements.	expression := testCase statementOfVarName: '_var2'.	testCase removeExpression: expression.	numExprsAfter := testCase numberStatements.	self assert: numExprsAfter equals: numExprsBefore</body><body package="SmallSuiteGenerator-Tests-Core">testRemoveExpression	| testCase expression |	testCase := SSTestCase with: utility typeInfoSFoo1.	expression := testCase addLiteral.	testCase removeExpression: expression.	self assert: testCase statements isEmpty</body><body package="SmallSuiteGenerator-Tests-Core">testRemoveExpressionWithoutRepairing	| testCase expression |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: #SFoo;		addMessage: #return: from: #SFoo.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := 7.3.' '_var1 := SFoo score: _var0.' '_var2 := ''hello''.' '_var3 := _var1 return: _var2.').	expression := testCase statementOfVarName: '_var2'.	testCase removeExpressionWithoutRepairing: expression.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 7.3.' '_var1 := SFoo score: _var0.')</body><body package="SmallSuiteGenerator-Tests-Core">testRemoveInEmptyTestCase	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	self should: [ testCase removeExpression: nil ] raise: SError</body><body package="SmallSuiteGenerator-Tests-Core">testRepair	| testCase expression |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: #SFoo;		addMessage: #return: from: #SFoo.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := 7.3.' '_var1 := SFoo score: _var0.' '_var2 := ''hello''.' '_var3 := _var1 return: _var2.').	expression := testCase statementOfVarName: '_var2'.	self should: [ testCase repair: expression ] raise: SError.	testCase removeFromStatements: expression.	self assert: (testCase repair: expression) isEmpty.	expression := testCase statementOfVarName: '_var3'.	self		assertCollection: (expression value args collect: #printString)		hasSameElements: #('_var4').	self		assert:			(((testCase subStatementsFrom: 1 toPrevIndexOf: expression)				collect: #printString)				includesAny: #('_var4 := ''hello''.' '_var4 := _var1 returnString.'))</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCaseTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-Core">setUp	utility := SUtilityTypeInfo new.	SConfiguration fileLogger: 'STestCaseTestLogger.log'</body><body package="SmallSuiteGenerator-Tests-Core">testCopy	| testCase typeInfo otherTestCase |	typeInfo := STypeInfo new		type:			#SFoo				-&gt;					(Array						with:							(Array								with: #returnNum -&gt; #(#SFoo #SmallInteger #() false)								with: #returnFloat -&gt; #(#SFoo #SmallFloat64 #() false)								with: #score -&gt; #(#SFoo #SmallInteger #() true)								with: #return: -&gt; #(#SFoo #ByteString #(#ByteString) false))						with: (Array with: #score: -&gt; #(#SFoo #SFoo #(#SmallFloat64) false))).	typeInfo scalar: #ByteString with: #('hello').	typeInfo scalar: #SmallInteger with: #(5).	typeInfo scalar: #SmallFloat64 with: #(7.3).	testCase := SSTestCase with: typeInfo.	testCase		addTargetClassName: #SFoo;		addMessage: #returnNum from: #SFoo;		addFieldAccessMessage: #score from: #SFoo;		addLiteral: #SmallInteger.	otherTestCase := testCase copy.	self assert: testCase numberStatements equals: 5.	self assert: testCase equals: otherTestCase.	self		assertCollection: testCase targetClassesNames		hasSameElements: #(#SFoo).	testCase addLiteral: #ByteString.	otherTestCase addMessage: #returnFloat from: #SFoo.	otherTestCase addMessage: #return: from: #SFoo.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := 7.3.' '_var1 := SFoo score: _var0.' '_var2 := _var1 returnNum.' '_var3 := _var1 score.' '_var4 := 5.' '_var5 := ''hello''.').	self		assertCollection: (otherTestCase statements collect: #printString)		hasSameElements:			#('_var0 := 7.3.' '_var1 := SFoo score: _var0.' '_var2 := _var1 returnNum.' '_var3 := _var1 score.' '_var4 := 5.' '_var5 := _var1 returnFloat.' '_var6 := ''hello''.' '_var7 := _var1 return: _var6.')</body><body package="SmallSuiteGenerator-Tests-Core">testFieldAccessMessage	| testCase |	testCase := SSTestCase		with:			(STypeInfo new				type:					#SFoo						-&gt;							(Array								with:									(Array										with: #score -&gt; #(#SFoo #SmallInteger #() true)										with: #score: -&gt; #(#SFoo #SmallInteger #(#SmallInteger) false))								with: (Array with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false)));				scalar: #SmallInteger with: #(5)).	testCase		addTargetClassName: #SFoo;		addFieldAccessMessage.	self assert: testCase statements size equals: 3.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 5.' '_var1 := SFoo score: _var0.' '_var2 := _var1 score.')</body><body package="SmallSuiteGenerator-Tests-Core">testGenerateStatements	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: #SFoo;		numMaxStatements: 30.	self shouldnt: [ testCase generateStatements ] raise: SError</body><body package="SmallSuiteGenerator-Tests-Core">testPickAccessorsOf	| testCase |	testCase := SSTestCase new.	testCase typeInfo: utility typeInfoOnPackage1.	self assert: (testCase pickAccessorsOf: #SEvent) isEmpty.	self		assertCollection: ((testCase pickAccessorsOf: #SConference) collect: #selector)		hasSameElements: #(#discount #offerPrice)</body><body package="SmallSuiteGenerator-Tests-Core">testPickMessagesOf	| testCase |	testCase := SSTestCase new.	testCase typeInfo: utility typeInfoOnPackage1.	self assert: (testCase pickMessagesOf: #SEvent) isEmpty.	self		assertCollection: ((testCase pickMessagesOf: #SConference) collect: #selector)		hasSameElements: #(#initialize #offerPrice: #canRegister: #price)</body></methods><methods><class-id>SmallSuiteGenerator.SSTestCaseTest</class-id> <category>running</category><body package="SmallSuiteGenerator-Tests-Core">tearDown	"SConfiguration clearFileLog: 'STestCaseTestLogger.log'"	</body></methods><methods><class-id>SmallSuiteGenerator.SComparisonAssertion class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-AST">comparisonAssertion: anExecutionContext with: array	| varName1 varName2 val1 val2 |	varName1 := array first.	varName2 := array second.	val1 := anExecutionContext at: varName1.	val2 := anExecutionContext at: varName2.	val1 class = val2 class		ifTrue: [ (val1 class allSelectorsBelow: Object)				detect: [ :selector | selector = #= ]				ifFound: [ | selector |					selector := val1 = val2						ifTrue: [ #assert:equals: ]						ifFalse: [ #deny:equals: ].					^ self new						selector: selector;						args:							(Array								with: (SVariable name: varName1)								with: (SVariable name: varName2));						yourself ] ].	^ nil</body><body package="SmallSuiteGenerator-AST">for: anExecutionContext	| assertions |	assertions := OrderedCollection new.	anExecutionContext keys		combinations: 2		atATimeDo: [ :comb | 			| compareAssert |			compareAssert := self				comparisonAssertion: anExecutionContext				with: comb.			compareAssert ifNotNil: [ assertions add: compareAssert ] ].	^ assertions</body></methods><methods><class-id>SmallSuiteGenerator.SRemoveTest</class-id> <category>mutation-remove</category><body package="SmallSuiteGenerator-Tests-Core">testRemoveArgsFactoryMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: #SFoo;		addFactoryMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 7.3.' '_var1 := SFoo score: _var0.').	testCase removeStatementOfVarName: '_var0'.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var2 := 7.3.' '_var1 := SFoo score: _var2.').	self assert: testCase validReferences</body><body package="SmallSuiteGenerator-Tests-Core">testRemoveArgsMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: #SFoo;		addMessage: #return: from: #SFoo.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := 7.3.' '_var1 := SFoo score: _var0.' '_var2 := ''hello''.' '_var3 := _var1 return: _var2.').	testCase removeStatementOfVarName: '_var2'.	self		assert:			(#('_var4 := ''hello''.' '_var4 := _var1 returnString.')				includes: (testCase statementOfVarName: '_var4') printString).	self		assert: (testCase statementOfVarName: '_var3') printString		equals: '_var3 := _var1 return: _var4.'.	self assert: testCase validReferences</body><body package="SmallSuiteGenerator-Tests-Core">testRemoveFactoryMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: #SFoo;		addFactoryMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 7.3.' '_var1 := SFoo score: _var0.').	testCase removeStatementOfVarName: '_var1'.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 7.3.')</body><body package="SmallSuiteGenerator-Tests-Core">testRemoveFieldAccessMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: #SFoo;		addFieldAccessMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := 7.3.' '_var1 := SFoo score: _var0.' '_var2 := _var1 score.').	testCase removeStatementOfVarName: '_var2'.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 7.3.' '_var1 := SFoo score: _var0.')</body><body package="SmallSuiteGenerator-Tests-Core">testRemoveMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: #SFoo;		addMessage: #return: from: #SFoo.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := 7.3.' '_var1 := SFoo score: _var0.' '_var2 := ''hello''.' '_var3 := _var1 return: _var2.').	testCase removeStatementOfVarName: '_var3'.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 7.3.' '_var1 := SFoo score: _var0.' '_var2 := ''hello''.')</body><body package="SmallSuiteGenerator-Tests-Core">testRemoveReceiverFieldAccessMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: #SFoo;		addFieldAccessMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := 7.3.' '_var1 := SFoo score: _var0.' '_var2 := _var1 score.').	testCase removeStatementOfVarName: '_var1'.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := 7.3.' '_var3 := SFoo score: _var0.' '_var2 := _var3 score.')</body><body package="SmallSuiteGenerator-Tests-Core">testRemoveReceiverMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: #SFoo;		addMessage: #return: from: #SFoo.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := 7.3.' '_var1 := SFoo score: _var0.' '_var2 := ''hello''.' '_var3 := _var1 return: _var2.').	testCase removeStatementOfVarName: '_var1'.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := 7.3.' '_var4 := SFoo score: _var0.' '_var2 := ''hello''.' '_var3 := _var4 return: _var2.')</body><body package="SmallSuiteGenerator-Tests-Core">testRemoveStatementNoRepairing	| testCase statement |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: #SFoo.	statement := testCase addFactoryMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 7.3.' '_var1 := SFoo score: _var0.').	testCase removeStatementNoRepairing: statement.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 7.3.').	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: #SFoo.	statement := testCase addFactoryMessage.	testCase addMessage: #returnFloat from: #SFoo.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := 7.3.' '_var1 := SFoo score: _var0.' '_var2 := _var1 returnFloat.').	testCase removeStatementNoRepairing: statement.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 7.3.')</body></methods><methods><class-id>SmallSuiteGenerator.SConfigurationTest</class-id> <category>running</category><body package="SmallSuiteGenerator-Tests-Core">tearDown	SConfiguration clearLog.	SConfiguration cleanAllLogs</body></methods><methods><class-id>SmallSuiteGenerator.SConfigurationTest</class-id> <category>as yet unclassified</category><body package="SmallSuiteGenerator-Tests-Core">testFileLogger	self		shouldnt: (SConfiguration fileLogger: 'STestLog.log')		raise: Error</body></methods><methods><class-id>SmallSuiteGenerator.SFactoryMessage</class-id> <category>mutation</category><body package="SmallSuiteGenerator-AST">insertOn: aTestCase	^ aTestCase		addFactoryMessage: self returnType		ofSelector: self selector</body></methods><methods><class-id>SmallSuiteGenerator.SFactoryMessage</class-id> <category>override</category><body package="SmallSuiteGenerator-AST">changeSelectorFrom: aExpression in: aTestCase	| otherFactoryMessage |	otherFactoryMessage := aTestCase		alternativeFactoryMessage: self		before: aExpression.	self selector: otherFactoryMessage selector.	self args: otherFactoryMessage args</body></methods><methods><class-id>SmallSuiteGenerator.SFactoryMessage</class-id> <category>testing</category><body package="SmallSuiteGenerator-AST">isFactoryMessage	^ true</body></methods><methods><class-id>SmallSuiteGenerator.SFactoryMessage</class-id> <category>accessing</category><body package="SmallSuiteGenerator-AST">referenceTo: aClassName	^ receiver referenceTo: aClassName</body></methods><methods><class-id>SmallSuiteGenerator.SFactoryMessage class</class-id> <category>accessing</category><body package="SmallSuiteGenerator-AST">default: aClassName	^ self new		receiver:			(SVariable new				varName: aClassName;				returnType: aClassName;				yourself);		selector: #new;		returnType: aClassName;		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SFactoryMessage class</class-id> <category>creation</category><body package="SmallSuiteGenerator-AST">method: aMethodTypeInfo class: aClassName previousStatements: statements	^ self new		receiver:			(SVariable new				varName: aClassName;				returnType: aClassName;				yourself);		returnType: aClassName;		selector: aMethodTypeInfo selector;		args: (self args: aMethodTypeInfo with: statements);		yourself</body><body package="SmallSuiteGenerator-AST">method: aMethodTypeInfo previousStatements: statements	| returnType |	returnType := aMethodTypeInfo returnType type.	^ self new		receiver:			(SVariable new				varName: returnType;				returnType: returnType;				yourself);		returnType: returnType;		selector: aMethodTypeInfo selector;		args: (self args: aMethodTypeInfo with: statements);		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifterTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-Core">testAddAssignment	| testCase expression |	testCase := SSTestCase new.	expression := testCase addAssignment: (SLiteral new value: 3).	self assert: expression printString equals: '_var0 := 3.'.	expression := testCase		addAssignment:			(SMessage new				receiver: (SVariable new id: 0);				selector: #foo;				yourself).	self assert: expression printString equals: '_var1 := _var0 foo.'</body><body package="SmallSuiteGenerator-Tests-Core">testAddFactoryMessage	| testCase aTypeInfo |	aTypeInfo := utility typeInfoSFoo3.	testCase := SSTestCase with: aTypeInfo.	testCase		addTargetClassName: #SFoo;		addFactoryMessage: #SFoo.	self assert: testCase statements size equals: 2.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 4.' '_var1 := SFoo score: _var0.').	self should: [ testCase addFactoryMessage: #SStack ] raise: SError.	aTypeInfo		type:			#SStack				-&gt;					(Array						with: (Array with: #top -&gt; #(#SStack nil #() false))						with: (Array with: #newStack: -&gt; #(#SStack #SStack #(#Array) false)));		scalar: #Array with: #(#(1 3 2)).	testCase		addTargetClassName: #SStack;		addFactoryMessage: #SStack.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := 4.' '_var1 := SFoo score: _var0.' '_var2 := #(1 3 2 ).' '_var3 := SStack newStack: _var2.')</body><body package="SmallSuiteGenerator-Tests-Core">testAddFactoryMessageOfInexistentSelector	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo2.	testCase		addTargetClassName: #SFoo;		addFactoryMessage: #SFoo ofSelector: #score:.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := SFoo new.')</body><body package="SmallSuiteGenerator-Tests-Core">testAddFactoryMessageOfSelector	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo3.	testCase		addTargetClassName: #SFoo;		addFactoryMessage: #SFoo ofSelector: #score:.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 4.' '_var1 := SFoo score: _var0.')</body><body package="SmallSuiteGenerator-Tests-Core">testAddFactoryMessageOnPackage	| testCase expression |	testCase := SSTestCase with: utility typeInfoOnPackage3.	self should: [ testCase addFactoryMessage: #SSTeacher ] raise: SError.	testCase addTargetClassName: #SSTeacher.	expression := testCase addFactoryMessage: #SSTeacher.	self		assert:			(#('_var2 := SSTeacher name: _var0 with: _var1.' '_var2 := SSTeacher name: _var1 with: _var0.')				includes: expression printString).	self		shouldnt: [ expression := testCase addFactoryMessage: #SConference ]		raise: SError.	self		assert: expression printString		equals: '_var3 := SConference new.'</body><body package="SmallSuiteGenerator-Tests-Core">testAddFactoryMessageWithAbstractClasses	| testCase |	testCase := SSTestCase with: utility typeInfoSSPerson1.	self should: [ testCase addFactoryMessage ] raise: SError.	self should: [ testCase addFactoryMessage: #SSPerson ] raise: SError.	testCase := SSTestCase with: utility typeInfoSAbstractClass.	self should: [ testCase addFactoryMessage ] raise: SError.	self		should: [ testCase addFactoryMessage: #SAbstractClass ]		raise: SError</body><body package="SmallSuiteGenerator-Tests-Core">testAddFieldAccessMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSSTeacher2.	self should: [ testCase addFieldAccessMessage ] raise: SError.	testCase addTargetClassName: #SSTeacher.	self		assert: testCase addFieldAccessMessage printString		equals: '_var1 := _var0 idTeacher.'</body><body package="SmallSuiteGenerator-Tests-Core">testAddFieldAccessMessageFrom	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo3.	self		should: [ testCase addFieldAccessMessage: #score from: #SFoo ]		raise: SError.	testCase addTargetClassName: #SFoo.	self		assert: (testCase addFieldAccessMessage: #score from: #SFoo) printString		equals: '_var2 := _var1 score.'</body><body package="SmallSuiteGenerator-Tests-Core">testAddFieldAccessMessageFromWithError	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo2.	self		should: [ testCase addFieldAccessMessage: #score from: #SFoo ]		raise: SError.	testCase addTargetClassName: #SFoo.	self		should: [ testCase addFieldAccessMessage: #score from: #SFoo ]		raise: SError.	self		should: [ testCase addFieldAccessMessage: #return: from: #SFoo ]		raise: SError</body><body package="SmallSuiteGenerator-Tests-Core">testAddFieldAccessMessageFromWithInvalidClassName	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo4.	testCase addTargetClassName: #SFoo.	self		should: [ testCase addFieldAccessMessage: #score from: #SStudent ]		raise: SError</body><body package="SmallSuiteGenerator-Tests-Core">testAddFieldAccessMessageWithLackTypeInfo	| testCase |	testCase := SSTestCase with: utility typeInfoSSTeacher3.	self should: [ testCase addFieldAccessMessage ] raise: SError.	testCase addTargetClassName: #SSTeacher.	self should: [ testCase addFieldAccessMessage ] raise: SError</body><body package="SmallSuiteGenerator-Tests-Core">testAddFieldAccessMessageWithReceiver	| testCase typeInfo receiver |	typeInfo := utility typeInfoSFoo1.	testCase := (SSTestCase with: typeInfo) addTargetClassName: #SFoo.	receiver := testCase addFactoryMessage variable.	self		assert:			(testCase				addFieldAccessMessage: (typeInfo accessMessagesFrom: #SFoo) first				withReceiver: receiver) printString		equals: '_var2 := _var1 score.'</body><body package="SmallSuiteGenerator-Tests-Core">testAddInvalidAssignment	| testCase |	testCase := SSTestCase new.	self should: [ testCase addAssignment: 3 ] raise: SError.	self should: [ testCase addAssignment: 'hello' ] raise: SError.	self should: [ testCase addAssignment: #name ] raise: SError.	self should: [ testCase addAssignment: 3.4 ] raise: SError.	self should: [ testCase addAssignment: #() ] raise: SError</body><body package="SmallSuiteGenerator-Tests-Core">testAddLiteral	| testCase aTypeInfo |	aTypeInfo := STypeInfo new.	aTypeInfo		scalar: #OrderedCollection			with: (Array with: (OrderedCollection newFrom: #(1 4)));		scalar: #ByteString with: #('World');		scalar: #SmallInteger with: #(2);		scalar: #SStudent with: (Array with: SStudent new).	testCase := SSTestCase with: aTypeInfo.	testCase		addLiteral: #ByteString;		addLiteral: #OrderedCollection;		addLiteral: #SmallInteger;		addLiteral: #SStudent.	self assert: testCase statements size equals: 4.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := ''World''.'				with:					'_var1 := '						,							(OrderedCollection new								add: 1;								add: 4;								yourself) storeString , '.'				with: '_var2 := 2.'				with: '_var3 := ' , SStudent new storeString , '.')</body><body package="SmallSuiteGenerator-Tests-Core">testAddLiteralWithError	| testCase |	testCase := SSTestCase with: STypeInfo new.	self should: [ testCase addLiteral ] raise: SError</body><body package="SmallSuiteGenerator-Tests-Core">testAddLiteralWithWrongClassName	| testCase aTypeInfo |	aTypeInfo := STypeInfo new.	aTypeInfo scalar: #SmallInteger with: #(2).	testCase := SSTestCase with: aTypeInfo.	self should: [ testCase addLiteral: #ByteString ] raise: SError</body><body package="SmallSuiteGenerator-Tests-Core">testAddMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo5.	testCase		addTargetClassName: #SFoo;		addMessage.	self assert: testCase statements size equals: 3.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := SFoo new.'				with: '_var1 := ' , (OrderedCollection newFrom: #(1 4 5)) storeString , '.'				with: '_var2 := _var0 return: _var1.')</body><body package="SmallSuiteGenerator-Tests-Core">testAddMessageFrom	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo3.	testCase		addTargetClassName: #SFoo;		addMessage: #returnFloat from: #SFoo.	self assert: testCase statements size equals: 3.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := 4.'				with: '_var1 := SFoo score: _var0.'				with: '_var2 := _var1 returnFloat.').	self		assert: (testCase addMessage: #returnNum from: #SFoo) printString		equals: '_var3 := _var1 returnNum.'.	self		assert:			(#('_var4 := _var1 score: _var0.' '_var4 := _var1 score: _var3.')				includes: (testCase addMessage: #score: from: #SFoo) printString)</body><body package="SmallSuiteGenerator-Tests-Core">testAddMessageFromDifferentReceiver	| testCase |	testCase := (SSTestCase with: utility typeInfoOnPackage1)		addTargetClassName: #SEvent.	self		should: [ testCase addMessage: #canRegister: from: #SEvent ]		raise: SError.	testCase addTargetClassName: #SConference.	testCase addMessage: #canRegister: from: #SConference.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := SConference new.'				with: '_var1 := ' , (SStudent new name: 'Mary') storeString , '.'				with: '_var2 := _var0 canRegister: _var1.')</body><body package="SmallSuiteGenerator-Tests-Core">testAddMessageWithEmptyTypeMethodInfo	| testCase |	testCase := SSTestCase with: utility typeInfoSFooEmpty.	testCase addTargetClassName: #SFoo.	self should: [ testCase addMessage ] raise: SError</body><body package="SmallSuiteGenerator-Tests-Core">testAddMessageWithReceiver	| testCase typeInfo receiver |	typeInfo := utility typeInfoSFoo2.	testCase := (SSTestCase with: typeInfo) addTargetClassName: #SFoo.	receiver := testCase addFactoryMessage variable.	self		assert:			(testCase				addMessage: (typeInfo messagesFrom: #SFoo) first				withReceiver: receiver) printString		equals: '_var1 := _var0 return: _var0.'</body><body package="SmallSuiteGenerator-Tests-Core">testAddMessageWithTwoDeepScalarSFoo	| testCase |	testCase := SSTestCase with: utility typeInfoSFooOnPackage3.	"(STON fromString: utility typeInfoStringSFoo6)."	testCase		addTargetClassName: #SFoo;		addMessage: #return: from: #SFoo.	self assert: testCase statements size equals: 3.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(OrderedCollection new				add: '_var0 := SFoo new.';				add: '_var1 := ' , (SStudent name: 'Lian' with: 1) storeString , '.';				add: '_var2 := SStack new.';				add: '_var3 := _var2 push: _var1.';				add: '_var4 := ' , (SStudent name: 'Josh' with: 2) storeString , '.';				add: '_var5 := _var2 push: _var4.';				add: '_var6 := ' , (SStudent name: 'Mery' with: 5) storeString , '.';				add: '_var7 := ((OrderedCollection new) add: _var6; yourself).';				add:					'_var8 := ((Dictionary new) add: (1-&gt;_var5); add: (2-&gt;_var7); yourself).';				add: '_var9 := _var0 return: _var8.';				yourself)</body><body package="SmallSuiteGenerator-Tests-Core">testAddMessageWithTwoDeepScalarSStack	| testCase |	testCase := SSTestCase with: utility typeInfoSStackOnPackage2.	"(STON fromString: utility typeInfoStringSStack1)"	testCase		addTargetClassName: #SStack;		addMessage: #push: from: #SStack.	self assert: testCase statements size equals: 3.	self		assert:			((testCase statements collect: #printString)				includesAny:					(Array						with:							(OrderedCollection new								add: '_var0 := SStack new.';								add: '_var1 := ' , (SStudent name: 'Lian' with: 1) storeString , '.';								add: '_var2 := ' , (SStudent name: 'Josh' with: 2) storeString , '.';								add: '_var3 := ((OrderedCollection new) add: _var1; add: _var2; yourself).';								add: '_var4 := _var0 push: _var3.';								yourself)						with:							(OrderedCollection new								add: '_var0 := SStack new.';								add: '_var1 := ' , (SStudent name: 'Mery' with: 5) storeString , '.';								add: '_var2 := ((OrderedCollection new) add: _var1; yourself).';								add: '_var3 := _var0 push: _var2.';								yourself)))</body><body package="SmallSuiteGenerator-Tests-Core">testAddStatementAfter	| testCase expression1 expression2 |	testCase := SSTestCase with: utility typeInfoSSTeacher1.	expression1 := SAssignment		name: (SVariable new id: 0)		value: ((SLiteral value: 2) returnType: #SmallInteger).	self		assert: (testCase addStatement: expression1 after: nil) printString		equals: '_var0 := 2.'.	expression2 := SAssignment		name: (SVariable new id: 1)		value: (SFactoryMessage default: #SSTeacher).	self		assert: (testCase addStatement: expression2 after: expression1) printString		equals: '_var1 := SSTeacher new.'.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 2.' '_var1 := SSTeacher new.').	expression1 := expression2.	expression2 := SAssignment		name: (SVariable new id: 2)		value:			(SMessage new				selector: #yearsWorkExperience;				receiver: expression1 variable;				yourself).	testCase addStatement: expression2 after: expression1.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := 2.' '_var1 := SSTeacher new.' '_var2 := _var1 yearsWorkExperience.').	expression2 := SAssignment		name: (SVariable new id: 3)		value: (SLiteral value: 4).	testCase addStatement: expression2 after: expression1.	self		assert:			((Array				with:					#('_var0 := 2.' '_var1 := SSTeacher new.' '_var2 := _var1 yearsWorkExperience.' '_var3 := 4.')				with:					#('_var0 := 2.' '_var1 := SSTeacher new.' '_var3 := 4.' '_var2 := _var1 yearsWorkExperience.'))				includes: (testCase statements collect: #printString) asArray)</body><body package="SmallSuiteGenerator-Tests-Core">testAddStatementBefore	| testCase expression1 expression2 |	testCase := SSTestCase new.	expression1 := SAssignment		name: (SVariable new id: 0)		value: ((SLiteral value: 2) returnType: #SmallInteger).	testCase addStatement: expression1 before: nil.	expression2 := SAssignment		name: (SVariable new id: 1)		value: (SFactoryMessage default: #SSTeacher).	testCase addStatement: expression2 before: expression1.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var1 := SSTeacher new.' '_var0 := 2.').	expression1 := expression2.	expression2 := SAssignment		name: (SVariable new id: 2)		value: ((SLiteral value: 100) returnType: #SmallInteger).	testCase addStatement: expression2 before: expression1.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var2 := 100.' '_var1 := SSTeacher new.' '_var0 := 2.').	expression1 := testCase statements last.	"_var0"	expression2 := SAssignment		name: (SVariable new id: 3)		value:			(SMessage new				selector: #yearsWorkExperience;				receiver: testCase statements second variable;				yourself).	testCase addStatement: expression2 before: expression1.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var2 := 100.' '_var1 := SSTeacher new.' '_var3 := _var1 yearsWorkExperience.' '_var0 := 2.')</body><body package="SmallSuiteGenerator-Tests-Core">testAddStatetementOfTypeBefore	| testCase expression |	testCase := SSTestCase with: utility typeInfoSEvent1.	testCase addTargetClassName: #SEvent.	expression := testCase addStatementOfType: #SEvent before: nil.	self		assert: expression printString		equals: '_var1 := SEvent price: _var0.'.	expression := testCase		addStatementOfType: #SmallInteger		before: expression.	self assert: expression printString equals: '_var2 := 8.'.	"change the form to select randomly"	self		assert:			(#(#('_var0 := 8.' '_var2 := 8.' '_var1 := SEvent price: _var0.') #('_var2 := 8.' '_var0 := 8.' '_var1 := SEvent price: _var0.'))				includes: (testCase statements collect: #printString) asArray)</body><body package="SmallSuiteGenerator-Tests-Core">testAddStatetementOfTypeBeforeFactoryMessage	| testCase expression |	testCase := SSTestCase with: utility typeInfoSEvent1.	testCase addTargetClassName: #SEvent.	expression := testCase addFactoryMessage.	expression := testCase addStatementOfType: #SEvent before: expression.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := 8.' '_var2 := SEvent price: _var0.' '_var1 := SEvent price: _var0.')</body><body package="SmallSuiteGenerator-Tests-Core">testAddTargetClassName	| testCase expression |	testCase := SSTestCase with: utility typeInfoOnPackage3.	self should: [ testCase addTargetClassName: #SEvent ] raise: SError.	self		shouldnt: [ testCase addTargetClassName: #SSTeacher ]		raise: SError.	expression := testCase addFactoryMessage: #SSTeacher.	self		assert:			(#('_var2 := SSTeacher name: _var0 with: _var1.' '_var2 := SSTeacher name: _var1 with: _var0.')				includes: expression printString)</body><body package="SmallSuiteGenerator-Tests-Core">testBuildArgsBefore	| testCase typeInfo expression |	typeInfo := utility typeInfoSEvent1.	testCase := SSTestCase with: typeInfo.	testCase addTargetClassName: #SEvent.	expression := testCase addLiteral.	testCase		buildArgs: (typeInfo factoryMessagesFrom: #SEvent) first argTypes		before: expression.	self		assertCollection: testCase printStatements		hasSameElements: #('_var1 := 8.' '_var0 := 8.')</body><body package="SmallSuiteGenerator-Tests-Core">testNewFactoryMessageBefore	| testCase expression |	testCase := SSTestCase with: utility typeInfoSEvent1.	testCase addTargetClassName: #SEvent.	expression := testCase addLiteral.	self		assert: (testCase newFactoryMessage: #SEvent before: expression) printString		equals: 'SEvent price: _var1'.	"default factoryMessage"	testCase := SSTestCase with: utility typeInfoSFoo5.	testCase addTargetClassName: #SFoo.	self		assert: (testCase newFactoryMessage: #SFoo before: nil) printString		equals: 'SFoo new'</body><body package="SmallSuiteGenerator-Tests-Core">testNewFactoryMessageUsingAnd	| testCase expression |	testCase := SSTestCase with: utility typeInfoSEvent1.	testCase addTargetClassName: #SEvent.	expression := testCase addLiteral.	self		assert: (testCase newFactoryMessageUsing: #SEvent and: expression) printString		equals: 'SEvent price: _var1'.	self		assertCollection: testCase printStatements		hasSameElements: #('_var1 := 8.' '_var0 := 8.')</body><body package="SmallSuiteGenerator-Tests-Core">testNewFieldAccessMessageOfTypeBefore	| testCase expression |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: #SFoo.	expression := testCase addLiteral: #SmallInteger.	self		should: [ testCase				newFieldAccessMessageOfType: #SmallInteger				before: expression ]		raise: SError.	testCase		addStatement:			(testCase				newAssignment: (testCase newFactoryMessage: #SFoo before: expression))		before: expression.	self		assert:			(testCase				newFieldAccessMessageOfType: #SmallFloat64				before: expression) printString		equals: '_var2 score'.	self		assertCollection: testCase printStatements		hasSameElements: #('_var1 := 7.3.' '_var2 := SFoo score: _var1.' '_var0 := 5.')</body><body package="SmallSuiteGenerator-Tests-Core">testNewMessageOfTypeBefore	| testCase expression |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: #SFoo.	expression := testCase addLiteral: #SmallInteger.	self		should: [ testCase newMessageOfType: #SmallInteger before: expression ]		raise: SError.	testCase		addStatement:			(testCase				newAssignment: (testCase newFactoryMessage: #SFoo before: expression))		before: expression.	self		assert:			(testCase newMessageOfType: #SmallInteger before: expression)				printString		equals: '_var2 returnNum'.	self		assertCollection: testCase printStatements		hasSameElements: #('_var1 := 7.3.' '_var2 := SFoo score: _var1.' '_var0 := 5.')</body><body package="SmallSuiteGenerator-Tests-Core">testNewStatementOfTypeBefore	| testCase expression |	testCase := SSTestCase with: utility typeInfoSEvent1.	testCase addTargetClassName: #SEvent.	expression := testCase		newAssignment: (testCase newStatementOfType: #SmallInteger before: nil).	testCase addStatement: expression before: nil.	self		assertCollection: testCase printStatements		hasSameElements: #('_var0 := 8.').	expression := testCase newStatementOfType: #SEvent before: expression.	self assert: expression printString equals: 'SEvent price: _var1'.	expression := testCase newAssignment: expression.	testCase		addStatement: expression		before: (testCase statementOfVarName: '_var0').	self		assertCollection: testCase printStatements		hasSameElements: #('_var1 := 8.' '_var2 := SEvent price: _var1.' '_var0 := 8.')</body><body package="SmallSuiteGenerator-Tests-Core">testObjectVariables	| testCase |	testCase := SSTestCase with: utility typeInfoSSTeacher3.	self assert: testCase objectVariables isEmpty.	testCase		addTargetClassName: #SSTeacher;		addFactoryMessage.	self		assertCollection: (testCase objectVariables collect: #printString)		hasSameElements: #('_var0')</body><body package="SmallSuiteGenerator-Tests-Core">testPickAccessorsOf	| testCase |	testCase := (SSTestCase with: utility typeInfoSSTeacher4)		addTargetClassName: #SSTeacher.	self		assertCollection: ((testCase pickAccessorsOf: #SSTeacher) collect: #selector)		hasSameElements: #(#yearsWorkExperience #idTeacher).	testCase := (SSTestCase with: utility typeInfoSSTeacher3)		addTargetClassName: #SSTeacher.	self assert: (testCase pickAccessorsOf: #SSTeacher) isEmpty</body><body package="SmallSuiteGenerator-Tests-Core">testPickAccessorsOfWithInvalidClassName	| testCase |	testCase := (SSTestCase with: utility typeInfoSSTeacher4)		addTargetClassName: #SSTeacher.	self assert: (testCase pickAccessorsOf: #SStudent) isEmpty</body><body package="SmallSuiteGenerator-Tests-Core">testPickAnObjectVariable	| testCase |	testCase := SSTestCase with: utility typeInfoSSTeacher3.	self should: [ testCase pickAnObjectVariable ] raise: SError.	testCase addTargetClassName: #SSTeacher.	self		assert: testCase pickAnObjectVariable printString		equals: '_var0'</body><body package="SmallSuiteGenerator-Tests-Core">testPickFactoryMessagesFrom	| testCase |	testCase := SSTestCase new.	testCase typeInfo: utility typeInfoOnPackage2.	self		should: [ testCase addMessage: #price: from: #SEvent ]		raise: SError.	testCase addFactoryMessage: #SConference ofSelector: #price:.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 95.' '_var1 := SConference price: _var0.')</body><body package="SmallSuiteGenerator-Tests-Core">testPickMessagesOf	| testCase |	testCase := SSTestCase with: utility typeInfoOnPackage2.	self		assert: ((testCase pickMessagesOf: #SEvent) collect: #selector) isEmpty.	self		assertCollection: ((testCase pickMessagesOf: #SConference) collect: #selector)		hasSameElements: #(#price: #initialize).	testCase := SSTestCase with: utility typeInfoOnPackage3.	self		assertCollection: ((testCase pickMessagesOf: #SSTeacher) collect: #selector)		hasSameElements: #(#name: #id: #nickname: #initialize #nickname)</body><body package="SmallSuiteGenerator-Tests-Core">testPickMessagesOfWrongClassName	| testCase |	testCase := SSTestCase with: utility typeInfoOnPackage2.	self assert: (testCase pickMessagesOf: #SSTeacher) isEmpty.	testCase := SSTestCase with: utility typeInfoOnPackage3.	self assert: (testCase pickMessagesOf: #SPerson) isEmpty.	self assert: (testCase pickMessagesOf: #SStudent) isEmpty</body><body package="SmallSuiteGenerator-Tests-Core">testPickOrCreateObjectVariableOf	| testCase |	testCase := (SSTestCase with: utility typeInfoSFoo2)		addTargetClassName: #SFoo.	self assert: testCase statements isEmpty.	self		assert: (testCase pickOrCreateObjectVariableOf: #SFoo) printString		equals: '_var0'.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := SFoo new.').	testCase pickOrCreateObjectVariableOf: #SFoo.	self assert: testCase statements size equals: 1</body><body package="SmallSuiteGenerator-Tests-Core">testPickOrCreateObjectVariableOfWrongClassName	| testCase |	testCase := (SSTestCase with: utility typeInfoSFoo2)		addTargetClassName: #SFoo.	self		should: [ testCase pickOrCreateObjectVariableOf: #SSTeacher ]		raise: SError</body><body package="SmallSuiteGenerator-Tests-Core">testRandomLiteralClassName	| testCase |	testCase := SSTestCase		with: (STypeInfo new scalar: #SmallInteger with: #(1 3 4)).	self assert: testCase randomLiteralClassName equals: #SmallInteger.	testCase := SSTestCase		with:			(STypeInfo new				scalar: #ByteString with: #('hello');				scalar: #SmallInteger with: #(1 5 6)).	self		assert:			(#(#ByteString #SmallInteger)				includes: testCase randomLiteralClassName)</body><body package="SmallSuiteGenerator-Tests-Core">testRandomLiteralClassNameWithEmptyScalars	| testCase |	testCase := SSTestCase with: STypeInfo new.	self should: [ testCase randomLiteralClassName ] raise: SError</body><body package="SmallSuiteGenerator-Tests-Core">testSubStatementsFromToPrevIndexOf	| testCase expression |	testCase := SSTestCase with: utility typeInfoSEvent1.	testCase addTargetClassName: #SEvent.	self		assert: (testCase subStatementsFrom: 1 toPrevIndexOf: nil) isEmpty.	expression := testCase addLiteral.	self		assert: (testCase subStatementsFrom: 1 toPrevIndexOf: expression) isEmpty.	expression := testCase addFactoryMessage.	self		assertCollection:			((testCase subStatementsFrom: 1 toPrevIndexOf: expression)				collect: #printString)		hasSameElements: #('_var0 := 8.').	expression := testCase addMessage: #discount: from: #SEvent.	self		assertCollection:			((testCase subStatementsFrom: 1 toPrevIndexOf: expression)				collect: #printString)		hasSameElements: #('_var0 := 8.' '_var1 := SEvent price: _var0.').	expression := testCase addFieldAccessMessage: #price from: #SEvent.	self		assertCollection:			((testCase subStatementsFrom: 1 toPrevIndexOf: expression)				collect: #printString)		hasSameElements:			#('_var0 := 8.' '_var1 := SEvent price: _var0.' '_var2 := _var1 discount: _var0.')</body><body package="SmallSuiteGenerator-Tests-Core">testValidTargetClassName	| testCase |	testCase := SSTestCase with: utility typeInfoOnPackage1.	self should: [ testCase validTargetClassName: #SEvent ] raise: SError.	testCase addTargetClassName: #SEvent.	self		shouldnt: [ testCase validTargetClassName: #SEvent ]		raise: SError.	self		shouldnt: [ testCase validTargetClassName: #SConference ]		raise: SError.	self		should: [ testCase validTargetClassName: #SStudent ]		raise: SError</body><body package="SmallSuiteGenerator-Tests-Core">testValidTargetClassNameWithLackTypeInfo	| testCase |	testCase := SSTestCase with: utility typeInfoOnPackage4.	self should: [ testCase validTargetClassName: #SEvent ] raise: SError.	testCase addTargetClassName: #SEvent.	self		shouldnt: [ testCase validTargetClassName: #SEvent ]		raise: SError.	self		shouldnt: [ testCase validTargetClassName: #SConference ]		raise: SError.	self should: [ testCase validTargetClassName: #SParty ] raise: SError</body></methods><methods><class-id>SmallSuiteGenerator.SSTestShifterTest</class-id> <category>running</category><body package="SmallSuiteGenerator-Tests-Core">setUp	utility := SUtilityTypeInfo new.	SConfiguration fileLogger: 'STestShifterTestLogger.log'</body></methods><methods><class-id>SmallSuiteGenerator.SInsertTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-Core">setUp	super setUp.	SConfiguration fileLogger: 'SInsertTestLogger.log'</body></methods><methods><class-id>SmallSuiteGenerator.SInsertTest</class-id> <category>mutation-insert</category><body package="SmallSuiteGenerator-Tests-Core">testInsertStatementAsParameterInMessage	| testCase anExpression |	testCase := SSTestCase with: utility typeInfoSFoo4.	testCase		addTargetClassName: #SFoo;		addFactoryMessage: #SFoo;		addLiteral;		addMessage: #return: from: #SFoo.	anExpression := testCase addLiteral.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := SFoo new.'				with: '_var1 := ' , SStudent new storeString , '.'				with: '_var2 := _var0 return: _var1.'				with: '_var3 := ' , SStudent new storeString , '.').	self		should: [ testCase				perform: #insertAsParameter:using:				inStatement: anExpression copy ]		raise: SError.	testCase addMessage: #return: from: #SFoo.	testCase		perform: #insertAsParameter:using:		inStatement: anExpression copy.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			(Array				with: '_var0 := SFoo new.'				with: '_var1 := ' , SStudent new storeString , '.'				with: '_var2 := _var0 return: _var1.'				with: '_var3 := ' , SStudent new storeString , '.'				with: '_var4 := _var0 return: _var3.')</body><body package="SmallSuiteGenerator-Tests-Core">testInsertStatementOfMixingSelectors	| testCase fieldAccess message |	testCase := (SSTestCase with: utility typeInfosSStudent first)		addTargetClassName: #SStudent;		addLiteral: #SmallInteger;		addFactoryMessage: #SStudent ofSelector: #new;		addMessage: #scoreStudent: from: #SStudent;		addFactoryMessage: #SStudent ofSelector: #new;		addFieldAccessMessage: #idStudent from: #SStudent;		yourself.	self		assertCollection: (testCase statements collect: #printString) allButLast		hasSameElements:			#('_var0 := 1.' '_var1 := SStudent new.' '_var2 := _var1 scoreStudent: _var0.' '_var3 := SStudent new.').	self		assert:			(#('_var4 := _var1 idStudent.' '_var4 := _var2 idStudent.' '_var4 := _var3 idStudent.')				includes: (testCase statementOfVarName: '_var4') printString).	fieldAccess := testCase statementOfVarName: '_var4'.	message := (testCase statementOfVarName: '_var2') value.	message := testCase insertExpression: message copy after: fieldAccess.	self		assert: message printString		equals: '_var5 := _var1 scoreStudent: _var0.'.	message := testCase		perform: #insertAsParameter:using:		inStatement: fieldAccess.	self		assert: message printString		equals: '_var5 := _var1 scoreStudent: _var4.'</body><body package="SmallSuiteGenerator-Tests-Core">testInsertStatementOfSelectorAsParameterInFactoryMessage	| testCase auxExpr expression |	testCase := SSTestCase with: utility typeInfoSFoo2.	testCase addTargetClassName: #SFoo.	expression := testCase addFactoryMessage.	testCase addFactoryMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := SFoo new.' '_var1 := SFoo new.').	auxExpr := testCase addMessage.	auxExpr value		receiver: (testCase statementOfVarName: '_var1') variable.	auxExpr := testCase		perform: #insertAsParameter:using:		inStatement: expression.	self		assert: auxExpr printString		equals: '_var2 := _var1 return: _var0.'</body><body package="SmallSuiteGenerator-Tests-Core">testInsertStatementOfSelectorAsParameterInFieldMessage	| testCase aExpression |	testCase := SSTestCase with: utility typeInfoSStack4.	testCase addFactoryMessage: #SStack ofSelector: #newStack.	aExpression := testCase		addFieldAccessMessage: #lastLinkStack		from: #SStack.	testCase addLiteral: #SmallInteger.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := SStack newStack.' '_var1 := _var0 lastLinkStack.' '_var2 := 5.').	testCase addMessage: #push: from: #SStack.	testCase		perform: #insertAsParameter:using:		inStatement: aExpression copy.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := SStack newStack.' '_var1 := _var0 lastLinkStack.' '_var2 := 5.' '_var3 := _var0 push: _var1.')</body><body package="SmallSuiteGenerator-Tests-Core">testInsertStatementOfSelectorAsParameterInMessage	| testCase aExpression |	testCase := SSTestCase with: utility typeInfoSStack4.	testCase addFactoryMessage: #SStack ofSelector: #newStackWith:.	aExpression := testCase addMessage: #pop from: #SStack.	testCase addLiteral: #SmallInteger.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := #(1 4 5 ).' '_var1 := SStack newStackWith: _var0.' '_var2 := _var1 pop.' '_var3 := 5.').	testCase addMessage: #push: from: #SStack.	testCase		perform: #insertAsParameter:using:		inStatement: aExpression copy.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := #(1 4 5 ).' '_var1 := SStack newStackWith: _var0.' '_var2 := _var1 pop.' '_var3 := 5.' '_var4 := _var1 push: _var2.')</body><body package="SmallSuiteGenerator-Tests-Core">testInsertStatementOfSelectorMethodMessageInFactoryMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: #SFoo;		addFactoryMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 7.3.' '_var1 := SFoo score: _var0.').	self		should: [ testCase insertStatementOfSelector: #insertMethodMessage:using: ]		raise: SError</body><body package="SmallSuiteGenerator-Tests-Core">testInsertStatementOfSelectorMethodMessageInFieldMessage	| testCase fieldMessage |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: #SFoo.	fieldMessage := testCase addFieldAccessMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := 7.3.' '_var1 := SFoo score: _var0.' '_var2 := _var1 score.').	self		should: [ testCase				perform: #insertMethodMessage:using:				inStatement: fieldMessage copy ]		raise: SError</body><body package="SmallSuiteGenerator-Tests-Core">testInsertStatementOfSelectorMethodMessageInLiteral	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addLiteral: #SmallInteger.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 5.').	self		should: [ testCase insertStatementOfSelector: #insertMethodMessage:using: ]		raise: SError</body><body package="SmallSuiteGenerator-Tests-Core">testInsertStatementOfSelectorMethodMessageInMessage	| testCase message |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: #SFoo.	message := testCase addMessage: #returnNum from: #SFoo.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := 7.3.' '_var1 := SFoo score: _var0.' '_var2 := _var1 returnNum.').	testCase		perform: #insertMethodMessage:using:		inStatement: message copy.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := 7.3.' '_var1 := SFoo score: _var0.' '_var2 := _var1 returnNum.' '_var3 := _var1 returnNum.')</body><body package="SmallSuiteGenerator-Tests-Core">testInsertStatementOfSelectorRandomMessageInFactoryMessage	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: #SFoo;		addFactoryMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 7.3.' '_var1 := SFoo score: _var0.').	testCase insertStatementOfSelector: #insertRandomMessage:using:.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := 7.3.' '_var1 := SFoo score: _var0.' '_var2 := SFoo score: _var0.')</body><body package="SmallSuiteGenerator-Tests-Core">testInsertStatementOfSelectorRandomMessageInFieldMessage	| testCase fieldMessage |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: #SFoo.	fieldMessage := testCase addFieldAccessMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := 7.3.' '_var1 := SFoo score: _var0.' '_var2 := _var1 score.').	testCase		perform: #insertRandomMessage:using:		inStatement: fieldMessage copy.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := 7.3.' '_var1 := SFoo score: _var0.' '_var2 := _var1 score.' '_var3 := _var1 score.')</body><body package="SmallSuiteGenerator-Tests-Core">testInsertStatementOfSelectorRandomMessageInLiteral	| testCase |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addLiteral: #SmallFloat64.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 7.3.').	self		should: [ testCase insertStatementOfSelector: #insertRandomMessage:using: ]		raise: SError</body><body package="SmallSuiteGenerator-Tests-Core">testInsertStatementOfSelectorRandomMessageInMessage	| testCase message |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase addTargetClassName: #SFoo.	message := testCase addMessage: #return: from: #SFoo.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := 7.3.' '_var1 := SFoo score: _var0.' '_var2 := ''hello''.' '_var3 := _var1 return: _var2.').	testCase		perform: #insertRandomMessage:using:		inStatement: message copy.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := 7.3.' '_var1 := SFoo score: _var0.' '_var2 := ''hello''.' '_var3 := _var1 return: _var2.' '_var4 := _var1 return: _var2.')</body></methods><methods><class-id>SmallSuiteGenerator.SRandomTest</class-id> <category>running</category><body package="SmallSuiteGenerator-Tests-Core">setUp	super setUp.	utility := SUtilityTypeInfo new</body></methods><methods><class-id>SmallSuiteGenerator.SRandomTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-Core">testCollectAtRandom	| generator array |	generator := SRandom seed: 100.	array := (1 to: 10) asArray.	self		assertCollection: (generator collectAtRandom: array)		hasSameElements: array</body><body package="SmallSuiteGenerator-Tests-Core">testCollectAtRandomOnStatements	| generator testCase |	generator := SRandom seed: 100.	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: #SFoo;		addFactoryMessage;		addMessage: #returnNum from: #SFoo;		addFieldAccessMessage: #score from: #SFoo.	self		assertCollection: testCase printStatements		hasSameElements:			((generator collectAtRandom: testCase statements)				collect: #printString)</body><body package="SmallSuiteGenerator-Tests-Core">testSelectAtRandom	| generator array |	generator := SRandom seed: 100.	array := (1 to: 10) asArray.	self assert: ((generator selectAtRandom: array) between: 1 and: 10)</body><body package="SmallSuiteGenerator-Tests-Core">testSelectAtRandomOnStatements	| generator testCase stringStatements statements |	generator := SRandom seed: 100.	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: #SFoo;		addFactoryMessage;		addMessage: #returnNum from: #SFoo;		addFieldAccessMessage: #score from: #SFoo.	stringStatements := testCase printStatements.	statements := testCase statements.	100		timesRepeat: [ self				assert:					(stringStatements						includes: (generator selectAtRandom: statements) printString) ]</body><body package="SmallSuiteGenerator-Tests-Core">testShuffleCollection	| generator array |	generator := SRandom seed: 100.	array := (1 to: 10) asArray.	self		assertCollection: (generator shuffleCollection: 10)		hasSameElements: array</body></methods><methods><class-id>SmallSuiteGenerator.SLiteral</class-id> <category>mutation</category><body package="SmallSuiteGenerator-AST">insertOn: aTestCase	^ aTestCase addLiteral: self returnType</body><body package="SmallSuiteGenerator-AST">repairOn: aTestCase changing: aExpression	self value: value mutateToChange</body></methods><methods><class-id>SmallSuiteGenerator.SLiteral</class-id> <category>evaluating</category><body package="SmallSuiteGenerator-AST">value	^ value</body></methods><methods><class-id>SmallSuiteGenerator.SLiteral</class-id> <category>accessing</category><body package="SmallSuiteGenerator-AST">referenceTo: aClassName	^ (value isClass		ifTrue: [ value name ]		ifFalse: [ value className ]) = aClassName asString</body><body package="SmallSuiteGenerator-AST">replaceBy: otherExpression	self value: otherExpression value</body><body package="SmallSuiteGenerator-AST">value: anObject	value := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SLiteral</class-id> <category>printing</category><body package="SmallSuiteGenerator-AST">printOn: aStream	aStream		nextPutAll:			(value isNumber				ifTrue: [ value printString ]				ifFalse: [ value storeString ])</body></methods><methods><class-id>SmallSuiteGenerator.SLiteral</class-id> <category>comparing</category><body package="SmallSuiteGenerator-AST">= other	^ super = other		and: [ value isLiteral				ifTrue: [ value = other value ]				ifFalse: [ value isClass						ifTrue: [ value name = other value name ]						ifFalse: [ value className = other value className ] ] ]</body><body package="SmallSuiteGenerator-AST">hash	^ super hash xor: value hash</body></methods><methods><class-id>SmallSuiteGenerator.SLiteral</class-id> <category>copying</category><body package="SmallSuiteGenerator-AST">copy	| copy |	copy := super copy.	copy value: value copy.	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.SLiteral class</class-id> <category>parsing</category><body package="SmallSuiteGenerator-AST">value: aValue	^ SLiteral new		value: aValue;		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SChangeTest</class-id> <category>mutation-change</category><body package="SmallSuiteGenerator-Tests-Core">testChangeStatementOfFactoryMessageWithAbstractClass	| testCase changed |	testCase := SSTestCase with: utility typeInfoArrayedCollection.	testCase		addTargetClassName: #ArrayedCollection;		addFactoryMessage;		addLiteral;		addFactoryMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements:			#('_var0 := ArrayedCollection new.' '_var1 := ''hello''.' '_var2 := ArrayedCollection new.').	changed := testCase changeStatementOfClassName: #ArrayedCollection.	self assert: changed equals: false.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var1 := ''hello''.')</body><body package="SmallSuiteGenerator-Tests-Core">testChangeStatementOfFactoryMessageWithMoreThanOneLiteral	| testCase expression expressionChanged |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addLiteral: #SmallFloat64;		addLiteral: #SmallFloat64.	expression := testCase addFactoryMessage: #SFoo ofSelector: #score:.	self		assertCollection: (testCase statements collect: #printString)		includesAll: #('_var0 := 7.3.' '_var1 := 7.3.').	self		assert:			(#('_var2 := SFoo score: _var0.' '_var2 := SFoo score: _var1.')				includes: expression printString).	expressionChanged := testCase changeStatementOfVarName: '_var2'.	self		assert:			(#('_var2 := SFoo score: _var0.' '_var2 := SFoo score: _var1.' '_var2 := SFoo new.')				includes: expressionChanged printString).	self assert: testCase validReferences</body><body package="SmallSuiteGenerator-Tests-Core">testChangeStatementOfFactoryMessageWithOneLiteral	| testCase expressionChanged |	testCase := SSTestCase with: utility typeInfoSFoo1.	testCase		addTargetClassName: #SFoo;		addFactoryMessage.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 7.3.' '_var1 := SFoo score: _var0.').	expressionChanged := testCase changeStatementOfVarName: '_var1'.	self		assert:			(#('_var1 := SFoo new.' '_var1 := SFoo score: _var2.')				includes: expressionChanged printString).	self assert: testCase validReferences</body><body package="SmallSuiteGenerator-Tests-Core">testChangeStatementOfFieldAccessMessage	| testCase exprField exprFieldChanged |	testCase := SSTestCase with: utility typeInfoSStack4.	testCase		addTargetClassName: #SStack;		addFactoryMessage: #SStack ofSelector: #newStack.	exprField := (testCase		addFieldAccessMessage: #firstLinkStack		from: #SStack) copy.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := SStack newStack.' '_var1 := _var0 firstLinkStack.').	exprFieldChanged := testCase changeStatement: exprField.	self		assert:			(#('_var1 := _var0 lastLinkStack.' '_var1 := _var3 firstLinkStack.' '_var1 := _var2 firstLinkStack.')				includes: exprFieldChanged printString).	self assert: testCase validReferences</body><body package="SmallSuiteGenerator-Tests-Core">testChangeStatementOfLiteral	| testCase exprLiteral exprLiteralChanged |	testCase := SSTestCase with: utility typeInfoSStack4.	exprLiteral := (testCase addLiteral: #SmallInteger) copy.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := 5.').	exprLiteralChanged := testCase changeStatementOfVarName: '_var0'.	self deny: exprLiteral equals: exprLiteralChanged.	self assert: testCase validReferences</body><body package="SmallSuiteGenerator-Tests-Core">testChangeStatementOfMessage	| testCase exprMessage exprLiteralChanged |	testCase := SSTestCase with: utility typeInfoSStack4.	testCase		addTargetClassName: #SStack;		addFactoryMessage: #SStack ofSelector: #newStack.	exprMessage := (testCase addMessage: #pop from: #SStack) copy.	self		assertCollection: (testCase statements collect: #printString)		hasSameElements: #('_var0 := SStack newStack.' '_var1 := _var0 pop.').	exprLiteralChanged := testCase changeStatement: exprMessage.	self		assert:			(#('_var1 := _var0 top.' '_var1 := _var0 push: _var2.' '_var1 := _var3 pop.' '_var1 := _var2 pop.')				includes: exprLiteralChanged printString).	self assert: testCase validReferences</body></methods><methods><class-id>SmallSuiteGenerator.SExtensionsTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-Core">createStudent	^ SStudent new		name: 'Pedro';		id: 5</body><body package="SmallSuiteGenerator-Tests-Core">testMutateToChange	self assert: true mutateToChange equals: false.	self assert: false mutateToChange equals: true.	self deny: 1234 mutateToChange equals: 1234.	self deny: 23.34 mutateToChange equals: 23.34.	self deny: $e mutateToChange equals: $e.	self deny: '$character' mutateToChange equals: '$character'.	self deny: 'hello' mutateToChange equals: 'hello'.	self assert: #(1 2 5 6) mutateToChange equals: #(1 2 5 6).	self deny: '#(1 2 5 6' mutateToChange equals: '#(1 2 5 6'.	self		assert: (SStack newStackWith: #(1 6 2 4)) mutateToChange		equals: (SStack newStackWith: #(1 6 2 4)).	self		assert: self createStudent mutateToChange storeString		equals: self createStudent storeString</body><body package="SmallSuiteGenerator-Tests-Core">testStoreString	self assert: 1 storeString equals: '1'.	self assert: 4.6 storeString equals: '4.6'.	self assert: true storeString equals: 'true'.	self assert: false storeString equals: 'false'.	self assert: 'hello' storeString equals: '''hello'''.	self assert: $d storeString equals: '$d'.	self assert: (SSTeacher new name: 'Mary') storeString isNotEmpty.	self assert: (SStudent new name: 'Alan') storeString isNotEmpty</body></methods><methods><class-id>SmallSuiteGenerator.SInspectorAssertion class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-AST">for: anExecutionContext	^ anExecutionContext associations		flatCollect: [ :assoc | self inspectorAssertionOf: assoc ]</body></methods><methods><class-id>SmallSuiteGenerator.SInspectorAssertion class</class-id> <category>As yet unclassified</category><body package="SmallSuiteGenerator-AST">for: anExecutionContext	^ anExecutionContext associations		flatCollect: [ :assoc | self inspectorAssertionOf: assoc ]</body></methods><methods><class-id>SmallSuiteGenerator.SInspectorAssertion class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-AST">inspectorAssertionOf: assoc	^ (assoc value class methods select: #isReturnField)		collect:			[ :compiledMethod | self inspectorAssertionOf: assoc and: compiledMethod ]		thenSelect: [ :assertion | assertion isNotNil ]</body><body package="SmallSuiteGenerator-AST">inspectorAssertionOf: assoc and: compiledMethod	| result |	result := assoc value perform: compiledMethod selector.	^ (self isPrimitive: result)		ifFalse: [ nil ]		ifTrue: [ self new				selector: #assert:equals:;				args:					(Array						with:							(SMessage new								receiver: (SVariable name: assoc key);								selector: compiledMethod selector;								yourself)						with: (SLiteral new value: result));				yourself ]</body></methods><methods><class-id>SmallSuiteGenerator.SClassInfoTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-Info">testEquals	self		assert: (STypeClassInfo type: #SFoo -&gt; #(#() #()))		equals: (STypeClassInfo type: #SFoo -&gt; #(#() #())).	self		assert:			(STypeClassInfo				type:					#SStudent						-&gt;							(Array								with: (Array with: #name -&gt; #(#SStudent #ByteString #() false))								with: #()))		equals:			(STypeClassInfo				type:					#SStudent						-&gt;							(Array								with: (Array with: #name -&gt; #(#SStudent #ByteString #() false))								with: #())).	self		assert:			(STypeClassInfo				type:					#SFoo						-&gt;							(Array								with: (Array with: #score -&gt; #(#SFoo #SmallInteger #() false))								with: (Array with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false))))		equals:			(STypeClassInfo				type:					#SFoo						-&gt;							(Array								with: (Array with: #score -&gt; #(#SFoo #SmallInteger #() false))								with: (Array with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false))))</body><body package="SmallSuiteGenerator-Tests-Info">testFromString	| typeClass |	typeClass := STypeClassInfo		type:			#SFoo				-&gt;					(Array						with:							(Array								with: #returnFloat -&gt; #(#SFoo #SmallFloat64 #() false)								with: #return: -&gt; #(#SFoo #ByteString #(#ByteString) false))						with: (Array with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false))).	self		assert:			(STON				fromString:					'STypeClassInfo {						#typeName: #SFoo,						#methodTypes: {							#returnFloat: STypeMethodInfo {#selector: #returnFloat, #receiver: SMultiTypeInfo [#SFoo], #returnType: SMultiTypeInfo [#SmallFloat64], #argTypes: [], #isQuick: false}, 							#''return:'': STypeMethodInfo {#selector: #''return:'', #receiver: SMultiTypeInfo [#SFoo], #returnType: SMultiTypeInfo [#ByteString], #argTypes: [SMultiTypeInfo [#ByteString]], #isQuick: false}}, 						#classMethodTypes: { 							#''score:'': STypeMethodInfo {#selector: #''score:'', #receiver: SMultiTypeInfo [#SFoo], #returnType: SMultiTypeInfo [#SFoo], #argTypes: [SMultiTypeInfo [#SmallInteger]], #isQuick: false}				}}')		equals: typeClass</body><body package="SmallSuiteGenerator-Tests-Info">testToString	| string |	string := STON		toString:			(STypeClassInfo				type:					#SFoo						-&gt;							(Array								with:									(Array										with: #returnFloat -&gt; #(#SFoo #SmallFloat64 #() false)										with: #return: -&gt; #(#SFoo #ByteString #(#ByteString) false))								with: (Array with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false)))).	self		assert: (STON fromString: string)		equals:			(STypeClassInfo				type:					#SFoo						-&gt;							(Array								with:									(Array										with: #returnFloat -&gt; #(#SFoo #SmallFloat64 #() false)										with: #return: -&gt; #(#SFoo #ByteString #(#ByteString) false))								with: (Array with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false))))</body><body package="SmallSuiteGenerator-Tests-Info">testType	| classInfo methodInfo |	classInfo := STypeClassInfo		type:			#SFoo				-&gt;					(Array						with:							(Array								with: #returnFloat -&gt; #(#SFoo #SmallFloat64 #() false)								with: #returnString -&gt; #(#SFoo #ByteString #() false)								with: #return: -&gt; #(#SFoo #OrderedCollection #(#OrderedCollection) false)								with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false)								with: #score -&gt; #(#SFoo #SmallInteger #() true))						with: (Array with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false))).	classInfo typeMethod: #returnNum -&gt; #(#SFoo #SmallInteger #() false).	self assert: classInfo methodTypes size equals: 6.	self assert: classInfo classMethodTypes size equals: 1.	methodInfo := classInfo methodTypes at: #return:.	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #OrderedCollection.	self		assertCollection: methodInfo allArgTypes		hasSameElements: #(#OrderedCollection).	self		assert: (classInfo methodTypes at: #returnFloat) returnType type		equals: #SmallFloat64.	self		assert: (classInfo methodTypes at: #returnString) returnType type		equals: #ByteString.	self		assert: (classInfo methodTypes at: #score) returnType type		equals: #SmallInteger.	methodInfo := classInfo methodTypes at: #score:.	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #SFoo.	self		assertCollection: methodInfo allArgTypes		hasSameElements: #(#SmallInteger).	self		assert: (classInfo classMethodTypes at: #score:) returnType type		equals: #SFoo.	self		assert: (classInfo methodTypes at: #returnNum) returnType type		equals: #SmallInteger</body></methods><methods><class-id>SmallSuiteGenerator.SFieldAccessMessage</class-id> <category>mutation</category><body package="SmallSuiteGenerator-AST">insertOn: aTestCase	^ aTestCase		addFieldAccessMessage: self selector		from: self receiver returnType</body></methods><methods><class-id>SmallSuiteGenerator.SFieldAccessMessage</class-id> <category>actions</category><body package="SmallSuiteGenerator-AST">replaceArg: expressions by: newExpressions	</body></methods><methods><class-id>SmallSuiteGenerator.SFieldAccessMessage</class-id> <category>override</category><body package="SmallSuiteGenerator-AST">changeSelectorFrom: expression in: aTestCase	| otherFieldAccessMessage |	otherFieldAccessMessage := aTestCase		alternativeFieldAccessMessage: self.	self selector: otherFieldAccessMessage selector</body></methods><methods><class-id>SmallSuiteGenerator.SFieldAccessMessage class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-AST">newFromReceiver: aReceiver andMethod: aMethod	^ SFieldAccessMessage new		returnType: aMethod returnType type;		selector: aMethod selector;		receiver: aReceiver;		yourself</body></methods><methods><class-id>SmallSuiteGenerator.SMultiTypeInfoTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-Info">testEqual	self		assert: (SMultiTypeInfo new type: #ByteString)		equals: (SMultiTypeInfo new type: #ByteString)</body><body package="SmallSuiteGenerator-Tests-Info">testFromSton	| multiTypeInfo |	multiTypeInfo := SMultiTypeInfo new type: #ByteString.	self		assert: (STON fromString: 'SMultiTypeInfo [#ByteString]')		equals: multiTypeInfo.	multiTypeInfo := SMultiTypeInfo new		type: #ByteString;		type: #SmallInteger.	self		assert: (STON fromString: 'SMultiTypeInfo [#ByteString, #SmallInteger]')		equals: multiTypeInfo.	multiTypeInfo := SMultiTypeInfo new		type: #ByteString;		type: #SmallInteger;		type: #SStudent.	self		assert:			(STON				fromString: 'SMultiTypeInfo [#ByteString, #SmallInteger, #SStudent, #ByteString]')		equals: multiTypeInfo</body><body package="SmallSuiteGenerator-Tests-Info">testToString	| string multiType |	multiType := SMultiTypeInfo new type: #ByteString.	string := STON toString: multiType.	self assert: (STON fromString: string) equals: multiType.	multiType := SMultiTypeInfo new		type: #ByteString;		type: #SmallInteger.	string := STON toString: multiType.	self assert: (STON fromString: string) equals: multiType.	multiType := SMultiTypeInfo new		type: #ByteString;		type: #SmallInteger;		type: #SStudent.	string := STON toString: multiType.	self assert: (STON fromString: string) equals: multiType</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfoTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-Info">nameOf: aClass	^ aClass name</body><body package="SmallSuiteGenerator-Tests-Info">testAccesssMessagesFrom	| typeInfo |	typeInfo := STypeInfo new		type:			#SFoo				-&gt;					(Array						with:							(Array								with: #returnString -&gt; #(#SFoo #ByteString #() false)								with: #score -&gt; #(#SFoo #SmallInteger #() true))						with: #()).	self		assertCollection: ((typeInfo accessMessagesFrom: #SFoo) collect: #selector)		hasSameElements: #(#score)</body><body package="SmallSuiteGenerator-Tests-Info">testAsTypeInfoSConferenceOnPackagesMatching	| typeInfo messages |	typeInfo := SSTypeCollector		profile: [ SConference price: 95 ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario'.	messages := typeInfo messagesFrom: (self nameOf: SConference).	self		assertCollection: (messages collect: #selector)		hasSameElements: #(#initialize #price:).	self		assert:			((messages flatCollect: [ :aMessage | aMessage receiver types ])				allSatisfy: [ :aType | aType = (self nameOf: SConference) ]).	self assert: (typeInfo messagesFrom: (self nameOf: SEvent)) isEmpty.	self assert: (typeInfo messagesFrom: (self nameOf: SParty)) isEmpty.	messages := typeInfo factoryMessagesFrom: (self nameOf: SConference).	self		assertCollection: (messages collect: #selector)		hasSameElements: #(#price:)</body><body package="SmallSuiteGenerator-Tests-Info">testAsTypeInfoSEventOnPackagesMatching	| typeInfo messages methodInfo classNameSEvent classNameSConference classNameSParty classNameByteString classNameSmallInteger classNameSStudent |	classNameSEvent := self nameOf: SEvent.	classNameSConference := self nameOf: SConference.	classNameSParty := self nameOf: SParty.	classNameByteString := self nameOf: ByteString.	classNameSmallInteger := self nameOf: SmallInteger.	classNameSStudent := self nameOf: SStudent.	typeInfo := SSTypeCollector		profile: [ | aConference aPerson |			aConference := SConference new offerPrice: 95.			aPerson := SStudent new name: 'Mary'.			aConference canRegister: aPerson ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario'.	self		assert: (typeInfo types at: classNameSEvent) methodTypes size		equals: 2.	self		assert: (typeInfo types at: classNameSEvent) classMethodTypes isEmpty.	self		assert: (typeInfo types at: classNameSConference) methodTypes size		equals: 3.	self		assert: (typeInfo types at: classNameSConference) classMethodTypes isEmpty.	self assert: (typeInfo types at: classNameSParty) methodTypes isEmpty.	self		assert: (typeInfo types at: classNameSParty) classMethodTypes isEmpty.	messages := typeInfo messagesFrom: classNameSConference.	self		assertCollection: (messages collect: #selector)		hasSameElements: #(#initialize #offerPrice: #canRegister: #price).	self		assert:			((messages flatCollect: [ :aMessage | aMessage receiver types ])				allSatisfy: [ :aType | aType = classNameSConference ]).	methodInfo := messages		detect: [ :aMessage | aMessage selector = #canRegister: ].	self		assertCollection: methodInfo returnType types		hasSameElements: (Array with: (self nameOf: False)).	self		assertCollection: methodInfo allArgTypes		hasSameElements: (Array with: classNameSStudent).	self		assertCollection: methodInfo allReceivers		hasSameElements: (Array with: classNameSConference).	self		assertCollection: typeInfo scalars keys		hasSameElements:			(Array				with: classNameSStudent				with: classNameSmallInteger				with: (self nameOf: False)				with: classNameByteString)</body><body package="SmallSuiteGenerator-Tests-Info">testAsTypeInfoSFoo	| profile typeInfo methodInfo classNameSFoo classNameOrderedCollection classNameSmallFloat64 classNameByteString classNameSmallInteger classNameDictionary |	classNameSFoo := self nameOf: SFoo.	classNameOrderedCollection := self nameOf: OrderedCollection.	classNameSmallFloat64 := self nameOf: SmallFloat64.	classNameByteString := self nameOf: ByteString.	classNameSmallInteger := self nameOf: SmallInteger.	classNameDictionary := self nameOf: Dictionary.	profile := SSTypeCollector		profile: [ SFoo new				return: Dictionary new;				return: OrderedCollection new;				returnFloat;				returnString;				returnCollection;				returnNum;				score;				score: 5 ]		onClass: SFoo.	typeInfo := profile asTypeInfo.	self		assert: (typeInfo types at: classNameSFoo) methodTypes size		equals: 8.	self		assert: (typeInfo types at: classNameSFoo) classMethodTypes size		equals: 0.	self		assert: (typeInfo methodType: #initialize from: classNameSFoo) returnType type		equals: classNameSFoo.	methodInfo := typeInfo methodType: #return: from: classNameSFoo.	self		assertCollection: methodInfo returnType types		hasSameElements: (Array with: classNameOrderedCollection with: classNameDictionary).	self		assertCollection: methodInfo allArgTypes		hasSameElements: (Array with: classNameOrderedCollection with: classNameDictionary).	self		assert:			(typeInfo methodType: #returnFloat from: classNameSFoo) returnType				type		equals: classNameSmallFloat64.	self		assert:			(typeInfo methodType: #returnCollection from: classNameSFoo)				returnType type		equals: classNameOrderedCollection.	self		assert:			(typeInfo methodType: #returnString from: classNameSFoo) returnType				type		equals: classNameByteString.	self		assert: (typeInfo methodType: #returnNum from: classNameSFoo) returnType type		equals: classNameSmallInteger.	self		assert: (typeInfo methodType: #score from: classNameSFoo) returnType type		equals: classNameSmallInteger.	methodInfo := typeInfo methodType: #score: from: classNameSFoo.	self assert: methodInfo returnType type equals: classNameSFoo.	self		assertCollection: methodInfo allArgTypes		hasSameElements: (Array with: classNameSmallInteger).	self assert: (typeInfo factoryMessagesFrom: classNameSFoo) isEmpty.	"the factoryMessage has not been executed"	self		assertCollection: typeInfo scalars keys		hasSameElements:			(Array				with: classNameOrderedCollection				with: classNameDictionary				with: classNameByteString				with: classNameSmallInteger				with: classNameSmallFloat64)</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfoTest</class-id> <category>As yet unclassified</category><body package="SmallSuiteGenerator-Tests-Info">testAsTypeInfoSFoo	| profile typeInfo methodInfo classNameSFoo classNameOrderedCollection classNameSmallFloat64 classNameByteString classNameSmallInteger classNameDictionary |	classNameSFoo := self nameOf: SFoo.	classNameOrderedCollection := self nameOf: OrderedCollection.	classNameSmallFloat64 := self nameOf: SmallFloat64.	classNameByteString := self nameOf: ByteString.	classNameSmallInteger := self nameOf: SmallInteger.	classNameDictionary := self nameOf: Dictionary.	profile := SSTypeCollector		profile: [ SFoo new				return: Dictionary new;				return: OrderedCollection new;				returnFloat;				returnString;				returnCollection;				returnNum;				score;				score: 5 ]		onClass: SFoo.	typeInfo := profile asTypeInfo.	self		assert: (typeInfo types at: classNameSFoo) methodTypes size		equals: 8.	self		assert: (typeInfo types at: classNameSFoo) classMethodTypes size		equals: 0.	self		assert: (typeInfo methodType: #initialize from: classNameSFoo) returnType type		equals: classNameSFoo.	methodInfo := typeInfo methodType: #return: from: classNameSFoo.	self		assertCollection: methodInfo returnType types		hasSameElements: (Array with: classNameOrderedCollection with: classNameDictionary).	self		assertCollection: methodInfo allArgTypes		hasSameElements: (Array with: classNameOrderedCollection with: classNameDictionary).	self		assert:			(typeInfo methodType: #returnFloat from: classNameSFoo) returnType				type		equals: classNameSmallFloat64.	self		assert:			(typeInfo methodType: #returnCollection from: classNameSFoo)				returnType type		equals: classNameOrderedCollection.	self		assert:			(typeInfo methodType: #returnString from: classNameSFoo) returnType				type		equals: classNameByteString.	self		assert: (typeInfo methodType: #returnNum from: classNameSFoo) returnType type		equals: classNameSmallInteger.	self		assert: (typeInfo methodType: #score from: classNameSFoo) returnType type		equals: classNameSmallInteger.	methodInfo := typeInfo methodType: #score: from: classNameSFoo.	self assert: methodInfo returnType type equals: classNameSFoo.	self		assertCollection: methodInfo allArgTypes		hasSameElements: (Array with: classNameSmallInteger).	self assert: (typeInfo factoryMessagesFrom: classNameSFoo) isEmpty.	"the factoryMessage has not been executed"	self		assertCollection: typeInfo scalars keys		hasSameElements:			(Array				with: classNameOrderedCollection				with: classNameDictionary				with: classNameByteString				with: classNameSmallInteger				with: classNameSmallFloat64)</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfoTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-Info">testAsTypeInfoSFooOnClass	| profile typeInfo methodInfo classNameSFoo |	classNameSFoo := self nameOf: SFoo.	profile := SSTypeCollector		profile: [ SFoo new return: OrderedCollection ]		onClass: SFoo.	typeInfo := profile asTypeInfo.	self		assert: (typeInfo types at: classNameSFoo) methodTypes size		equals: 2.	self		assert: (typeInfo types at: classNameSFoo) classMethodTypes isEmpty.	self		assert: (typeInfo methodType: #initialize from: classNameSFoo) returnType type		equals: classNameSFoo.	methodInfo := typeInfo methodType: #return: from: classNameSFoo.	self		assertCollection: methodInfo returnType types		hasSameElements: #('OrderedCollection class').	self		assertCollection: methodInfo allArgTypes		hasSameElements: #('OrderedCollection class').	self		assertCollection: ((typeInfo messagesFrom: classNameSFoo) collect: #selector)		hasSameElements: #(#initialize #return:)</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfoTest</class-id> <category>As yet unclassified</category><body package="SmallSuiteGenerator-Tests-Info">testAsTypeInfoSFooOnClass	| profile typeInfo methodInfo classNameSFoo |	classNameSFoo := self nameOf: SFoo.	profile := SSTypeCollector		profile: [ SFoo new return: OrderedCollection ]		onClass: SFoo.	typeInfo := profile asTypeInfo.	self		assert: (typeInfo types at: classNameSFoo) methodTypes size		equals: 2.	self		assert: (typeInfo types at: classNameSFoo) classMethodTypes isEmpty.	self		assert: (typeInfo methodType: #initialize from: classNameSFoo) returnType type		equals: classNameSFoo.	methodInfo := typeInfo methodType: #return: from: classNameSFoo.	self		assertCollection: methodInfo returnType types		hasSameElements: #('OrderedCollection class').	self		assertCollection: methodInfo allArgTypes		hasSameElements: #('OrderedCollection class').	self		assertCollection: ((typeInfo messagesFrom: classNameSFoo) collect: #selector)		hasSameElements: #(#initialize #return:)</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfoTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-Info">testAsTypeInfoSFooWithNil	| profile typeInfo methodInfo classNameSFoo |	classNameSFoo := self nameOf: SFoo.	profile := SSTypeCollector		profile: [ SFoo new return: nil ]		onClass: SFoo.	typeInfo := profile asTypeInfo.	self		assert: (typeInfo types at: classNameSFoo) methodTypes size		equals: 2.	self		assert: (typeInfo types at: classNameSFoo) classMethodTypes isEmpty.	self		assert: (typeInfo methodType: #initialize from: classNameSFoo) returnType type		equals: classNameSFoo.	methodInfo := typeInfo methodType: #return: from: classNameSFoo.	self		assertCollection: methodInfo returnType types		hasSameElements: (Array with: (self nameOf: UndefinedObject)).	self		assertCollection: methodInfo allArgTypes		hasSameElements: (Array with: (self nameOf: UndefinedObject)).	self		assertCollection: ((typeInfo messagesFrom: classNameSFoo) collect: #selector)		hasSameElements: #(#initialize #return:)</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfoTest</class-id> <category>As yet unclassified</category><body package="SmallSuiteGenerator-Tests-Info">testAsTypeInfoSFooWithNil	| profile typeInfo methodInfo classNameSFoo |	classNameSFoo := self nameOf: SFoo.	profile := SSTypeCollector		profile: [ SFoo new return: nil ]		onClass: SFoo.	typeInfo := profile asTypeInfo.	self		assert: (typeInfo types at: classNameSFoo) methodTypes size		equals: 2.	self		assert: (typeInfo types at: classNameSFoo) classMethodTypes isEmpty.	self		assert: (typeInfo methodType: #initialize from: classNameSFoo) returnType type		equals: classNameSFoo.	methodInfo := typeInfo methodType: #return: from: classNameSFoo.	self		assertCollection: methodInfo returnType types		hasSameElements: (Array with: (self nameOf: UndefinedObject)).	self		assertCollection: methodInfo allArgTypes		hasSameElements: (Array with: (self nameOf: UndefinedObject)).	self		assertCollection: ((typeInfo messagesFrom: classNameSFoo) collect: #selector)		hasSameElements: #(#initialize #return:)</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfoTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-Info">testAsTypeInfoSTeacherOnClass	| typeInfo classNameSTeacher |	classNameSTeacher := self nameOf: SSTeacher.	typeInfo := (SSTypeCollector		profile: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		onClass: SSTeacher) asTypeInfo.	self		assertCollection:			((typeInfo types at: classNameSTeacher) methodTypes values				collect: #selector)		hasSameElements: #(#idTeacher #initialize #nickname #yearsWorkExperience).	self		assert: (typeInfo types at: classNameSTeacher) classMethodTypes isEmpty.	self		assertCollection: ((typeInfo messagesFrom: classNameSTeacher) collect: #selector)		hasSameElements: #(#initialize #nickname).	self		assertCollection: ((typeInfo accessMessagesFrom: classNameSTeacher) collect: #selector)		hasSameElements: #(#idTeacher #yearsWorkExperience)</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfoTest</class-id> <category>As yet unclassified</category><body package="SmallSuiteGenerator-Tests-Info">testAsTypeInfoSTeacherOnClass	| typeInfo classNameSTeacher |	classNameSTeacher := self nameOf: SSTeacher.	typeInfo := (SSTypeCollector		profile: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		onClass: SSTeacher) asTypeInfo.	self		assertCollection:			((typeInfo types at: classNameSTeacher) methodTypes values				collect: #selector)		hasSameElements: #(#idTeacher #initialize #nickname #yearsWorkExperience).	self		assert: (typeInfo types at: classNameSTeacher) classMethodTypes isEmpty.	self		assertCollection: ((typeInfo messagesFrom: classNameSTeacher) collect: #selector)		hasSameElements: #(#initialize #nickname).	self		assertCollection: ((typeInfo accessMessagesFrom: classNameSTeacher) collect: #selector)		hasSameElements: #(#idTeacher #yearsWorkExperience)</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfoTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-Info">testAsTypeInfoSTeacherOnPackagesMatching	| typeInfo |	typeInfo := SSTypeCollector		profile: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario'.	self		assertCollection:			((typeInfo types at: (self nameOf: SSTeacher)) methodTypes values				collect: #selector)		hasSameElements: #(#idTeacher #initialize #nickname #yearsWorkExperience).	self		assertCollection:			((typeInfo factoryMessagesFrom: (self nameOf: SSTeacher))				collect: #selector)		hasSameElements: #(#name:with:).	self		assertCollection: ((typeInfo messagesFrom: (self nameOf: SSTeacher)) collect: #selector)		hasSameElements: #(#initialize #nickname #id: #nickname: #name:).	self		assertCollection:			((typeInfo accessMessagesFrom: (self nameOf: SSTeacher))				collect: #selector)		hasSameElements: #(#idTeacher #yearsWorkExperience #name #id)</body><body package="SmallSuiteGenerator-Tests-Info">testClassMethodTypeFrom	| typeInfo |	typeInfo := STypeInfo new type: #SFoo -&gt; (Array with: #() with: #()).	self		should: [ typeInfo classMethodType: #new from: #SFoo ]		raise: SError.	typeInfo := STypeInfo new		type:			#SFoo				-&gt;					(Array						with: (Array with: #initialize -&gt; #(#SFoo #SFoo #() false))						with: #()).	self		shouldnt: [ typeInfo classMethodType: #new from: #SFoo ]		raise: SError</body><body package="SmallSuiteGenerator-Tests-Info">testEquals	self		assert: (STypeInfo new type: #SFoo -&gt; #(#() #()))		equals: (STypeInfo new type: #SFoo -&gt; #(#() #())).	self		assert:			(STypeInfo new				type:					#SStudent						-&gt;							(Array								with: (Array with: #name -&gt; #(#SStudent #ByteString #() false))								with: #());				scalar: #ByteString with: #('Abi'))		equals:			(STypeInfo new				type:					#SStudent						-&gt;							(Array								with: (Array with: #name -&gt; #(#SStudent #ByteString #() false))								with: #());				scalar: #ByteString with: #('Abi')).	self		assert:			(STypeInfo new				type:					#SFoo						-&gt;							(Array								with: (Array with: #return: -&gt; #(#SFoo #SStudent #(#SStudent) false))								with: (Array with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false)));				scalar: #SmallInteger with: #(1 3 4);				scalar: #SStudent with: (Array with: (SStudent name: 'Nilson')))		equals:			(STypeInfo new				type:					#SFoo						-&gt;							(Array								with: (Array with: #return: -&gt; #(#SFoo #SStudent #(#SStudent) false))								with: (Array with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false)));				scalar: #SmallInteger with: #(1 3 4);				scalar: #SStudent with: (Array with: (SStudent name: 'Nilson')))</body><body package="SmallSuiteGenerator-Tests-Info">testFactoryMessages	| typeInfo |	typeInfo := (SSTypeCollector		profile: [ SStudent name: 'Mary' ]		onClass: SStudent) asTypeInfo.	self assert: (typeInfo factoryMessagesFrom: #SStudent) isEmpty.	typeInfo := SSTypeCollector		profile: [ SStudent name: 'Mary' ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario'.	self		assertCollection: ((typeInfo factoryMessagesFrom: #SStudent) collect: #selector)		hasSameElements: #(#name:).	typeInfo := SSTypeCollector		profile: [ SConference price: 95 ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario'.	self		assertCollection: ((typeInfo factoryMessagesFrom: #SConference) collect: #selector)		hasSameElements: #(#price:)</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfoTest</class-id> <category>As yet unclassified</category><body package="SmallSuiteGenerator-Tests-Info">testFactoryMessages	| typeInfo |	typeInfo := (SSTypeCollector		profile: [ SStudent name: 'Mary' ]		onClass: SStudent) asTypeInfo.	self assert: (typeInfo factoryMessagesFrom: #SStudent) isEmpty.	typeInfo := SSTypeCollector		profile: [ SStudent name: 'Mary' ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario'.	self		assertCollection: ((typeInfo factoryMessagesFrom: #SStudent) collect: #selector)		hasSameElements: #(#name:).	typeInfo := SSTypeCollector		profile: [ SConference price: 95 ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario'.	self		assertCollection: ((typeInfo factoryMessagesFrom: #SConference) collect: #selector)		hasSameElements: #(#price:)</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfoTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-Info">testFactoryMessagesFrom	"self halt"	</body><body package="SmallSuiteGenerator-Tests-Info">testFromString	| typeInfo |	typeInfo := STypeInfo new		type:			#SFoo				-&gt;					(Array						with:							(Array								with: #returnFloat -&gt; #(#SFoo #SmallFloat64 #() false)								with: #return: -&gt; #(#SFoo #ByteString #(#ByteString) false))						with: (Array with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false)));		scalar: #SmallFloat64 with: #(2.3 4.6);		scalar: #ByteString with: #('hello' 'Abi').	self		assert:			(STON				fromString:					'STypeInfo {						#types: { 							#SFoo: STypeClassInfo { 							#typeName: #SFoo,							#methodTypes: {								#returnFloat: STypeMethodInfo {#selector: #returnFloat, #receiver: SMultiTypeInfo [#SFoo], #returnType: SMultiTypeInfo [#SmallFloat64], #argTypes: [], #isQuick: false}, 								#''return:'': STypeMethodInfo {#selector: #''return:'', #receiver: SMultiTypeInfo [#SFoo], #returnType: SMultiTypeInfo [#ByteString], #argTypes: [SMultiTypeInfo [#ByteString]], #isQuick: false}}, 							#classMethodTypes: { 								#''score:'': STypeMethodInfo {#selector: #''score:'', #receiver: SMultiTypeInfo [#SFoo], #returnType: SMultiTypeInfo [#SFoo], #argTypes: [SMultiTypeInfo [#SmallInteger]], #isQuick: false}							}}						},					#scalars: {						#SmallFloat64: [ 2.3, 4.6 ],						#ByteString: [ ''hello'', ''Abi'' ]					}}')		equals: typeInfo</body><body package="SmallSuiteGenerator-Tests-Info">testIsAbstracClass	| typeInfo |	typeInfo := STypeInfo new		type:			#SSPerson				-&gt;					(Array						with:							(Array								with: #name -&gt; #(#SSPerson #ByteString #() true)								with: #id -&gt; #(#SSPerson #SmallInteger #() false))						with:							(Array								with:									#name:with:										-&gt; #(#SSPerson #SSPerson #(#ByteString #SmallInteger) false)));		scalar: #SmallInteger with: #(50);		scalar: #ByteString with: #('Ann').	self assert: (typeInfo isAbstractClass: #SSPerson)</body><body package="SmallSuiteGenerator-Tests-Info">testJoinWith	| typeInfo methodInfo otherTypeInfo |	typeInfo := STypeInfo new		type:			#SFoo				-&gt;					(Array						with:							(Array								with: #return: -&gt; #(#SFoo #OrderedCollection #(#OrderedCollection) false)								with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false)								with: #score -&gt; #(#SFoo #SmallInteger #() true))						with: (Array with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false))).	otherTypeInfo := STypeInfo new		type:			#SFoo				-&gt;					(Array						with:							(Array								with: #returnFloat -&gt; #(#SFoo #SmallFloat64 #() false)								with: #returnString -&gt; #(#SFoo #ByteString #() false)								with: #return: -&gt; #(#SFoo #Stack #(#Stack) false))						with: #()).	typeInfo joinWith: otherTypeInfo.	self assert: (typeInfo types at: #SFoo) methodTypes size equals: 5.	self		assert: (typeInfo types at: #SFoo) classMethodTypes size		equals: 1.	methodInfo := typeInfo methodType: #return: from: #SFoo.	self assert: methodInfo receiver type equals: #SFoo.	self		assertCollection: #(#OrderedCollection #Stack)		hasSameElements: methodInfo returnType types.	self		assertCollection: #(#OrderedCollection #Stack)		hasSameElements: (methodInfo argTypes flatCollect: [ :argType | argType types ]).	self		assert: (typeInfo methodType: #returnFloat from: #SFoo) returnType type		equals: #SmallFloat64.	self		assert: (typeInfo methodType: #returnString from: #SFoo) returnType type		equals: #ByteString.	self		assert: (typeInfo methodType: #score from: #SFoo) returnType type		equals: #SmallInteger.	methodInfo := typeInfo methodType: #score: from: #SFoo.	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #SFoo.	self		assertCollection: (methodInfo argTypes flatCollect: [ :argType | argType types ])		hasSameElements: #(#SmallInteger).	self		assert: (typeInfo classMethodType: #score: from: #SFoo) returnType type		equals: #SFoo</body><body package="SmallSuiteGenerator-Tests-Info">testMessagesFrom	| typeInfo |	typeInfo := STypeInfo new		type:			#SFoo				-&gt;					(Array						with:							(Array								with: #returnFloat -&gt; #(#SFoo #SmallFloat64 #() false)								with: #returnString -&gt; #(#SFoo #ByteString #() false)								with: #score -&gt; #(#SFoo #SmallInteger #() true))						with: (Array with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false))).	self		assertCollection: ((typeInfo messagesFrom: #SFoo) collect: #selector)		hasSameElements: #(#returnFloat #returnString)	"self assertCollection: ((typeInfo accessMessagesFrom: #SFoo) collect: #selector) hasSameElements: #(#score)."</body><body package="SmallSuiteGenerator-Tests-Info">testNoneAbstractClasses	| typeInfo |	typeInfo := STypeInfo new		type:			#SSPerson				-&gt;					(Array						with:							(Array								with: #name -&gt; #(#SSPerson #ByteString #() true)								with: #id -&gt; #(#SSPerson #SmallInteger #() false))						with:							(Array								with:									#name:with:										-&gt; #(#SSPerson #SSPerson #(#ByteString #SmallInteger) false)));		type:			#SAbstractClass				-&gt;					(Array						with: (Array with: #id -&gt; #(#SAbstractClass #SmallInteger #() true))						with: #());		type:			#SStudent				-&gt;					(Array						with: (Array with: #scoreStudent -&gt; #(#SStudent #SmallInteger #() true))						with: #());		scalar: #SmallInteger with: #(50 1);		scalar: #ByteString with: #('Ann').	self		assertCollection: (typeInfo noneAbstractClasses collect: #name)		hasSameElements: #(#SStudent)</body><body package="SmallSuiteGenerator-Tests-Info">testScalar	| typeInfo |	typeInfo := STypeInfo new		scalar: #SmallInteger with: #(1 5 6);		scalar: #ByteString with: #('hello' 'world');		scalar: #Dictionary			with:			(Array				with: Dictionary new				with:					(Dictionary new						at: 2 put: 3;						yourself)).	self		assertCollection: typeInfo scalars keys		hasSameElements: #(#Dictionary #ByteString #SmallInteger).	self		assertCollection: (typeInfo scalars at: #ByteString)		hasSameElements: #('hello' 'world').	self		assertCollection: (typeInfo scalars at: #SmallInteger)		hasSameElements: #(1 5 6).	self		assertCollection: ((typeInfo scalars at: #Dictionary) collect: #className)		hasSameElements: #('Dictionary' 'Dictionary')</body><body package="SmallSuiteGenerator-Tests-Info">testToString	| string typeInfo |	typeInfo := STypeInfo new		type:			#SFoo				-&gt;					(Array						with:							(Array								with: #returnFloat -&gt; #(#SFoo #SmallFloat64 #() false)								with: #return: -&gt; #(#SFoo #ByteString #(#ByteString) false))						with: (Array with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false)));		scalar: #SmallFloat64 with: #(2.3 4.6);		scalar: #ByteString with: #('hello' 'Abi').	string := STON toString: typeInfo.	self assert: (STON fromString: string) equals: typeInfo</body><body package="SmallSuiteGenerator-Tests-Info">testToStringComplexScalar	| string typeInfo |	typeInfo := STypeInfo new		type:			#SFoo				-&gt;					(Array						with: (Array with: #return: -&gt; #(#SFoo #ByteString #(#ByteString) false))						with: #());		scalar: #SStudent with: (Array with: (SStudent name: 'Abi')).	string := STON toString: typeInfo.	self assert: (STON fromString: string) equals: typeInfo</body><body package="SmallSuiteGenerator-Tests-Info">testType	| typeInfo methodInfo |	typeInfo := STypeInfo new		type:			#SFoo				-&gt;					(Array						with:							(Array								with: #returnFloat -&gt; #(#SFoo #SmallFloat64 #() false)								with: #returnString -&gt; #(#SFoo #ByteString #() false)								with: #return: -&gt; #(#SFoo #OrderedCollection #(#OrderedCollection) false)								with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false)								with: #score -&gt; #(#SFoo #SmallInteger #() true))						with: (Array with: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false))).	self assert: (typeInfo types at: #SFoo) methodTypes size equals: 5.	self		assert: (typeInfo types at: #SFoo) classMethodTypes size		equals: 1.	methodInfo := typeInfo methodType: #return: from: #SFoo.	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #OrderedCollection.	self		assertCollection: methodInfo allArgTypes		hasSameElements: #(#OrderedCollection).	self		assert: (typeInfo methodType: #returnFloat from: #SFoo) returnType type		equals: #SmallFloat64.	self		assert: (typeInfo methodType: #returnString from: #SFoo) returnType type		equals: #ByteString.	self		assert: (typeInfo methodType: #score from: #SFoo) returnType type		equals: #SmallInteger.	methodInfo := typeInfo methodType: #score: from: #SFoo.	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #SFoo.	self		assertCollection: methodInfo allArgTypes		hasSameElements: #(#SmallInteger).	self		assert: (typeInfo classMethodType: #score: from: #SFoo) returnType type		equals: #SFoo</body></methods><methods><class-id>SmallSuiteGenerator.SVariable</class-id> <category>mutation</category><body package="SmallSuiteGenerator-AST">pickUpReferences: anExpression	^ self = anExpression reference		ifFalse: [ #() ]		ifTrue: [ Array with: self ]</body><body package="SmallSuiteGenerator-AST">repairOn: aTestCase changing: aExpression	| otherVariable |	otherVariable := aTestCase		alternativeOfVariable: self		before: aExpression.	self varName: otherVariable varName.	self id: otherVariable id</body><body package="SmallSuiteGenerator-AST">replaceArgBy: expression	returnType = expression returnType		ifFalse: [ ^ self				error:					'Cannot replace argument of type: ' , returnType , ' by: '						, expression returnType ].	self replaceBy: expression</body><body package="SmallSuiteGenerator-AST">variablesWithId	^ id ifNotNil: [ Array with: self ] ifNil: [ super variablesWithId ]</body></methods><methods><class-id>SmallSuiteGenerator.SVariable</class-id> <category>accessing</category><body package="SmallSuiteGenerator-AST">referenceTo: aClassName	^ self returnType = aClassName</body><body package="SmallSuiteGenerator-AST">replaceBy: otherVariable	self varName: otherVariable varName.	self id: otherVariable id.	self returnType: otherVariable returnType</body><body package="SmallSuiteGenerator-AST">varName	^ varName</body><body package="SmallSuiteGenerator-AST">varName: anObject	varName := anObject</body></methods><methods><class-id>SmallSuiteGenerator.SVariable</class-id> <category>printing</category><body package="SmallSuiteGenerator-AST">printOn: aStream	aStream nextPutAll: varName.	id ifNotNil: [ aStream nextPutAll: id printString ]</body></methods><methods><class-id>SmallSuiteGenerator.SVariable</class-id> <category>actions</category><body package="SmallSuiteGenerator-AST">replaceExpression: anExpression by: newExpression	| reference |	self = anExpression		ifFalse: [ ^ self ].	reference := newExpression reference.	self		id: reference id;		varName: reference varName;		returnType: reference returnType</body></methods><methods><class-id>SmallSuiteGenerator.SVariable</class-id> <category>comparing</category><body package="SmallSuiteGenerator-AST">= other	^ super = other and: [ varName = other varName ]</body><body package="SmallSuiteGenerator-AST">hash	^ super hash bitXor: varName hash</body></methods><methods><class-id>SmallSuiteGenerator.SVariable</class-id> <category>copying</category><body package="SmallSuiteGenerator-AST">copy	| copy |	copy := super copy.	copy varName: varName copy.	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.SVariable</class-id> <category>initialization</category><body package="SmallSuiteGenerator-AST">initialize	super initialize.	varName := '_var'</body></methods><methods><class-id>SmallSuiteGenerator.SVariable class</class-id> <category>accessing</category><body package="SmallSuiteGenerator-AST">name: aString	| variable |	variable := self new.	variable varName: aString.	^ variable</body></methods><methods><class-id>SmallSuiteGenerator.SMethodInfoTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-Info">testEquals	self		assert: (STypeMethodInfo type: #name -&gt; #(#SStudent #ByteString #() false))		equals: (STypeMethodInfo type: #name -&gt; #(#SStudent #ByteString #() false)).	self		assert:			(STypeMethodInfo				type: #return: -&gt; #(#SFoo #ByteString #(#ByteString) false))		equals:			(STypeMethodInfo				type: #return: -&gt; #(#SFoo #ByteString #(#ByteString) false))</body><body package="SmallSuiteGenerator-Tests-Info">testFromSton	| typeMethod |	typeMethod := STypeMethodInfo		type: #name -&gt; #(#SStudent #ByteString #() true).	self		assert:			(STON				fromString:					'STypeMethodInfo {#selector: #name, #receiver: SMultiTypeInfo [#SStudent], #returnType: SMultiTypeInfo [#ByteString], #argTypes: [], #isQuick: true}')		equals: typeMethod.	typeMethod := STypeMethodInfo		type: #return: -&gt; #(#SFoo #ByteString #(#ByteString) false).	self		assert:			(STON				fromString:					'STypeMethodInfo {#selector: #''return:'', #receiver: SMultiTypeInfo [#SFoo], #returnType: SMultiTypeInfo [#ByteString], #argTypes: [SMultiTypeInfo [#ByteString]], #isQuick: false}')		equals: typeMethod</body><body package="SmallSuiteGenerator-Tests-Info">testToString	| string typeMethod |	typeMethod := STypeMethodInfo		type: #name -&gt; #(#SStudent #ByteString #() true).	string := STON toString: typeMethod.	self assert: (STON fromString: string) equals: typeMethod.	typeMethod := STypeMethodInfo		type: #return: -&gt; #(#SFoo #ByteString #(#ByteString) false).	string := STON toString: typeMethod.	self assert: (STON fromString: string) equals: typeMethod</body><body package="SmallSuiteGenerator-Tests-Info">testType	| methodInfo |	methodInfo := STypeMethodInfo		type: #returnFloat -&gt; #(#SFoo #SmallFloat64 #() false).	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #SmallFloat64.	self assert: methodInfo allArgTypes isEmpty.	self deny: methodInfo isQuick.	self deny: methodInfo isDeprecated.	methodInfo := STypeMethodInfo		type: #returnString -&gt; #(#SFoo #ByteString #() false).	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #ByteString.	self assert: methodInfo allArgTypes isEmpty.	self deny: methodInfo isQuick.	methodInfo := STypeMethodInfo		type: #return: -&gt; #(#SFoo #OrderedCollection #(#OrderedCollection) false).	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #OrderedCollection.	self		assertCollection: methodInfo allArgTypes		hasSameElements: #(#OrderedCollection).	self deny: methodInfo isQuick.	methodInfo := STypeMethodInfo		type: #score: -&gt; #(#SFoo #SFoo #(#SmallInteger) false).	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #SFoo.	self		assertCollection: methodInfo allArgTypes		hasSameElements: #(#SmallInteger).	self deny: methodInfo isQuick.	methodInfo := STypeMethodInfo		type: #score -&gt; #(#SFoo #SmallInteger #() true).	self assert: methodInfo receiver type equals: #SFoo.	self assert: methodInfo returnType type equals: #SmallInteger.	self assert: methodInfo argTypes isEmpty.	self assert: methodInfo isQuick</body></methods><methods><class-id>SmallSuiteGenerator.SSelf</class-id> <category>initialization</category><body package="SmallSuiteGenerator-AST">initialize	super initialize.	varName := 'self'</body></methods><methods><class-id>SmallSuiteGenerator.SMultiFitnessFunctionTest</class-id> <category>running</category><body package="SmallSuiteGenerator-Tests-GA">setUp	super setUp	"function := SMultiFitnessFunction.	function clean.	fitnessFunctions := Array		with: SMethodCoverage		with: SStatementCoverage.	utility := SUtilityTypeInfo new"</body><body package="SmallSuiteGenerator-Tests-GA">tearDown	"fitnessFunctions do: #clean.	function		clean;		reset."	super tearDown</body></methods><methods><class-id>SmallSuiteGenerator.SMultiFitnessFunctionTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-GA">testComputeFitnessOnFactoryMessage	"| aTestCase res fitness |	aTestCase := SSTestCase with: utility typeInfoSFoo1.	aTestCase addFactoryMessage.	fitness := SStatementCoverage new.	res := (function computeFitness: aTestCase) values.	self assertCollection: res hasSameElements: #(33.33 28.57)"	</body><body package="SmallSuiteGenerator-Tests-GA">testComputeFitnessOnFieldAccessMessage	"| aTestCase res |	aTestCase := SSTestCase with: utility typeInfoSFoo1.	aTestCase addFieldAccessMessage: #score from: #SFoo.	""fitness := SStatementCoverage new.""	res := (function computeFitness: aTestCase) values.	self assertCollection: res hasSameElements: #(44.44 35.71)"	</body><body package="SmallSuiteGenerator-Tests-GA">testComputeFitnessOnLiteral	"| aTestCase res |	aTestCase := SSTestCase with: utility typeInfoSFoo1.	aTestCase addLiteral.	""fitness := SStatementCoverage new.""	res := (function computeFitness: aTestCase) values.	self assertCollection: res hasSameElements: #(0 0)"	</body><body package="SmallSuiteGenerator-Tests-GA">testComputeFitnessOnMessage	"| aTestCase res |	aTestCase := SSTestCase with: utility typeInfoSFoo1.	aTestCase addMessage: #returnFloat from: #SFoo.	""fitness := SStatementCoverage new.""	res := (function computeFitness: aTestCase) values.	self assertCollection: res hasSameElements: #(44.44 42.86)"	</body><body package="SmallSuiteGenerator-Tests-GA">testIsBetterThan	"| testCase1 testCase2 functions |	testCase1 := utility testSuiteSStudentManual second.	testCase2 := utility testSuiteSStudentManual second.	""testCase2 addFieldAccessMessage: #scoreStudent from: #SStudent.	functions := SStatementCoverage new, SMethodCoverage new.""	testCase1 computeFitness: functions first.	testCase1 computeFitness: functions second.	testCase2 computeFitness: functions first.	testCase2 computeFitness: functions second	""self deny: (function is: testCase1 betterThan: testCase2).	self assert: (function is: testCase2 betterThan: testCase1)"""	</body></methods><methods><class-id>SmallSuiteGenerator.SSExecutionContext</class-id> <category>initialization</category><body package="SmallSuiteGenerator-Core">at: aSymbol	^ values at: aSymbol</body><body package="SmallSuiteGenerator-Core">at: aSymbol put: aValue	values at: aSymbol put: aValue</body><body package="SmallSuiteGenerator-Core">initialize	super initialize.	values := OrderedDictionary new</body><body package="SmallSuiteGenerator-Core">keys	^ values keys asOrderedCollection</body></methods><methods><class-id>SmallSuiteGenerator.SSExecutionContext</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Core">associations	^ values associations</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngineTest</class-id> <category>running</category><body package="SmallSuiteGenerator-Tests-GA">setUp	super setUp.	engine := SGAEngine new.	profiler := SBProfiler new.	utility := SUtilityTypeInfo new</body><body package="SmallSuiteGenerator-Tests-GA">tearDown	[ profiler cleanInstrumentation ]		on: Error		do: [  ].	S2Lock value: false.	S2Context value: nil.	S2Profiler remove.	super tearDown</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngineTest</class-id> <category>As yet unclassified</category><body package="SmallSuiteGenerator-Tests-GA">tearDown	[ profiler cleanInstrumentation ]		on: Error		do: [  ].	S2Lock value: false.	S2Context value: nil.	S2Profiler remove.	super tearDown</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngineTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-GA">testRunOnClassSStudentManual	"| testSuite block utility |	utility := SUtilityTypeInfo new.	block := [ SStudent new		scoreStudent: 34;		scoreStudent;		idStudent ].	testSuite := utility testSuiteSStudentManual.	engine		populationSize: 3;		numberOfStatements: 10;		blockToExecute: block;		endForMaxNumberOfGeneration: 10;		typeInfo: utility typeInfosSStudent first;		initializePopulationWith: testSuite;		fitness: (SStatementCoverage coverageOf: block onClass: SStudent).	engine run"	</body><body package="SmallSuiteGenerator-Tests-GA">testRunOnPackagesMatchingSFoo	| first last functionFitness targetPackageRegex |	targetPackageRegex := 'SmallSuiteGenerator-Scenario'.	self profilerOf: targetPackageRegex.	functionFitness := SMethodCoverage new profiler: profiler.	functionFitness tagetPackagesRegex: targetPackageRegex.	engine		typeInfo: utility typeInfoSFooOnPackage1;		" STON fromString: utility typeInfoStringSFoo3."			fitness: functionFitness;		targetClassName: #SFoo;		numberOfIterations: 5;		run.	first := engine logs first fittestTestCase fitness		at: functionFitness functionName.	last := engine logs last fittestTestCase fitness		at: functionFitness functionName.	self assert: first &gt; 0.	self assert: first &lt;= last</body><body package="SmallSuiteGenerator-Tests-GA">testRunOnPackagesSSTeacherUsingMethodCoverage	| first last functionFitness targetPackageRegex |	targetPackageRegex := 'SmallSuiteGenerator-Scenario'.	self profilerOf: targetPackageRegex.	functionFitness := SMethodCoverage new profiler: profiler.	functionFitness tagetPackagesRegex: targetPackageRegex.	engine		typeInfo: utility typeInfoSSTeacherOnPackage1;		"STON fromString: utility typeInfoStringSSTeacher1."			fitness: functionFitness;		targetClassName: #SSTeacher;		numberOfIterations: 5;		run.	first := engine logs first fittestTestCase fitness		at: functionFitness functionName.	last := engine logs last fittestTestCase fitness		at: functionFitness functionName.	self assert: first &gt; 0.	"20 = (1/5) * 100"	self assert: first &lt;= last	"80 = (4/5) * 100"</body><body package="SmallSuiteGenerator-Tests-GA">testRunOnPackagesSSTeacherUsingStatementCoverage	| first last functionFitness targetPackageRegex |	targetPackageRegex := 'SmallSuiteGenerator-Scenario'.	self profilerOf: targetPackageRegex.	functionFitness := SStatementCoverage new profiler: profiler.	functionFitness tagetPackagesRegex: targetPackageRegex.	engine		typeInfo: utility typeInfoSSTeacherOnPackage1;		"STON fromString: utility typeInfoStringSSTeacher1."			fitness: functionFitness;		targetClassName: #SSTeacher;		numberOfIterations: 5;		run.	first := engine logs first fittestTestCase fitness		at: functionFitness functionName.	last := engine logs last fittestTestCase fitness		at: functionFitness functionName.	self assert: first &gt; 0.	"37.5 = (3/8) * 100"	self assert: first &lt;= last	"87.5 = (7/8) * 100"</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngineTest</class-id> <category>as yet unclassified</category><body package="SmallSuiteGenerator-Tests-GA">profilerOf: string	(S2CInstrumentator onPackagesMatching: string) applyOn: profiler.	(profiler allMethods select: #isNotMethodExtension)		do: #installGhosts</body></methods><methods><class-id>SmallSuiteGenerator.SGACrossoverOperationTest</class-id> <category>running</category><body package="SmallSuiteGenerator-Tests-GA">setUp	super setUp.	operation := SGACrossoverOperation new		randomGenerator: SConfiguration newRandomGenerator.	mutationOperation := SGAMutationOperation new		randomGenerator: SConfiguration newRandomGenerator.	utility := SUtilityTypeInfo new</body></methods><methods><class-id>SmallSuiteGenerator.SGACrossoverOperationTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Tests-GA">crossOver: listTestCase	| offSprings offSpring1 offSpring2 |	self assert: listTestCase size &gt;= 2.	offSprings := operation		crossover: listTestCase first		with: listTestCase second.	offSpring1 := offSprings first.	offSpring2 := offSprings second.	self assert: offSpring1 validReferences.	self assert: offSpring2 validReferences</body><body package="SmallSuiteGenerator-Tests-GA">crossOverWithMutation: listTestCase	| offSprings offSpring1 offSpring2 |	self assert: listTestCase size &gt;= 2.	self assert: listTestCase first validReferences.	self assert: listTestCase second validReferences.	offSpring1 := mutationOperation mutate: listTestCase first.	offSpring2 := mutationOperation mutate: listTestCase second.	offSprings := operation crossover: offSpring1 with: offSpring2.	offSpring1 := offSprings first.	offSpring2 := offSprings second.	offSpring1 := mutationOperation mutate: offSpring1.	offSpring2 := mutationOperation mutate: offSpring2.	offSprings := operation crossover: offSpring1 with: offSpring2.	self assert: offSpring1 validReferences.	self assert: offSpring2 validReferences</body><body package="SmallSuiteGenerator-Tests-GA">testCrossOverToSStack	self crossOver: utility testSuiteSStack.	self crossOverWithMutation: utility testSuiteSStack</body><body package="SmallSuiteGenerator-Tests-GA">testCrossOverToSStudent	self crossOver: utility testSuiteSStudent</body><body package="SmallSuiteGenerator-Tests-GA">testCrossOverToSStudent2	self crossOver: utility testSuiteSStudentManual.	self crossOverWithMutation: utility testSuiteSStudentManual</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactoryPharo</class-id> <category>actions</category><body package="SmallSuiteGenerator-Core">cleanInstrumentation	profiler cleanInstrumentation</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>PackageSpy</name><environment>Smalltalk</environment><super>Spy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packageName classes profiler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>Spy-Core</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>ParkMillerRandom</name><environment>Core</environment><super>Core.Random</super><private>false</private><indexed-type>none</indexed-type><inst-vars>a m </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>MethodSpy</name><environment>Smalltalk</environment><super>Spy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instrumentedMethod originalMethod selector classSpy outgoingCalls incomingCalls executionTime localExecutionTime globalCounter staticOutgoingCalls spywrapper isExecuted messageTally </inst-vars><class-inst-vars>inMeta </class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>Spy-Core</package></attributes></class><class><name>Profiler</name><environment>Smalltalk</environment><super>Spy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packages totalExecutionTime allClassesAsDictionaryCache allMethodsCache unitTestResult packagesToTest iterations maxTimeToRun myTimeProfiler messageTallyMethods allNonAbstractMethodsCache evaluatedMethods </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>Spy-Core</package></attributes></class><class><name>ClassSpy</name><environment>Smalltalk</environment><super>Spy</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methods className allSubclassesCache packageSpy metaclassSpy originalClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>Spy-Core</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class></st-source>