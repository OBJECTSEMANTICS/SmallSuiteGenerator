<?xml version="1.0"?><st-source><!-- Name: SpyLite-ExtensionsBundleName: SpyLite-ExtensionsBundleStructure: a Store.BundleForParcelDevelopmentPrerequisites: #(#(#any 'SpyLite' '' ) )Parcel: nilParcelName: SpyLite-ExtensionsPrerequisiteDescriptions: #(#(#name 'SpyLite' #componentType #bundle ) )PrerequisiteParcels: #(#('SpyLite' '' ) )Version: imageDate: 4:21:37 PM January 21, 2020 --><time-stamp>From VisualWorksÂ®, 8.3 of July 28, 2017 on January 21, 2020 at 4:21:37 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><methods><class-id>Spy1.SLMethodCoverage</class-id> <category>installing</category><body package="SpyLite-Extensions">uninstall 	probedMethod ifNotNil: [		probedMethod revert.		]</body></methods><methods><class-id>Core.String class</class-id> <category>defaults</category><body package="SpyLite-Extensions">lf	"Answer a string containing a single carriage return character."	^ self with: Character lf</body></methods><methods><class-id>Core.String</class-id> <category>private</category><body package="SpyLite-Extensions">substrings	"Answer an array of non-empty substrings from the receiver separated by	one or more whitespace characters."		"'let us make seperate strings' substrings &gt;&gt;&gt;  #('let' 'us' 'make' 'seperate' 'strings')"	^ self  substrings: (Array with: Character space)</body></methods><methods><class-id>Core.Collection</class-id> <category>converting</category><body package="SpyLite-Extensions">asDictionary	^ Dictionary newFrom: self</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="SpyLite-Extensions">associationsDo: aBlock 	"Evaluate aBlock for each of the receiver's key/value associations."	tally == 0 ifTrue: [^self].	1 to: self basicSize do: 		[:index |		| elem |		(elem := self basicAt: index) == nil ifFalse: [aBlock value: elem]]</body><body package="SpyLite-Extensions">difference: aCollection	"Answer the set theoretic difference of two collections. Pay attention that the difference is not commutative, hence the order is important."	"(#(a b c d e f) difference:  #(a b z k))&gt;&gt;&gt; #(#f #d #e #c)"	"(#(a b z k) difference: #(a b c d e f)) &gt;&gt;&gt; #(#k #z)"	| set |	set := self asSet		removeAllFoundIn: aCollection;		yourself.	^ self species withAll: set asArray</body><body package="SpyLite-Extensions">intersection: aCollection	"Answer the set theoretic intersection of two collections."	"(#(1 2 3 4) intersection: #(3 4 5)) &gt;&gt;&gt; #(3 4)"	"(#(1 2 3 4) intersection: #()) &gt;&gt;&gt; #()"	"(#() intersection: #(1 2 3 4)) &gt;&gt;&gt; #()"	^ self species withAll: (self asSet intersection: aCollection) asArray</body></methods><methods><class-id>Core.Collection</class-id> <category>testing</category><body package="SpyLite-Extensions">isCollection	"Answer true if the receiver is a collection, excluding character arrays, ie strings,	which are treated as non-collections. This choice has proven to be most practical."	^true</body></methods><methods><class-id>Core.Collection</class-id> <category>removing</category><body package="SpyLite-Extensions">removeAllFoundIn: aCollection 	"Remove each element of aCollection which is present in the receiver 	from the receiver. Answer aCollection. No error is raised if an element	isn't found. ArrayedCollections cannot respond to this message."	aCollection do: [:each | self remove: each ifAbsent: []].	^ aCollection</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="SpyLite-Extensions">select: selectBlock thenCollect: collectBlock	"Utility method to improve readability."	^ (self select: selectBlock) collect: collectBlock</body><body package="SpyLite-Extensions">select: selectBlock thenDo: doBlock    "Utility method to improve readability.	Do not create the intermediate collection."    self do: [: each |        ( selectBlock value: each ) 			ifTrue: [ doBlock value: each ]    ].</body></methods><methods><class-id>Spy1.SpyLite</class-id> <category>assertion</category><body package="SpyLite-Extensions">assert: aBlock	aBlock value ifFalse: [ self error: 'Assertion failed' ]</body><body package="SpyLite-Extensions">nameOf: anObject		^ (anObject isClass				ifTrue: [ anObject fullName ]				ifFalse: [ anObject class fullName ]) asSymbol</body></methods><methods><class-id>Core.Object</class-id> <category>controlling</category><body package="SpyLite-Extensions">assert: aBlock	aBlock value ifFalse: [ self error: 'Assertion failed' ]</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="SpyLite-Extensions">isCollection	^false</body></methods><methods><class-id>Core.Object</class-id> <category>event accessing</category><body package="SpyLite-Extensions">isSpy	^ false</body><body package="SpyLite-Extensions">isSpyMethod	^ false</body></methods><methods><class-id>Spy1.SLProfilerCoverage class</class-id> <category>public - profiling</category><body package="SpyLite-Extensions">profile: aBlock inPackages: packageInfo	^ self new profile: aBlock inPackages: packageInfo</body></methods><methods><class-id>Spy1.SLProfilerCoverage</class-id> <category>as yet unclassified</category><body package="SpyLite-Extensions">calculateExecutedMethodsByClass	^ (self allClassesAsDictionary keys		collect:			[ :aClassName | aClassName -&gt; (self calculateExecutedMethodsOf: aClassName) ])		asDictionary</body><body package="SpyLite-Extensions">calculateExecutedStatementsByClass	^ (self allClassesAsDictionary keys        collect:            [ :aClassName | aClassName -&gt; (self calculateExecutedStatementsOf: aClassName) ]        thenSelect: [ :assoc | assoc value &gt; 0 ]) asDictionary</body></methods><methods><class-id>Spy1.SLProfilerCoverage</class-id> <category>public-profiling</category><body package="SpyLite-Extensions">profile: aBlock inPackages: packageInfo	Transcript show: 'profiling...'; cr.	[		self beforeProfiling.		self gatherForPackages: packageInfo.		self install.		self beforeProfiling.		aBlock value.				self afterProfiling  	]	ensure: [ self uninstall ].	Transcript show: 'ended...'; cr.	self setIfNecessaryTimeProfiler: aBlock.	self setIfNecessaryTimeAndCallGraphFrom: aBlock.	self setIfNecessaryStateChanges.	self checkInvariant.	^ self</body></methods><methods><class-id>Core.Character</class-id> <category>converting</category><body package="SpyLite-Extensions">asString		^ String with: self</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>contract</category><body package="SpyLite-Extensions">checkInvariant	self assert: [ className notNil ].	self assert: [ className isKindOf: Symbol ].	self assert: [ self profiler notNil ].	self assert: [ self methods notNil ].	self assert: [ self methods isSequenceable ].	self assert: [ self methods allSatisfy: [:m| m isKindOf: SLMethod ] ].	self assert: [ self class spyClassForMethod == self profiler class spyClassForMethod ].	self assert: [ self class spyClassForMethod == self profiler class spyClassForMethod ].	self assert: [ self class == self profiler class spyClassForClass ].</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>accessing-computed</category><body package="SpyLite-Extensions">coveredMethods	^ self methods select: #isCovered</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>initialize-release</category><body package="SpyLite-Extensions">initialize 	super initialize.	 methods := IdentityDictionary new.	packageSpy := SLPackage new</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>installing</category><body package="SpyLite-Extensions">install		self allMethods do:[:m | m install]</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>testing</category><body package="SpyLite-Extensions">isClassPresent	^ Smalltalk organization includesElement: className</body><body package="SpyLite-Extensions">isPartiallyCovered	^ self methods anySatisfy: #isCovered</body><body package="SpyLite-Extensions">isPartiallyExecuted	| isPartiallyExecuted |	isPartiallyExecuted := false.	self allMethods do:[:m | m numberOfInvocations &gt; 0 ifTrue:[isPartiallyExecuted := true]].	^isPartiallyExecuted</body><body package="SpyLite-Extensions">isTestClass		^ self superclass 			ifNil: [ self theClass superclass = SUnit.TestCase or:[self theClass superclass = XProgramming.SUnit.TestCase] ] 			ifNotNil: [ self superclass isTestClass ]</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>accessing</category><body package="SpyLite-Extensions">metaclassSpy	"Return the class spy for the metaclass."	^ metaclassSpy ifNil: 		[ metaclassSpy := self class new 							className: (self nameOf: self theClass class) "name asSymbol";							originalClass: self theClass class; 							yourself ]</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>accessing-computed</category><body package="SpyLite-Extensions">numberOfCoveredMethods	^ self coveredMethods size</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>accessing</category><body package="SpyLite-Extensions">originalClass	^originalClass</body><body package="SpyLite-Extensions">originalClass: aClass	originalClass := aClass</body><body package="SpyLite-Extensions">superclass	self theClass superclass ifNil: [^nil].	^ self profiler classAt: self theClass superclass name ifNone: [nil]</body><body package="SpyLite-Extensions">theClass	^ originalClass</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>creating class hierarchy</category><body package="SpyLite-Extensions">numberOfLinesOfCode 	"Return the amount of lines of code"		^ 5 + ((self methodDictionary)  inject: 0 into: [:sum :el | sum + el linesOfCode ])</body></methods><methods><class-id>Spy1.SLInstrumentor</class-id> <category>visitor-double dispatching</category><body package="SpyLite-Extensions">acceptBlockNode: aBlockNode    self instrumentBlock: aBlockNode.    super acceptBlockNode: aBlockNode</body><body package="SpyLite-Extensions">acceptMethodNode: aMethodNode    self instrumentBlock: aMethodNode.    super acceptMethodNode: aMethodNode</body></methods><methods><class-id>Spy1.SLInstrumentor</class-id> <category>visiting</category><body package="SpyLite-Extensions">buildSBBlock: aBlockNode	^ SLBlock new		id: self nextId;		numberOfStatements: aBlockNode body statements size;		start: aBlockNode body start;		stop: aBlockNode body stop;		yourself</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>copying</category><body package="SpyLite-Extensions">collect: aBlock thenSelect: aSelectBlock    ^ (self collect: aBlock) select: aSelectBlock.</body></methods><methods><class-id>Core.Dictionary class</class-id> <category>Signal constants</category><body package="SpyLite-Extensions">newFrom: aDict 	"Answer an instance of me containing the same associations as aDict.	 Error if any key appears twice."	| newDictionary |	newDictionary := self new: aDict size.	aDict associationsDo:		[:x |		(newDictionary includesKey: x key)			ifTrue: [self error: 'Duplicate key: ', x key printString]			ifFalse: [newDictionary add: x]].	^ newDictionary"	NewDictionary newFrom: {1-&gt;#a. 2-&gt;#b. 3-&gt;#c}	{1-&gt;#a. 2-&gt;#b. 3-&gt;#c} as: NewDictionary	NewDictionary newFrom: {1-&gt;#a. 2-&gt;#b. 1-&gt;#c}	{1-&gt;#a. 2-&gt;#b. 1-&gt;#c} as: NewDictionary"</body></methods><methods><class-id>Core.Set</class-id> <category>enumerating</category><body package="SpyLite-Extensions">intersection: aCollection	"Answer the set theoretic intersection of two collections.	Optimized version for Sets where no intermediate Set is necessary"	"(#(1 2 3 4) asSet intersection: #(3 4 5) asSet) &gt;&gt;&gt; #(3 4) asSet"	"(#(1 2 3 4) asSet intersection: #() asSet) &gt;&gt;&gt; Set new"	"( #() asSet intersection: #(1 2 3 4) asSet) &gt;&gt;&gt; Set new"	| outputSet |	outputSet := self class new.	aCollection do: [ :each | (self includes: each) ifTrue: [ outputSet add: each ] ].	^ outputSet</body></methods><methods><class-id>Spy1.SSTypeCollectorMethod</class-id> <category>hooks</category><body package="SpyLite-Extensions">beforeRun: methodName with: listOfArguments in: aReceiver	self saveArguments: listOfArguments.	self saveReceiver: aReceiver.	self selectLiteralsOf: self originalMethod getSource.	listOfArguments do: [ :arg | self checkIfArgIsScalar: arg ].	executed := true</body></methods><methods><class-id>Spy1.SSTypeCollectorMethod</class-id> <category>testing</category><body package="SpyLite-Extensions">isQuick	^ self originalMethod isReturnField "or: [ self returnType size == 1 and: [ (self returnType includes: self classSpy typeName) ]]"</body></methods><methods><class-id>Spy1.SSTypeCollectorMethod</class-id> <category>hooks</category><body package="SpyLite-Extensions">nameOf: anObject	^ (anObject isClass		ifTrue: [ anObject fullName  ]		ifFalse: [ anObject class fullName ])asSymbol</body></methods><methods><class-id>Core.Behavior</class-id> <category>creating class hierarchy</category><body package="SpyLite-Extensions">classSpy 	| spys |	spys := self spys.	spys isEmpty ifTrue: [ self error: 'no spy installed'. ^ self].	^ self spys first classSpy</body><body package="SpyLite-Extensions">hasSpy	^ self methodDictionary values anySatisfy: [ :spy | spy isTemplateMethod ]</body><body package="SpyLite-Extensions">linesOfCode 	"An approximate measure of lines of code.	Includes comments, but excludes blank lines."	| lines |	lines := self getMethodDictionary inject: 0 into: [:sum :each | sum + each linesOfCode]. 	^ self isMeta 		ifTrue: [lines]		ifFalse: [lines + self class linesOfCode]</body><body package="SpyLite-Extensions">numberOfLinesOfCode 	"Return the amount of lines of code"		^ 5 + ((self methodDictionary values, self class methodDictionary values) inject: 0 into: [:sum :el | sum + el numberOfLinesOfCode ])</body><body package="SpyLite-Extensions">profiler	^ self classSpy profiler</body><body package="SpyLite-Extensions">removeSpys	(self == SpyLite.SLProfiler class) ifTrue: [ ^ self ].	self isMeta ifFalse: [ self class removeSpys ].	self methodDictionary keysAndValuesDo: [:key :value|		 key isSpy ifTrue:[				self methodDictionary at: key put: value originalMethod.			].		].</body><body package="SpyLite-Extensions">spys	^ (self methodDictionary values select: [ :spy | spy isTemplateMethod ]) collect: #methodSpy</body></methods><methods><class-id>Spy1.SLProfilerCoverageTest</class-id> <category>as yet unclassified</category><body package="SpyLite-Extensions">assertMethodCoverageOf: profiler on: symbol equals: number	| dictMethodCoverage |	dictMethodCoverage := profiler methodCoverage1.	self assert: (dictMethodCoverage at: symbol) equals: number</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>initialize-release</category><body package="SpyLite-Extensions">initialize	super initialize.		selector := #unamed.	"Set a mock method, the #initialize itself"	"This is to make the class invariant pass"	originalMethod := self class compiledMethodAt: #initialize.	classSpy := SLClass new</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>installing</category><body package="SpyLite-Extensions">install	"We do nothing if the method has been supressed"	"(self theClass methodDict includesKey: self selector) ifFalse: [ ^ self ].	self assert: [ (self theClass methodDict at: self selector) isSpy not ].	self assert: [ self originalMethod notNil ].	self assert: [ self instrumentedMethod notNil ].	self flushCache."		"We update the original method, it may have changed since the uninstall"	"originalMethod := self theClass methodDict at: self selector.	self theClass methodDict at: self selector put: self instrumentedMethod."	self spyWrapper install.</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>testing</category><body package="SpyLite-Extensions">isAbstract	^false</body><body package="SpyLite-Extensions">isTest		^ ('#test*' match: self selector printString ) and: [(self classSpy isTestClass )]</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>accessing-computed</category><body package="SpyLite-Extensions">numberOfLinesOfCode	^4	"^ originalMethod  numberOfLinesOfCode"</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>accessing</category><body package="SpyLite-Extensions">originalMethod	"originalMethod isSpy ifTrue: [ ^ originalMethod originalMethod ]."	^ originalMethod</body><body package="SpyLite-Extensions">originalMethod: aCompiledMethod	"self assert: [ aCompiledMethod isSpy not ]."	originalMethod := aCompiledMethod</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>hooks</category><body package="SpyLite-Extensions">run: methodName with: listOfArguments in: receiver	| v |	self classSpy ifNotNil: [		classSpy beforeEachExecution: methodName On: receiver with: listOfArguments ].	self beforeRun: methodName with: listOfArguments in: receiver.	"	v := originalMethod valueWithReceiver: receiver arguments: listOfArguments."	v := self spyWrapper clientMethod valueWithReceiver: receiver arguments: listOfArguments.	self classSpy ifNotNil: [ 		classSpy afterEachExecution: methodName On: receiver with: listOfArguments ].	self afterRun: methodName with: listOfArguments in: receiver.	self returnValue: v.	^ v</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>accessing-computed</category><body package="SpyLite-Extensions">sourceCode"	^ originalMethod getSourceFromFile"	^ originalMethod getSource</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>delegation</category><body package="SpyLite-Extensions">theClass	^ spywrapper mclass</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>installing</category><body package="SpyLite-Extensions">uninstall	"self theClass methodDict at: self selector put: self originalMethod."	(self spyWrapper) uninstall."	self originalMethod uninstall."	self flushCache</body></methods><methods><class-id>Spy1.SLCollectorLiteral</class-id> <category>visiting</category><body package="SpyLite-Extensions">acceptLiteralNode: aLiteralNode	| literalValue aValue |	literalValue := aLiteralNode value.	aValue := literals		at: (self nameOf: literalValue class)		ifAbsentPut: [ Set new ].	aValue add: literalValue</body><body package="SpyLite-Extensions">nameOf: aClass	^ aClass fullName asSymbol</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="SpyLite-Extensions">lineIndicesDo: aBlock	"execute aBlock with 3 arguments for each line:	- start index of line	- end index of line without line delimiter	- end index of line including line delimiter(s) CR, LF or CRLF"		| cr lf start sz nextLF nextCR |	start := 1.	sz := self size.	cr := Character cr.	(nextCR := self nextIndexOf: cr from: 1 to: self size) ifNil:[nextCR:= 0].	lf := Character lf.	(nextLF := self nextIndexOf: lf from: 1 to: self size) ifNil:[nextLF := 0].	[ start &lt;= sz ] whileTrue: [		(nextLF = 0 and: [ nextCR = 0 ])			ifTrue: [ "No more CR, nor LF, the string is over"					aBlock value: start value: sz value: sz.					^self ].		(nextCR = 0 or: [ 0 &lt; nextLF and: [ nextLF &lt; nextCR ] ])			ifTrue: [ "Found a LF"					aBlock value: start value: nextLF - 1 value: nextLF.					start := 1 + nextLF.					(nextLF := self nextIndexOf: lf from: start to: self size) ifNil:[nextLF := 0]. ]			ifFalse: [ 1 + nextCR = nextLF				ifTrue: [ "Found a CR-LF pair"					aBlock value: start value: nextCR - 1 value: nextLF.					start := 1 + nextLF.					(nextCR := self nextIndexOf: cr from: start to: self size) ifNil:[nextCR := 0].					(nextLF := self nextIndexOf: lf from: start to: self size) ifNil:[nextLF := 0].]				ifFalse: [ "Found a CR"					aBlock value: start value: nextCR - 1 value: nextCR.					start := 1 + nextCR.					(nextCR := self nextIndexOf: cr from: start to: self size) ifNil:[nextCR := 0].]]]</body></methods><methods><class-id>Spy1.SLProfiler class</class-id> <category>public - profiling</category><body package="SpyLite-Extensions">profilerForPackagesMatching: regexp	self installOnPackagesMatching: regexp.	^ self gatherForPackagesMatching: regexp</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>accessing - read only</category><body package="SpyLite-Extensions">allMethods	"Return the list of methods"	| answer |	answer := OrderedCollection new.	self packages do: [:p | 		answer addAll: p allMethods ].	^ answer</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>contract</category><body package="SpyLite-Extensions">checkInvariant	self assert: [ self packages notNil ].	self assert: [ self packages allSatisfy: [ :p | p isKindOf: self class spyClassForPackage ] ].	self assert: [ self packages allSatisfy: [ :p | p profiler notNil ]].	self assert: [ self packages allSatisfy: [ :p | p profiler == self ]].	self packages do: [ :p | p checkInvariant ]</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>util</category><body package="SpyLite-Extensions">classesInCategory: categoryName	"Return the list of classes that belong to a category. Reject non behavior, such as namespaces"	^ self  class classesInCategory: categoryName</body><body package="SpyLite-Extensions">classesInCategory: categoryName inNamespace: namespace	"Return the list of classes that belong to a category. Reject non behavior, such as namespaces"	^ self class classesInCategory: categoryName inNamespace: namespace</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>gathering</category><body package="SpyLite-Extensions">fillClassType: classType with: methodDictionary	"This method is that the core of the instrumentation of Spy. 	It wraps all the methods with a wrappers "	"Enhanced by Philippe Van Langenhove"	| cm metaObject spyWrapper |	classType theClass == SLProfiler class		ifTrue: [ ^ self ].	methodDictionary keys do:		[:k|			cm := methodDictionary at: k.				spyWrapper := SpyWrapper on: k inClass: classType originalClass.				spyWrapper ifNotNil: [					metaObject := self class spyClassForMethod new initialize											originalMethod: cm; 											selector: k; 											instrumentedMethod: spyWrapper;											classSpy: classType;											yourself.						spyWrapper	methodSpy: metaObject.					metaObject spyWrapper: spyWrapper.										classType localMethodAt: k put: metaObject ].		].</body><body package="SpyLite-Extensions">gatherForClassCategories: categoriesNames inNamespace: aNamespace	"Return a profiler"	categoriesNames do:[:nameAsString |		| package |		package := self packageForClassesInCategory: nameAsString inNamespace: aNamespace.		package packageName: nameAsString.		self addPackage: package.	].	^ self</body><body package="SpyLite-Extensions">gatherForPackageNamed: nameAsString	"Return a profiler"		| classes classType package |	package := self class spyClassForPackage new.	package packageName: nameAsString.	self addPackage: package.	"	classes := ((PackageInfo named: nameAsString)							classes reject: #isTrait)."	classes := Store.Registry packageNamed: nameAsString allDefinedClasses.		classes do: [:cls |		classType := self spyForClass: cls.		classType packageSpy: package.		package profiler: self.		package classAt: cls name put: classType].				^ self</body><body package="SpyLite-Extensions">gatherForPackages: packageNames	"Return a profiler"	packageNames do: [ :pak | 		| class package |		package := self class spyClassForPackage new.		package packageName: pak name.		self addPackage: package.		(pak allDefinedClasses) do: [:cls|			class := self spyForClass: cls.			class packageSpy: package.			package classAt: (self nameOf: cls) asSymbol put: class ] ].	^ self</body><body package="SpyLite-Extensions">gatherForPackagesMatching: regexpAsString	"Return a profiler"		| packageInfos |	packageInfos := Store.Registry allPackages select:[:p | regexpAsString match: (p name asString)].	^ self gatherForPackages: packageInfos</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>util</category><body package="SpyLite-Extensions">getInstrumentedClasses: reports		"	This method returns all the packages from the executed methods in the block that was profiled.	The reports are extracted from the MessageTally tree produced by the TimeProfiler.	All packages from the Kernel and from the Spy bundle are excluded, as they usually are not the method to inspect.	"	|classesInfos tg baseClasses baseClassesNames testPackageBlock|	testPackageBlock := [:package | package isNil ifTrue:[Array new] ifFalse:[package allClasses]].	baseClasses := (Store.Registry bundleNamed: 'Base VisualWorks') allClasses .	baseClasses addAll: ((Store.Registry bundleNamed: 'Spy') allClasses).	baseClasses addAll: (testPackageBlock value: (Store.Registry packageNamed: 'SUnit')).	baseClasses addAll: (testPackageBlock value:(Store.Registry packageNamed: 'SUnitToo')).	baseClassesNames := baseClasses collect:[:c |c isMeta ifTrue:[c instanceBehavior name] ifFalse:[ c name]].	classesInfos := OrderedCollection new.	reports do:[:p |		tg := p method.		(tg mclass isMeta) ifTrue:[(baseClassesNames includes: tg mclass instanceBehavior name asString) ifFalse:[classesInfos add: tg mclass instanceBehavior ].]						ifFalse:[(baseClassesNames includes: tg mclass name asString) ifFalse:[classesInfos add: tg mclass].]	].	^classesInfos asSet asOrderedCollection</body><body package="SpyLite-Extensions">getInstrumentedPackages: reports		"	This method returns all the packages from the executed methods in the block that was profiled.	The reports are extracted from the MessageTally tree produced by the TimeProfiler.	All packages from the Kernel and from the Spy bundle are excluded, as they usually are not the method to inspect.	"	|packagesInfos tg baseClasses baseClassesNames |	baseClasses := (Store.Registry bundleNamed: 'Base VisualWorks') allClasses .	baseClasses addAll: ((Store.Registry bundleNamed: 'Spy') allClasses).	baseClasses add: Object.	baseClassesNames := baseClasses collect:[:c |c isMeta ifTrue:[c instanceBehavior name] ifFalse:[ c name]].	packagesInfos := OrderedCollection new.	reports do:[:p |		tg := p method.		(tg mclass isMeta) ifTrue:[(baseClassesNames includes: tg mclass instanceBehavior name asString) ifFalse:[packagesInfos addAll: (Store.Registry packagesContaining: tg mclass instanceBehavior) ].]						ifFalse:[(baseClassesNames includes: tg mclass name asString) ifFalse:[packagesInfos addAll: (Store.Registry packagesContaining: tg mclass) ].]	].	^packagesInfos asSet asOrderedCollection</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>accessing - read only</category><body package="SpyLite-Extensions">getPackageNamed: aPackageName	"Return a particular package"	^ self packages detect: [:pak | pak packageName asString = aPackageName asString ]</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>hooks</category><body package="SpyLite-Extensions">getTimeAndCallGraph	^ false</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>gathering</category><body package="SpyLite-Extensions">packageForClassCategories: categoriesNames	| package classNames classType |	package := self class spyClassForPackage new.	classNames := OrderedCollection new.	categoriesNames do: [:nameAsString |		classNames addAll: ( Smalltalk organization listAtCategoryNamed: nameAsString asSymbol).	].		classNames do: [:clsName |		| cls |		cls := Smalltalk at: clsName.			classType := self spyForClass: cls.			classType packageSpy: package.			package classAt: clsName put: classType].		^ package</body><body package="SpyLite-Extensions">packageForClassCategory: nameAsString	| package classNames classType |	package := self class spyClassForPackage new.	classNames := Smalltalk organization listAtCategoryNamed: nameAsString asSymbol.		classNames do: [:clsName |		| cls |		cls := Smalltalk at: clsName.		cls class = NameSpace ifFalse:[			classType := self spyForClass: cls.			classType packageSpy: package.			package classAt: clsName put: classType]].		^ package</body><body package="SpyLite-Extensions">packageForClassesInCategory: categoryName inNamespace: namespace	| package classNames classType |	package := self class spyClassForPackage new.	classNames := self classesInCategory: categoryName inNamespace: namespace.		classNames do: [:aclass |		| cls |		cls := namespace at: aclass name.			classType := self spyForClass: cls.			classType packageSpy: package.			package classAt: aclass name put: classType].		^ package</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>RefactoringBrowser</category><body package="SpyLite-Extensions">hasMethodSpyAsLiteral	"True if one of my literals has a method spy"	^ self literals anySatisfy: [ :l | (l isKindOf: SpyLite.SLMethod) ]</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>accessing</category><body package="SpyLite-Extensions">isExtension	^ ((Refactory.Browser.RefactoryChange new packageForClassDefinition: self mclass) name = (Refactory.Browser.RefactoryChange new packageForClass: self mclass selector: self selector) name) not.</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>RefactoringBrowser</category><body package="SpyLite-Extensions">isTemplateMethod	^ SpyLite.SLProfiler templateMethods anySatisfy: [ :cm | (self size = cm size) 													and: [ (self initialPC to: self endPC) allSatisfy: [ :i | 															(self at: i) = (cm at: i) ] ] ]</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>accessing</category><body package="SpyLite-Extensions">linesOfCode	"An approximate measure of lines of code.	Includes comments, but excludes empty lines."	| lines |	lines := 0.	"It may happens that there is no source"	self getSource ifNil: [ ^ 0 ].	self getSource asString lineIndicesDo: [:start :endWithoutDelimiters :end |		endWithoutDelimiters &gt; start ifTrue: [lines := lines+1]].	^lines</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>SpyLite</name><environment>Spy1</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>currentTestCase currentTestMethod </class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>SpyLite-Core</package></attributes></class><class><name>SLProfiler</name><environment>Spy1</environment><super>Spy1.SpyLite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packages allClassesAsDictionaryCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>SpyLite-Core</package></attributes></class><class><name>SLProfilerCoverage</name><environment>Spy1</environment><super>Spy1.SLProfiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite-Coverage</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>SLMethod</name><environment>Spy1</environment><super>Spy1.SpyLite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instrumentedMethod originalMethod selector classSpy spywrapper </inst-vars><class-inst-vars>inMeta </class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>SpyLite-Core</package></attributes></class><class><name>SSTypeCollectorMethod</name><environment>Spy1</environment><super>Spy1.SLMethod</super><private>false</private><indexed-type>none</indexed-type><inst-vars>returnType argTypes receiverType executed literals </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-TypeCollector</category><attributes><package>SpyLite-TypeCollector</package></attributes></class><class><name>SLClass</name><environment>Spy1</environment><super>Spy1.SpyLite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methods className allSubclassesCache packageSpy metaclassSpy originalClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>SpyLite-Core</package></attributes></class><class><name>SLProfilerCoverageTest</name><environment>Spy1</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Tests</category><attributes><package>SpyLite-Tests</package></attributes></class><class><name>SLCollectorLiteral</name><environment>Spy1</environment><super>Refactory.Browser.RBProgramNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>literals </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite-Coverage</package></attributes></class><class><name>SLMethodCoverage</name><environment>Spy1</environment><super>Spy1.SLMethod</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blocks probedMethod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite-Coverage</package></attributes></class><class><name>SLInstrumentor</name><environment>Spy1</environment><super>Refactory.Browser.RBProgramNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blocks currentId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite-Coverage</package></attributes></class><class><name>ClassDescription</name><environment>Core</environment><super>Core.Behavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceVariables organization </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class></st-source>