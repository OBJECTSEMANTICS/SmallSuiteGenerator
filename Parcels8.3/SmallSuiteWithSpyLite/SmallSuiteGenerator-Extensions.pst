<?xml version="1.0"?><st-source><!-- Name: SmallSuiteGenerator-ExtensionsBundleName: SmallSuiteGenerator-ExtensionsBundleStructure: a Store.BundleForParcelDevelopmentPrerequisites: #(#(#any 'SmallSuiteGenerator' '' ) )Parcel: nilParcelName: SmallSuiteGenerator-ExtensionsPrerequisiteDescriptions: #(#(#name 'SmallSuiteGenerator' #componentType #bundle ) )PrerequisiteParcels: #(#('SmallSuiteGenerator' '' ) )Version: imageDate: 4:16:06 PM January 21, 2020 --><time-stamp>From VisualWorksÂ®, 8.3 of July 28, 2017 on January 21, 2020 at 4:16:06 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>AbstractSmallSuiteGeneratorUI</name><environment>SmallSuiteGenerator</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packageModule packageModule1 classModule dialog generations population statements numberGenerations populationSize numberStatements </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SmallSuiteGeneratorUI-Extensions</package></attributes></class><class><name>SmallSuiteGeneratorGenericUI</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.AbstractSmallSuiteGeneratorUI</super><private>false</private><indexed-type>none</indexed-type><inst-vars>profiler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SmallSuiteGeneratorUI-Extensions</package></attributes></class><class><name>OrderedDictionary</name><environment>Smalltalk</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>dictionary orderedKeys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SmallSuiteGenerator-Extensions</package></attributes></class><comment><class-id>OrderedDictionary</class-id><body>I am a collection that act as a Dictionary except that I use key insertion order when enumerating, printing, or returing collections of keys/values/associations, but not when testing for equality (but it does not matters in this case).I will assume that you know the Dictionary class in this comment.Description--------------------I work mainly as a Dictionary except that I also store the keys in an Array that keeps the order of elements. I should be used ONLY if you need to keep the keys ordered. Else you should use a Dictionary that is faster and keep less values into memory. (I duplicate the keys).Insertion, update, and inclusion testing have O(1) complexity while removing has O(n) worst-case.Public API and Key Messages--------------------- #at: aKey put: aValue / #at: aKey ifAbsentPut: aValue 		allow to add an element.  - #at: aKey / #at: aKey ifAbsent: aBlock / #at: aKey ifPresent: aBlock ifAbsent: aBlock 		allow to access my values.- #keysDo: aBlock / #valuesDo: aBlock / #associationsDo: 		allow to iterate on me effectively.		- #keyAtIndex: anIndex / KeyAtIndex: anIndex ifAbsent: aBlock 		allow to acess my keys from an index.Examples------------------	"For basic examples see Dictionary comment."		ordDic := (Dictionary with: 1 -&gt; $a with: 2 -&gt; $b) asOrderedDictionary.	ordDic.   		"returns:  an OrderedDictionary(1-&gt;$a 2-&gt;$b)"	ordDic keyAtIndex: 2.		"returns:  2"	Internal Representation and Key Implementation Points.-------------------    Instance Variables	dictionary:			&lt;Dictionary&gt;		A dictionary where I store my keys and values.	orderedKeys:		&lt;Array&gt;			An ordered collection where I store my keys to maintain the order.I base my implementation on a Dictionary and when I need to execute an action where the order of the values is important I use the keys in my ordered collection.</body></comment><class><name>SVisitorNodes</name><environment>SmallSuiteGenerator</environment><super>Refactory.Browser.RBProgramNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>isAbstractt </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Extensions2</category><attributes><package>SmallSuiteGenerator-Extensions2</package></attributes></class><class><name>SmallSuiteGeneratorEditorUI</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.AbstractSmallSuiteGeneratorUI</super><private>false</private><indexed-type>none</indexed-type><inst-vars>documentModel </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SmallSuiteGeneratorUI-Extensions</package></attributes></class><shared-variable><name>PundleAccess</name><environment>SmallSuiteGenerator.STestCaseFactory</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>SmallSuiteGenerator-Extensions2</package></attributes></shared-variable><methods><class-id>SmallSuiteGenerator.AbstractSmallSuiteGeneratorUI</class-id> <category>accessing</category><body package="SmallSuiteGeneratorUI-Extensions">acceptButton	"pages selection value == #createSpec		ifTrue: [self createClass].	className value: candidateClassName value."		population := self populationSize value.	generations := self numberGenerations value.	statements := self numberStatements value.	dialog accept; closeRequest</body><body package="SmallSuiteGeneratorUI-Extensions">cancelButton	self populationSize value: population.	self numberGenerations value: generations.	self numberStatements value: statements.	dialog doCancel</body><body package="SmallSuiteGeneratorUI-Extensions">classModule	^ classModule</body><body package="SmallSuiteGeneratorUI-Extensions">numberGenerations	^numberGenerations</body><body package="SmallSuiteGeneratorUI-Extensions">numberOfGenerations	^ self widgetAt: #numberGenerations</body><body package="SmallSuiteGeneratorUI-Extensions">numberOfPopulation	^ self widgetAt: #numberPopulation</body><body package="SmallSuiteGeneratorUI-Extensions">numberOfStatements	^ self widgetAt: #numberStatements</body><body package="SmallSuiteGeneratorUI-Extensions">numberStatements	^numberStatements</body><body package="SmallSuiteGeneratorUI-Extensions">packageModule	^ packageModule</body><body package="SmallSuiteGeneratorUI-Extensions">packageModule1	^ packageModule1</body><body package="SmallSuiteGeneratorUI-Extensions">populationSize	^populationSize</body></methods><methods><class-id>SmallSuiteGenerator.AbstractSmallSuiteGeneratorUI</class-id> <category>actions</category><body package="SmallSuiteGeneratorUI-Extensions">createTestCasesFor: typeInfo	^ STestCaseFactoryVisualWorks new    		typeInfo: typeInfo;    		fitness: SStatementCoverage new;    		targetClassName: classModule value asSymbol;    		targetPackageRegex: packageModule value;    		outputPackageName: packageModule1 value;     		numberOfGenerations: generations;    		numberOfStatements: statements;		populationSize: population;    		createTestCases;    		yourself.</body><body package="SmallSuiteGeneratorUI-Extensions">showAdvancedSettings		| returnVal |	returnVal := self openDialogInterface: #advancedSettings.</body></methods><methods><class-id>SmallSuiteGenerator.AbstractSmallSuiteGeneratorUI</class-id> <category>interface opening</category><body package="SmallSuiteGeneratorUI-Extensions">openDialogInterface: aSymbol 	"Answer the result of opening a dialog using the named specification. 	A SimpleDialog with the receiver as the source of bindings is 	initialized and used. The SimpleDialog provides bindings for 'accept' 	and 'cancel'"	dialog := SimpleDialog new.	builder := dialog builder.	dialog postBuildBlock:[:dlg :bld | 	self postBuildWith: bld].	dialog postOpenBlock: [:dlg :bld | self postOpenWith: bld].	dialog openFor: self interface: aSymbol</body></methods><methods><class-id>SmallSuiteGenerator.AbstractSmallSuiteGeneratorUI</class-id> <category>initialize-release</category><body package="SmallSuiteGeneratorUI-Extensions">initialize	super initialize.	packageModule := EntryWithPasteButtonModule forPackages.	packageModule1 := EntryWithPasteButtonModule forPackages.	classModule := EntryWithPasteButtonModule forClasses.	generations := 20.	statements := 10.	population := 30.	numberStatements := statements asValue.	numberGenerations := generations asValue.	populationSize := population asValue.</body></methods><methods><class-id>SmallSuiteGenerator.AbstractSmallSuiteGeneratorUI class</class-id> <category>interface opening</category><body package="SmallSuiteGeneratorUI-Extensions">open	"Override to use the currently-open manager, if one exists."	"^self raiseSingleInstance ifNil: [super open]"	^ super open</body></methods><methods><class-id>SmallSuiteGenerator.SmallSuiteGeneratorGenericUI</class-id> <category>accessing</category><body package="SmallSuiteGeneratorUI-Extensions">checkInvariants	self		assert: classModule value isNil not		description: 'Please provide a target class'.	self		assert: packageModule1 value isNil not		description: 'Please provide a package output'</body><body package="SmallSuiteGeneratorUI-Extensions">generateTests	[		Notice 			show: (#LoadingParcelOrParcels &lt;&lt; #dialogs &gt;&gt; 'Generating tests...')			while:		[			profiler ifNotNil: [ 				self createTestCasesFor: (SmallSuiteGenerator.STypeInfo asTypeInfo: (profiler))			]		]	]on: SError	do: [:ex |  Dialog			warn: ex messageText			withCRs	]</body><body package="SmallSuiteGeneratorUI-Extensions">start	Notice 		show: (#LoadingParcelOrParcels &lt;&lt; #dialogs &gt;&gt; 'Instrumenting...')		while:	[		profiler ifNotNil: [ self uninstall ].		self profilerForPackagesMatching: packageModule value.	]</body><body package="SmallSuiteGeneratorUI-Extensions">stop 	Notice 		show: (#LoadingParcelOrParcels &lt;&lt; #dialogs &gt;&gt; 'Deconstructing...')		while:	[		profiler ifNotNil: [			self uninstall		]	]</body><body package="SmallSuiteGeneratorUI-Extensions">uninstall	profiler afterProfiling;		uninstall.	Transcript show: 'ended...'; cr.</body></methods><methods><class-id>SmallSuiteGenerator.SmallSuiteGeneratorGenericUI</class-id> <category>initialize-release</category><body package="SmallSuiteGeneratorUI-Extensions">packagesMatchingWith: regexExpression	 ^ Store.Registry allPackages select:[:p | regexExpression match: p name asString]</body><body package="SmallSuiteGeneratorUI-Extensions">profilerForPackagesMatching: regexExpression	profiler := Spy1.SSTypeCollector new.	Transcript show: 'profiling...'; cr.	profiler beforeProfiling.	profiler gatherForPackages: (self packagesMatchingWith: regexExpression).	profiler install.	profiler beforeProfiling</body></methods><methods><class-id>OrderedDictionary</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Extensions">= anObject	self == anObject		ifTrue: [^ true].	(self species == anObject species		and: [self size = anObject size])		ifFalse: [^ false].	dictionary associationsDo: [:each |		(anObject at: each key ifAbsent: [^ false]) = each value			ifFalse: [^ false]].	^ true.</body><body package="SmallSuiteGenerator-Extensions">hash	^ dictionary hash</body></methods><methods><class-id>OrderedDictionary</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions">associationAt: aKey	^ dictionary associationAt: aKey</body><body package="SmallSuiteGenerator-Extensions">associations	| associations i |	associations := Array new: self size.	i := 1.	self associationsDo: [:each |		associations at: i put: each.		i := i + 1].	^ associations.</body><body package="SmallSuiteGenerator-Extensions">associationsDo: aBlock	self keysDo: [:each | aBlock value: (self associationAt: each)]</body><body package="SmallSuiteGenerator-Extensions">at: aKey	^ dictionary at: aKey</body><body package="SmallSuiteGenerator-Extensions">at: aKey ifAbsent: aBlock	^ dictionary at: aKey ifAbsent: aBlock</body><body package="SmallSuiteGenerator-Extensions">at: aKey ifAbsentPut: aBlock	^ self at: aKey ifAbsent: [self at: aKey put: aBlock value]</body><body package="SmallSuiteGenerator-Extensions">at: aKey ifPresent: aBlock	^ dictionary at: aKey ifPresent: aBlock</body><body package="SmallSuiteGenerator-Extensions">at: aKey put: aValue	| oldSize |	oldSize := dictionary size.	dictionary at: aKey put: aValue.	dictionary size &gt; oldSize		ifTrue: [			orderedKeys size &gt; oldSize				ifFalse: [self growOrderedKeys].			orderedKeys at: oldSize + 1 put: aKey].	^ aValue.</body><body package="SmallSuiteGenerator-Extensions">do: aBlock	self valuesDo: aBlock</body><body package="SmallSuiteGenerator-Extensions">encodeAsJSONDataUsing: aJSONEncoder	| index |	aJSONEncoder beginObject.	index := 0.	(orderedKeys reject: #isNil) do: [ :k | | value |		index := index + 1.		value := dictionary at: k.		index &gt; 1 ifTrue: [aJSONEncoder emitComma].		aJSONEncoder encodeKey: k value: value	].	aJSONEncoder endObject.</body><body package="SmallSuiteGenerator-Extensions">growOrderedKeys	orderedKeys :=		(Array new: ((orderedKeys size * 1.5) asInteger max: 10))			replaceFrom: 1			to: orderedKeys size			with: orderedKeys			startingAt: 1.</body><body package="SmallSuiteGenerator-Extensions">includesKey: aKey	^ dictionary includesKey: aKey</body><body package="SmallSuiteGenerator-Extensions">keys	^ orderedKeys copyFrom: 1 to: self size</body><body package="SmallSuiteGenerator-Extensions">keysDo: aBlock	1 to: self size do: [:i | aBlock value: (orderedKeys at: i)]</body><body package="SmallSuiteGenerator-Extensions">size	^ dictionary size</body><body package="SmallSuiteGenerator-Extensions">values	^ self associations collect: [:each | each value]</body></methods><methods><class-id>OrderedDictionary</class-id> <category>testing</category><body package="SmallSuiteGenerator-Extensions">isDictionary	^true</body></methods><methods><class-id>OrderedDictionary</class-id> <category>enumerating</category><body package="SmallSuiteGenerator-Extensions">collect: aBlock	^ self species newFrom:		(self associations collect: [:each |			each key -&gt; (aBlock value: each value)])</body><body package="SmallSuiteGenerator-Extensions">keysAndValuesDo: aBlock	self keysDo: [:each | aBlock value: each value: (self at: each)]</body><body package="SmallSuiteGenerator-Extensions">valuesDo: aBlock	self keysDo: [:each | aBlock value: (self at: each)]</body></methods><methods><class-id>OrderedDictionary</class-id> <category>initialize-release</category><body package="SmallSuiteGenerator-Extensions">initialize	dictionary := Dictionary new: 10.	orderedKeys := Array new: 10.</body></methods><methods><class-id>OrderedDictionary</class-id> <category>adding</category><body package="SmallSuiteGenerator-Extensions">add: anAssociation	| oldSize |	oldSize := dictionary size.	dictionary add: anAssociation.	dictionary size &gt; oldSize		ifTrue: [			orderedKeys size &gt; oldSize				ifFalse: [self growOrderedKeys].			orderedKeys at: oldSize + 1 put: anAssociation key].	^ anAssociation.</body><body package="SmallSuiteGenerator-Extensions">addAll: anAssociationCollection	"Since Collection implements #associationsDo:, this method can accept	any collection of associations including Arrays and OrderedCollections"	anAssociationCollection associationsDo: [:each | self add: each].	^ anAssociationCollection.</body></methods><methods><class-id>OrderedDictionary class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Extensions">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="SmallSuiteGenerator-Extensions">newFrom: anAssociationCollection	| newDictionary |	newDictionary := self new.	anAssociationCollection associationsDo: [:each |		newDictionary			at: each key			put: each value].	^ newDictionary.</body></methods><methods><class-id>SmallSuiteGenerator.SVisitorNodes</class-id> <category>visitor-double dispatching</category><body package="SmallSuiteGenerator-Extensions2">acceptMessageNode: aMessageNode	isAbstractt := aMessageNode selector == #subclassResponsibility</body></methods><methods><class-id>SmallSuiteGenerator.SVisitorNodes</class-id> <category>initialize-release</category><body package="SmallSuiteGenerator-Extensions2">isAbstract	^ isAbstractt ifNil: [false]</body></methods><methods><class-id>SmallSuiteGenerator.SmallSuiteGeneratorEditorUI</class-id> <category>accessing</category><body package="SmallSuiteGeneratorUI-Extensions">document	^documentModel value</body><body package="SmallSuiteGeneratorUI-Extensions">document: anObject	documentModel value: anObject</body><body package="SmallSuiteGeneratorUI-Extensions">documentModel	"This method was generated by UIDefiner.  Any edits made here	may be lost whenever methods are automatically defined.  The	initialization provided below may have been preempted by an	initialize method."	^documentModel</body><body package="SmallSuiteGeneratorUI-Extensions">newCode	self class compile: 'performTest	',self document asString</body><body package="SmallSuiteGeneratorUI-Extensions">typeInfoFor: aCode	|typeInfo|		typeInfo := STypeInfo asTypeInfo: (Spy1.SSTypeCollector        profile: aCode         inPackagesMatching: packageModule value).	^ typeInfo</body></methods><methods><class-id>SmallSuiteGenerator.SmallSuiteGeneratorEditorUI</class-id> <category>actions</category><body package="SmallSuiteGeneratorUI-Extensions">generateTests		[		Notice 			show: (#LoadingParcelOrParcels &lt;&lt; #dialogs &gt;&gt; 'Generating tests...')			while:		[			| typeInfo |			self newCode.			typeInfo := self typeInfoFor: [self performTest].			self createTestCasesFor: typeInfo		]	]on: SError	do: [:ex |  Dialog			warn: ex messageText			withCRs	]</body><body package="SmallSuiteGeneratorUI-Extensions">performTest</body></methods><methods><class-id>SmallSuiteGenerator.SmallSuiteGeneratorEditorUI</class-id> <category>initialize-release</category><body package="SmallSuiteGeneratorUI-Extensions">initialize	super initialize.	documentModel := Text2.Document new asValue.</body></methods><methods><class-id>Core.Integer</class-id> <category>truncation and round off</category><body package="SmallSuiteGenerator-Extensions">round: numberOfWishedDecimal	"Round the decimal part of the receiver to be limited to the number of wished decimal. Only leave a fixed amount of decimal. Integers there are already rounded."	^ self</body></methods><methods><class-id>SmallSuiteGenerator.SStack</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Extensions">= another 	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to an 	incorrect position in the file. The file may have been modified after this method 	was updated."	self ==another ifTrue: [^true].	self species == another species ifFalse: [^false].	^self hasEqualElements: another</body></methods><methods><class-id>SmallSuiteGenerator.SStack</class-id> <category>adding</category><body package="SmallSuiteGenerator-Extensions">addFirst: aLink	| t2 |	t2 := aLink asLink.	self isEmpty ifTrue: [lastLink := t2].	t2 nextLink: firstLink.	firstLink := t2.	^t2</body><body package="SmallSuiteGenerator-Extensions">addLast: anObject 	| t2 |	t2 := anObject asLink.	self isEmpty		ifTrue: [firstLink := t2]		ifFalse: [lastLink nextLink: t2].	lastLink := t2.	^t2</body><body package="SmallSuiteGenerator-Extensions">hasEqualElements: otherCollection 	| size index |	(otherCollection isKindOf: SequenceableCollection)		ifFalse: [^false].	(size := self size) =otherCollection size ifFalse: [^false].	index := 1.	[index &lt;= size]		whileTrue: 			[(self at: index) value = (otherCollection at: index) value ifFalse: [^false].			index := index + 1].	^true</body></methods><methods><class-id>SmallSuiteGenerator.SStack</class-id> <category>removing</category><body package="SmallSuiteGenerator-Extensions">removeFirst	| oldLink |	self emptyCheck.	oldLink := firstLink.	firstLink == lastLink		ifTrue: 			[firstLink := nil.			lastLink := nil]		ifFalse: [firstLink := oldLink nextLink].	oldLink nextLink: nil.	^oldLink value</body><body package="SmallSuiteGenerator-Extensions">removeLast	| oldLink aLink |	self emptyCheck.	oldLink := lastLink.	firstLink == lastLink		ifTrue: 			[firstLink := nil.			lastLink := nil]		ifFalse: 			[aLink := firstLink.			[aLink nextLink == oldLink]				whileFalse: [aLink := aLink nextLink].			aLink nextLink: nil.			lastLink := aLink].	oldLink nextLink: nil.	^oldLink value</body></methods><methods><class-id>Core.Object</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Extensions">asLink	"Answer a string that represents the receiver."	^ LinkValue value: self</body></methods><methods><class-id>Core.Object</class-id> <category>controlling</category><body package="SmallSuiteGenerator-Extensions">assert: aBlock description: aString	aBlock value ifFalse: [ self error: aString]</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="SmallSuiteGenerator-Extensions">asString	"Answer a string that represents the receiver."	^ self printString</body><body package="SmallSuiteGenerator-Extensions">className	"Answer a string characterizing the receiver's class, for use in list views for example"	^ self class name asString</body><body package="SmallSuiteGenerator-Extensions">isClass	^ false</body><body package="SmallSuiteGenerator-Extensions">isDeprecated	^false</body><body package="SmallSuiteGenerator-Extensions">isNumber	"Overridden to return true in Number, natch"	^ false</body><body package="SmallSuiteGenerator-Extensions">mutateToChange	^ self</body></methods><methods><class-id>Core.Object</class-id> <category>class initialization</category><body package="SmallSuiteGenerator-Extensions">perform: selector withEnoughArguments: anArray	"Send the selector, aSymbol, to the receiver with arguments in argArray.	Only use enough arguments for the arity of the selector; supply nils for missing ones."	| numArgs args |	numArgs := selector numArgs.	anArray size == numArgs		ifTrue: [ ^self perform: selector withArguments: anArray asArray ].	args := Array new: numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self perform: selector withArguments: args</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="SmallSuiteGenerator-Extensions">storeOn: aStream	"Append to the argument aStream a sequence of characters that is an 	expression whose evaluation creates an object similar to the receiver."	SmallSuiteGenerator.SConfiguration reduceLevel.	aStream nextPut: $(.	self class isVariable		ifTrue: [ aStream				nextPutAll: '(' , self class name , ' basicNew: ';				store: self basicSize;				nextPutAll: ') ' ]		ifFalse: [ aStream nextPutAll: self class name , ' basicNew' ].	SmallSuiteGenerator.SConfiguration levelToPrint &lt; 0		ifFalse: [ 1 to: self class instSize do: [ :i | 				aStream					nextPutAll: ' instVarAt: ';					store: i;					nextPutAll: ' put: ';					store: (self instVarAt: i);					nextPut: $; ].			1 to: self basicSize do: [ :i | 				aStream					nextPutAll: ' basicAt: ';					store: i;					nextPutAll: ' put: ';					store: (self basicAt: i);					nextPut: $; ] ].	aStream nextPutAll: ' yourself)'</body><body package="SmallSuiteGenerator-Extensions">value	^self</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="SmallSuiteGenerator-Extensions">asString	^ self</body></methods><methods><class-id>Core.String</class-id> <category>testing</category><body package="SmallSuiteGenerator-Extensions">mutateToChange	| interval stringCopy randomGenerator |	"correct bug to some characters form the string correctly, e.g: $-&gt; problem in a string"	randomGenerator := SmallSuiteGenerator.SConfiguration newRandomGenerator.	interval := (41 to: 127) asArray.	stringCopy := self		ifEmpty: [ '' ]		ifNotEmpty: [ self copyFrom: 1 to: self size - 1 ].	^ ((Character value: (randomGenerator selectAtRandom: interval) ) asString , stringCopy		, (Character value: (randomGenerator selectAtRandom: interval )) asString) printString</body></methods><methods><class-id>Core.String</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Extensions">substrings: separators	"Answer an array of non-empty substrings from the receiver separated by	one or more characters from the 'separators' argument collection."	| substrings substringStart |	substrings := (Array new: 10) writeStream.	1 to: self size do: [ :i | 		| nextChar |		nextChar := self at: i.		(separators includes: nextChar)			ifTrue: [				substringStart					ifNotNil: [						substrings nextPut: (self copyFrom: substringStart to: i - 1).						substringStart := nil ] ]			ifFalse: [ substringStart ifNil: [ substringStart := i ] ] ].	substringStart		ifNotNil: [ substrings nextPut: (self copyFrom: substringStart to: self size) ].	^ substrings contents</body></methods><methods><class-id>SUnit.TestCase</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions">assertCollection: actual hasSameElements: expected	"Assert that a collection contains the same elements as the given collection. Order is not checked, only the presence/absence of elements."	| missingElements additionalElements |	additionalElements := actual difference: expected.	missingElements := expected difference: (actual intersection: expected).	self		assert: (additionalElements isEmpty and: [ missingElements isEmpty ])		description:			(String				streamContents: [ :stream | 					stream						nextPutAll: 'Given Collections do not match!';						lf;						tab;						nextPutAll: 'additions : ';						print: additionalElements asArray;						lf;						tab;						nextPutAll: 'missing: ';						print: missingElements asArray;						lf ])</body></methods><methods><class-id>SUnit.TestCase</class-id> <category>backwards compatibility</category><body package="SmallSuiteGenerator-Extensions">assertCollection: actualCollection includesAll: subcollection    "Raises an AssertionFailure if actualCollection does not include all the elements of expectedCollection (using #includesAll: message).     I also provide a specialized message for the AssertionFailure in case I fail.    "    ^ self        assert: (actualCollection includesAll: subcollection)        description: [ actualCollection asString , ' does not include all in '                , subcollection asString ]</body><body package="SmallSuiteGenerator-Extensions">deny: anObject equals: anotherObject	(anObject = anotherObject) ifTrue: [self signalFailure: anObject printString, ' is not equal to ', anotherObject printString.]</body></methods><methods><class-id>Core.Metaclass</class-id> <category>testing</category><body package="SmallSuiteGenerator-Extensions">isClass	^ true</body></methods><methods><class-id>Core.Collection class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Extensions">with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject	"Answer a new instance of a Collection containing the		four arguments as the elements."	| newCollection |	newCollection := self new.	newCollection add: firstObject.	newCollection add: secondObject.	newCollection add: thirdObject.	newCollection add: fourthObject.	newCollection add: fifthObject.	^newCollection</body></methods><methods><class-id>Core.Collection</class-id> <category>copying</category><body package="SmallSuiteGenerator-Extensions">allButFirst		^self copyFrom: 2 to: self size.</body></methods><methods><class-id>Core.Collection</class-id> <category>COMPATIBILITY-testing</category><body package="SmallSuiteGenerator-Extensions">anyOne	"Answer a representative sample of the receiver. This method can	be helpful when needing to preinfer the nature of the contents of 	semi-homogeneous collections."	self emptyCheck.	self do: [:each | ^ each]</body></methods><methods><class-id>Core.Collection</class-id> <category>testing</category><body package="SmallSuiteGenerator-Extensions">collect: collectBlock thenSelect: selectBlock	"Utility method to improve readability."	^ (self collect: collectBlock) select: selectBlock</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions">fifth	^self at:5</body><body package="SmallSuiteGenerator-Extensions">flatCollect: aBlock 	"Evaluate aBlock for each of the receiver's elements and answer the	list of all resulting values flatten one level. Assumes that aBlock returns some kind	of collection for each element. Equivalent to the lisp's mapcan"		"( #((3 4) (1 2)) flatCollect: [:each | each ] )&gt;&gt;&gt; #(3 4 1 2)"	"( #(3 4 1 2) flatCollect: [:each | { each } ] ) &gt;&gt;&gt; #(3 4 1 2)"		^ self flatCollect: aBlock as: self species</body><body package="SmallSuiteGenerator-Extensions">flatCollect: aBlock as: aCollectionClass	"Evaluate aBlock for each of the receiver's elements and answer the	list of all resulting values flatten one level. Assumes that aBlock returns some kind	of collection for each element. Equivalent to the lisp's mapcan"	| col |	col := aCollectionClass new: self size. 		self do: [ :each |		col addAll: (aBlock value: each) ].	^aCollectionClass withAll: col</body><body package="SmallSuiteGenerator-Extensions">fourth	 ^self at:4</body></methods><methods><class-id>Core.Collection</class-id> <category>testing</category><body package="SmallSuiteGenerator-Extensions">ifEmpty: aBlock	"Evaluate the given block, answering its value if the receiver is empty, otherwise answer the receiver."		"Note that the fact that this method returns its receiver in case the receiver is not empty allows one to write expressions like the following ones: self classifyMethodAs: (myProtocol ifEmpty: ['As yet unclassified'])"	^ self isEmpty 		ifTrue: [ aBlock value ]		ifFalse: [ self ]</body><body package="SmallSuiteGenerator-Extensions">ifEmpty: emptyBlock ifNotEmpty: notEmptyBlock	"Evaluate emptyBlock if I'm empty, notEmptyBlock otherwise"	" If the notEmptyBlock has an argument, eval with the receiver as its argument"	self isEmpty ifTrue: [ ^emptyBlock value ].	^notEmptyBlock cull: self</body><body package="SmallSuiteGenerator-Extensions">ifNotEmpty: aBlock	"Evaluate the given block with the receiver as argument, answering its value    unless the receiver is empty, in which case answer the receiver."    ^self isEmpty          ifTrue: [self]          ifFalse: [aBlock cull: self]</body></methods><methods><class-id>Core.Collection</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Extensions">includesAll: aCollection 	"Answer true if the receiver includes all elements of aCollection with at	least as many occurrences as in aCollection. For a less strict comparison	please refer to supersetOf: and its inverse subsetOf:."	^(aCollection isCollection) and: [		aCollection size &lt;= self size and: [			aCollection allSatisfy: [ :each | 				(aCollection occurrencesOf: each) &lt;= (self occurrencesOf: each) ]]]</body><body package="SmallSuiteGenerator-Extensions">includesAny: aCollection 	"Answer whether any element of aCollection is one of the receiver's elements."	aCollection do: [:elem | (self includes: elem) ifTrue: [^ true]].	^ false</body></methods><methods><class-id>Core.Collection</class-id> <category>COMPATIBILITY-testing</category><body package="SmallSuiteGenerator-Extensions">max	^ self inject: self anyOne into: [:max :each | max max: each]</body></methods><methods><class-id>Core.Collection</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Extensions">min	^ self inject: self anyOne into: [:min :each | min min: each]</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions">second	^self at:2</body><body package="SmallSuiteGenerator-Extensions">third	^self at:3</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="SmallSuiteGenerator-Extensions">union: aCollection	"Answer the set theoretic union of two collections."	"(#(1 2 3) union: #(4 5 6 2)) &gt;&gt;&gt; #(1 2 3 4 5 6)"	| set |	set := self asSet		addAll: aCollection;		yourself.	^ self species withAll: set asArray</body></methods><methods><class-id>Core.LinkValue</class-id> <category>comparing</category><body package="SmallSuiteGenerator-Extensions">= anotherObject	^self species == anotherObject species 		and: [self value = anotherObject value 				and: [self nextLink == anotherObject nextLink]]</body></methods><methods><class-id>Core.Character</class-id> <category>testing</category><body package="SmallSuiteGenerator-Extensions">mutateToChange	| newValue interval randomGenerator |	randomGenerator := SmallSuiteGenerator.SConfiguration newRandomGenerator.	interval := (33 to: 127) asArray.	newValue := randomGenerator selectAtRandom: interval.	[ newValue == self asInteger ]		whileTrue: [ newValue := randomGenerator selectAtRandom: interval ].	^ Character value: newValue</body></methods><methods><class-id>Core.Link</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions">asLink	^self</body></methods><methods><class-id>Core.Class</class-id> <category>testing</category><body package="SmallSuiteGenerator-Extensions">isClass	^ true</body></methods><methods><class-id>Core.SequenceableCollection class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Extensions">new: newSize streamContents: blockWithArg	| stream |	stream := WriteStream on: (self streamSpecies new: newSize).	blockWithArg value: stream.	^ stream contents</body><body package="SmallSuiteGenerator-Extensions">streamContents: blockWithArg	^ self new: 100 streamContents: blockWithArg</body><body package="SmallSuiteGenerator-Extensions">streamSpecies	"I return the class that is used for streaming. If override consider overriding #new:streamContents:"	^ self</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>copying</category><body package="SmallSuiteGenerator-Extensions">allButLast	^ self allButLast: 1</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions">combinations: kk atATimeDo: aBlock	"Take the items in the receiver, kk at a time, and evaluate the block for each combination.  Hand in an array of elements of self as the block argument.  Each combination only occurs once, and order of the elements does not matter.  There are (self size take: kk) combinations."	"(Array streamContents: [:stream | 'abcde' combinations: 3 atATimeDo: [:each | stream nextPut: each copy]]) &gt;&gt;&gt; #(#($a $b $c) #($a $b $d) #($a $b $e) #($a $c $d) #($a $c $e) #($a $d $e) #($b $c $d) #($b $c $e) #($b $d $e) #($c $d $e))"	| aCollection |	aCollection := Array new: kk.	self		combinationsAt: 1		in: aCollection		after: 0		do: aBlock</body><body package="SmallSuiteGenerator-Extensions">combinationsAt: jj in: aCollection after: nn do: aBlock	"Choose k of N items and put in aCollection.  jj-1 already chosen.  Indexes of items are in numerical order, to avoid the same combo being used twice.  In this slot, we are allowed to use items in self indexed by nn+1 to self size.  nn is the index used for position jj-1."	nn + 1 to: self size do: [ :index | 		aCollection at: jj put: (self at: index).		jj = aCollection size			ifTrue: [ aBlock value: aCollection ]			ifFalse: [ 				self					combinationsAt: jj + 1					in: aCollection					after: index					do: aBlock ] ]</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>copying</category><body package="SmallSuiteGenerator-Extensions">copyFrom: start to: stop 	"Answer a copy of a subset of the receiver, starting from element at index start 	until element at index stop."	| newSize |	newSize := stop - start + 1.	^(self species withSize: newSize)		replaceFrom: 1		to: newSize		with: self		startingAt: start</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions">flatCollect: aBlock	"Evaluate aBlock for each of the receiver's elements and answer the	list of all resulting values flatten one level. Assumes that aBlock returns some kind	of collection for each element. optimized version for Sequencable Collection and subclasses	implementing #writeStream"	"(#( (2 -3) (4 -5) #(-6)) flatCollect: [ :e | e abs  ]) &gt;&gt;&gt; #(2 3 4 5 6)"	"(#( (2 -3) #((4 -5)) #(-6)) flatCollect: [ :e | e abs  ]) &gt;&gt;&gt; #(2 3 #(4 5) 6)"	| stream |	self isEmpty		ifTrue: [ ^ self copy ].	stream := (self species new: 0) writeStream.	self do: [ :each | stream nextPutAll: (aBlock value: each) ].	^ stream contents</body></methods><methods><class-id>Core.ArrayedCollection class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Extensions">with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject	"Answer a new instance of ArrayedCollection, containing the four 	arguments as the elements."	| newCollection |	newCollection := self new: 5.	newCollection at: 1 put: firstObject.	newCollection at: 2 put: secondObject.	newCollection at: 3 put: thirdObject.	newCollection at: 4 put: fourthObject.	newCollection at: 5 put: fifthObject.	^newCollection</body><body package="SmallSuiteGenerator-Extensions">with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject with: sixthObject	"Answer a new instance of ArrayedCollection, containing the four 	arguments as the elements."	| newCollection |	newCollection := self new: 6.	newCollection at: 1 put: firstObject.	newCollection at: 2 put: secondObject.	newCollection at: 3 put: thirdObject.	newCollection at: 4 put: fourthObject.	newCollection at: 5 put: fifthObject.	newCollection at: 6 put: sixthObject.	^newCollection</body></methods><methods><class-id>Core.Number</class-id> <category>testing</category><body package="SmallSuiteGenerator-Extensions">isNumber	^ true</body><body package="SmallSuiteGenerator-Extensions">mutateToChange	|randomGenerator|	randomGenerator := SmallSuiteGenerator.SConfiguration newRandomGenerator.	^ (self perform: (randomGenerator selectAtRandom: #(#+ #- #*))  with: (randomGenerator selectAtRandom: (1 to: 100) asArray) )		perform: (randomGenerator selectAtRandom: #(#+ #-))		with: 1</body></methods><methods><class-id>Core.Number</class-id> <category>truncation and round off</category><body package="SmallSuiteGenerator-Extensions">round: numberOfWishedDecimal	"Round the decimal part of the receiver to be limited to the number of wished decimal. Only leave a fixed amount of decimal"	^ self subclassResponsibility</body></methods><methods><class-id>Core.Dictionary</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions">at: key ifPresent: aPresentBlock ifAbsent: anAbsentBlock	"Lookup the given key in the receiver. If it is present, answer the	value of evaluating the first block optionally with the value associated	with the key.	Otherwise answer the value of the second block."	self at: key ifPresent: [:v | ^ aPresentBlock cull: v].	^ anAbsentBlock value</body><body package="SmallSuiteGenerator-Extensions">at: key ifPresent: aPresentBlock ifAbsentPut: anAbsentBlock	"Lookup the given key in the receiver. If it is present, answer the	value of evaluating the first block optionally with the value associated	with the key.	Otherwise store and return the result of evaluating the second block as the	new value of the key."	^ self		at: key		ifPresent: aPresentBlock		ifAbsent: [self at: key put: anAbsentBlock value]</body><body package="SmallSuiteGenerator-Extensions">flatCollect: aBlock 	"Evaluate aBlock for each of the receiver's values (by opposition to keys) and answer the	list of all resulting values flatten one level. Assumes that aBlock returns some kind	of collection for each element. Equivalent to the lisp's mapcan"	"If you want to have keys use associations collect: or associations flatCollect: "		^ self flatCollect: aBlock as: OrderedCollection</body></methods><methods><class-id>Core.Behavior</class-id> <category>accessing method dictionary</category><body package="SmallSuiteGenerator-Extensions">allSelectorsBelow: topClass	| coll |	coll := IdentitySet new.	self		withAllSuperclasses do: [ :aClass | 			aClass = topClass				ifTrue: [ ^ coll ]				ifFalse: [ aClass selectors do: [ :sel | coll add: sel ] ] ].	^ coll</body></methods><methods><class-id>Core.Behavior</class-id> <category>creating method dictionary</category><body package="SmallSuiteGenerator-Extensions">isAbstract		"By default a class is not abstract.	Hook to mark your own subclasses as abstract."	^false</body></methods><methods><class-id>Core.Boolean</class-id> <category>testing</category><body package="SmallSuiteGenerator-Extensions">mutateToChange 	^ self not</body></methods><methods><class-id>Core.Random class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Extensions">seed: anInteger 	^self new seed: anInteger</body></methods><methods><class-id>Core.Random</class-id> <category>private</category><body package="SmallSuiteGenerator-Extensions">nextInt: anInteger	"Answer a random integer in the interval [1, anInteger].	Handle large numbers too (for cryptography)."	anInteger strictlyPositive ifFalse: [ self error: 'Range must be positive' ].	anInteger asFloat isInfinity		ifTrue: [^(self next asFraction * anInteger) truncated + 1].	^ (self next * anInteger) truncated + 1</body></methods><methods><class-id>Core.WriteStream</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions">lf	"Append a line feed character to the receiver."	self nextPut: Character lf</body></methods><methods><class-id>Core.Float</class-id> <category>truncation and round off</category><body package="SmallSuiteGenerator-Extensions">round: numberOfWishedDecimal	"Round the decimal part of the receiver to be limited to the number of wished decimal. Only leave a fixed amount of decimal"	"10.12345 round: 2 &gt;&gt;&gt; 10.12 "	^ (self asFraction round: numberOfWishedDecimal) asFloat</body></methods><methods><class-id>Core.OrderedCollection class</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions">newFrom: aCollection 	"Answer an instance of me containing the same elements as aCollection."	| newCollection |	newCollection := self new: aCollection size.	newCollection addAll: aCollection.	^newCollection"	OrderedCollection newFrom: {1. 2. 3}	{1. 2. 3} as: OrderedCollection	{4. 2. 7} as: SortedCollection"</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>adding</category><body package="SmallSuiteGenerator-Extensions">add: newObject afterIndex: index 	"Add the argument, newObject, as an element of the receiver. Put it in 	the sequence just after index. Answer newObject."	(index between: 0 and: self size) ifFalse:[^self errorOutOfBounds].	self insert: newObject before: firstIndex + index.	^ newObject</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>enumerating</category><body package="SmallSuiteGenerator-Extensions">average	"Calculate the average of a collection, return a CollectionIsEmpty exception if the collection is empty. Look averageIfEmpty: aBlock"		" #(2 6 7) average   	&gt;&gt;&gt; 5 "		" #(3 5 7 7) average 	&gt;&gt;&gt; (11/2) "	^ self sum / self size</body><body package="SmallSuiteGenerator-Extensions">sum	"	***This is decompiled code.*** 	This may reflect a problem with the configuration of your image and its sources 	and changes files. 	Please refer to the documentation and the settings tool for help in setting up the 	proper source code files."	^self inject: 0 into: [:t1 :t2 | t1 + t2]</body></methods><methods><class-id>Core.Array</class-id> <category>printing</category><body package="SmallSuiteGenerator-Extensions">printOn: aStream 	"Append to the argument, aStream, the elements of the Array 	enclosed by parentheses."	| tooMany |	tooMany := aStream position + self maxPrint.	aStream nextPutAll: '#('.	self do: [:element | 			aStream position &gt; tooMany				ifTrue: 					[aStream nextPutAll: (#etc &lt;&lt; #dialogs &gt;&gt; '...etc...') asString, ')'.					^self].			element printOn: aStream]		separatedBy: [aStream space]. 	aStream space.	aStream nextPut: $)</body><body package="SmallSuiteGenerator-Extensions">storeOn: aStream 	"Append to the argument aStream a sequence of characters that is an	expression whose evaluation creates an object similar to the receiver.	Use the literal form if possible."	self isLiteral		ifTrue: 			[aStream nextPutAll: '#('.			aStream policy				printCharactersLiterally: true				while: [self						do: [:element | element storeOn: aStream]						separatedBy: [aStream space]].			aStream space.			aStream nextPut: $)]		ifFalse: [super storeOn: aStream]</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>testing</category><body package="SmallSuiteGenerator-Extensions">isAbstract	| node visitor |	node := (Refactory.Browser.RBParser parseMethod: self getSource).	visitor :=  SmallSuiteGenerator.SVisitorNodes new.	node acceptVisitor:visitor.	^ visitor isAbstract</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions">isReturnField	| node stmts |	stmts := (Refactory.Browser.RBParser parseMethod: self getSource) body statements.	stmts ifEmpty: [ ^ false ].	node := stmts first.	^ (node isKindOf: Refactory.Browser.RBReturnNode) and: [ (node value isKindOf: Refactory.Browser.RBVariableNode) and: [self mclass instVarNames includes: node value token value ]]</body></methods><methods><class-id>Core.Fraction</class-id> <category>truncation and round off</category><body package="SmallSuiteGenerator-Extensions">round: numberOfWishedDecimal	"Round the decimal part of the receiver to be limited to the number of wished decimal. Only leave a fixed amount of decimal"	"(1/3 round: 2) &gt;&gt;&gt; (33/100) "	"(111/100 round: 2) &gt;&gt;&gt; (111/100) "	^ self roundTo: (10 raisedTo: numberOfWishedDecimal negated)</body></methods><methods><class-id>SmallSuiteGenerator.SSExecutionContext</class-id> <category>initialize-release</category><body package="SmallSuiteGenerator-Extensions2">initialize	super initialize.	values := OrderedDictionary new</body></methods><methods><class-id>SmallSuiteGenerator.SConfigurationVisualWorks class</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions2">classConfigurationName    ^ superclass fullName, self implementationType</body></methods><methods><class-id>SmallSuiteGenerator.SConfigurationVisualWorks class</class-id> <category>tests</category><body package="SmallSuiteGenerator-Extensions2">createTestCaseClass: aClassName inPackage: aPackageName	| approved builder testCaseClass |	approved := SystemUtils validateClassName: aClassName for: nil.	approved ifNil: [^nil].	testCaseClass := self testCaseClass.	builder := testCaseClass classBuilder addRecord: (BehaviorBuilderRecord forName: approved in: self environment).	^builder		superclass: testCaseClass;		"environment: self environment;"		instVarString: '';		classVarString: '';		poolString: (testCaseClass computeFullPoolString: '');		category: aPackageName;		beFixed;		reviseSystem</body></methods><methods><class-id>SmallSuiteGenerator.SConfigurationVisualWorks class</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions2">implementationType    ^ "Glorp.Dialect dialectName"'VisualWorks'</body></methods><methods><class-id>SmallSuiteGenerator.SConfigurationVisualWorks class</class-id> <category>as yet unclassified</category><body package="SmallSuiteGenerator-Extensions2">rbParserClass	^ Refactory.Browser.RBParser</body></methods><methods><class-id>SmallSuiteGenerator.SConfigurationVisualWorks class</class-id> <category>tests</category><body package="SmallSuiteGenerator-Extensions2">testCaseClass	^ SUnit.TestCase</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfoTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Extensions2">nameOf: aClass	^ aClass fullName asSymbol</body><body package="SmallSuiteGenerator-Extensions2">testAsTypeInfoScalars	 | typeInfo |    typeInfo := STypeInfo asTypeInfo: (Spy1.SSTypeCollector        profile: [ SConference price: 95 ]        onPackagesMatching: 'SmallSuiteGenerator-Scenario').    self        assertCollection: (typeInfo scalars values flatCollect: [ :val | val ])        hasSameElements: #(95 0 100).    typeInfo := STypeInfo asTypeInfo: (Spy1.SSTypeCollector        profile: [ SFoo new                returnCollection;                returnFloat;                returnNum;                returnString ]        onPackagesMatching: 'SmallSuiteGenerator-Scenario').    self        assertCollection: typeInfo scalars associations        hasSameElements:            (Array                with: (self nameOf: SmallInteger) -&gt; #(0 4)                with: (self nameOf: OrderedCollection) -&gt; (Array with: OrderedCollection new)                with: (self nameOf: ByteString) -&gt; #('Hello')                with: (self nameOf: 2.3 class) -&gt; #(2.3))</body><body package="SmallSuiteGenerator-Extensions2">testAsTypeInfoSConferenceOnPackagesMatching	| typeInfo messages |	typeInfo := STypeInfo		asTypeInfo:			(Spy1.SSTypeCollector				profile: [ SConference price: 95 ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario').	messages := typeInfo messagesFrom: (self nameOf: SConference).	self		assertCollection: (messages collect: #selector)		hasSameElements: #(#initialize #price:).	self		assert:			((messages flatCollect: [ :aMessage | aMessage receiver types ])				allSatisfy: [ :aType | aType = (self nameOf: SConference) ]).	self assert: (typeInfo messagesFrom: (self nameOf: SEvent)) isEmpty.	self assert: (typeInfo messagesFrom: (self nameOf: SParty)) isEmpty.	messages := typeInfo factoryMessagesFrom: (self nameOf: SConference).	self		assertCollection: (messages collect: #selector)		hasSameElements: #(#price:)</body><body package="SmallSuiteGenerator-Extensions2">testAsTypeInfoSEventOnPackagesMatching	| typeInfo messages methodInfo classNameSEvent classNameSConference classNameSParty classNameByteString classNameSmallInteger classNameSStudent |	classNameSEvent := self nameOf: SEvent.	classNameSConference := self nameOf: SConference.	classNameSParty := self nameOf: SParty.	classNameByteString := self nameOf: ByteString.	classNameSmallInteger := self nameOf: SmallInteger.	classNameSStudent := self nameOf: SStudent.	typeInfo := STypeInfo		asTypeInfo:			(Spy1.SSTypeCollector				profile: [ | aConference aPerson |					aConference := SConference new offerPrice: 95.					aPerson := SStudent new name: 'Mary'.					aConference canRegister: aPerson ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario').	self		assert: (typeInfo types at: classNameSEvent) methodTypes size		equals: 2.	self		assert: (typeInfo types at: classNameSEvent) classMethodTypes isEmpty.	self		assert: (typeInfo types at: classNameSConference) methodTypes size		equals: 3.	self		assert: (typeInfo types at: classNameSConference) classMethodTypes isEmpty.	self assert: (typeInfo types at: classNameSParty) methodTypes isEmpty.	self		assert: (typeInfo types at: classNameSParty) classMethodTypes isEmpty.	messages := typeInfo messagesFrom: classNameSConference.	self		assertCollection: (messages collect: #selector)		hasSameElements: #(#initialize #offerPrice: #canRegister: #price).	self		assert:			((messages flatCollect: [ :aMessage | aMessage receiver types ])				allSatisfy: [ :aType | aType = classNameSConference ]).	methodInfo := messages		detect: [ :aMessage | aMessage selector = #canRegister: ].	self		assertCollection: methodInfo returnType types		hasSameElements: (Array with: (self nameOf: False)).	self		assertCollection: methodInfo allArgTypes		hasSameElements: (Array with: classNameSStudent).	self		assertCollection: methodInfo allReceivers		hasSameElements: (Array with: classNameSConference).	self		assertCollection: typeInfo scalars keys		hasSameElements:			(Array				with: classNameSStudent				with: classNameSmallInteger				with: (self nameOf: False)				with: classNameByteString				with: (self nameOf: 2.3 class))</body><body package="SmallSuiteGenerator-Extensions2">testAsTypeInfoSFoo	| profile typeInfo methodInfo classNameSFoo classNameOrderedCollection classNameSmallFloat64 classNameByteString classNameSmallInteger classNameDictionary |	classNameSFoo := self nameOf: SFoo.	classNameOrderedCollection := self nameOf: OrderedCollection.	classNameSmallFloat64 := self nameOf: Float.	classNameByteString := self nameOf: ByteString.	classNameSmallInteger := self nameOf: SmallInteger.	classNameDictionary := self nameOf: Dictionary.	profile := Spy1.SSTypeCollector		profile: [ SFoo new				return: Dictionary new;				return: OrderedCollection new;				returnFloat;				returnString;				returnCollection;				returnNum;				score;				score: 5 ]		forClassNamed: classNameSFoo.	typeInfo :=  STypeInfo asTypeInfo: profile.	self assert: (typeInfo types at: classNameSFoo) methodTypes size equals: 8.	self		assert: (typeInfo types at: classNameSFoo) classMethodTypes size		equals: 0.	self		assert: (typeInfo methodType: #initialize from: classNameSFoo) returnType type		equals: classNameSFoo.	methodInfo := typeInfo methodType: #return: from: classNameSFoo.	self		assertCollection: methodInfo returnType types		hasSameElements: (Array with: classNameOrderedCollection with: classNameDictionary).	self		assertCollection: methodInfo allArgTypes		hasSameElements: (Array with: classNameOrderedCollection with: classNameDictionary).	self		assert: (typeInfo methodType: #returnFloat from: classNameSFoo) returnType type		equals: classNameSmallFloat64.	self		assert: (typeInfo methodType: #returnCollection from: classNameSFoo) returnType type		equals: classNameOrderedCollection.	self		assert: (typeInfo methodType: #returnString from: classNameSFoo) returnType type		equals: classNameByteString.	self		assert: (typeInfo methodType: #returnNum from: classNameSFoo) returnType type		equals: classNameSmallInteger .	self		assert: (typeInfo methodType: #score from: classNameSFoo) returnType type		equals: classNameSmallInteger.	methodInfo := typeInfo methodType: #score: from: classNameSFoo.	self assert: methodInfo returnType type equals: classNameSFoo.	self		assertCollection: methodInfo allArgTypes		hasSameElements: (Array with: classNameSmallInteger).	self assert: (typeInfo factoryMessagesFrom: classNameSFoo) isEmpty.	"the factoryMessage has not been executed"	self		assertCollection: typeInfo scalars keys		hasSameElements: (Array with: classNameOrderedCollection with: classNameDictionary with: classNameByteString with: classNameSmallInteger with: classNameSmallFloat64)</body><body package="SmallSuiteGenerator-Extensions2">testAsTypeInfoSFooOnClass	| profile typeInfo methodInfo classNameSFoo |	classNameSFoo := self nameOf: SFoo.	profile := Spy1.SSTypeCollector		profile: [ SFoo new return: OrderedCollection ]		forClassNamed: classNameSFoo.	typeInfo := STypeInfo asTypeInfo: profile.	self		assert: (typeInfo types at: classNameSFoo) methodTypes size		equals: 2.	self		assert: (typeInfo types at: classNameSFoo) classMethodTypes isEmpty.	self		assert: (typeInfo methodType: #initialize from: classNameSFoo) returnType type		equals: classNameSFoo.	methodInfo := typeInfo methodType: #return: from: classNameSFoo.	self		assertCollection: methodInfo returnType types		hasSameElements: (Array with: (self nameOf: OrderedCollection class)).	self		assertCollection: methodInfo allArgTypes		hasSameElements: (Array with: (self nameOf: OrderedCollection class)).	self		assertCollection: ((typeInfo messagesFrom: classNameSFoo) collect: #selector)		hasSameElements: #(#initialize #return:)</body><body package="SmallSuiteGenerator-Extensions2">testAsTypeInfoSFooWithNil	| profile typeInfo methodInfo classNameSFoo |	classNameSFoo := self nameOf: SFoo.	profile := Spy1.SSTypeCollector		profile: [ SFoo new return: nil ]		forClassNamed: classNameSFoo.	typeInfo := STypeInfo asTypeInfo: profile.	self		assert: (typeInfo types at: classNameSFoo) methodTypes size		equals: 2.	self		assert: (typeInfo types at: classNameSFoo) classMethodTypes isEmpty.	self		assert: (typeInfo methodType: #initialize from: classNameSFoo) returnType type		equals: classNameSFoo.	methodInfo := typeInfo methodType: #return: from: classNameSFoo.	self		assertCollection: methodInfo returnType types		hasSameElements: (Array with: (self nameOf: UndefinedObject)).	self		assertCollection: methodInfo allArgTypes		hasSameElements: (Array with: (self nameOf: UndefinedObject)).	self		assertCollection: ((typeInfo messagesFrom: classNameSFoo) collect: #selector)		hasSameElements: #(#initialize #return:)</body><body package="SmallSuiteGenerator-Extensions2">testAsTypeInfoSTeacherOnClass	| typeInfo classNameSTeacher |	classNameSTeacher := self nameOf: SSTeacher.	typeInfo :=  STypeInfo asTypeInfo:  (Spy1.SSTypeCollector		profile: [ (SSTeacher name: 'Ann' with: 34)				name;				nickname;				yearsWorkExperience;				idTeacher;				id ]		forClassNamed: classNameSTeacher).	self		assertCollection:			((typeInfo types at: classNameSTeacher) methodTypes values				collect: #selector)		hasSameElements: #(#idTeacher #initialize #nickname #yearsWorkExperience).	self		assert: (typeInfo types at: classNameSTeacher) classMethodTypes isEmpty.	self		assertCollection: ((typeInfo messagesFrom: classNameSTeacher) collect: #selector)		hasSameElements: #(#initialize #nickname).	self		assertCollection: ((typeInfo accessMessagesFrom: classNameSTeacher) collect: #selector)		hasSameElements: #(#idTeacher #yearsWorkExperience)</body><body package="SmallSuiteGenerator-Extensions2">testAsTypeInfoSTeacherOnPackagesMatching	| typeInfo |	typeInfo := STypeInfo		asTypeInfo:			(Spy1.SSTypeCollector				profile: [ (SSTeacher name: 'Ann' with: 34)						name;						nickname;						yearsWorkExperience;						idTeacher;						id ]				onPackagesMatching: 'SmallSuiteGenerator-Scenario').	self		assertCollection:			((typeInfo types at: (self nameOf: SSTeacher)) methodTypes values				collect: #selector)		hasSameElements: #(#idTeacher #initialize #nickname #yearsWorkExperience).	self		assertCollection:			((typeInfo factoryMessagesFrom: (self nameOf: SSTeacher))				collect: #selector)		hasSameElements: #(#name:with:).	self		assertCollection: ((typeInfo messagesFrom: (self nameOf: SSTeacher)) collect: #selector)		hasSameElements: #(#initialize #nickname #id: #nickname: #name:).	self		assertCollection:			((typeInfo accessMessagesFrom: (self nameOf: SSTeacher))				collect: #selector)		hasSameElements: #(#idTeacher #yearsWorkExperience #name #id)</body><body package="SmallSuiteGenerator-Extensions2">testFactoryMessages	| typeInfo classNameSStudent|		classNameSStudent := self nameOf: SStudent.	typeInfo := STypeInfo asTypeInfo:  (Spy1.SSTypeCollector		profile: [ SStudent name: 'Mary' ]		forClassNamed: classNameSStudent).	self assert: (typeInfo factoryMessagesFrom: classNameSStudent) isEmpty.	typeInfo :=  STypeInfo asTypeInfo:  ( Spy1.SSTypeCollector		profile: [ SStudent name: 'Mary' ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario').	self		assertCollection: ((typeInfo factoryMessagesFrom: classNameSStudent) collect: #selector)		hasSameElements: #(#name:).	typeInfo :=  STypeInfo asTypeInfo:  (Spy1.SSTypeCollector		profile: [ SConference price: 95 ]		onPackagesMatching: 'SmallSuiteGenerator-Scenario').	self		assertCollection: ((typeInfo factoryMessagesFrom: (self nameOf:SConference)) collect: #selector)		hasSameElements: #(#price:)</body></methods><methods><class-id>SmallSuiteGenerator.SError</class-id> <category>signaling</category><body package="SmallSuiteGenerator-Extensions2">signal: message	SConfiguration saveOnLog: message.	self raiseSignal: message</body></methods><methods><class-id>SmallSuiteGenerator.SInspectorAssertion class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Extensions2">for: anExecutionContext	| assertions |	assertions := OrderedCollection new.	anExecutionContext keys		do: [ :varName | 			| value |			value := anExecutionContext at: varName.			(value class methodDictionary values select: #isReturnField)				do: [ :compiledMethod | 					| fieldValue |					fieldValue := value perform: compiledMethod selector.					(self isPrimitive: fieldValue)						ifTrue: [ assertions								add:									(self new										selector: #assert:equals:;										args:											(Array												with:													(SMessage new														receiver: (SVariable name: varName);														selector: compiledMethod selector;														yourself)												with: (SLiteral new value: fieldValue));										yourself) ] ] ].	^ assertions</body></methods><methods><class-id>SmallSuiteGenerator.SSTestRunner</class-id> <category>test - instrumentation</category><body package="SmallSuiteGenerator-Extensions2">analyze: aSmalltalkContext	"it takes an snapshot of the thisContext object"	| sContext |	sContext := SSExecutionContext new.	aSmalltalkContext tempNames		doWithIndex:			[ :varName :index | sContext at: varName put: (aSmalltalkContext tempAt: index) ].	^ sContext</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage</class-id> <category>copying</category><body package="SmallSuiteGenerator-Extensions2">copy	| copy |	copy := super copy.	copy		args: args dcopy;		receiver: receiver copy;		selector: selector copy.	^ copy</body></methods><methods><class-id>SmallSuiteGenerator.SAbstractMessage</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions2">replaceBy: otherExpression	receiver replaceBy: otherExpression receiver.	self selector: otherExpression selector.	self args size = otherExpression args size		ifTrue: [ self args				with: otherExpression args				do: [ :arg :newArg | arg replaceBy: newArg ] ]		ifFalse: [ self args: otherExpression args dcopy ]</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngineTest</class-id> <category>as yet unclassified</category><body package="SmallSuiteGenerator-Extensions2">profilerOf: string	profiler beforeProfiling;	gatherForPackages: ( Store.Registry allPackages select:[:p | string match: p name asString]);	install;	beforeProfiling</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngineTest</class-id> <category>running</category><body package="SmallSuiteGenerator-Extensions2">setUp	super setUp.	engine := SGAEngine new.	profiler := Spy1.SLProfilerCoverage new.	utility := SUtilityTypeInfo new</body><body package="SmallSuiteGenerator-Extensions2">tearDown	[ profiler cleanInstrumentation ]		on: Error		do: [  ].	"S2Lock value: false.	S2Context value: nil.	S2Profiler remove."	super tearDown</body></methods><methods><class-id>SmallSuiteGenerator.SAssertionTest</class-id> <category>tests</category><body package="SmallSuiteGenerator-Extensions2">testAssertString	| test |	test := SSTestCase new.	test		addStatements:			(self				parse:					'_var0 := 1.			 _var1 := 2.			 _var3 := Point x: _var1 y: _var0.').	test generateAssertions: (Array with: SStringAssertion).	self assert: test assertions size equals: 1.	self		assert: test assertions first printString		equals: 'self assert: _var3 printString equals: ''2 @ 1''.'</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngineExample</class-id> <category>actions</category><body package="SmallSuiteGenerator-Extensions2">runOnClass: aClass withBlock: aBlock andFitness: aClassFitness	| engine |	engine := SGAEngine new.	engine		populationSize: 30;		numberOfStatements: 15;		blockToExecute: aBlock;		targetClassName: aClass name.	engine		typeInfo:			(SSTypeCollector profile: engine blockToExecute forClassNamed: aClass)				asTypeInfo;		fitness: aClassFitness;		targetClassName: aClass name;		numberOfIterations: 15;		run.	^ engine</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactory</class-id> <category>actions</category><body package="SmallSuiteGenerator-Extensions2">export: aTestCase with: aSelector	| aClassName class |	aClassName := ('GA' ,  (self targetClassName substrings: '.') last , 'Test') asSymbol.	class := SConfiguration lookUpClass: aClassName.	class		ifNil: [ class := SConfiguration				createTestCaseClass: aClassName				inPackage: self outputPackageName ].	self moveClass: class.	[ aTestCase generateAssertions.	class		compile:			(SConfiguration rbParserClass				parseMethod:					aSelector , aTestCase printDescriptiveComment						, aTestCase parseTreeWithAssertions body formattedCode)				formattedCode ]		on: Error		do: [ | carReturn |			carReturn := String with: Character cr.			class				compile:					aSelector , carReturn , 'self should:'						, aTestCase parseTree formattedCode , carReturn						, ' raise:Error.' , carReturn ]</body><body package="SmallSuiteGenerator-Extensions2">moveClass: aClass	  | bundle pkg list filter |bundle := Store.Registry bundleNamed: 'SmallSuiteGenerator'.pkg :=Store.Registry packageNamedOrCreate: self outputPackageName.Store.XMainChangeSet current  moveWholeClass: aClass toPackage:pkg.list := bundle containedItems.filter := list select: [:d | d name = self outputPackageName].filter isEmpty ifFalse:[ list remove: filter first ].list add: pkg.bundle containedItems: list.</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions2">classes	    classes ifNil: [ classes := Dictionary new ].    types        keysDo: [ :aClassName |             classes                at: aClassName                ifAbsentPut: (SConfiguration lookUpClass: (self fullNameOfClass: aClassName)) ].    ^ classes</body></methods><methods><class-id>SmallSuiteGenerator.STypeInfo</class-id> <category>as yet unclassified</category><body package="SmallSuiteGenerator-Extensions2">isAbstractClass: symbol	| aClass |	aClass := self classes at: symbol.	^ (aClass methodDictionary values select: #isAbstract) isNotEmpty</body></methods><methods><class-id>SmallSuiteGenerator.SCoverageTest</class-id> <category>running</category><body package="SmallSuiteGenerator-Extensions2">installOn: aPackageName	fitness tagetPackagesRegex: aPackageName.	profiler := Spy1.SLProfilerCoverage		profilerForPackagesMatching: aPackageName.	fitness profiler: profiler.	profiler uninstall.	profiler beforeProfiling</body><body package="SmallSuiteGenerator-Extensions2">setUp	utility := SUtilityTypeInfo new.	fitness := self fitnessClass new.	profiler := Spy1.SLProfilerCoverage new</body></methods><methods><class-id>SmallSuiteGenerator.STestCaseFactoryVisualWorks</class-id> <category>actions</category><body package="SmallSuiteGenerator-Extensions2">cleanInstrumentation	profiler class removeFromPackages: packageInfos</body><body package="SmallSuiteGenerator-Extensions2">initializeProfiler	profiler := Spy1.SLProfilerCoverage profilerForPackagesMatching: self targetPackageRegex.	(profiler allMethods select: #isNotMethodExtension)	do: #installGhosts</body></methods><methods><class-id>SmallSuiteGenerator.SGAEngine</class-id> <category>actions</category><body package="SmallSuiteGenerator-Extensions2">run	population := self createRandomPopulation.	self computeFitness.	(1 to: numberOfGenerations)		do: [ :iteration | 			| t log aDictionary |			t := Time now asSeconds.			log := SGALog new				generationNumber: iteration;				fittestTestCase: self pickBestTest;				timeToProduceGeneration: Time now asSeconds - t.			aDictionary := self collectFitnessByName.			log				lowestFit: (self pickMinFitTest: aDictionary);				averageFit: (self pickAverageFitTest: aDictionary).			logs add: log.			self createNewPopulation ]		"displayingProgress: [ :iteration | 'Evolving - Iteration' , iteration printString ]"</body></methods><methods><class-id>SmallSuiteGenerator.SObject</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions2">fullNameOfClass: aSymbol    #('Smalltalk.' 'SmallSuiteGenerator.') detect: [:string |         (Smalltalk at: string, aSymbol ifAbsent: [nil]) isNil not        ] ifFound: [:string | ^ string, aSymbol asString].    self error: 'I cant find the namespace for: ', aSymbol</body></methods><methods><class-id>SmallSuiteGenerator.SRandom class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Extensions2">new	^ self basicNewInstance</body></methods><methods><class-id>SmallSuiteGenerator.AbstractSmallSuiteGeneratorUI class</class-id> <category>interface specs</category><body package="SmallSuiteGeneratorUI-Extensions">advancedSettings	"Tools.UIPainter new openOnClass: self andSelector: #advancedSettings"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#properties: #(#{UI.PropertyListDictionary} #labelFromApplication false ) 			#label: 'Advanced Settings' 			#min: #(#{Core.Point} 20 20 ) 			#max: #(#{Core.Point} 0 0 ) 			#bounds: #(#{Graphics.Rectangle} 640 311 972 581 ) ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 12 0 320 0 120 0 ) 					#name: #GroupBox2 ) 				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 10 0 126 0 320 0 229 0 ) 					#name: #GroupBox1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 21 0 27 0 ) 					#name: #Label1 					#label: 'Generations:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 22 0 58 0 ) 					#name: #Label2 					#label: 'Statements:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 21 0 81 0 ) 					#name: #Label3 ) 				#(#{UI.SpinButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 119 0 26 0 305 0 47 0 ) 					#name: #numberGenerations 					#model: #numberGenerations 					#type: #number 					#low: 1 					#high: 100 					#interval: 1 ) 				#(#{UI.SpinButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 117 0 57 0 308 0 78 0 ) 					#name: #numberStatements 					#model: #numberStatements 					#type: #number 					#low: 1 					#high: 100 					#interval: 1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 22 0 89 0 ) 					#name: #Label4 					#label: 'Population:' ) 				#(#{UI.SpinButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 117 0 89 0 307 0 110 0 ) 					#name: #numberPopulation 					#model: #populationSize 					#type: #number 					#low: 1 					#high: 100 					#interval: 1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 22 0 135 0 ) 					#name: #Label5 					#label: 'Class:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 22 0 168 0 ) 					#name: #Label6 					#label: 'Package(s):' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 20 0 200 0 ) 					#name: #Label7 					#label: 'Output package:' ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 117 0 194 0 311 0 222 0 ) 					#name: #packageModule1 					#flags: 0 					#majorKey: #{EntryWithPasteButtonModule} 					#minorKey: #windowSpec 					#clientKey: #packageModule1 ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 117 0 164 0 310 0 189 0 ) 					#name: #packageModule 					#flags: 0 					#majorKey: #{EntryWithPasteButtonModule} 					#minorKey: #windowSpec 					#clientKey: #packageModule ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 117 0 134 0 310 0 158 0 ) 					#name: #classModule 					#flags: 0 					#majorKey: #{EntryWithPasteButtonModule} 					#minorKey: #windowSpec 					#clientKey: #classModule ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 193 0 240 0 250 0 261 0 ) 					#name: #accept 					#model: #acceptButton 					#label: 					#(#{Kernel.UserMessage} 						#key: #OK 						#defaultString: 'OK' 						#catalogID: #labels ) 					#isDefault: true 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 263 0 241 0 320 0 262 0 ) 					#model: #cancelButton 					#label: 					#(#{Kernel.UserMessage} 						#key: #Cancel 						#defaultString: 'Cancel' 						#catalogID: #labels ) 					#defaultable: true ) ) ) )</body></methods><methods><class-id>SmallSuiteGenerator.SmallSuiteGeneratorGenericUI class</class-id> <category>interface specs</category><body package="SmallSuiteGeneratorUI-Extensions">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'SmallSuiteGenerator' 			#min: #(#{Core.Point} 430 155 ) 			#max: #(#{Core.Point} 430 155 ) 			#bounds: #(#{Graphics.Rectangle} 2185 -370 2615 -215 ) 			#flags: 4 ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{UI.GroupBoxSpec} 					#layout: #(#{Graphics.LayoutFrame} 11 0 9 0 416 0 110 0 ) 					#name: #GroupBox1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 24 0 54 0 ) 					#name: #Label1 					#label: 'Packages:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 23 0 79 0 ) 					#name: #Label2 					#label: 'Output package:' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 308 0 125 0 413 0 146 0 ) 					#name: #ActionButton1 					#model: #generateTests 					#label: 'Create tests' 					#defaultable: true ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 121 0 45 0 403 0 73 0 ) 					#name: #packageModule 					#flags: 0 					#majorKey: #{EntryWithPasteButtonModule} 					#minorKey: #windowSpec 					#clientKey: #packageModule ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 122 0 75 0 403 0 100 0 ) 					#name: #packageModule1 					#flags: 0 					#majorKey: #{EntryWithPasteButtonModule} 					#minorKey: #windowSpec 					#clientKey: #packageModule1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 24 0 24 0 ) 					#name: #Label3 					#label: 'For class:' ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 120 0 21 0 402 0 42 0 ) 					#name: #classModule 					#flags: 0 					#majorKey: #{EntryWithPasteButtonModule} 					#minorKey: #windowSpec 					#clientKey: #classModule ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 11 0 124 0 124 0 145 0 ) 					#name: #ActionButton2 					#model: #showAdvancedSettings 					#label: 'Advanced Settings' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 129 0 124 0 186 0 145 0 ) 					#name: #startButton 					#model: #start 					#label: 'Rec' 					#defaultable: true ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 190 0 124 0 247 0 145 0 ) 					#name: #startButton 					#model: #stop 					#label: 'Stop' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>SmallSuiteGenerator.SmallSuiteGeneratorEditorUI class</class-id> <category>resources</category><body package="SmallSuiteGeneratorUI-Extensions">menuBar	"Tools.MenuEditor new openOnClass: self andSelector: #menuBar"	&lt;resource: #menu&gt;	^#(#{UI.Menu} #(			#(#{UI.MenuItem} 				#rawLabel: 'Settings' ) 			#(#{UI.MenuItem} 				#rawLabel: 'Help' ) ) #(2 ) nil ) decodeAsLiteralArray</body></methods><methods><class-id>SmallSuiteGenerator.SmallSuiteGeneratorEditorUI class</class-id> <category>interface specs</category><body package="SmallSuiteGeneratorUI-Extensions">windowSpec	"Tools.UIPainter new openOnClass: self andSelector: #windowSpec"	&lt;resource: #canvas&gt;	^#(#{UI.FullSpec} 		#window: 		#(#{UI.WindowSpec} 			#label: 'SmallSuiteGenerator' 			#min: #(#{Core.Point} 577 422 ) 			#max: #(#{Core.Point} 577 422 ) 			#bounds: #(#{Graphics.Rectangle} 687 239 1264 661 ) 			#flags: 4 ) 		#component: 		#(#{UI.SpecCollection} 			#collection: #(				#(#{Refactory.Browser.SourceCodeEditorSpec} 					#properties: 					#(#{UI.PropertyListDictionary} #dropSelector 						#drop: #dragOverSelector 						#dragOver: #dragEnterSelector 						#dragEntry: ) 					#layout: #(#{Graphics.LayoutFrame} 2 0 39 0 584 0 366 0 ) 					#name: #document 					#flags: 15 					#isOpaque: true 					#model: #documentModel 					#isWrapped: true 					#isReadOnly: false 					#showHiddenCharacters: false 					#showLineStriping: false 					#autoAccept: true 					#continuousAccept: false 					#showInputCursor: true 					#showSelection: true ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 11 0 376 0 ) 					#name: #Label1 					#label: 'Packages:' ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 298 0 376 0 ) 					#name: #Label2 					#label: 'Output package:' ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 5 0 11 0 110 0 32 0 ) 					#name: #ActionButton1 					#model: #generateTests 					#label: 'Create tests' 					#defaultable: true ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 7 0 387 0 289 0 415 0 ) 					#name: #packageModule 					#flags: 0 					#majorKey: #{EntryWithPasteButtonModule} 					#minorKey: #windowSpec 					#clientKey: #packageModule ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 296 0 392 0 564 0 417 0 ) 					#name: #packageModule1 					#flags: 0 					#majorKey: #{EntryWithPasteButtonModule} 					#minorKey: #windowSpec 					#clientKey: #packageModule1 ) 				#(#{UI.LabelSpec} 					#layout: #(#{Graphics.LayoutOrigin} 233 0 14 0 ) 					#name: #Label3 					#label: 'For class:' ) 				#(#{UI.SubCanvasSpec} 					#layout: #(#{Graphics.LayoutFrame} 293 0 16 0 566 0 34 0 ) 					#name: #classModule 					#flags: 0 					#majorKey: #{EntryWithPasteButtonModule} 					#minorKey: #windowSpec 					#clientKey: #classModule ) 				#(#{UI.ActionButtonSpec} 					#layout: #(#{Graphics.LayoutFrame} 116 0 11 0 229 0 32 0 ) 					#name: #ActionButton2 					#model: #showAdvancedSettings 					#label: 'Advanced Settings' 					#defaultable: true ) ) ) )</body></methods><methods><class-id>Tools.VisualLauncher</class-id> <category>toolbar</category><body package="SmallSuiteGeneratorUI-Extensions">toolbarItemNewSmallSuiteGenerator	&lt;vwPrivileged&gt;	&lt;menuItemForCommand: #uipainterOpenNewCanvas		icon: #(#{UI.ResourceRetriever} #{Refactory.Browser.BrowserIcons} #adoptOverrideIdle )		nameKey: nil		menu: #(#launcherToolBar)		position: 40.1		helpText: #(#EditANewCanvas #UIPainter 'Open generator of tests')&gt;	self applicationForClassNamed: #{SmallSuiteGenerator.SmallSuiteGeneratorGenericUI} do: [ :class | class open ]</body><body package="SmallSuiteGeneratorUI-Extensions">toolbarItemNewSmallSuiteGeneratorEditor	&lt;vwPrivileged&gt;	&lt;menuItemForCommand: #uipainterOpenNewCanvas		icon: #(#{UI.ResourceRetriever} #{Tools.GeneralIcons} #webConsole )		nameKey: nil		menu: #(#launcherToolBar)		position: 40.2		helpText: #(#EditANewCanvas #UIPainter 'Open generator of tests with editor')&gt;	self applicationForClassNamed: #{SmallSuiteGenerator.SmallSuiteGeneratorEditorUI} do: [ :class | class open ]</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Integer</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SObject</name><environment>SmallSuiteGenerator</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><class><name>SSExecutionContext</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>values </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Array</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>STestCaseFactory</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>engine typeInfo targetClassName targetPackageRegex outputPackageName fitness numberOfIterations profiler </inst-vars><class-inst-vars>instance </class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><class><name>STestCaseFactoryVisualWorks</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.STestCaseFactory</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><class><name>Fraction</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numerator denominator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>SError</name><environment>SmallSuiteGenerator</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><class><name>Random</name><environment>Core</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>seed </inst-vars><class-inst-vars>defaultGeneratorClass </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Float</name><environment>Core</environment><super>Core.LimitedPrecisionReal</super><private>false</private><indexed-type>bytes</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>RBProgramNodeVisitor</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class><class><name>VisualLauncher</name><environment>Tools</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>menuBar toolBar textCollector transcriptView statusBar </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Tools-Misc</category><attributes><package>Tools-Misc</package></attributes></class><class><name>SGAEngineTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>engine profiler utility </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-GA</category><attributes><package>SmallSuiteGenerator-Tests-GA</package></attributes></class><class><name>SCoverageTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>utility fitness profiler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-GA</category><attributes><package>SmallSuiteGenerator-Tests-GA</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>SAssertionTest</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpressionTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-AST</category><attributes><package>SmallSuiteGenerator-Tests-AST</package></attributes></class><class><name>STypeInfoTest</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Tests-Info</category><attributes><package>SmallSuiteGenerator-Tests-Info</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>WriteStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>SStack</name><environment>SmallSuiteGenerator</environment><super>Core.LinkedList</super><private>false</private><indexed-type>none</indexed-type><inst-vars>firstLinkStack lastLinkStack </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Scenario</category><attributes><package>SmallSuiteGenerator-Scenario</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SSTestRunner</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testCase invariants </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Core</category><attributes><package>SmallSuiteGenerator-Core</package></attributes></class><class><name>OrderedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>firstIndex lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>STypeInfo</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>types classes noneAbstractClasses scalars </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-Info</category><attributes><package>SmallSuiteGenerator-Info</package></attributes></class><class><name>Link</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nextLink </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>LinkValue</name><environment>Core</environment><super>Core.Link</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Support</category><attributes><package>Collections-Support</package></attributes></class><class><name>SAbstractMessage</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SExpression</super><private>false</private><indexed-type>none</indexed-type><inst-vars>receiver selector args </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-AST</category><attributes><package>SmallSuiteGenerator-AST</package></attributes></class><class><name>SGAEngine</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SGAObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>populationSize mutationOperator crossoverOperator numberOfStatements population logs typeInfo fitness selectionStrategy targetClassName numberOfGenerations </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class><class><name>SGAEngineExample</name><environment>SmallSuiteGenerator</environment><super>SmallSuiteGenerator.SObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SmallSuiteGenerator-GA</category><attributes><package>SmallSuiteGenerator-GA</package></attributes></class></st-source>