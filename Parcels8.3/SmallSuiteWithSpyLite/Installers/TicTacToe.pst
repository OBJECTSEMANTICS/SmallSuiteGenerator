<?xml version="1.0"?><st-source><!-- Name: TicTacToeDbIdentifier: nilDbTrace: nilPackageName: TicTacToeParcel: #('TicTacToe' )ParcelName: TicTacToePrintStringCache: nilDate: 5:16:59 am June 3, 2020 --><time-stamp>From VisualWorksÂ®, 7.4 of December 5, 2005 on June 3, 2020 at 5:16:59 am</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>TicTacToeTest</name><environment>Smalltalk</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fsmTicTacToe </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>TicTacToe</package></attributes></class><class><name>TicTacToeGame</name><environment>Smalltalk</environment><super>UI.TwoDList</super><private>false</private><indexed-type>none</indexed-type><inst-vars>player winner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>(none)</category><attributes><package>TicTacToe</package></attributes></class><class><name>FSMTicTacToe</name><environment>Smalltalk</environment><super>TicTacToeGame</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fsm variables mutex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>TicTacToe</category><attributes><package>TicTacToe</package></attributes></class><class><name>FSMTicTacToe1</name><environment>Smalltalk</environment><super>FSMTicTacToe</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>TicTacToe</category><attributes><package>TicTacToe</package></attributes></class><class><name>TicTacToeUI</name><environment>Smalltalk</environment><super>UI.ApplicationModel</super><private>false</private><indexed-type>none</indexed-type><inst-vars>button1 button2 button3 button4 button5 button6 button7 button8 button9 game assoc </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>TicTacToe</package></attributes></class><class><name>TicTacToeUIFSM</name><environment>Smalltalk</environment><super>TicTacToeUI</super><private>false</private><indexed-type>none</indexed-type><inst-vars>semaphore </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>TicTacToe</package></attributes></class><class><name>GAFSMTicTacToe1Test</name><environment>SmallSuiteGenerator</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>TicTacToe</category><attributes><package>TicTacToe</package></attributes></class><shared-variable><name>PlayerX</name><environment>TicTacToeGame</environment><private>false</private><constant>false</constant><category>players</category><initializer>nil</initializer><attributes><package>TicTacToe</package></attributes></shared-variable><shared-variable><name>PlayerO</name><environment>TicTacToeGame</environment><private>false</private><constant>false</constant><category>players</category><initializer>nil</initializer><attributes><package>TicTacToe</package></attributes></shared-variable><methods><class-id>TicTacToeTest</class-id> <category>As yet unclassified</category><body package="TicTacToe" selector="events">events	^ #('started' 'play' 'reset' 'win' 'close' ) </body><body package="TicTacToe" selector="params">params	^ OrderedCollection with: (Array			with: 1 @ 1			with: 1 @ 2			with: 2 @ 2			with: 3 @ 1			with: 3 @ 3)		with: (Array				with: 1 @ 1				with: 2 @ 2				with: 3 @ 1				with: 2 @ 1				with: 1 @ 3				with: 2 @ 3) </body><body package="TicTacToe" selector="setUp">setUp</body><body package="TicTacToe" selector="tearDown">tearDown	fsmTicTacToe fsm terminate.</body><body package="TicTacToe" selector="testInitGame">testInitGame	fsmTicTacToe := FSMTicTacToe new.	LamDynamicDelay		waitUntilComeTrue: [fsmTicTacToe isStarting]		withTickTime: 100		withTimeout: 1500		atTimeoutDo: [self assert: fsmTicTacToe isStarting]</body><body package="TicTacToe" selector="testInitGame1">testInitGame1	fsmTicTacToe := (FSMTicTacToe1 new) playWith: 1 @ 1; playWith: 1 @ 2; playWith: 2 @ 2; playWith: 3 @ 1; playWith: 3 @ 3; playWith: 1 @ 1; playWith: 2 @ 2; playWith: 3 @ 1; playWith: 2 @ 1; playWith: 1 @ 3; playWith: 2 @ 3; playWith: 1 @ 1; reset; close.	LamDynamicDelay		waitUntilComeTrue: [self verifyAllProcess]		withTickTime: 100		withTimeout: 1500		atTimeoutDo: [self assert: false].	self assert: fsmTicTacToe isStarting</body><body package="TicTacToe" selector="testSendRandomEvents">testSendRandomEvents	(fsmTicTacToe := FSMTicTacToe1 new) playWith: 2 @ 2.	fsmTicTacToe startWith: [nil].	fsmTicTacToe winWith: [nil].	LamDynamicDelay		waitUntilComeTrue: [self verifyAllProcess]		withTickTime: 100		withTimeout: 15000		atTimeoutDo: [self assert: false].	self assert: fsmTicTacToe isStarting</body><body package="TicTacToe" selector="testSimulateAndCloseGame">testSimulateAndCloseGame	fsmTicTacToe := FSMTicTacToe1 new.	self params at: 1.	(1 to: 3)		do: [:t1 | fsmTicTacToe playWith: t1].	fsmTicTacToe resetWith: [nil].	LamDynamicDelay		waitUntilComeTrue: [self verifyAllProcess]		withTickTime: 100		withTimeout: 15000		atTimeoutDo: [self assert: false].	self assert: fsmTicTacToe isStarting</body><body package="TicTacToe" selector="testSimulateGame">testSimulateGame	| t1 |	fsmTicTacToe := FSMTicTacToe1 new.	t1 := self params at: 1.	(1 to: 3)		do: [:t2 | fsmTicTacToe playWith: (t1 at: t2)].	LamDynamicDelay		waitUntilComeTrue: [self verifyAllProcess]		withTickTime: 100		withTimeout: 15000		atTimeoutDo: [self assert: false].	self assert: fsmTicTacToe isPlayingA</body><body package="TicTacToe" selector="testSimulateWinA">testSimulateWinA	| t1 |	fsmTicTacToe := FSMTicTacToe1 new.	(t1 := self params at: 1) do: [:t2 | fsmTicTacToe playWith: t2].	LamDynamicDelay		waitUntilComeTrue: [self verifyAllProcess]		withTickTime: 100		withTimeout: 15000		atTimeoutDo: [self assert: false].	self assert: fsmTicTacToe isStarting</body><body package="TicTacToe" selector="testSimulateWinB">testSimulateWinB	| t1 |	fsmTicTacToe := FSMTicTacToe1 new.	(t1 := self params at: 2) do: [:t2 | fsmTicTacToe playWith: t2].	LamDynamicDelay		waitUntilComeTrue: [self verifyAllProcess]		withTickTime: 100		withTimeout: 15000		atTimeoutDo: [self assert: false].	self assert: fsmTicTacToe isStarting</body><body package="TicTacToe" selector="verifyAllProcess">verifyAllProcess 	| t1 |	^(t1 := Process allInstances asOrderedCollection select: [:t2 | t2 name ~= nil and: [(t2 name startsWith: 'FiniteStateMachine')						or: [t2 name startsWith: 'FSMTicTacToe']]]) allSatisfy: [:t3 | t3 processState = #blocked or: [t3 processState = #terminated]]</body></methods><methods><class-id>TicTacToeGame</class-id> <category>As yet unclassified</category><body package="TicTacToe" selector="checkForWinner">checkForWinner	(self checkLine: #(1 5 9 ))		| (self checkLine: #(3 5 7 )) | ((self checkLine: #(1 2 3 ))			| (self checkLine: #(4 5 6 )) | (self checkLine: #(7 8 9 ))) | ((self checkLine: #(1 4 7 ))			| (self checkLine: #(2 5 8 )) | (self checkLine: #(3 6 9 ))) ifTrue: [self winner: self player].	^self winner notNil </body><body package="TicTacToe" selector="checkLine:">checkLine: t1 	^ (self isPlayer: (self atInteger: (t1 at: 1)))		&amp; (self isPlayer: (self atInteger: (t1 at: 2))) &amp; (self isPlayer: (self atInteger: (t1 at: 3))) </body><body package="TicTacToe" selector="initialize">initialize	self atAllPut: ''</body><body package="TicTacToe" selector="isBoardFull">isBoardFull	^ (self detect: [:t1 | t1 isEmpty]		ifNone: [nil]) isNil </body><body package="TicTacToe" selector="isGameOver">isGameOver	self isBoardFull ifTrue: [^ true].	^self checkForWinner </body><body package="TicTacToe" selector="isPlayableAt:">isPlayableAt: t1 	t1 isZero not		ifTrue: 			[self winner isNil ifTrue: [^ (self at: t1) isEmpty].			^false].	^false </body><body package="TicTacToe" selector="isPlayer:">isPlayer: t1 	^ self player = t1 </body><body package="TicTacToe" selector="player">player	player isNil ifTrue: [player := PlayerX].	^player </body><body package="TicTacToe" selector="resetGame">resetGame	winner := nil.	self initialize</body><body package="TicTacToe" selector="togglePlayer">togglePlayer	self player = PlayerO		ifTrue: [player := PlayerX]		ifFalse: [player := PlayerO]</body><body package="TicTacToe" selector="updateSquare:">updateSquare: t1 	(self isPlayableAt: t1)		ifTrue: 			[self at: t1 put: self player.			self isGameOver ifFalse: [self togglePlayer]]</body><body package="TicTacToe" selector="winner">winner	^ winner </body><body package="TicTacToe" selector="winner:">winner: t1 	winner := t1</body></methods><methods><class-id>TicTacToeGame class</class-id> <category>As yet unclassified</category><body package="TicTacToe" selector="initialize">initialize	PlayerX := 'X'.	PlayerO := 'O'</body><body package="TicTacToe" selector="newGame">newGame	^ (self columns: 3 rows: 3) initialize </body></methods><methods><class-id>FSMTicTacToe</class-id> <category>initialize-release</category><body package="TicTacToe" selector="initialize">initialize	super initialize.	mutex := Semaphore forMutualExclusion.	variables := self class localVariables.	self buildFSM</body></methods><methods><class-id>FSMTicTacToe</class-id> <category>testing</category><body package="TicTacToe" selector="close">close	self fsm postEventNamed: #close</body><body package="TicTacToe" selector="playWith:">playWith: aPoint 	self fsm postEventNamed: #play parameter: aPoint</body><body package="TicTacToe" selector="resetWith:">resetWith: t1 	self fsm postEventNamed: #reset parameter: t1</body><body package="TicTacToe" selector="startWith:">startWith: t1	self fsm postEventNamed: #started parameter: t1</body><body package="TicTacToe" selector="winWith:">winWith: t1	self fsm postEventNamed: #win parameter: t1</body></methods><methods><class-id>FSMTicTacToe</class-id> <category>finite state machine</category><body package="TicTacToe" selector="buildFSM">buildFSM	fsm		ifNil: 			[self fsm: (self buildFSMWithSpecSelector: #fsmSpec).			self fsm stateVariable: (self variableNamed: #State).			self fsm start] </body><body package="TicTacToe" selector="fsmendingActionFor:with:">fsmendingActionFor: client with: args 	[ self resetGame] fork.	self fsm postFirstEventNamed: #close</body><body package="TicTacToe" selector="fsmidleActionFor:with:">fsmidleActionFor: client with: args 	self fsm postFirstEventNamed: #started</body><body package="TicTacToe" selector="fsmplayingAActionFor:with:">fsmplayingAActionFor: client with: args	self playAt: (args at: 1)		with: (args at: 2)</body><body package="TicTacToe" selector="fsmplayingBActionFor:with:">fsmplayingBActionFor: client with: args	self playAt: (args at: 1)		with: (args at: 2)</body><body package="TicTacToe" selector="fsmstartingActionFor:with:">fsmstartingActionFor: client with: args</body></methods><methods><class-id>FSMTicTacToe</class-id> <category>accessing</category><body package="TicTacToe" selector="fsm">fsm	^ fsm </body><body package="TicTacToe" selector="fsm:">fsm: aFSM 	fsm := aFSM</body><body package="TicTacToe" selector="isEnding">isEnding	^ self fsm isWithinStateNamed: #ending </body><body package="TicTacToe" selector="isIdle">isIdle 	^ self fsm isWithinStateNamed: #idle</body><body package="TicTacToe" selector="isPlayingA">isPlayingA	^ self fsm isWithinStateNamed: #playingA </body><body package="TicTacToe" selector="isPlayingB">isPlayingB	^ self fsm isWithinStateNamed: #playingB </body><body package="TicTacToe" selector="isStarting">isStarting	^ self fsm isWithinStateNamed: #starting </body><body package="TicTacToe" selector="playAt:with:">playAt: aPoint with: aColl 		[(self isPlayableAt: aPoint)		ifTrue: 			[mutex critical: [self updateSquare: aPoint].			aColl first value.			self isGameOver ifTrue: [self winner					ifNotNil: 						[aColl second cull: self winner.						self fsm postFirstEventNamed: #win]					ifNil: 						[aColl third value.						self fsm postFirstEventNamed: #win]]]		ifFalse: 			[aColl first value.			aColl fourth value].	(Delay forSeconds: 5) wait] fork</body><body package="TicTacToe" selector="state">state	^ self fsm state </body><body package="TicTacToe" selector="variableNamed:">variableNamed: aSymbol 	^ variables detect: [:var | var name = aSymbol]		ifNone: [nil] </body></methods><methods><class-id>FSMTicTacToe class</class-id> <category>finite state machine-protected</category><body package="TicTacToe" selector="fsmStateSpecs">fsmStateSpecs	^ (OrderedCollection new) add: ((FSMStateSpec new) nodeClass: FSMBlockActionState; name: #ending; actionBlock: [:t1 :t2 :t3 | t3 fsmendingActionFor: t2 with: t1]; yourself); add: ((FSMStateSpec new) nodeClass: FSMBlockActionState; name: #idle; actionBlock: [:t4 :t5 :t6 | t6 fsmidleActionFor: t5 with: t4]; yourself); add: ((FSMStateSpec new) nodeClass: FSMBlockActionState; name: #playingA; actionBlock: [:t7 :t8 :t9 | t9 fsmplayingAActionFor: t8 with: t7]; yourself); add: ((FSMStateSpec new) nodeClass: FSMBlockActionState; name: #playingB; actionBlock: [:t10 :t11 :t12 | t12 fsmplayingBActionFor: t11 with: t10]; yourself); add: ((FSMStateSpec new) nodeClass: FSMBlockActionState; name: #starting; actionBlock: [:t13 :t14 :t15 | t15 fsmstartingActionFor: t14 with: t13]; yourself); yourself </body><body package="TicTacToe" selector="fsmTransitionSpecs">fsmTransitionSpecs	^ (OrderedCollection new) add: ((FSMTransitionSpec new) transitionClass: FSMTransition; oldState: #idle; event: #started; newState: #starting; transitionNumber: 1; properties: nil; yourself); add: ((FSMTransitionSpec new) transitionClass: FSMTransition; oldState: #starting; event: #play; newState: #playingA; transitionNumber: 2; properties: nil; yourself); add: ((FSMTransitionSpec new) transitionClass: FSMTransition; oldState: #playingA; event: #play; newState: #playingB; transitionNumber: 3; properties: nil; yourself); add: ((FSMTransitionSpec new) transitionClass: FSMTransition; oldState: #playingB; event: #play; newState: #playingA; transitionNumber: 4; properties: nil; yourself); add: ((FSMTransitionSpec new) transitionClass: FSMTransition; oldState: #playingA; event: #reset; newState: #ending; transitionNumber: 5; properties: nil; yourself); add: ((FSMTransitionSpec new) transitionClass: FSMTransition; oldState: #playingB; event: #reset; newState: #ending; transitionNumber: 6; properties: nil; yourself); add: ((FSMTransitionSpec new) transitionClass: FSMTransition; oldState: #playingA; event: #win; newState: #ending; transitionNumber: 7; properties: nil; yourself); add: ((FSMTransitionSpec new) transitionClass: FSMTransition; oldState: #playingB; event: #win; newState: #ending; transitionNumber: 8; properties: nil; yourself); add: ((FSMTransitionSpec new) transitionClass: FSMTransition; oldState: #ending; event: #close; newState: #idle; transitionNumber: 9; properties: nil; yourself); yourself </body><body package="TicTacToe" selector="localVariables">localVariables	^ (OrderedCollection new) add: (StatusVariable			newNamed: #State			allowedValues: (CWValueTypeConstraint forClass: Symbol)			unit: #''			isPublic: true); yourself </body><body package="TicTacToe" selector="new">new	^ (super newGame) initialize; yourself </body></methods><methods><class-id>FSMTicTacToe class</class-id> <category>finite state machines</category><body package="TicTacToe" selector="eventsTriggered">eventsTriggered	^ #(#resetGame ) </body></methods><methods><class-id>FSMTicTacToe1</class-id> <category>As yet unclassified</category><body package="TicTacToe" selector="fsmplayingAActionFor:with:">fsmplayingAActionFor: client with: args 	self playAt: args</body><body package="TicTacToe" selector="fsmplayingBActionFor:with:">fsmplayingBActionFor: client with: args 	self playAt: args</body><body package="TicTacToe" selector="playAt:">playAt: aPoint 	[( self isPlayableAt: aPoint)		ifTrue: 			[mutex critical: [self at: aPoint put: self player].			self isGameOver				ifTrue: [self updateStateGameOver]				ifFalse: [self togglePlayer]]		ifFalse: [Transcript show: 'False'].	(Delay forSeconds: 5) wait] fork</body><body package="TicTacToe" selector="reset">reset	self fsm postEventNamed: #reset</body><body package="TicTacToe" selector="updateStateGameOver">updateStateGameOver	self winner ifNotNil: [self fsm postFirstEventNamed: #win]		ifNil: [self fsm postFirstEventNamed: #win]</body></methods><methods><class-id>TicTacToeUI</class-id> <category>As yet unclassified</category><body package="TicTacToe" selector="assocGameUI">assocGameUI	^ assoc		ifNil: 			[(assoc := Array new: 9) at: 1 put: 1 @ 1 -&gt; (builder componentAt: #button1).			assoc at: 2 put: 1 @ 2 -&gt; (builder componentAt: #button2).			assoc at: 3 put: 1 @ 3 -&gt; (builder componentAt: #button3).			assoc at: 4 put: 2 @ 1 -&gt; (builder componentAt: #button4).			assoc at: 5 put: 2 @ 2 -&gt; (builder componentAt: #button5).			assoc at: 6 put: 2 @ 3 -&gt; (builder componentAt: #button6).			assoc at: 7 put: 3 @ 1 -&gt; (builder componentAt: #button7).			assoc at: 8 put: 3 @ 2 -&gt; (builder componentAt: #button8).			assoc at: 9 put: 3 @ 3 -&gt; (builder componentAt: #button9).			assoc := OrderedCollection newFrom: assoc] </body><body package="TicTacToe" selector="button1">button1	self doButton: (builder componentAt: #button1)		withPosition: 1 @ 1</body><body package="TicTacToe" selector="button2">button2	self doButton: (builder componentAt: #button2)		withPosition: 1 @ 2</body><body package="TicTacToe" selector="button3">button3	self doButton: (builder componentAt: #button3)		withPosition: 1 @ 3</body><body package="TicTacToe" selector="button4">button4	self doButton: (builder componentAt: #button4)		withPosition: 2 @ 1</body><body package="TicTacToe" selector="button5">button5	self doButton: (builder componentAt: #button5)		withPosition: 2 @ 2</body><body package="TicTacToe" selector="button6">button6	self doButton: (builder componentAt: #button6)		withPosition: 2 @ 3</body><body package="TicTacToe" selector="button7">button7	self doButton: (builder componentAt: #button7)		withPosition: 3 @ 1</body><body package="TicTacToe" selector="button8">button8	self doButton: (builder componentAt: #button8)		withPosition: 3 @ 2</body><body package="TicTacToe" selector="button9">button9	self doButton: (builder componentAt: #button9)		withPosition: 3 @ 3</body><body package="TicTacToe" selector="doButton:withPosition:">doButton: t1 withPosition: t2 	(game isPlayableAt: t2)		ifTrue: 			[t1 widget labelString: game player.			game updateSquare: t2.			game isGameOver ifTrue: [game winner					ifNotNil: 						[Dialog warn: 'Player ' , game winner , ' wins. Game over.'.						self reset]					ifNil: 						[Dialog warn: 'There is no winner.'.						self reset]]]		ifFalse: [Dialog warn: 'This field is already occupied']</body><body package="TicTacToe" selector="game">game	^ game</body><body package="TicTacToe" selector="game:">game: t1 	game := t1.	self syncGame</body><body package="TicTacToe" selector="initialize">initialize	self mainWindow.	button1 := self wrapperAt: #button1.	button2 := self wrapperAt: #button2.	button3 := self wrapperAt: #button3.	button4 := self wrapperAt: #button4.	button5 := self wrapperAt: #button5.	button6 := self wrapperAt: #button6.	button7 := self wrapperAt: #button7.	button8 := self wrapperAt: #button8.	button9 := self wrapperAt: #button9.	self initializeGame</body><body package="TicTacToe" selector="initializeGame">initializeGame	game := TicTacToeGame newGame</body><body package="TicTacToe" selector="postBuildWith:">postBuildWith: t1 	button1 := (t1 componentAt: #button1) widget.	button2 := (t1 componentAt: #button2) widget.	button3 := (t1 componentAt: #button3) widget.	button4 := (t1 componentAt: #button4) widget.	button5 := (t1 componentAt: #button5) widget.	button6 := (t1 componentAt: #button6) widget.	button7 := (t1 componentAt: #button7) widget.	button8 := (t1 componentAt: #button8) widget.	button9 := (t1 componentAt: #button9) widget</body><body package="TicTacToe" selector="reset">reset	button1 labelString: ''.	button2 labelString: ''.	button3 labelString: ''.	button4 labelString: ''.	button5 labelString: ''.	button6 labelString: ''.	button7 labelString: ''.	button8 labelString: ''.	button9 labelString: ''.	game resetGame</body><body package="TicTacToe" selector="syncGame">syncGame	self assocGameUI do: [:t1 | t1 value widget labelString: (game atPoint: t1 key)]</body></methods><methods><class-id>TicTacToeUI class</class-id> <category>As yet unclassified</category><body package="TicTacToe" selector="open">open	^ super open </body><body package="TicTacToe" selector="openWithGame:">openWithGame: t1 	^ self open source game: t1 </body></methods><methods><class-id>TicTacToeUIFSM</class-id> <category>As yet unclassified</category><body package="TicTacToe" selector="doButton:withPosition:">doButton: t1 withPosition: t2 	game playWith: (Array with: t2 with: ((OrderedCollection new) add: [semaphore signal]; add: [:t3 | Dialog warn: 'Player ' , t3 , ' wins. Game over.']; add: [Dialog warn: 'There is no winner.']; add: [Dialog warn: 'This field is already occupied']; yourself)).	semaphore wait.	self syncGame</body><body package="TicTacToe" selector="initializeGame">initializeGame	(game := FSMTicTacToe new) when: #resetGame		do: 			[self halt.			game isEnding				ifTrue: 					[game close.					self syncGame]				ifFalse: [nil]].	semaphore := Semaphore new</body><body package="TicTacToe" selector="reset">reset	game resetWith: nil</body></methods><methods><class-id>SmallSuiteGenerator.GAFSMTicTacToe1Test</class-id> <category>As yet unclassified</category><body package="TicTacToe" selector="setUp">setUp	(Process allInstances select: [:e | (e name ~= nil) and: [(e name startsWith: 'FiniteStateMachine') or: [ e name startsWith: 'FSMTicTacToe']]]) do: [:e | e terminate].</body><body package="TicTacToe" selector="tearDown">tearDown	(Process allInstances select: [:e | (e name ~= nil) and: [(e name startsWith: 'FiniteStateMachine') or: [ e name startsWith: 'FSMTicTacToe']]]) do: [:e | e terminate].</body><body package="TicTacToe" selector="test1">test1self should:[| var |var := Dictionary new.var at: 1 put: FSMTicTacToe1 newGame.var at: 2 put: (var at: 1) checkForWinner.var at: 3 put: 'O'.var at: 4 put: ((var at: 1) isPlayer: (var at: 3)).var at: 5 put: (var at: 1) initialize.var at: 6 put: ((var at: 5) isPlayer: (var at: 3)).var at: 7 put: (var at: 5) player.var at: 8 put: ((var at: 1) isPlayer: (var at: 3)).var at: 9 put: ((var at: 5) isPlayer: (var at: 7)).var at: 10 put: (var at: 1) fsm.var at: 11 put: (Core.Point x: 3 y: 3).var at: 12 put: ((var at: 1) playWith: (var at: 11)).var at: 13 put: (var at: 1) winner.var at: 14 put: (var at: 5) updateStateGameOver.var at: 15 put: (var at: 12) fsm.var at: 16 put: (var at: 1) fsm.var at: 17 put: (var at: 1) fsm.var at: 18 put: (var at: 1) player.LamDynamicDelay 	waitUntilComeTrue: 		[| process |		process := Process allInstances asOrderedCollection select: 						[:e | 						e name ~= nil and: 								[(e name startsWith: 'FiniteStateMachine') 									or: [e name startsWith: 'FSMTicTacToe']]].		process 			allSatisfy: [:e | e processState = #blocked or: [e processState = #terminated]]]	withTickTime: 100	withTimeout: 15000	atTimeoutDo: [self assert: false]] raise:Error.</body><body package="TicTacToe" selector="test10">test10self should:[| var |var := Dictionary new.var at: 1 put: FSMTicTacToe1 newGame.var at: 2 put: (var at: 1) checkForWinner.var at: 3 put: 'O'.var at: 4 put: ((var at: 1) isPlayer: (var at: 3)).var at: 5 put: (var at: 1) initialize.var at: 6 put: ((var at: 5) isPlayer: (var at: 3)).var at: 8 put: ((var at: 5) isPlayer: (var at: 3)).var at: 10 put: ((var at: 1) isPlayer: (var at: 3)).var at: 11 put: (var at: 5) fsm.var at: 7 put: (Core.Point x: 2 y: 1).var at: 9 put: ((var at: 5) playWith: (var at: 7)).var at: 12 put: (var at: 1) updateStateGameOver.var at: 13 put: (var at: 9) updateStateGameOver.var at: 14 put: (var at: 5) winner.var at: 15 put: ((var at: 1) isPlayer: (var at: 14)).LamDynamicDelay 	waitUntilComeTrue: 		[| process |		process := Process allInstances asOrderedCollection select: 						[:e | 						e name ~= nil and: 								[(e name startsWith: 'FiniteStateMachine') 									or: [e name startsWith: 'FSMTicTacToe']]].		process 			allSatisfy: [:e | e processState = #blocked or: [e processState = #terminated]]]	withTickTime: 100	withTimeout: 15000	atTimeoutDo: [self assert: false]] raise:Error.</body><body package="TicTacToe" selector="test11">test11self should:[| var |var := Dictionary new.var at: 1 put: FSMTicTacToe1 newGame.var at: 2 put: (var at: 1) checkForWinner.var at: 3 put: 'O'.var at: 4 put: ((var at: 1) isPlayer: (var at: 3)).var at: 5 put: (var at: 1) initialize.var at: 6 put: ((var at: 5) isPlayer: (var at: 3)).var at: 8 put: ((var at: 5) isPlayer: (var at: 3)).var at: 10 put: ((var at: 1) isPlayer: (var at: 3)).var at: 11 put: (var at: 5) fsm.var at: 12 put: (Core.Point x: 2 y: 2).var at: 13 put: ((var at: 1) playWith: (var at: 12)).var at: 15 put: (var at: 13) updateStateGameOver.var at: 18 put: (var at: 13) updateStateGameOver.var at: 16 put: (var at: 13) winner.var at: 17 put: ((var at: 13) isPlayer: (var at: 3)).LamDynamicDelay 	waitUntilComeTrue: 		[| process |		process := Process allInstances asOrderedCollection select: 						[:e | 						e name ~= nil and: 								[(e name startsWith: 'FiniteStateMachine') 									or: [e name startsWith: 'FSMTicTacToe']]].		process 			allSatisfy: [:e | e processState = #blocked or: [e processState = #terminated]]]	withTickTime: 100	withTimeout: 15000	atTimeoutDo: [self assert: false]] raise:Error.</body><body package="TicTacToe" selector="test12">test12self should:[| var |var := Dictionary new.var at: 1 put: FSMTicTacToe1 newGame.var at: 2 put: (var at: 1) checkForWinner.var at: 3 put: 'O'.var at: 4 put: ((var at: 1) isPlayer: (var at: 3)).var at: 5 put: (var at: 1) initialize.var at: 6 put: (var at: 5) initialize.var at: 7 put: ((var at: 6) isPlayer: (var at: 3)).var at: 8 put: ((var at: 5) isPlayer: (var at: 3)).var at: 9 put: ((var at: 1) isPlayer: (var at: 3)).var at: 10 put: (var at: 6) fsm.var at: 11 put: (Core.Point x: 2 y: 2).var at: 12 put: ((var at: 6) playWith: (var at: 11)).var at: 13 put: (var at: 12) updateStateGameOver.var at: 14 put: (var at: 12) updateStateGameOver.var at: 17 put: ((var at: 1) isPlayer: (var at: 3)).LamDynamicDelay 	waitUntilComeTrue: 		[| process |		process := Process allInstances asOrderedCollection select: 						[:e | 						e name ~= nil and: 								[(e name startsWith: 'FiniteStateMachine') 									or: [e name startsWith: 'FSMTicTacToe']]].		process 			allSatisfy: [:e | e processState = #blocked or: [e processState = #terminated]]]	withTickTime: 100	withTimeout: 15000	atTimeoutDo: [self assert: false]] raise:Error.</body><body package="TicTacToe" selector="test13">test13self should:[| var |var := Dictionary new.var at: 1 put: FSMTicTacToe1 newGame.var at: 2 put: (var at: 1) checkForWinner.var at: 3 put: 'O'.var at: 4 put: ((var at: 1) isPlayer: (var at: 3)).var at: 5 put: (var at: 1) initialize.var at: 6 put: (var at: 5) initialize.var at: 7 put: ((var at: 6) isPlayer: (var at: 3)).var at: 8 put: ((var at: 5) isPlayer: (var at: 3)).var at: 9 put: ((var at: 1) isPlayer: (var at: 3)).var at: 10 put: (var at: 6) fsm.var at: 11 put: (Core.Point x: 2 y: 2).var at: 12 put: ((var at: 6) playWith: (var at: 11)).var at: 13 put: (var at: 12) updateStateGameOver.var at: 14 put: (var at: 12) updateStateGameOver.var at: 17 put: ((var at: 1) isPlayer: (var at: 3)).LamDynamicDelay 	waitUntilComeTrue: 		[| process |		process := Process allInstances asOrderedCollection select: 						[:e | 						e name ~= nil and: 								[(e name startsWith: 'FiniteStateMachine') 									or: [e name startsWith: 'FSMTicTacToe']]].		process 			allSatisfy: [:e | e processState = #blocked or: [e processState = #terminated]]]	withTickTime: 100	withTimeout: 15000	atTimeoutDo: [self assert: false]] raise:Error.</body><body package="TicTacToe" selector="test14">test14self should:[| var |var := Dictionary new.var at: 1 put: FSMTicTacToe1 newGame.var at: 2 put: (var at: 1) checkForWinner.var at: 3 put: 'O'.var at: 4 put: ((var at: 1) isPlayer: (var at: 3)).var at: 5 put: ((var at: 1) isPlayer: (var at: 3)).var at: 6 put: (var at: 1) player.var at: 7 put: ((var at: 1) isPlayer: (var at: 6)).var at: 8 put: ((var at: 1) isPlayer: (var at: 6)).var at: 10 put: ((var at: 1) isPlayer: (var at: 3)).var at: 11 put: (var at: 1) fsm.var at: 12 put: (Core.Point x: 1 y: 2).var at: 13 put: ((var at: 1) playWith: (var at: 12)).var at: 14 put: (var at: 1) winner.var at: 15 put: (var at: 1) updateStateGameOver.var at: 16 put: (var at: 1) fsm.var at: 17 put: (var at: 13) fsm.LamDynamicDelay 	waitUntilComeTrue: 		[| process |		process := Process allInstances asOrderedCollection select: 						[:e | 						e name ~= nil and: 								[(e name startsWith: 'FiniteStateMachine') 									or: [e name startsWith: 'FSMTicTacToe']]].		process 			allSatisfy: [:e | e processState = #blocked or: [e processState = #terminated]]]	withTickTime: 100	withTimeout: 15000	atTimeoutDo: [self assert: false]] raise:Error.</body><body package="TicTacToe" selector="test15">test15self should:[| var |var := Dictionary new.var at: 1 put: FSMTicTacToe1 newGame.var at: 2 put: (var at: 1) checkForWinner.var at: 3 put: 'O'.var at: 4 put: ((var at: 1) isPlayer: (var at: 3)).var at: 5 put: ((var at: 1) isPlayer: (var at: 3)).var at: 6 put: (var at: 1) player.var at: 7 put: ((var at: 1) isPlayer: (var at: 6)).var at: 10 put: ((var at: 1) isPlayer: (var at: 3)).var at: 9 put: (Core.Point x: 1 y: 3).var at: 12 put: ((var at: 1) playWith: (var at: 9)).var at: 13 put: (var at: 12) winner.var at: 14 put: (var at: 1) updateStateGameOver.var at: 15 put: (var at: 14) fsm.var at: 16 put: (var at: 12) fsm.var at: 17 put: (var at: 12) fsm.var at: 18 put: (var at: 12) player.LamDynamicDelay 	waitUntilComeTrue: 		[| process |		process := Process allInstances asOrderedCollection select: 						[:e | 						e name ~= nil and: 								[(e name startsWith: 'FiniteStateMachine') 									or: [e name startsWith: 'FSMTicTacToe']]].		process 			allSatisfy: [:e | e processState = #blocked or: [e processState = #terminated]]]	withTickTime: 100	withTimeout: 15000	atTimeoutDo: [self assert: false]] raise:Error.</body><body package="TicTacToe" selector="test2">test2self should:[| var |var := Dictionary new.var at: 1 put: FSMTicTacToe1 newGame.var at: 2 put: (var at: 1) checkForWinner.var at: 3 put: 'O'.var at: 4 put: ((var at: 1) isPlayer: (var at: 3)).var at: 5 put: (var at: 1) initialize.var at: 6 put: ((var at: 5) isPlayer: (var at: 3)).var at: 7 put: (var at: 5) player.var at: 8 put: ((var at: 1) isPlayer: (var at: 3)).var at: 9 put: ((var at: 5) isPlayer: (var at: 7)).var at: 10 put: (var at: 1) fsm.var at: 11 put: (Core.Point x: 3 y: 3).var at: 12 put: ((var at: 1) playWith: (var at: 11)).var at: 13 put: (var at: 1) winner.var at: 14 put: (var at: 5) updateStateGameOver.var at: 15 put: (var at: 12) fsm.var at: 16 put: (var at: 1) fsm.var at: 17 put: (var at: 1) fsm.var at: 18 put: (var at: 1) player.LamDynamicDelay 	waitUntilComeTrue: 		[| process |		process := Process allInstances asOrderedCollection select: 						[:e | 						e name ~= nil and: 								[(e name startsWith: 'FiniteStateMachine') 									or: [e name startsWith: 'FSMTicTacToe']]].		process 			allSatisfy: [:e | e processState = #blocked or: [e processState = #terminated]]]	withTickTime: 100	withTimeout: 15000	atTimeoutDo: [self assert: false]] raise:Error.</body><body package="TicTacToe" selector="test3">test3self should:[| var |var := Dictionary new.var at: 1 put: FSMTicTacToe1 newGame.var at: 2 put: (var at: 1) checkForWinner.var at: 3 put: 'O'.var at: 4 put: ((var at: 1) isPlayer: (var at: 3)).var at: 5 put: (var at: 1) initialize.var at: 6 put: ((var at: 5) isPlayer: (var at: 3)).var at: 7 put: (var at: 5) player.var at: 8 put: ((var at: 1) isPlayer: (var at: 3)).var at: 9 put: ((var at: 5) isPlayer: (var at: 7)).var at: 10 put: (var at: 1) fsm.var at: 11 put: (Core.Point x: 3 y: 3).var at: 12 put: ((var at: 1) playWith: (var at: 11)).var at: 13 put: (var at: 1) winner.var at: 14 put: (var at: 5) updateStateGameOver.var at: 15 put: (var at: 12) fsm.var at: 16 put: (var at: 1) fsm.var at: 17 put: (var at: 1) fsm.var at: 18 put: (var at: 1) player.LamDynamicDelay 	waitUntilComeTrue: 		[| process |		process := Process allInstances asOrderedCollection select: 						[:e | 						e name ~= nil and: 								[(e name startsWith: 'FiniteStateMachine') 									or: [e name startsWith: 'FSMTicTacToe']]].		process 			allSatisfy: [:e | e processState = #blocked or: [e processState = #terminated]]]	withTickTime: 100	withTimeout: 15000	atTimeoutDo: [self assert: false]] raise:Error.</body><body package="TicTacToe" selector="test4">test4self should:[| var |var := Dictionary new.var at: 1 put: FSMTicTacToe1 newGame.var at: 2 put: (var at: 1) checkForWinner.var at: 3 put: 'O'.var at: 4 put: ((var at: 1) isPlayer: (var at: 3)).var at: 5 put: (var at: 1) player.var at: 7 put: ((var at: 1) isPlayer: (var at: 3)).var at: 9 put: (var at: 1) fsm.var at: 11 put: (Core.Point x: 2 y: 3).var at: 12 put: ((var at: 1) playWith: (var at: 11)).var at: 8 put: (var at: 12) winner.var at: 10 put: (var at: 12) updateStateGameOver.var at: 14 put: (var at: 1) updateStateGameOver.var at: 15 put: (var at: 1) winner.LamDynamicDelay 	waitUntilComeTrue: 		[| process |		process := Process allInstances asOrderedCollection select: 						[:e | 						e name ~= nil and: 								[(e name startsWith: 'FiniteStateMachine') 									or: [e name startsWith: 'FSMTicTacToe']]].		process 			allSatisfy: [:e | e processState = #blocked or: [e processState = #terminated]]]	withTickTime: 100	withTimeout: 15000	atTimeoutDo: [self assert: false]] raise:Error.</body><body package="TicTacToe" selector="test5">test5self should:[| var |var := Dictionary new.var at: 1 put: FSMTicTacToe1 newGame.var at: 2 put: (var at: 1) checkForWinner.var at: 3 put: 'O'.var at: 4 put: ((var at: 1) isPlayer: (var at: 3)).var at: 5 put: (var at: 1) initialize.var at: 6 put: (var at: 5) initialize.var at: 7 put: ((var at: 6) isPlayer: (var at: 3)).var at: 8 put: ((var at: 5) isPlayer: (var at: 3)).var at: 9 put: ((var at: 1) isPlayer: (var at: 3)).var at: 10 put: (var at: 6) fsm.var at: 11 put: (Core.Point x: 2 y: 2).var at: 13 put: (var at: 1) updateStateGameOver.var at: 14 put: (var at: 6) updateStateGameOver.var at: 17 put: ((var at: 1) isPlayer: (var at: 3)).LamDynamicDelay 	waitUntilComeTrue: 		[| process |		process := Process allInstances asOrderedCollection select: 						[:e | 						e name ~= nil and: 								[(e name startsWith: 'FiniteStateMachine') 									or: [e name startsWith: 'FSMTicTacToe']]].		process 			allSatisfy: [:e | e processState = #blocked or: [e processState = #terminated]]]	withTickTime: 100	withTimeout: 15000	atTimeoutDo: [self assert: false]] raise:Error.</body><body package="TicTacToe" selector="test6">test6self should:[| var |var := Dictionary new.var at: 1 put: FSMTicTacToe1 newGame.var at: 2 put: (var at: 1) checkForWinner.var at: 3 put: 'O'.var at: 4 put: ((var at: 1) isPlayer: (var at: 3)).var at: 5 put: (var at: 1) initialize.var at: 6 put: ((var at: 5) isPlayer: (var at: 3)).var at: 7 put: (var at: 5) player.var at: 8 put: ((var at: 1) isPlayer: (var at: 3)).var at: 9 put: ((var at: 5) isPlayer: (var at: 3)).var at: 10 put: (var at: 1) fsm.var at: 11 put: (var at: 1) updateStateGameOver.var at: 12 put: (var at: 5) fsm.var at: 13 put: (var at: 1) fsm.var at: 14 put: (var at: 11) fsm.var at: 15 put: (var at: 1) player.LamDynamicDelay 	waitUntilComeTrue: 		[| process |		process := Process allInstances asOrderedCollection select: 						[:e | 						e name ~= nil and: 								[(e name startsWith: 'FiniteStateMachine') 									or: [e name startsWith: 'FSMTicTacToe']]].		process 			allSatisfy: [:e | e processState = #blocked or: [e processState = #terminated]]]	withTickTime: 100	withTimeout: 15000	atTimeoutDo: [self assert: false]] raise:Error.</body><body package="TicTacToe" selector="test7">test7self should:[| var |var := Dictionary new.var at: 1 put: FSMTicTacToe1 newGame.var at: 2 put: (var at: 1) checkForWinner.var at: 3 put: 'O'.var at: 4 put: ((var at: 1) isPlayer: (var at: 3)).var at: 5 put: (var at: 1) initialize.var at: 6 put: ((var at: 5) isPlayer: (var at: 3)).var at: 8 put: ((var at: 5) isPlayer: (var at: 3)).var at: 10 put: ((var at: 1) isPlayer: (var at: 3)).var at: 11 put: (var at: 5) fsm.var at: 12 put: (Core.Point x: 2 y: 2).var at: 13 put: ((var at: 1) playWith: (var at: 12)).var at: 15 put: (var at: 13) updateStateGameOver.var at: 18 put: (var at: 13) updateStateGameOver.var at: 16 put: (var at: 13) winner.var at: 17 put: ((var at: 13) isPlayer: (var at: 3)).LamDynamicDelay 	waitUntilComeTrue: 		[| process |		process := Process allInstances asOrderedCollection select: 						[:e | 						e name ~= nil and: 								[(e name startsWith: 'FiniteStateMachine') 									or: [e name startsWith: 'FSMTicTacToe']]].		process 			allSatisfy: [:e | e processState = #blocked or: [e processState = #terminated]]]	withTickTime: 100	withTimeout: 15000	atTimeoutDo: [self assert: false]] raise:Error.</body><body package="TicTacToe" selector="test8">test8self should:[| var |var := Dictionary new.var at: 1 put: FSMTicTacToe1 newGame.var at: 2 put: (var at: 1) checkForWinner.var at: 3 put: 'O'.var at: 4 put: ((var at: 1) isPlayer: (var at: 3)).var at: 5 put: (var at: 1) initialize.var at: 6 put: ((var at: 5) isPlayer: (var at: 3)).var at: 8 put: ((var at: 5) isPlayer: (var at: 3)).var at: 10 put: ((var at: 1) isPlayer: (var at: 3)).var at: 11 put: (var at: 5) fsm.var at: 12 put: (Core.Point x: 2 y: 2).var at: 13 put: ((var at: 1) playWith: (var at: 12)).var at: 15 put: (var at: 13) updateStateGameOver.var at: 18 put: (var at: 13) updateStateGameOver.var at: 16 put: (var at: 13) winner.var at: 17 put: ((var at: 13) isPlayer: (var at: 3)).LamDynamicDelay 	waitUntilComeTrue: 		[| process |		process := Process allInstances asOrderedCollection select: 						[:e | 						e name ~= nil and: 								[(e name startsWith: 'FiniteStateMachine') 									or: [e name startsWith: 'FSMTicTacToe']]].		process 			allSatisfy: [:e | e processState = #blocked or: [e processState = #terminated]]]	withTickTime: 100	withTimeout: 15000	atTimeoutDo: [self assert: false]] raise:Error.</body><body package="TicTacToe" selector="test9">test9self should:[| var |var := Dictionary new.var at: 1 put: FSMTicTacToe1 newGame.var at: 2 put: (var at: 1) checkForWinner.var at: 3 put: 'O'.var at: 4 put: ((var at: 1) isPlayer: (var at: 3)).var at: 5 put: (var at: 1) initialize.var at: 6 put: ((var at: 5) isPlayer: (var at: 3)).var at: 8 put: ((var at: 5) isPlayer: (var at: 3)).var at: 10 put: ((var at: 1) isPlayer: (var at: 3)).var at: 11 put: (var at: 5) fsm.var at: 12 put: (Core.Point x: 2 y: 2).var at: 13 put: ((var at: 1) playWith: (var at: 12)).var at: 15 put: (var at: 13) updateStateGameOver.var at: 18 put: (var at: 13) updateStateGameOver.var at: 16 put: (var at: 13) winner.var at: 17 put: ((var at: 13) isPlayer: (var at: 3)).LamDynamicDelay 	waitUntilComeTrue: 		[| process |		process := Process allInstances asOrderedCollection select: 						[:e | 						e name ~= nil and: 								[(e name startsWith: 'FiniteStateMachine') 									or: [e name startsWith: 'FSMTicTacToe']]].		process 			allSatisfy: [:e | e processState = #blocked or: [e processState = #terminated]]]	withTickTime: 100	withTimeout: 15000	atTimeoutDo: [self assert: false]] raise:Error.</body></methods><methods><class-id>Core.Array class</class-id> <category>instance creation</category><body package="TicTacToe" selector="with:with:with:with:with:with:">with: t1 with: t2 with: t3 with: t4 with: t5 with: t6 	| t7 |	(t7 := self new: 6) at: 1 put: t1.	t7 at: 2 put: t2.	t7 at: 3 put: t3.	t7 at: 4 put: t4.	t7 at: 5 put: t5.	t7 at: 6 put: t6.	^t7 </body></methods><methods><class-id>FSMTicTacToe class</class-id> <category>finite state machines</category><body package="TicTacToe" selector="fsmSpec">fsmSpec	&lt;resource: #fsm&gt;	^ (FSMSpec new) fsmClassName: #CWFiniteStateMachine; fsmName: #fsm; stateSpecsSelector: #fsmStateSpecs; transitionSpecsSelector: #fsmTransitionSpecs; initialStateName: #idle; yourself </body></methods><methods><class-id>TicTacToeUI class</class-id> <category>As yet unclassified</category><body package="TicTacToe" selector="windowSpec">windowSpec	&lt;resource: #canvas&gt;	^ #(#{UI.FullSpec} #window: #(#{UI.WindowSpec} #label: 'TicTacToe' #bounds: #(#{Graphics.Rectangle} 645 333 933 566 ) ) #component: #(#{UI.SpecCollection} #collection: #(#(#{UI.ActionButtonSpec} #layout: #(#{Graphics.LayoutFrame} 195 0 23 0 252 0 44 0 ) #name: #button3 #model: #button3 #defaultable: true ) #(#{UI.ActionButtonSpec} #layout: #(#{Graphics.LayoutFrame} 39 0 67 0 96 0 88 0 ) #name: #button4 #model: #button4 #defaultable: true ) #(#{UI.ActionButtonSpec} #layout: #(#{Graphics.LayoutFrame} 117 0 66 0 174 0 87 0 ) #name: #button5 #model: #button5 #defaultable: true ) #(#{UI.ActionButtonSpec} #layout: #(#{Graphics.LayoutFrame} 193 0 68 0 250 0 89 0 ) #name: #button6 #model: #button6 #defaultable: true ) #(#{UI.ActionButtonSpec} #layout: #(#{Graphics.LayoutFrame} 38 0 112 0 95 0 133 0 ) #name: #button7 #model: #button7 #defaultable: true ) #(#{UI.ActionButtonSpec} #layout: #(#{Graphics.LayoutFrame} 116 0 113 0 173 0 134 0 ) #name: #button8 #model: #button8 #defaultable: true ) #(#{UI.ActionButtonSpec} #layout: #(#{Graphics.LayoutFrame} 194 0 112 0 251 0 133 0 ) #name: #button9 #model: #button9 #defaultable: true ) #(#{UI.ActionButtonSpec} #layout: #(#{Graphics.LayoutFrame} 38 0 24 0 95 0 45 0 ) #name: #button1 #model: #button1 #defaultable: true ) #(#{UI.ActionButtonSpec} #layout: #(#{Graphics.LayoutFrame} 118 0 23 0 175 0 44 0 ) #name: #button2 #model: #button2 #defaultable: true ) #(#{UI.ActionButtonSpec} #layout: #(#{Graphics.LayoutFrame} 117 0 188 0 174 0 209 0 ) #name: #reset #model: #reset #label: 'Reset' #defaultable: true ) #(#{UI.DividerSpec} #layout: #(#{Graphics.LayoutFrame} 29 0 53 0 256 0 57 0 ) #name: #Divider1 ) #(#{UI.DividerSpec} #layout: #(#{Graphics.LayoutFrame} 27 0 100 0 255 0 104 0 ) #name: #Divider2 ) #(#{UI.DividerSpec} #layout: #(#{Graphics.LayoutFrame} 107 0 9 0 204 0 149 0 ) #name: #Divider3 #orientation: #vertical ) #(#{UI.DividerSpec} #layout: #(#{Graphics.LayoutFrame} 182 0 11 0 282 0 146 0 ) #name: #Divider4 #orientation: #vertical ) ) ) ) </body></methods><initialize><class-id>TicTacToeGame</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>TwoDList</name><environment>UI</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependents collection rows columns transposed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>UIBasics-Collections</category><attributes><package>UIBasics-Collections</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>ApplicationModel</name><environment>UI</environment><super>UI.Model</super><private>false</private><indexed-type>none</indexed-type><inst-vars>builder uiSession eventHandlers </inst-vars><class-inst-vars>savedWindowInformation </class-inst-vars><imports></imports><category>UIBuilder-Framework</category><attributes><package>UIBuilder-Framework</package></attributes></class></st-source>