<?xml version="1.0"?><st-source><!-- Name: SpyLite-Extensions1BundleName: SpyLite-ExtensionsBundleStructure: a Store.BundleForParcelDevelopmentPrerequisites: #(#(#any 'SpyLite' ''))Parcel: nilParcelName: SpyLite-Extensions1PrerequisiteDescriptions: #(#(#name 'SpyLite' #componentType #bundle))PrerequisiteParcels: #(#('SpyLite' ''))Date: 4:35:35 PM December 26, 2019 --><time-stamp>From VisualWorksÂ®, 8.3 of July 28, 2017 on December 26, 2019 at 4:35:35 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>SLCodeProbe</name><environment>Spy1</environment><super>CraftedSmalltalk.CodeProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>SpyLite-Extensions</package></attributes></class><methods><class-id>Spy1.SLCodeProbe</class-id> <category>initialize-release</category><body package="SpyLite-Extensions">actOn: aContext    block executed</body><body package="SpyLite-Extensions">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Replace this comment with the appropriate initialization code *** "	^self</body></methods><methods><class-id>Spy1.SLCodeProbe</class-id> <category>accessing</category><body package="SpyLite-Extensions">block	^block</body><body package="SpyLite-Extensions">block: anObject	block := anObject</body></methods><methods><class-id>Core.Object</class-id> <category>controlling</category><body package="SpyLite-Extensions">assert: aBlock	aBlock value ifFalse: [ self error: 'Assertion failed' ]</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="SpyLite-Extensions">asString		^ self printString</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="SpyLite-Extensions">isCollection	^false</body></methods><methods><class-id>Core.Object</class-id> <category>event accessing</category><body package="SpyLite-Extensions">isSpy	^ false</body><body package="SpyLite-Extensions">isSpyMethod	^ false</body></methods><methods><class-id>Core.String class</class-id> <category>defaults</category><body package="SpyLite-Extensions">lf	"Answer a string containing a single carriage return character."	^ self with: Character lf</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="SpyLite-Extensions">asString	"Answer this string."	^ self</body></methods><methods><class-id>Core.String</class-id> <category>private</category><body package="SpyLite-Extensions">substrings	"Answer an array of non-empty substrings from the receiver separated by	one or more whitespace characters."		"'let us make seperate strings' substrings &gt;&gt;&gt;  #('let' 'us' 'make' 'seperate' 'strings')"	^ self  substrings: (Array with: Character space)</body><body package="SpyLite-Extensions">substrings: separators	"Answer an array of non-empty substrings from the receiver separated by	one or more characters from the 'separators' argument collection."	| substrings substringStart |	substrings := (Array new: 10) writeStream.	1 to: self size do: [ :i | 		| nextChar |		nextChar := self at: i.		(separators includes: nextChar)			ifTrue: [				substringStart					ifNotNil: [						substrings nextPut: (self copyFrom: substringStart to: i - 1).						substringStart := nil ] ]			ifFalse: [ substringStart ifNil: [ substringStart := i ] ] ].	substringStart		ifNotNil: [ substrings nextPut: (self copyFrom: substringStart to: self size) ].	^ substrings contents</body></methods><methods><class-id>Core.Collection</class-id> <category>converting</category><body package="SpyLite-Extensions">asDictionary	^ Dictionary newFrom: self</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="SpyLite-Extensions">associationsDo: aBlock 	"Evaluate aBlock for each of the receiver's key/value associations."	tally == 0 ifTrue: [^self].	1 to: self basicSize do: 		[:index |		| elem |		(elem := self basicAt: index) == nil ifFalse: [aBlock value: elem]]</body><body package="SpyLite-Extensions">collect: collectBlock thenSelect: selectBlock	"Utility method to improve readability."	^ (self collect: collectBlock) select: selectBlock</body><body package="SpyLite-Extensions">difference: aCollection	"Answer the set theoretic difference of two collections. Pay attention that the difference is not commutative, hence the order is important."	"(#(a b c d e f) difference:  #(a b z k))&gt;&gt;&gt; #(#f #d #e #c)"	"(#(a b z k) difference: #(a b c d e f)) &gt;&gt;&gt; #(#k #z)"	| set |	set := self asSet		removeAllFoundIn: aCollection;		yourself.	^ self species withAll: set asArray</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="SpyLite-Extensions">ifNotEmpty: aBlock	"Evaluate the given block with the receiver as argument, answering its value    unless the receiver is empty, in which case answer the receiver."	^ self isEmpty		ifTrue: [ self ]		ifFalse: [ aBlock cull: self ]</body><body package="SpyLite-Extensions">includesAll: aCollection 	"Answer true if the receiver includes all elements of aCollection with at	least as many occurrences as in aCollection. For a less strict comparison	please refer to supersetOf: and its inverse subsetOf:."	^(aCollection isCollection) and: [		aCollection size &lt;= self size and: [			aCollection allSatisfy: [ :each | 				(aCollection occurrencesOf: each) &lt;= (self occurrencesOf: each) ]]]</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="SpyLite-Extensions">intersection: aCollection	"Answer the set theoretic intersection of two collections."	"(#(1 2 3 4) intersection: #(3 4 5)) &gt;&gt;&gt; #(3 4)"	"(#(1 2 3 4) intersection: #()) &gt;&gt;&gt; #()"	"(#() intersection: #(1 2 3 4)) &gt;&gt;&gt; #()"	^ self species withAll: (self asSet intersection: aCollection) asArray</body></methods><methods><class-id>Core.Collection</class-id> <category>testing</category><body package="SpyLite-Extensions">isCollection	"Answer true if the receiver is a collection, excluding character arrays, ie strings,	which are treated as non-collections. This choice has proven to be most practical."	^true</body></methods><methods><class-id>Core.Collection</class-id> <category>removing</category><body package="SpyLite-Extensions">removeAllFoundIn: aCollection 	"Remove each element of aCollection which is present in the receiver 	from the receiver. Answer aCollection. No error is raised if an element	isn't found. ArrayedCollections cannot respond to this message."	aCollection do: [:each | self remove: each ifAbsent: []].	^ aCollection</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="SpyLite-Extensions">select: selectBlock thenCollect: collectBlock	"Utility method to improve readability."	^ (self select: selectBlock) collect: collectBlock</body><body package="SpyLite-Extensions">select: selectBlock thenDo: doBlock    "Utility method to improve readability.	Do not create the intermediate collection."    self do: [: each |        ( selectBlock value: each ) 			ifTrue: [ doBlock value: each ]    ].</body></methods><methods><class-id>Spy1.SLProfilerCoverage class</class-id> <category>public - profiling</category><body package="SpyLite-Extensions">profile: aBlock inPackages: packageInfo	^ self new profile: aBlock inPackages: packageInfo</body></methods><methods><class-id>Spy1.SLProfilerCoverage</class-id> <category>as yet unclassified</category><body package="SpyLite-Extensions">calculateExecutedMethodsByClass	^ (self allClassesAsDictionary keys		collect:			[ :aClassName | aClassName -&gt; (self calculateExecutedMethodsOf: aClassName) ])		asDictionary</body><body package="SpyLite-Extensions">calculateExecutedStatementsByClass	^ (self allClassesAsDictionary keys        collect:            [ :aClassName | aClassName -&gt; (self calculateExecutedStatementsOf: aClassName) ]        thenSelect: [ :assoc | assoc value &gt; 0 ]) asDictionary</body></methods><methods><class-id>Spy1.SLProfilerCoverage</class-id> <category>public-profiling</category><body package="SpyLite-Extensions">profile: aBlock inPackages: packageInfo	Transcript show: 'profiling...'; cr.	[		self beforeProfiling.		self gatherForPackages: packageInfo.		self install.		self beforeProfiling.		aBlock value.				self afterProfiling  	]	ensure: [ self uninstall ].	Transcript show: 'ended...'; cr.	self setIfNecessaryTimeProfiler: aBlock.	self setIfNecessaryTimeAndCallGraphFrom: aBlock.	self setIfNecessaryStateChanges.	self checkInvariant.	^ self</body></methods><methods><class-id>Spy1.SLInstrumentor</class-id> <category>visitor-double dispatching</category><body package="SpyLite-Extensions">acceptBlockNode: aBlockNode    self instrumentBlock: aBlockNode.    super acceptBlockNode: aBlockNode</body><body package="SpyLite-Extensions">acceptMethodNode: aMethodNode    self instrumentBlock: aMethodNode.    super acceptMethodNode: aMethodNode</body></methods><methods><class-id>Spy1.SLInstrumentor</class-id> <category>visiting</category><body package="SpyLite-Extensions">buildGhostNode: anInteger	^ Refactory.Browser.RBParser		parseExpression: '#metaObject count: ' , anInteger asString , '.nil.'</body><body package="SpyLite-Extensions">buildSBBlock: aBlockNode	^ SLBlock new		id: self nextId;		numberOfStatements: aBlockNode body statements size;		start: aBlockNode body start;		stop: aBlockNode body stop;		yourself</body></methods><methods><class-id>Core.Character</class-id> <category>converting</category><body package="SpyLite-Extensions">asString		^ String with: self</body></methods><methods><class-id>Core.ClassDescription</class-id> <category>creating class hierarchy</category><body package="SpyLite-Extensions">numberOfLinesOfCode 	"Return the amount of lines of code"		^ 5 + ((self methodDictionary)  inject: 0 into: [:sum :el | sum + el linesOfCode ])</body></methods><methods><class-id>Core.SequenceableCollection class</class-id> <category>accessing</category><body package="SpyLite-Extensions">new: newSize streamContents: blockWithArg	| stream |	stream := WriteStream on: (self streamSpecies new: newSize).	blockWithArg value: stream.	^ stream contents</body><body package="SpyLite-Extensions">streamContents: blockWithArg	^ self new: 100 streamContents: blockWithArg</body><body package="SpyLite-Extensions">streamSpecies	"I return the class that is used for streaming. If override consider overriding #new:streamContents:"	^ self</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>copying</category><body package="SpyLite-Extensions">collect: aBlock thenSelect: aSelectBlock    ^ (self collect: aBlock) select: aSelectBlock.</body><body package="SpyLite-Extensions">flatCollect: aBlock	"Evaluate aBlock for each of the receiver's elements and answer the	list of all resulting values flatten one level. Assumes that aBlock returns some kind	of collection for each element. optimized version for Sequencable Collection and subclasses	implementing #writeStream"	"(#( (2 -3) (4 -5) #(-6)) flatCollect: [ :e | e abs  ]) &gt;&gt;&gt; #(2 3 4 5 6)"	"(#( (2 -3) #((4 -5)) #(-6)) flatCollect: [ :e | e abs  ]) &gt;&gt;&gt; #(2 3 #(4 5) 6)"	| stream |	self isEmpty		ifTrue: [ ^ self copy ].	stream := (self species new: 0) writeStream.	self do: [ :each | stream nextPutAll: (aBlock value: each) ].	^ stream contents</body></methods><methods><class-id>Spy1.SLProfilerCoverageTest</class-id> <category>as yet unclassified</category><body package="SpyLite-Extensions">assertMethodCoverageOf: profiler on: symbol equals: number	| dictMethodCoverage |	dictMethodCoverage := profiler methodCoverage1.	self assert: (dictMethodCoverage at: symbol) equals: number</body></methods><methods><class-id>Core.Dictionary class</class-id> <category>Signal constants</category><body package="SpyLite-Extensions">newFrom: aDict 	"Answer an instance of me containing the same associations as aDict.	 Error if any key appears twice."	| newDictionary |	newDictionary := self new: aDict size.	aDict associationsDo:		[:x |		(newDictionary includesKey: x key)			ifTrue: [self error: 'Duplicate key: ', x key printString]			ifFalse: [newDictionary add: x]].	^ newDictionary"	NewDictionary newFrom: {1-&gt;#a. 2-&gt;#b. 3-&gt;#c}	{1-&gt;#a. 2-&gt;#b. 3-&gt;#c} as: NewDictionary	NewDictionary newFrom: {1-&gt;#a. 2-&gt;#b. 1-&gt;#c}	{1-&gt;#a. 2-&gt;#b. 1-&gt;#c} as: NewDictionary"</body></methods><methods><class-id>Core.Number</class-id> <category>truncation and round off</category><body package="SpyLite-Extensions">round: aNumber 	"Answer the integer multiple of the argument, aNumber,	that is nearest the receiver."	^ (self roundTo: (10 ** (aNumber * -1))) asFloat</body></methods><methods><class-id>Core.Set</class-id> <category>enumerating</category><body package="SpyLite-Extensions">intersection: aCollection	"Answer the set theoretic intersection of two collections.	Optimized version for Sets where no intermediate Set is necessary"	"(#(1 2 3 4) asSet intersection: #(3 4 5) asSet) &gt;&gt;&gt; #(3 4) asSet"	"(#(1 2 3 4) asSet intersection: #() asSet) &gt;&gt;&gt; Set new"	"( #() asSet intersection: #(1 2 3 4) asSet) &gt;&gt;&gt; Set new"	| outputSet |	outputSet := self class new.	aCollection do: [ :each | (self includes: each) ifTrue: [ outputSet add: each ] ].	^ outputSet</body></methods><methods><class-id>Core.Behavior</class-id> <category>creating class hierarchy</category><body package="SpyLite-Extensions">classSpy 	| spys |	spys := self spys.	spys isEmpty ifTrue: [ self error: 'no spy installed'. ^ self].	^ self spys first classSpy</body><body package="SpyLite-Extensions">hasSpy	^ self methodDictionary values anySatisfy: [ :spy | spy isTemplateMethod ]</body><body package="SpyLite-Extensions">linesOfCode 	"An approximate measure of lines of code.	Includes comments, but excludes blank lines."	| lines |	lines := self getMethodDictionary inject: 0 into: [:sum :each | sum + each linesOfCode]. 	^ self isMeta 		ifTrue: [lines]		ifFalse: [lines + self class linesOfCode]</body><body package="SpyLite-Extensions">numberOfLinesOfCode 	"Return the amount of lines of code"		^ 5 + ((self methodDictionary values, self class methodDictionary values) inject: 0 into: [:sum :el | sum + el numberOfLinesOfCode ])</body><body package="SpyLite-Extensions">profiler	^ self classSpy profiler</body><body package="SpyLite-Extensions">removeSpys	(self == SpyLite.SLProfiler class) ifTrue: [ ^ self ].	self isMeta ifFalse: [ self class removeSpys ].	self methodDictionary keysAndValuesDo: [:key :value|		 key isSpy ifTrue:[				self methodDictionary at: key put: value originalMethod.			].		].</body><body package="SpyLite-Extensions">spys	^ (self methodDictionary values select: [ :spy | spy isTemplateMethod ]) collect: #methodSpy</body></methods><methods><class-id>SUnit.TestCase</class-id> <category>private</category><body package="SpyLite-Extensions">assertCollection: actual hasSameElements: expected	"Assert that a collection contains the same elements as the given collection. Order is not checked, only the presence/absence of elements."	| missingElements additionalElements |	additionalElements := actual difference: expected.	missingElements := expected difference: (actual intersection: expected).	self		assert: (additionalElements isEmpty and: [ missingElements isEmpty ])		description:			(String				streamContents: [ :stream | 					stream						nextPutAll: 'Given Collections do not match!';						lf;						tab;						nextPutAll: 'additions : ';						print: additionalElements asArray;						lf;						tab;						nextPutAll: 'missing: ';						print: missingElements asArray;						lf ])</body><body package="SpyLite-Extensions">assertCollection: actualCollection includesAll: subcollection    "Raises an AssertionFailure if actualCollection does not include all the elements of expectedCollection (using #includesAll: message).     I also provide a specialized message for the AssertionFailure in case I fail.    "    ^ self        assert: (actualCollection includesAll: subcollection)        description: [ actualCollection asString , ' does not include all in '                , subcollection asString ]</body><body package="SpyLite-Extensions">deny: anObject equals: anotherObject	(anObject = anotherObject) ifTrue: [self signalFailure: anObject printString, ' is not equal to ', anotherObject printString.]</body></methods><methods><class-id>Spy1.SLMethodCoverage</class-id> <category>as yet unclassified</category><body package="SpyLite-Extensions">installGhosts	"	***This is decompiled code.*** 	No source was available"	| methodNode |	self originalMethod getSource size &gt; 20000		ifTrue: [self uninstall]		ifFalse: [			[				self uninstall.				methodNode := Refactory.Browser.RBParser parseMethod: self originalMethod getSource.				blocks := SLInstrumentor new visitNode: methodNode; blocks.				probedMethod := ProbedCompiledMethod from: (self originalMethod) full: false.				blocks do: [:block | 					| probe |					probe := SLCodeProbe new.					probe record: (probedMethod probeRecordFor: (block start to: block start) ).					probe block: block.					probedMethod addProbe: probe.					].				self theClass methodDictionary at: self selector put: probedMethod 			] on: Error do: [:e | self halt. self uninstall]		].	^self</body></methods><methods><class-id>Spy1.SLMethodCoverage</class-id> <category>installing</category><body package="SpyLite-Extensions">uninstall 	probedMethod ifNotNil: [		probedMethod revert.		]</body></methods><methods><class-id>Core.WriteStream</class-id> <category>accessing</category><body package="SpyLite-Extensions">lf	"Append a line feed character to the receiver."	self nextPut: Character lf</body></methods><methods><class-id>Core.CharacterArray</class-id> <category>converting</category><body package="SpyLite-Extensions">lineIndicesDo: aBlock	"execute aBlock with 3 arguments for each line:	- start index of line	- end index of line without line delimiter	- end index of line including line delimiter(s) CR, LF or CRLF"		| cr lf start sz nextLF nextCR |	start := 1.	sz := self size.	cr := Character cr.	(nextCR := self nextIndexOf: cr from: 1 to: self size) ifNil:[nextCR:= 0].	lf := Character lf.	(nextLF := self nextIndexOf: lf from: 1 to: self size) ifNil:[nextLF := 0].	[ start &lt;= sz ] whileTrue: [		(nextLF = 0 and: [ nextCR = 0 ])			ifTrue: [ "No more CR, nor LF, the string is over"					aBlock value: start value: sz value: sz.					^self ].		(nextCR = 0 or: [ 0 &lt; nextLF and: [ nextLF &lt; nextCR ] ])			ifTrue: [ "Found a LF"					aBlock value: start value: nextLF - 1 value: nextLF.					start := 1 + nextLF.					(nextLF := self nextIndexOf: lf from: start to: self size) ifNil:[nextLF := 0]. ]			ifFalse: [ 1 + nextCR = nextLF				ifTrue: [ "Found a CR-LF pair"					aBlock value: start value: nextCR - 1 value: nextLF.					start := 1 + nextLF.					(nextCR := self nextIndexOf: cr from: start to: self size) ifNil:[nextCR := 0].					(nextLF := self nextIndexOf: lf from: start to: self size) ifNil:[nextLF := 0].]				ifFalse: [ "Found a CR"					aBlock value: start value: nextCR - 1 value: nextCR.					start := 1 + nextCR.					(nextCR := self nextIndexOf: cr from: start to: self size) ifNil:[nextCR := 0].]]]</body></methods><methods><class-id>Spy1.SSTypeCollectorMethod</class-id> <category>hooks</category><body package="SpyLite-Extensions">selectLiteralsOf: string	| node visitor |	node := Refactory.Browser.RBParser parseMethod: string.	visitor := SLCollectorLiteral new.	node acceptVisitor: visitor.	literals := visitor literals</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>RefactoringBrowser</category><body package="SpyLite-Extensions">hasMethodSpyAsLiteral	"True if one of my literals has a method spy"	^ self literals anySatisfy: [ :l | (l isKindOf: SpyLite.SLMethod) ]</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>accessing</category><body package="SpyLite-Extensions">isExtension	^ ((Refactory.Browser.RefactoryChange new packageForClassDefinition: self mclass) name = (Refactory.Browser.RefactoryChange new packageForClass: self mclass selector: self selector) name) not.</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>RefactoringBrowser</category><body package="SpyLite-Extensions">isTemplateMethod	^ SpyLite.SLProfiler templateMethods anySatisfy: [ :cm | (self size = cm size) 													and: [ (self initialPC to: self endPC) allSatisfy: [ :i | 															(self at: i) = (cm at: i) ] ] ]</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>accessing</category><body package="SpyLite-Extensions">linesOfCode	"An approximate measure of lines of code.	Includes comments, but excludes empty lines."	| lines |	lines := 0.	"It may happens that there is no source"	self getSource ifNil: [ ^ 0 ].	self getSource asString lineIndicesDo: [:start :endWithoutDelimiters :end |		endWithoutDelimiters &gt; start ifTrue: [lines := lines+1]].	^lines</body></methods><methods><class-id>Spy1.SLCollectorLiteral</class-id> <category>visiting</category><body package="SpyLite-Extensions">acceptLiteralNode: aLiteralNode	| literalValue aValue |	literalValue := aLiteralNode value.	aValue := literals		at: literalValue class name		ifAbsentPut: [ Set new ].	aValue add: literalValue</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>SLMethodCoverage</name><environment>Spy1</environment><super>Spy1.SLMethod</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blocks probedMethod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite-Coverage</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>SLCollectorLiteral</name><environment>Spy1</environment><super>Refactory.Browser.RBProgramNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>literals </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite-Coverage</package></attributes></class><class><name>SLProfilerCoverage</name><environment>Spy1</environment><super>Spy1.SLProfiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite-Coverage</package></attributes></class><class><name>SLInstrumentor</name><environment>Spy1</environment><super>Refactory.Browser.RBProgramNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blocks currentId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite-Coverage</package></attributes></class><class><name>SSTypeCollectorMethod</name><environment>Spy1</environment><super>Spy1.SLMethod</super><private>false</private><indexed-type>none</indexed-type><inst-vars>returnType argTypes receiverType executed literals </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-TypeCollector</category><attributes><package>SpyLite-TypeCollector</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>SLProfilerCoverageTest</name><environment>Spy1</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Tests</category><attributes><package>SpyLite-Tests</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>CharacterArray</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>WriteStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>ClassDescription</name><environment>Core</environment><super>Core.Behavior</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instanceVariables organization </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>CodeProbe</name><environment>CraftedSmalltalk</environment><super>CraftedSmalltalk.AbstractCodeProbe</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testMethod testSource variables labelString permanent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>CraftedSt-Probes</category><attributes><package>Debugger-Probes</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class></st-source>