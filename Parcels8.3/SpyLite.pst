<?xml version="1.0"?><st-source><!-- Name: SpyLite1BundleName: SpyLiteBundleStructure: a Store.BundleForParcelDevelopmentPrerequisites: #(#(#any 'Method Wrapper Base' '') #(#any 'SUnitToo(ls)' ''))Parcel: nilParcelName: SpyLite1PrerequisiteDescriptions: #(#(#name 'Method Wrapper Base' #componentType #package) #(#name 'SUnitToo(ls)' #componentType #package))PrerequisiteParcels: #(#('Method Wrapper Base' '') #('SUnitToo(ls)' ''))Date: 4:35:26 PM December 26, 2019 --><time-stamp>From VisualWorksÂ®, 8.3 of July 28, 2017 on December 26, 2019 at 4:35:26 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Spy1</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>Spy1</category><attributes><package>SpyLite</package></attributes></name-space><class><name>SpyLite</name><environment>Spy1</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>currentTestCase currentTestMethod </class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>SpyLite-Core</package></attributes></class><comment><class-id>Spy1.SpyLite</class-id><body>We need a super class to make it compatible</body></comment><class><name>SLProfiler</name><environment>Spy1</environment><super>Spy1.SpyLite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packages allClassesAsDictionaryCache </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>SpyLite-Core</package></attributes></class><comment><class-id>Spy1.SLProfiler</class-id><body>The main class of the framework. Subclassing it to create a new code execution profilerInstance Variables	allClassesAsDictionaryCache	&lt;Cache | DatabaseRow | Dictionary | ImageCache | KeyedCollection | LDMPerspective | LDMRelationship | PDPWeakDictionary | ProcessEnvironment | PublishSpecification | StoreClassEnvironment | StoreForGlorpBrowserEnvironment | StoreMethodDefinitionEnvironment | StoreProtocolEnvironment | StorePundleEnvironment | StoreSelectorEnvironment | TimedProxyReaper&gt;	description of allClassesAsDictionaryCache	allMethodsCache	&lt;IdentityObjectSetTest | Object | ProtoObject | WeakProxy&gt;	description of allMethodsCache	iterations	&lt;Integer&gt;	description of iterations	maxTimeToRun	&lt;Float | SmallInteger&gt;	description of maxTimeToRun	packages	&lt;OrderedCollection&gt;	description of packages	packagesToTest	&lt;IdentityObjectSetTest | Object | ProtoObject | WeakProxy&gt;	description of packagesToTest	totalExecutionTime	&lt;SmallInteger&gt;	description of totalExecutionTime	unitTestResult	&lt;Object&gt;	description of unitTestResult</body></comment><class><name>SpyWrapper</name><environment>Spy1</environment><super>Refactory.Wrappers.MethodWrapper</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>count methodSpy previousMethod v originalMethod receiver listOfArguments </inst-vars><class-inst-vars>currentTestCase currentTestMethod </class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>SpyLite-Core</package></attributes></class><comment><class-id>Spy1.SpyWrapper</class-id><body>a method wrapper to intercept method call</body></comment><class><name>SLClass</name><environment>Spy1</environment><super>Spy1.SpyLite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methods className allSubclassesCache packageSpy metaclassSpy originalClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>SpyLite-Core</package></attributes></class><comment><class-id>Spy1.SLClass</class-id><body>ClassSpy has not been commented.  The comment should state the purpose of the class and also explain any unobvious aspects of the implementation.Instance Variables	allSubclassesCache	&lt;&gt; the list of subclasses	className	&lt;SequenceableCollection&gt; name of the class 	metaclassSpy	&lt;ClassSpy&gt;	 the spy of the metaclass	methods	&lt;Dictionary&gt;	 methods defined in ClassSpy	originalClass	&lt;Behavior&gt;	the class for which I am a metaobject of	packageSpy	&lt;ClassSpy | PackageSpy&gt;	description of packageSpy</body></comment><class><name>SLPackage</name><environment>Spy1</environment><super>Spy1.SpyLite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>packageName classes profiler </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>SpyLite-Core</package></attributes></class><comment><class-id>Spy1.SLPackage</class-id><body>SLPackage contains SLClass instances</body></comment><class><name>SLMethod</name><environment>Spy1</environment><super>Spy1.SpyLite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>instrumentedMethod originalMethod selector classSpy spywrapper </inst-vars><class-inst-vars>inMeta </class-inst-vars><imports></imports><category>Spy-Core</category><attributes><package>SpyLite-Core</package></attributes></class><comment><class-id>Spy1.SLMethod</class-id><body>it is a proxy and collects run-time data</body></comment><class><name>SLMethodCoverage</name><environment>Spy1</environment><super>Spy1.SLMethod</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blocks probedMethod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite-Coverage</package></attributes></class><class><name>SLCollectorLiteral</name><environment>Spy1</environment><super>Refactory.Browser.RBProgramNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>literals </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite-Coverage</package></attributes></class><comment><class-id>Spy1.SLCollectorLiteral</class-id><body>Visit any RBProgramNode in the sintax tree and evaluate literal values    Instance Variables	literals:		&amp;lt;Dictionary&amp;gt;</body></comment><class><name>SLProfilerCoverage</name><environment>Spy1</environment><super>Spy1.SLProfiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite-Coverage</package></attributes></class><class><name>SLClassCoverage</name><environment>Spy1</environment><super>Spy1.SLClass</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite-Coverage</package></attributes></class><class><name>SLPackageCoverage</name><environment>Spy1</environment><super>Spy1.SLPackage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite-Coverage</package></attributes></class><class><name>SLBlock</name><environment>Spy1</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id executed numberOfStatements start stop </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite-Coverage</package></attributes></class><class><name>SLInstrumentor</name><environment>Spy1</environment><super>Refactory.Browser.RBProgramNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>blocks currentId </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Coverage</category><attributes><package>SpyLite-Coverage</package></attributes></class><class><name>SSTypeCollectorClass</name><environment>Spy1</environment><super>Spy1.SLClass</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-TypeCollector</category><attributes><package>SpyLite-TypeCollector</package></attributes></class><comment><class-id>Spy1.SSTypeCollectorClass</class-id><body>SSTypeCollectorClass is a subclass of profiler Class that collects class types.</body></comment><class><name>SSTypeCollectorMethod</name><environment>Spy1</environment><super>Spy1.SLMethod</super><private>false</private><indexed-type>none</indexed-type><inst-vars>returnType argTypes receiverType executed literals </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-TypeCollector</category><attributes><package>SpyLite-TypeCollector</package></attributes></class><comment><class-id>Spy1.SSTypeCollectorMethod</class-id><body>SSTypeCollectorMethod is a subclass of profiler method that collects method types.Instance Variables	argTypes:			&amp;lt;Collection&amp;gt;	executed:			&amp;lt;False&amp;gt;	receiverType:	&amp;lt;SMultiTypeInfo&amp;gt;	returnType:		&amp;lt;SMultiTypeInfo&amp;gt;</body></comment><class><name>SSTypeCollectorPackage</name><environment>Spy1</environment><super>Spy1.SLPackage</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-TypeCollector</category><attributes><package>SpyLite-TypeCollector</package></attributes></class><comment><class-id>Spy1.SSTypeCollectorPackage</class-id><body>SSTypeCollectorPackage is a subclass of Package that collects packages types</body></comment><class><name>SSTypeCollector</name><environment>Spy1</environment><super>Spy1.SLProfiler</super><private>false</private><indexed-type>none</indexed-type><inst-vars>scalars </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-TypeCollector</category><attributes><package>SpyLite-TypeCollector</package></attributes></class><comment><class-id>Spy1.SSTypeCollector</class-id><body>SSTypeCollector is a subclass of Profiler that collects project typesInstance Variables	scalars:		&amp;lt;Dictionary&amp;gt;</body></comment><class><name>SSTypeCollectorMethodTest</name><environment>Spy1</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeCollectorMethod </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Tests</category><attributes><package>SpyLite-Tests</package></attributes></class><comment><class-id>Spy1.SSTypeCollectorMethodTest</class-id><body>This class contains tests</body></comment><class><name>SLProfilerCoverageTest</name><environment>Spy1</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Tests</category><attributes><package>SpyLite-Tests</package></attributes></class><comment><class-id>Spy1.SLProfilerCoverageTest</class-id><body>This class contains tests</body></comment><class><name>SLCounter</name><environment>Spy1</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpyLite-Scenario</category><attributes><package>SpyLite-Scenario</package></attributes></class><shared-variable><name>CurrentMethod</name><environment>Spy1.SpyWrapper</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>SpyLite-Core</package></attributes></shared-variable><shared-variable><name>Registry</name><environment>Spy1.SLProfiler</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>SpyLite-Core</package></attributes></shared-variable><methods><class-id>Spy1.SpyLite</class-id> <category>visualization</category><body package="SpyLite-Core">nameAsString	^'Spy'</body></methods><methods><class-id>Spy1.SpyLite</class-id> <category>assertion</category><body package="SpyLite-Core">assert: aBlock	aBlock value ifFalse: [ self error: 'Assertion failed' ]</body></methods><methods><class-id>Spy1.SpyLite</class-id> <category>initialize-release</category><body package="SpyLite-Core">initialize</body></methods><methods><class-id>Spy1.SpyLite class</class-id> <category>instance creation</category><body package="SpyLite-Core">new	^ super new initialize</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>accessing</category><body package="SpyLite-Core">packages	^ packages ifNil: [ packages := OrderedCollection new ]</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>hooks</category><body package="SpyLite-Core">afterProfiling</body><body package="SpyLite-Core">beforeProfiling 	SLMethod setInNonMeta</body><body package="SpyLite-Core">getTimeAndCallGraph	^ false</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>actions</category><body package="SpyLite-Core">remove	^ self class remove</body><body package="SpyLite-Core">removeFromRegistry	self class registry removeKey: (self class registry keyAtValue: self )</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>testing</category><body package="SpyLite-Core">allNonAbstractMethods	"Return the list of non abstract methods"		Smalltalk.allNonAbstractMethodsCache ifNotNil: [ ^ Smalltalk.allNonAbstractMethodsCache ].	^ Smalltalk.allNonAbstractMethodsCache := self allMethods select: [:element | element isAbstract == false].</body><body package="SpyLite-Core">hasUnitTestResult	^ Smalltalk.unitTestResult notNil</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>gathering</category><body package="SpyLite-Core">fillClassType: classType with: methodDictionary	"This method is that the core of the instrumentation of Spy. 	It wraps all the methods with a wrappers "	"Enhanced by Philippe Van Langenhove"	| cm metaObject spyWrapper |	classType theClass == SLProfiler class		ifTrue: [ ^ self ].	methodDictionary keys do:		[:k|			cm := methodDictionary at: k.				spyWrapper := SpyWrapper on: k inClass: classType originalClass.				spyWrapper ifNotNil: [					metaObject := self class spyClassForMethod new initialize											originalMethod: cm; 											selector: k; 											instrumentedMethod: spyWrapper;											classSpy: classType;											yourself.						spyWrapper	methodSpy: metaObject.					metaObject spyWrapper: spyWrapper.										classType localMethodAt: k put: metaObject ].		].</body><body package="SpyLite-Core">gather	^ self gatherForClasses: self class nonDangerousClasses.</body><body package="SpyLite-Core">gatherForClassCategories: categoriesNames inNamespace: aNamespace	"Return a profiler"	categoriesNames do:[:nameAsString |		| package |		package := self packageForClassesInCategory: nameAsString inNamespace: aNamespace.		package packageName: nameAsString.		self addPackage: package.	].	^ self</body><body package="SpyLite-Core">gatherForClassCategory: nameAsString	"Return a profiler"	| package cls classNames classType answer |	package := self packageForClassCategory: nameAsString.	package packageName: nameAsString.	self addPackage: package.	^ self</body><body package="SpyLite-Core">gatherForClasses: classes	| package classType profiler |	package := self class spyClassForPackage new.	package packageName: 'Global profiling'.	classes do: [:cls |		classType := self spyForClass: cls.		classType packageSpy: package.		package classAt: cls name put: classType].		self addPackage: package.	^ package</body><body package="SpyLite-Core">gatherForPackageNamed: nameAsString	"Return a profiler"		| classes classType package |	package := self class spyClassForPackage new.	package packageName: nameAsString.	self addPackage: package.	"	classes := ((PackageInfo named: nameAsString)							classes reject: #isTrait)."	classes := Store.Registry packageNamed: nameAsString allDefinedClasses.		classes do: [:cls |		classType := self spyForClass: cls.		classType packageSpy: package.		package profiler: self.		package classAt: cls name put: classType].				^ self</body><body package="SpyLite-Core">gatherForPackages: packageNames	"Return a profiler"	packageNames do: [ :pak | 		| class package |		package := self class spyClassForPackage new.		package packageName: pak name.		self addPackage: package.		(pak allDefinedClasses) do: [:cls|			class := self spyForClass: cls.			class packageSpy: package.			package classAt: cls name asSymbol put: class ] ].	^ self</body><body package="SpyLite-Core">gatherForPackagesMatching: regexpAsString	"Return a profiler"		| packageInfos |	packageInfos := Store.Registry allPackages select:[:p | regexpAsString match: (p name asString)].	^ self gatherForPackages: packageInfos</body><body package="SpyLite-Core">packageForClassCategories: categoriesNames	| package classNames classType |	package := self class spyClassForPackage new.	classNames := OrderedCollection new.	categoriesNames do: [:nameAsString |		classNames addAll: ( Smalltalk organization listAtCategoryNamed: nameAsString asSymbol).	].		classNames do: [:clsName |		| cls |		cls := Smalltalk at: clsName.			classType := self spyForClass: cls.			classType packageSpy: package.			package classAt: clsName put: classType].		^ package</body><body package="SpyLite-Core">packageForClassCategory: nameAsString	| package classNames classType |	package := self class spyClassForPackage new.	classNames := Smalltalk organization listAtCategoryNamed: nameAsString asSymbol.		classNames do: [:clsName |		| cls |		cls := Smalltalk at: clsName.		cls class = NameSpace ifFalse:[			classType := self spyForClass: cls.			classType packageSpy: package.			package classAt: clsName put: classType]].		^ package</body><body package="SpyLite-Core">packageForClassesInCategory: categoryName inNamespace: namespace	| package classNames classType |	package := self class spyClassForPackage new.	classNames := self classesInCategory: categoryName inNamespace: namespace.		classNames do: [:aclass |		| cls |		cls := namespace at: aclass name.			classType := self spyForClass: cls.			classType packageSpy: package.			package classAt: aclass name put: classType].		^ package</body><body package="SpyLite-Core">spyForClass: aClass	"Return a spy class for a given real Smalltalk class.	The spy class is filled with method spy"	| classType |	classType := self class spyClassForClass new initialize.	classType className: aClass name.	classType originalClass: aClass.	classType metaclassSpy initialize.	self fillClassType: classType with: aClass methodDictionary.	self fillClassType: classType metaclassSpy with: aClass class methodDictionary.	^ classType</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>installing</category><body package="SpyLite-Core">install	self allMethods asSet do:[:m | m install]</body><body package="SpyLite-Core">uninstall	self allMethods do: #uninstall</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>adding</category><body package="SpyLite-Core">addPackage: aPackageSpy	self assert: [ aPackageSpy class == self class spyClassForPackage ].		self packages add: aPackageSpy.	aPackageSpy profiler: self.</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>accessing - read only</category><body package="SpyLite-Core">&gt;&gt; aSymbol	"Fetching a class"		"we are accessing a method defined in a metaclass"	(aSymbol includes: $ ) ifTrue: [ ^ (self &gt;&gt; aSymbol asString sunitSubStrings first asSymbol) metaclassSpy ].		^ self classAt: aSymbol</body><body package="SpyLite-Core">allClasses	"Return the list of all the classes, excluding metaclasses"	| answer |	answer := OrderedCollection new.	self packages do: [:p | answer addAll: p classes ].	^ answer</body><body package="SpyLite-Core">allClassesAsDictionary	"Return the list of classes as a dictionary"	| answer |	allClassesAsDictionaryCache ifNotNil: [ ^ allClassesAsDictionaryCache ].	answer := Dictionary new.	self packages do: [:p | p classes do: [:c | answer at: c className put: c]].	^ allClassesAsDictionaryCache := answer</body><body package="SpyLite-Core">allClassesSuchThat: aBlock	"Select a particular group of classes"	^ self allClasses select: aBlock</body><body package="SpyLite-Core">allMethods	"Return the list of methods"	| answer |	answer := OrderedCollection new.	self packages do: [:p | 		answer addAll: p allMethods ].	^ answer</body><body package="SpyLite-Core">allNonMetaClasses	"Return the list of non metaclasses"	^ self allClasses reject: #isMeta</body><body package="SpyLite-Core">classAt: aSymbol	"Return a class that corresponds to the given name"	^ self allClassesAsDictionary at: aSymbol ifAbsent: [ self error: 'Class ', aSymbol, ' not found']</body><body package="SpyLite-Core">classAt: aSymbol ifNone: aBlock	"Return a class or evaluate a block if the class does not exist"	^ self allClassesAsDictionary at: aSymbol ifAbsent: aBlock</body><body package="SpyLite-Core">getPackageNamed: aPackageName	"Return a particular package"	^ self packages detect: [:pak | pak packageName asString = aPackageName asString ]</body><body package="SpyLite-Core">includesClassNamed: aClassName	"True if a particular class has been profiled"	self classAt: aClassName asSymbol ifNone: [ ^ false ].	^ true</body><body package="SpyLite-Core">numberOfClasses	"Return the number of classes in total"	^ self allClasses size</body><body package="SpyLite-Core">numberOfMethods	"Return the number of methods in total"	^ self allMethods size</body><body package="SpyLite-Core">numberOfNonAbstractMethods	"Return the number of non abstract methods, including the one of the metaclass "	^ self allNonAbstractMethods size</body><body package="SpyLite-Core">numberOfPackages	"Return the amount of packages in total"	^ self packages size</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>util</category><body package="SpyLite-Core">addEvaluatedMethod: methods fromTally: aTally atLevel: level	"Collects all the methods evaluated in the block from the profile: aBlock call."	level = 2 ifTrue: [methods addAll: aTally receivers] 			ifFalse:[ aTally receivers size &gt; 0 ifTrue:[ self addEvaluatedMethod: methods fromTally: (aTally receivers asOrderedCollection at: 1) atLevel: level + 1]].</body><body package="SpyLite-Core">addExecutedMethod: methods fromTally: aTally	"This method collects all the executedmethods stored in the aTally to then find all the related packages to instument. 	It is restricted to 0.2 to not include very deep methods, like collections or tools"	(aTally receivers size &gt; 0 and:[(aTally tally /aTally root tally ) &gt; 0.2]) ifTrue:[		(aTally receivers) do:[:r |				methods add: r.				self addExecutedMethod: methods fromTally: r		]	].</body><body package="SpyLite-Core">classesInCategory: categoryName	"Return the list of classes that belong to a category. Reject non behavior, such as namespaces"	^ self  class classesInCategory: categoryName</body><body package="SpyLite-Core">classesInCategory: categoryName inNamespace: namespace	"Return the list of classes that belong to a category. Reject non behavior, such as namespaces"	^ self class classesInCategory: categoryName inNamespace: namespace</body><body package="SpyLite-Core">getInstrumentedClasses: reports		"	This method returns all the packages from the executed methods in the block that was profiled.	The reports are extracted from the MessageTally tree produced by the TimeProfiler.	All packages from the Kernel and from the Spy bundle are excluded, as they usually are not the method to inspect.	"	|classesInfos tg baseClasses baseClassesNames testPackageBlock|	testPackageBlock := [:package | package isNil ifTrue:[Array new] ifFalse:[package allClasses]].	baseClasses := (Store.Registry bundleNamed: 'Base VisualWorks') allClasses .	baseClasses addAll: ((Store.Registry bundleNamed: 'Spy') allClasses).	baseClasses addAll: (testPackageBlock value: (Store.Registry packageNamed: 'SUnit')).	baseClasses addAll: (testPackageBlock value:(Store.Registry packageNamed: 'SUnitToo')).	baseClassesNames := baseClasses collect:[:c |c isMeta ifTrue:[c instanceBehavior name] ifFalse:[ c name]].	classesInfos := OrderedCollection new.	reports do:[:p |		tg := p method.		(tg mclass isMeta) ifTrue:[(baseClassesNames includes: tg mclass instanceBehavior name asString) ifFalse:[classesInfos add: tg mclass instanceBehavior ].]						ifFalse:[(baseClassesNames includes: tg mclass name asString) ifFalse:[classesInfos add: tg mclass].]	].	^classesInfos asSet asOrderedCollection</body><body package="SpyLite-Core">getInstrumentedPackages: reports		"	This method returns all the packages from the executed methods in the block that was profiled.	The reports are extracted from the MessageTally tree produced by the TimeProfiler.	All packages from the Kernel and from the Spy bundle are excluded, as they usually are not the method to inspect.	"	|packagesInfos tg baseClasses baseClassesNames |	baseClasses := (Store.Registry bundleNamed: 'Base VisualWorks') allClasses .	baseClasses addAll: ((Store.Registry bundleNamed: 'Spy') allClasses).	baseClasses add: Object.	baseClassesNames := baseClasses collect:[:c |c isMeta ifTrue:[c instanceBehavior name] ifFalse:[ c name]].	packagesInfos := OrderedCollection new.	reports do:[:p |		tg := p method.		(tg mclass isMeta) ifTrue:[(baseClassesNames includes: tg mclass instanceBehavior name asString) ifFalse:[packagesInfos addAll: (Store.Registry packagesContaining: tg mclass instanceBehavior) ].]						ifFalse:[(baseClassesNames includes: tg mclass name asString) ifFalse:[packagesInfos addAll: (Store.Registry packagesContaining: tg mclass) ].]	].	^packagesInfos asSet asOrderedCollection</body><body package="SpyLite-Core">selectProfiledClassesFrom: reports	| profiledClasses classNames  |	classNames := self allClasses collect: [:c | c originalClass ].	profiledClasses := reports select: [:c | (c method mclass class class) isMeta      	ifTrue:[ classNames includes:( c method mclass instanceBehavior)]		ifFalse:[ (classNames includes:( c method mclass))]].	^profiledClasses</body><body package="SpyLite-Core">setInfoFromTimeProfiler: aTimeProfiler    "Set to each method of the profiler its the total execution time"    "public method"    | |		Smalltalk.maxTimeToRun := 0.		Smalltalk.totalExecutionTime = 0 ifTrue:[Smalltalk.totalExecutionTime :=(( aTimeProfiler core totalTime  / 10 / self iterations ) rounded / 100.0 ) ].	Smalltalk.totalExecutionTime = 0 ifTrue:[Smalltalk.totalExecutionTime := 1].	self setTimeInfoFromTimeProfiler: aTimeProfiler.	self setLocalTimeInfoFromTimeProfiler: aTimeProfiler.	Smalltalk.maxTimeToRun = 0 ifTrue:[Smalltalk.maxTimeToRun := 1]</body><body package="SpyLite-Core">setLocalTimeInfoFromTimeProfiler: aTimeProfiler	| tg tg_tmp method localTimeUsages localTimeReports localprofiledClasses |	localTimeUsages := Set new: 200.		aTimeProfiler core rootTally addLocalUsageIntoWithReceivers: localTimeUsages.	localTimeReports := localTimeUsages asSortedCollection.	localprofiledClasses := self selectProfiledClassesFrom: localTimeReports.	localprofiledClasses do: [:p |		tg := p method.		tg_tmp := tg.		[tg_tmp class == CompiledBlock ] whileTrue:[ tg_tmp := tg_tmp outerMethod].		method := (self &gt;&gt; tg mclass name) localMethodAt: tg_tmp selector ifAbsent: [method := nil].		method = nil 			ifFalse:[p root tally  = 0 				ifFalse:[method addLocalExecutionTime: (((0.1 * (1000.0 * p tally  / p root tally)) * Smalltalk.totalExecutionTime/100.0 ) roundTo: 0.01).]]	].</body><body package="SpyLite-Core">setReceiversInfo: aTally for: aMethod	| className selector aTally_tmp called |	className := aTally method mclass name.	aTally_tmp := aTally method.	[aTally_tmp class == CompiledBlock ] whileTrue:[ aTally_tmp := aTally_tmp outerMethod].	selector := aTally_tmp selector.	"it could very well be that the class is not part of the profiled package"           		(self includesClassNamed: className) 		ifTrue: [			called := self &gt;&gt; className &gt;&gt; selector.			"called addIncomingCalls: aMethod.			aMethod addOutgoingCalls: called ."			Smalltalk.messageTallyMethods add: called.		].	Smalltalk.messageTallyMethods add: aMethod.</body><body package="SpyLite-Core">setTimeInfoFromTally: aTally	"Set to each method of the profiler its the total execution time"	"public method"	"	totalExecutionTime := aTally time."	self setTimeInfoFromTally: aTally parents: (Array with: aTally).</body><body package="SpyLite-Core">setTimeInfoFromTally: aTally parents: tallies	"private method"	| sons mClass method newTallies parentTally callerMethod callerClass |	mClass := self classAt: aTally method methodClass name ifNone: [nil].	mClass ifNotNil: [		method := mClass localMethodAt: aTally method selector ifAbsent: [nil].		method ifNotNilDo: [:e | 			method useTime: aTally parents: tallies.			parentTally := tallies last.			callerClass := self classAt: parentTally method methodClass name ifNone: [nil].			callerClass ifNotNil: [				callerMethod := callerClass localMethodAt: parentTally method selector ifAbsent: [nil].				callerMethod ifNotNil: [ 					callerMethod addOutgoingCalls: method.					method addIncomingCalls: callerMethod.					self assert: [callerMethod outgoingCalls includes: method] ] 			]]].	sons := aTally receivers.	newTallies := tallies , (Array with: aTally).	sons do: [:e | self setTimeInfoFromTally: e parents: newTallies].</body><body package="SpyLite-Core">setTimeInfoFromTimeProfiler: aTimeProfiler  	| tg tg_tmp method timeUsages reports tallyEvaluatedMethods profiledClasses |	timeUsages := Set new: 200.	aTimeProfiler core rootTally addUsageIntoWithReceivers: timeUsages.	reports := timeUsages asSortedCollection.	"Evaluated methods"	tallyEvaluatedMethods := OrderedCollection new.	self addEvaluatedMethod: tallyEvaluatedMethods fromTally: aTimeProfiler core rootTally atLevel: 0.	profiledClasses := self selectProfiledClassesFrom: reports.	profiledClasses do: [:p |		tg := p method.		(tg class = CompiledBlock) 			ifFalse: [				tg_tmp := tg.				[tg_tmp class == CompiledBlock ] whileTrue:[ tg_tmp := tg_tmp outerMethod ].				method := (self &gt;&gt; tg mclass name) localMethodAt: tg_tmp selector ifAbsent: [ method := nil ].				(method = nil) 					ifFalse: [ 						p receivers do:[ :m | self setReceiversInfo: m for: method ].							(tallyEvaluatedMethods includes: p) ifTrue: [ self evaluatedMethods add: method.].							method useTime: p.					].			]		].</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>public-profiling</category><body package="SpyLite-Core">profile: aBlock 	"	-= public method. This is probably THE method you want to use =-	Profile the aBlock the first time using an execution sampling, we then identify all the packages that deserve to be instrumented for the second phase.	All the packages that belong to the 'Base VisualWorks' bundle are excluded, since it is dangerous to instrument those classes"	| tallyEvaluatedMethods classesInfos | 	Transcript show: 'Phase 1 / 2 : profiling using sampling...'; cr.	self setIfNecessaryTimeProfiler: aBlock.	Transcript show: 'ended!'; cr.	tallyEvaluatedMethods := OrderedCollection new.	self addExecutedMethod: tallyEvaluatedMethods fromTally: Smalltalk.myTimeProfiler core rootTally .	"packagesInfos := self getInstrumentedPackages: (tallyEvaluatedMethods asSet)."	classesInfos := self getInstrumentedClasses: (tallyEvaluatedMethods asSet).	"self setIfNecessaryTimeProfiler: aBlock."	Transcript show: 'Phase 2 / 2 : profiling using instrumentation...'; cr.	[		self beforeProfiling.		"self gatherForPackages: packagesInfos."		self gatherForClasses: classesInfos.		self setIfNecessaryTimeAndCallGraphFrom: aBlock.		self install.		self beforeProfiling.		aBlock value.				self afterProfiling.	]	ensure: [		"self class removeFromPackages: packagesInfos"		self class removeFromClasses: classesInfos ].		self setIfNecessaryStateChanges.	Transcript show: 'finished!'; cr.	self checkInvariant.</body><body package="SpyLite-Core">profile: aBlock inClassCategories: categoriesNames	"Return an instance of myself that contains a profiling structure (Package, Class, Method) filled with the information gathered during the execution.  	 All the classes that belong to the categories given as argument are instrumented before the profile and later on un-instrumented"	"	self 		profile:  [ OSkSubStream example01 ]		inClassCategories: (Array with: 'OSkStreams' )	"	^self profile: aBlock inClassCategories: categoriesNames inNamespace: Smalltalk.</body><body package="SpyLite-Core">profile:  aBlock inClassCategories: categories inNamespace: aNamespace	"Return an instance of myself that contains a profiling structure (Package, Class, Method) filled with the information gathered during the execution.  	 All the classes that belong to the categories given as argument are instrumented before the profile and later on un-instrumented"	"	self 		profile:  [ OSkSubStream example01 ]		inClassCategories: (Array with: 'OSkStreams' )	""	self setIfNecessaryTimeProfiler: aBlock."	Transcript show: 'profiling...'; cr.	[		self beforeProfiling.		self gatherForClassCategories: categories inNamespace: aNamespace.		self install.		aBlock value.		self afterProfiling 	]	ensure: [ self class removeFromClassCategories: categories inNamespace: aNamespace].	Transcript show: 'ended...'; cr.	self setIfNecessaryTimeProfiler: aBlock.	self setIfNecessaryTimeAndCallGraphFrom: aBlock.	self setIfNecessaryStateChanges.	self checkInvariant.	^ self</body><body package="SpyLite-Core">profile: aBlock inClassCategoriesMatching: rexexp	^self profile: aBlock inClassCategoriesMatching: rexexp inNamespace: Smalltalk.</body><body package="SpyLite-Core">profile:  aBlock inClassCategoriesMatching: rexexp inNamespace: aNamespace	| categoriesNames|	categoriesNames := aNamespace organization categories select:[:c | rexexp match: c].	categoriesNames := categoriesNames collect:[:c | c asString].	^self profile: aBlock inClassCategories: categoriesNames inNamespace: aNamespace.</body><body package="SpyLite-Core">profile: aBlock inClassCategory: classCategory		^self profile: aBlock inClassCategories: (Array with: classCategory) inNamespace: Smalltalk.</body><body package="SpyLite-Core">profile: aBlock inPackage: packageName	^self profile: aBlock inPackages: (Array with: (Store.Registry packageNamed: packageName) )</body><body package="SpyLite-Core">profile: aBlock inPackages: packageInfo	Transcript show: 'profiling...'; cr.	[		self beforeProfiling.		self gatherForPackages: packageInfo.		self install.		self beforeProfiling.		aBlock value.				self afterProfiling  	]	ensure: [ self class removeFromPackages: packageInfo ].	Transcript show: 'ended...'; cr.	self setIfNecessaryTimeProfiler: aBlock.	self setIfNecessaryTimeAndCallGraphFrom: aBlock.	self setIfNecessaryStateChanges.	self checkInvariant.	^ self</body><body package="SpyLite-Core">profile: aBlock inPackagesMatching: regexp	|packagesInfos|	packagesInfos := Store.Registry allPackages select:[:p | regexp match: p name asString].	^self profile: aBlock inPackages: packagesInfos</body><body package="SpyLite-Core">profile: aBlock inPackagesNames: packagesNames	|packagesInfos|	packagesInfos := Store.Registry allPackages select:[:p | packagesNames includes: p name asString].	^self profile: aBlock inPackages: packagesInfos</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>contract</category><body package="SpyLite-Core">checkInvariant	self assert: [ self packages notNil ].	self assert: [ self packages allSatisfy: [ :p | p isKindOf: self class spyClassForPackage ] ].	self assert: [ self packages allSatisfy: [ :p | p profiler notNil ]].	self assert: [ self packages allSatisfy: [ :p | p profiler == self ]].	self packages do: [ :p | p checkInvariant ]</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>private-profiling</category><body package="SpyLite-Core">profile: aBlock forClassNamed: className	"Doing a profile on a block only on the instrumentation f a class"	| packageSpy cls classSpy |	cls := Smalltalk at: className.	Transcript show: 'profiling...'; cr.	[		self beforeProfiling.		classSpy := self spyForClass: cls.		packageSpy := self class spyClassForPackage new initialize.		packageSpy classAt: className put: classSpy.		self addPackage: packageSpy.		self install.		aBlock value.		self afterProfiling. 	]	ensure:[ self class removeFromClass: cls ].	Transcript show: 'ended...'; cr.	self setIfNecessaryTimeProfiler: aBlock.	self setIfNecessaryTimeAndCallGraphFrom: aBlock.	^ self</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>time and call graph</category><body package="SpyLite-Core">setIfNecessaryStateChanges	"Mark all the methods doing at least one side effect"	| incomingCalls |	self getTimeAndCallGraph ifTrue: [		self allMethods do:[:m |			(m numberOfInvocations &gt; 0 and: [ m performLocalSideEffect ]) ifTrue:[				incomingCalls := m  withAllIncomingCalls asSet.				incomingCalls do:[ :ic | 					ic performLocalSideEffect: true.				]			]		]		].</body><body package="SpyLite-Core">setIfNecessaryTimeAndCallGraphFrom: aBlock	self getTimeAndCallGraph ifTrue: [ self setInfoFromTimeProfiler: Smalltalk.myTimeProfiler. ]</body><body package="SpyLite-Core">setIfNecessaryTimeProfiler: aBlock	self getTimeAndCallGraph ifTrue: [		| t myBlock AccessProtect |		AccessProtect := Semaphore new.		myBlock := [ self iterations timesRepeat: [ aBlock evaluate ] ].		Smalltalk.TimeProfiler 			profile: myBlock			onExitDo: [ :spy | 					t := spy.					Smalltalk.myTimeProfiler := spy.					AccessProtect signal			].		AccessProtect wait.	]</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>visualization</category><body package="SpyLite-Core">addFindClassMenuOn: aview	aview addMenu: 'Find a Class...'		callBack: 			[:stack |			| allModels element keysList valuesList menuItem parent |			allModels := SortedCollection						sortBlock: [:a1 :a2 | a1 key printString &lt; a1 key printString].			keysList := OrderedCollection new.			valuesList := OrderedCollection new.			self allClasses do: [:c | allModels add: c originalClass -&gt; c].			allModels do: 					[:assoc |					keysList add: assoc key.					valuesList add: assoc value].			menuItem := Refactory.Browser.BrowserApplicationModel new						choose: 'Find a class'						fromList: keysList						values: valuesList						lines: 20						cancel: [nil].			menuItem isNil not				ifTrue: 					[| node |					node := nil.					element := nil.					"Not very pretty.need to fix eventually..."					aview raw elementsDo: 							[:c |							node isNil								ifTrue: 									[node := aview nestedLookup: menuItem in: c.									node isNil										ifFalse: 											[node elementsDo: 													[:n |													element isNil ifTrue: [element := aview nestedLookup: menuItem in: n]]].									parent := c]].					element isNil						ifFalse: 							[ self findElementStack: stack element: element ] ] ]</body><body package="SpyLite-Core">addFindMethodMenuOn: aview	aview addMenu: 'Find a Method...'		callBack: 			[:stack |			| allModels element keysList valuesList menuItem parent |			allModels := SortedCollection sortBlock: [:a1 :a2 | a1 &lt; a1].			keysList := OrderedCollection new.			valuesList := OrderedCollection new.			self allMethods do: [:c | allModels add: c printString -&gt; c].			allModels do: 					[:assoc |					keysList add: assoc key.					valuesList add: assoc value].			menuItem := Refactory.Browser.BrowserApplicationModel new						choose: 'Find a class'						fromList: keysList						values: valuesList						lines: 20						cancel: [nil].			menuItem isNil not				ifTrue: 					[element := nil.					aview raw elementsDo: 							[:c |							element isNil								ifTrue: 									[element := aview nestedLookup: menuItem in: c.									parent := c]].					element isNil						ifFalse: [self findElementStack: stack element: element]]]</body><body package="SpyLite-Core">legendSeparationOn: view		view interaction noPopup; forwarder.	view shape label.		view 		node: '---------------------------------------------------------------------------------------------------' 		"using: (self labelForLegend)"		forIt: [view verticalLineLayout ].</body><body package="SpyLite-Core">populateMenuOn: aview	aview addMenu: 'Zoom in' callBack: [ :stack | Roassal.ROZoomInMove new on: stack firstView ].	aview addMenu: 'Zoom out' callBack: [ :stack | Roassal.ROZoomOutMove new on: stack firstView ].		self addFindClassMenuOn: aview.	self addFindMethodMenuOn: aview.	"We also do a small scrolling to not have the buttons over the nodes"	aview raw translateBy: 0 @ 30.</body><body package="SpyLite-Core">setInteractionForMethodSpyOn: view	"view interaction 		item: 'inspect' action: #inspect;		item: 'browse' action: [:m | m browse]"</body><body package="SpyLite-Core">visualizeWithoutNonExecutedClasses</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>initialize-release</category><body package="SpyLite-Core">initialize 	packages := nil.	</body></methods><methods><class-id>Spy1.SLProfiler</class-id> <category>visualization-util</category><body package="SpyLite-Core">findElementStack: stack element: element	Roassal.ROFocusView new on: element view: stack firstView.</body><body package="SpyLite-Core">nameAsString	^ 'Profiler'</body></methods><methods><class-id>Spy1.SLProfiler class</class-id> <category>private - installing</category><body package="SpyLite-Core">install	" Install on all classes"	self installOnClasses: Smalltalk allClasses</body><body package="SpyLite-Core">installOnBehavior: aBehavior	| dict cm templateMethod metaObject |	aBehavior flushCache.		"We do nothing for traits"	aBehavior isTrait ifTrue: [ ^ self ].	dict := aBehavior methodDictionary.	dict keys do:		[:k|			k flushCache.			cm := dict at: k.			cm isSpy ifFalse: [				"Using template method"				templateMethod := self templateMethodForNumberOfArguments: cm 	numArgs.				templateMethod := templateMethod copyFor: aBehavior.				metaObject := self spyClassForMethod new 										originalMethod: cm; 										selector: k; 										instrumentedMethod: templateMethod;										yourself.				templateMethod replaceLiterals: 					(Array with: templateMethod selector -&gt; k  					 with: #metaObject -&gt; metaObject  					 with: #selector -&gt; k)				dict at: k put: templateMethod.]						"Using method wrapper""			(cm isCompiledMethod and: [ self shouldInstallOnCompiledMethod: cm])			 	ifTrue: [dict at: k put: (self spyClassForMethod new originalMethod: cm; selector: k; yourself)]"		]</body><body package="SpyLite-Core">installOnClass: aClass"Transcript show: 'instrumenting ', aClass name printString ;cr."	||"	(self isDangerous: aClass theNonMetaClass)"	(self isDangerous: aClass)		ifTrue: [ ^ self ].	"self "		"installOnBehavior: aClass theNonMetaClass;"		"installOnBehavior: aClass theMetaClass."		"installOnBehavior: aClass."	"classSpy := self spyClassForClass new initialize.	dict := aClass methodDictionary.	dict keys do:		[:k|			cm := dict at: k.				templateMethod := self templateMethodForNumberOfArguments: cm 	numArgs.				metaObject := self spyClassForMethod new initialize										originalMethod: cm; 										selector: k; 										instrumentedMethod: templateMethod;										classSpy: classSpy;										yourself.				spyWrapper := SpyWrapper on: k inClass: aClass.				spyWrapper	methodSpy: metaObject.				metaObject spyWrapper: spyWrapper.								classSpy localMethodAt: k put: metaObject.		]."	^ (self new spyForClass: aClass).	"^classSpy"</body><body package="SpyLite-Core">installOnClassCategory: nameAsString	| classNames classes |	classNames := Smalltalk organization listAtCategoryNamed: nameAsString asSymbol.	classes := classNames collect: [:clsName | Smalltalk at: clsName].	self installOnClasses: classes</body><body package="SpyLite-Core">installOnClassCategoryMatching: regexpAsString	| categories |	categories := Smalltalk organization categories select:[:c | c match: regexpAsString].	self removeFromClassCategories: categories.	categories do: [:cat | self installOnClassCategory: cat]</body><body package="SpyLite-Core">installOnClasses: classes	classes do: [:cls | self installOnClass: cls ].</body><body package="SpyLite-Core">installOnPackagesMatching: regexpAsString	| classes |	classes := self classesForPackagesMatching: regexpAsString.	classes do: [:cls | self installOnClass: cls ]</body><body package="SpyLite-Core">installOnPackagesNamed: strings	| classes |	self assert: [ strings isString not ] description: 'A collection of String must be passed to #installOnPackagesNamed:'.	self assert: [ (strings allSatisfy: #isString) ] description: 'A collection of String must be passed to #installOnPackagesNamed:'.		strings do: [:packageName |"		classes := Smalltalk organization listAtCategoryNamed:(PackageInfo named: packageName) classes.""		classes := classes reject: #isTrait."		classes := Smalltalk organization listAtCategoryNamed: packageName classes.		classes do: [:cls | self installOnClass: cls theNonMetaClass ] ]</body><body package="SpyLite-Core">remove	" Install on all classes"	self removeFromClasses: Smalltalk allClasses</body><body package="SpyLite-Core">removeFrom: class	class flushVMmethodCache.	class rebindAllMethods.</body><body package="SpyLite-Core">removeFromClass: class	SLProfiler class == class ifTrue: [ ^ self ].	^ self removeFrom: class</body><body package="SpyLite-Core">removeFromClassCategories: categoriesNames	"Uninstall all the wrapper for the classes found in each category name given as argument"	| classes |	categoriesNames do: 			[:nameAsString |			classes := self classesInCategory: nameAsString.			self removeFromClasses: classes , (classes collect: [:cls | cls class ] ) ]</body><body package="SpyLite-Core">removeFromClassCategories: categoriesNames inNamespace: aNamespace	"Uninstall all the wrapper for the classes found in each category name given as argument"	| classes |	categoriesNames do: 			[:nameAsString |			classes := self classesInCategory: nameAsString inNamespace: aNamespace.			self removeFromClasses: classes , (classes collect: [:cls | cls class ] ) ]</body><body package="SpyLite-Core">removeFromClassCategoriesMatching: regexpAsString	|categories|	categories := Smalltalk organization categories select:[:c | c match: regexpAsString].	self removeFromClassCategories: categories.</body><body package="SpyLite-Core">removeFromClassCategoriesMatching: regexpAsString inNamespace: aNamespace	|categories|	categories := aNamespace organization categories select:[:c | regexpAsString match: c].	self removeFromClassCategories: categories inNamespace: aNamespace.</body><body package="SpyLite-Core">removeFromClassCategory: nameAsString	|categories|	categories := OrderedCollection new.	categories add: nameAsString.	self removeFromClassCategories: (Array with: nameAsString)</body><body package="SpyLite-Core">removeFromClasses: classes	^ classes do: [:cls | self 							removeFromClass: cls;							removeFromClass: cls class ].</body><body package="SpyLite-Core">removeFromPackages: packageNames	| classes |	classes := self classesForPackages: packageNames.	classes do: [:cls | cls myClass flushVMmethodCache. 					cls myClass rebindAllMethods. ]</body><body package="SpyLite-Core">removeFromPackagesMatching: regexpAsString	| classes |	classes := self classesForPackagesMatching: regexpAsString.	classes do: [:cls | cls flushVMmethodCache. 					cls rebindAllMethods. ]</body></methods><methods><class-id>Spy1.SLProfiler class</class-id> <category>util</category><body package="SpyLite-Core">classesInCategory: categoryName	"Return the list of classes that belong to a category. Reject non behavior, such as namespaces"	^ self classesInCategory: categoryName inNamespace: Smalltalk</body><body package="SpyLite-Core">classesInCategory: categoryName inNamespace: namespace	"Return the list of classes that belong to a category. Reject non behavior, such as namespaces"	^ ((namespace organization listAtCategoryNamed: categoryName asSymbol) 		collect: [ :n | namespace at: n] )			select: [ :c | c isBehavior ]</body><body package="SpyLite-Core">getTestClasses	|testClasses|	testClasses := SUnit.TestCase withAllSubclasses.	testClasses addAll:XProgramming.SUnit.TestCase withAllSubclasses.	^testClasses</body><body package="SpyLite-Core">isDangerous: aClass	| isDangerous |"	self assert: ( aClass theNonMetaClass == aClass ) description: 'Can only be called on non meta class'."	"XProgramming.SUnit.TestCase assert: ( aClass theNonMetaClass == aClass ) description: 'Can only be called on non meta class'.""	(aClass inheritsFrom: Spy) ifTrue: [ ^ true ].	true ifTrue: [ ^ false ].	"			"Cannot instrument a configuration"	(aClass name beginsWith: 'ConfigurationOf') ifTrue: [ ^ true ].  		"Can instrument the scenario example, even it belongs to Spy"	(aClass category beginsWith: 'Spy-ScenarioExample') ifTrue: [ ^ false ]."	((Array with: ByteSymbol with: String with: Symbol with: MethodReference with: MorphicToolBuilder) includes: aClass)		ifTrue: [ ^ true ]."	(#('Spy-Core' 'Announcements' 'Balloon' 'Collections' 'CollectionsTests' 'Compiler' 'CompilerTests' 'Compression' 'DeprecatedPreferences' 'Exceptions' 'Files' 'FixUnderscores' 'FreeType' 'FreeTypeSubPixelAntiAliasing' 'FreeTypeTests' 'Gofer' 'Graphics' 'GraphicsTests' 'HostMenus' 'Kernel' 'KernelTests' 'MCDirtyPackage' 'MenuRegistration' 'Monticello' 'MonticelloConfigurations' 'MonticelloGUI' 'MonticelloMocks' 'Morphic' 'MorphicTests' 'Multilingual' 'MultilingualTests' 	"'Network' 'NetworkTests' "	'ObjectMetaTools' 'PackageInfo' 'PinesoftEnhancementsForFreetype' 'Polymorph' 'PreferenceBrowser' 'ST80' 'SUnit' 'SUnitGUI' 'ScriptLoader' 'ScriptLoader11' 'Settings' 'System' 'Tests' 'ToolBuilder' 'Tools' 'ToolsTest' 'Traits' 'TrueType' 'VB') anySatisfy: [ :cat | aClass category beginsWith: cat ])		ifTrue: [ ^ true ].	^ false		"	^ aClass isCollection		or: [ ((Smalltalk specialObjectsArray select: #isBehavior) includes: aClass) ]"</body><body package="SpyLite-Core">isNotDangerous: aClass	^ (self isDangerous: aClass) not</body><body package="SpyLite-Core">log: aString	"Transcript show: 'Running: ', aString asString; cr."</body><body package="SpyLite-Core">nonDangerousClasses	^ Smalltalk allClasses select: [:cls | SLProfiler isNotDangerous: cls ]</body><body package="SpyLite-Core">nullObject	^ self new</body><body package="SpyLite-Core">shouldInstallOnClass: aClass	| isDangerous |	self assert: [ aClass theNonMetaClass == aClass ] description: 'Can only be called on non meta class'.		^ (self isNotDangerous: aClass)</body><body package="SpyLite-Core">shouldInstallOnCompiledMethod: compiledMethod	^ (compiledMethod pragmaAt: #nospy) isNil</body></methods><methods><class-id>Spy1.SLProfiler class</class-id> <category>gathering</category><body package="SpyLite-Core">allSpysForPackagesMatching: regexpAsString	"	self allSpysForPackagesMatching: 'Mondrian*'.	"	| classes answer |	classes := self classesForPackagesMatching: regexpAsString.	answer := OrderedCollection new.	classes do: [:cls | answer addAll: (cls methods select: #isSpy)].	^ answer</body><body package="SpyLite-Core">classesForPackages: packageNames	| packages classes |	packages := Store.Registry allPackages select:[:p | packageNames includes: p].	classes := packages inject: #() 						into: [:sum :el | sum, el allClasses].	^ classes</body><body package="SpyLite-Core">classesForPackagesMatching: regexpAsString	| packages classes |	packages := Store.Registry allPackages select:[:p | regexpAsString match: (p name asString)].	classes := (packages inject: #() 						into: [:sum :el | sum, el allClasses]) collect:[: c | c myClass].	^ classes</body><body package="SpyLite-Core">gather	^ self new gather</body><body package="SpyLite-Core">gatherForClassCategory: nameAsString	"Return a profiler"	^ self new gatherForClassCategory: nameAsString</body><body package="SpyLite-Core">gatherForPackageNamed: nameAsString	"Return a profiler"		^ self new gatherForPackageNamed: nameAsString</body><body package="SpyLite-Core">gatherForPackagesMatching: regexpAsString	"Return a profiler"		^ self new gatherForPackagesMatching: regexpAsString</body></methods><methods><class-id>Spy1.SLProfiler class</class-id> <category>public - profiling</category><body package="SpyLite-Core">profile: aBlock inClassCategories: categoriesNames	"Return an instance of myself that contains a profiling structure (Package, Class, Method) filled with the information gathered during the execution.  	 All the classes that belong to the categories given as argument are instrumented before the profile and later on un-instrumented"	"	self 		profile:  [ OSkSubStream example01 ]		inClassCategories: (Array with: 'OSkStreams' )	"	^self profile: aBlock inClassCategories: categoriesNames inNamespace: Smalltalk.</body><body package="SpyLite-Core">profile:  aBlock inClassCategories: categories inNamespace: aNamespace	"Return an instance of myself that contains a profiling structure (Package, Class, Method) filled with the information gathered during the execution.  	 All the classes that belong to the categories given as argument are instrumented before the profile and later on un-instrumented"	"	self 		profile:  [ OSkSubStream example01 ]		inClassCategories: (Array with: 'OSkStreams' )	"	| profiler |		Transcript show: 'profiling using instrumentation...'; cr.	profiler := self new.	[		profiler beforeProfiling.		profiler gatherForClassCategories: categories inNamespace: aNamespace.		profiler install.		aBlock value.		profiler afterProfiling 	]	ensure: [ self removeFromClassCategories: categories inNamespace: aNamespace].			profiler setIfNecessaryTimeProfiler: aBlock.	profiler setIfNecessaryTimeAndCallGraphFrom: aBlock.	profiler setIfNecessaryStateChanges.	profiler checkInvariant.	Transcript show: 'ended!'; cr.	^ profiler</body><body package="SpyLite-Core">profile: aBlock inClassCategoriesMatching: rexexp	^self profile: aBlock inClassCategoriesMatching: rexexp inNamespace: Smalltalk.</body><body package="SpyLite-Core">profile:  aBlock inClassCategoriesMatching: rexexp inNamespace: aNamespace	| categoriesNames|	categoriesNames := aNamespace organization categories select:[:c | rexexp match: c].	categoriesNames := categoriesNames collect:[:c | c asString].	^self profile: aBlock inClassCategories: categoriesNames inNamespace: aNamespace.</body><body package="SpyLite-Core">profile: aBlock inClassCategory: classCategory		^self profile: aBlock inClassCategories: (Array with:  classCategory) inNamespace: Smalltalk.</body><body package="SpyLite-Core">profile: aBlock inPackage: packageName	^self profile: aBlock inPackages: (Array with: (Store.Registry packageNamed: packageName) )</body><body package="SpyLite-Core">profile: aBlock inPackages: Packages	| profiler |		Transcript show: 'profiling...'; cr.	profiler := self new.	[		profiler beforeProfiling.		profiler gatherForPackages: Packages.		profiler install.		profiler beforeProfiling.		aBlock value.				profiler afterProfiling  ]	ensure: [ self removeFromPackages: Packages ].	Transcript show: 'ended...'; cr.	profiler setIfNecessaryTimeProfiler: aBlock.	profiler setIfNecessaryTimeAndCallGraphFrom: aBlock.	profiler setIfNecessaryStateChanges.	profiler checkInvariant.	^ profiler</body><body package="SpyLite-Core">profile: aBlock inPackagesMatching: regexp	| packageInfos |		packageInfos := Store.Registry allPackages select:[:p | regexp match: (p name asString)].	^self profile: aBlock inPackages: packageInfos.</body><body package="SpyLite-Core">profile: aBlock inPackagesNames: packagesNames	|packagesInfos|	packagesInfos := Store.Registry allPackages select:[:p | packagesNames includes: p name asString].	^self profile: aBlock inPackages: packagesInfos</body></methods><methods><class-id>Spy1.SLProfiler class</class-id> <category>hooks</category><body package="SpyLite-Core">defaultRun	"Tell on what the profiler has to be run per default"	^ #package</body><body package="SpyLite-Core">spyClassForClass	^ self spyClassForPackage spyClassForClass</body><body package="SpyLite-Core">spyClassForMethod	^ self spyClassForPackage spyClassForClass spyClassForMethod</body><body package="SpyLite-Core">spyClassForPackage	^ SLPackage</body><body package="SpyLite-Core">testMethodsToIgnore	"This is intended to be temporary. There are some strange bugs that are hard to track down"	^ #(testNestingOfFormBuilder testNestedCycle)</body></methods><methods><class-id>Spy1.SLProfiler class</class-id> <category>public - registry</category><body package="SpyLite-Core">profilerAt: registryNameAsSymbol	^ self registry at: registryNameAsSymbol</body><body package="SpyLite-Core">profilingOf: aProfilerClass	^ self registry values select: [ :p | p isKindOf: aProfilerClass ]</body><body package="SpyLite-Core">removeRegistryNamed: aRegistryName	self registry removeKey: aRegistryName</body><body package="SpyLite-Core">reset	Registry := nil.	Smalltalk garbageCollect</body></methods><methods><class-id>Spy1.SLProfiler class</class-id> <category>public - installing removing</category><body package="SpyLite-Core">forClass: aClass	| profiler classSpy packageSpy |	self installOnClass: aClass.	profiler := self new.	classSpy := profiler spyForClass: aClass.	packageSpy := self spyClassForPackage new.	packageSpy classAt: aClass name put: classSpy.	classSpy packageSpy:  packageSpy.	packageSpy packageName: 'Smalltalk'.	profiler addPackage: packageSpy.	^ profiler</body></methods><methods><class-id>Spy1.SLProfiler class</class-id> <category>private - profiling</category><body package="SpyLite-Core">profile: aBlock forClassNamed: className	"Doing a profile on a block only on the instrumentation f a class"	"^ self new profile: aBlock forClassNamed: className"	| profiler packageSpy cls classSpy |	cls := Smalltalk at: className.	profiler := self new.	Transcript show: 'profiling...'; cr.	[		profiler beforeProfiling.		classSpy := profiler spyForClass: cls.		packageSpy := self spyClassForPackage new initialize.		packageSpy classAt: className put: classSpy.		profiler addPackage: packageSpy.		profiler install.		aBlock value.		profiler afterProfiling. ]	ensure:[self removeFromClass: cls ].	profiler setIfNecessaryTimeProfiler: aBlock.	profiler setIfNecessaryTimeAndCallGraphFrom: aBlock.	Transcript show: 'ended...'; cr.	^ profiler</body></methods><methods><class-id>Spy1.SLProfiler class</class-id> <category>updating</category><body package="SpyLite-Core">update: aspectSymbol with: parameter from: sender	"Normally, this expects to receive updates from the test suite it is running only.  For these updates aspectSymbol is in fact aTestCase (the one about to be run), parameter is nil and sender is the test suite.  If other updates ever have to be sent, you could preface this method with	aspectSymbol isSymbol ifTrue: [super update: aspectSymbol with: parameter from: sender].or similar."	"Transcript nextPutAll: 'test method  ', aspectSymbol printString; cr."	self currentTestMethod: aspectSymbol.	"aspectSymbol is in fact an XProgramming.SUnit.TestCase"</body></methods><methods><class-id>Spy1.SpyWrapper</class-id> <category>accessing</category><body package="SpyLite-Core">clientMethod	^clientMethod</body><body package="SpyLite-Core">currentMethod	^ self class currentMethod</body><body package="SpyLite-Core">currentMethod: spyMethod	self class currentMethod: spyMethod</body><body package="SpyLite-Core">methodSpy	^methodSpy</body><body package="SpyLite-Core">methodSpy: aMethodSpy	methodSpy := aMethodSpy.</body><body package="SpyLite-Core">originalMethod	^ self unwrappedMethod.</body></methods><methods><class-id>Spy1.SpyWrapper</class-id> <category>initialize-release</category><body package="SpyLite-Core">class: aClass selector: aSymbol 	^super class: aClass selector: aSymbol</body></methods><methods><class-id>Spy1.SpyWrapper</class-id> <category>evaluating</category><body package="SpyLite-Core">valueWithReceiver: anObject arguments: anArrayOfObjects 	"methodSpy addIncomingCalls: LastCalledMethod."	|a|	a := self methodSpy run: self selector with: anArrayOfObjects in: anObject.	^a</body></methods><methods><class-id>Spy1.SpyWrapper</class-id> <category>evaluating-before-after</category><body package="SpyLite-Core">beforeMethod</body></methods><methods><class-id>Spy1.SpyWrapper class</class-id> <category>global info</category><body package="SpyLite-Core">currentTestMethod	^ currentTestMethod</body><body package="SpyLite-Core">currentTestMethod: aTestCase	"This method is confusingly named, presumably for historical reasons."	currentTestMethod := aTestCase.</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>accessing-computed</category><body package="SpyLite-Core">&gt;&gt; aSymbol	^ self localMethodAt: aSymbol</body><body package="SpyLite-Core">allMethods	"Return the list of methods defined in myself and in my metaspy"	^ self methods , self metaclassSpy methods</body><body package="SpyLite-Core">allSubclasses	"Return all the subclasses of myself"	allSubclassesCache ifNotNil: [ ^ allSubclassesCache ].	^ allSubclassesCache := self subclasses inject: #() into: [ :sum :cls | sum, (Array with: cls), cls allSubclasses ]</body><body package="SpyLite-Core">coveredMethods	^ self methods select: #isCovered</body><body package="SpyLite-Core">downwardLookupMethodsNamed: aSelector	^ (self allSubclasses select: [:cls | cls hasMethodNamed: aSelector])			collect: [:cls | cls localMethodAt: aSelector ]</body><body package="SpyLite-Core">localMethodAt: aSelector	^ self localMethods at: aSelector</body><body package="SpyLite-Core">localMethodAt: aSelector ifAbsent: aBlock	^ self localMethods at: aSelector ifAbsent: aBlock</body><body package="SpyLite-Core">localMethodAt: aSelector put:  value	^ self localMethods at: aSelector put: value</body><body package="SpyLite-Core">lookupMethodNamed: aSelector	^ (self hasMethodNamed: aSelector)			ifTrue: [ self localMethodAt: aSelector ]			ifFalse: [ self superclass lookupMethodNamed: aSelector ]</body><body package="SpyLite-Core">methods 	"Return the list of spy representing a method"	^ methods values</body><body package="SpyLite-Core">nonMetaClassName	^ (self isMeta		ifTrue: [ self className copyFrom: 1 to: ((self className indexOf: $ ) - 1)] 		ifFalse: [ self className ]) asSymbol</body><body package="SpyLite-Core">numberOfAllMethods	^ self allMethods size</body><body package="SpyLite-Core">numberOfCoveredMethods	^ self coveredMethods size</body><body package="SpyLite-Core">numberOfMethods	^ self methods size</body><body package="SpyLite-Core">profiler	^ self package profiler</body><body package="SpyLite-Core">subclasses	^ self profiler allClassesSuchThat: [:cls | cls superclass == self]</body><body package="SpyLite-Core">theNonMetaClass 	"Return the non metaclass spy for the receiver"		self isMeta ifFalse: [ ^ self ].	^ self packageSpy &gt;&gt; self nonMetaClassName</body><body package="SpyLite-Core">withAllSubclasses	^ (Array with: self), self allSubclasses</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>contract</category><body package="SpyLite-Core">checkInvariant	self assert: [ className notNil ].	self assert: [ className isKindOf: Symbol ].	self assert: [ self profiler notNil ].	self assert: [ self methods notNil ].	self assert: [ self methods isSequenceable ].	self assert: [ self methods allSatisfy: [:m| m isKindOf: SLMethod ] ].	self assert: [ self class spyClassForMethod == self profiler class spyClassForMethod ].	self assert: [ self class spyClassForMethod == self profiler class spyClassForMethod ].	self assert: [ self class == self profiler class spyClassForClass ].</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>accessing</category><body package="SpyLite-Core">addMethod: aMethod	"Useful for testing"	aMethod classSpy: self.	methods at: aMethod selector put: aMethod.</body><body package="SpyLite-Core">className	^ className</body><body package="SpyLite-Core">className: aSymbol	className := aSymbol</body><body package="SpyLite-Core">localMethods	^ methods</body><body package="SpyLite-Core">metaclassSpy	"Return the class spy for the metaclass."	^ metaclassSpy ifNil: 		[ metaclassSpy := self class new 							className: self theClass class name asSymbol;							originalClass: self theClass class; 							yourself ]</body><body package="SpyLite-Core">originalClass	^originalClass</body><body package="SpyLite-Core">originalClass: aClass	originalClass := aClass</body><body package="SpyLite-Core">package	^ packageSpy</body><body package="SpyLite-Core">packageSpy	^ packageSpy</body><body package="SpyLite-Core">packageSpy: anObject 	packageSpy := anObject.	metaclassSpy ifNotNil: [:v | metaclassSpy packageSpy: anObject ]</body><body package="SpyLite-Core">superclass	self theClass superclass ifNil: [^nil].	^ self profiler classAt: self theClass superclass name ifNone: [nil]</body><body package="SpyLite-Core">superclassesToRoot	|classes|	classes := OrderedCollection new.	(self superclass isNil) ifFalse: [classes add: self superclass. classes addAll: self superclass superclassesToRoot].	^ classes</body><body package="SpyLite-Core">theClass	^ originalClass</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>hooks</category><body package="SpyLite-Core">afterEachExecution: messageName On: aReceiver with: arguments</body><body package="SpyLite-Core">beforeEachExecution: messageName On: aReceiver with: arguments</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>testing</category><body package="SpyLite-Core">hasMethodNamed: aSelector	^ self localMethods includesKey: aSelector</body><body package="SpyLite-Core">isClassPresent"	^ Smalltalk globals includesKey: className"	^ Smalltalk organization includesElement: className</body><body package="SpyLite-Core">isMeta	^ self className includes: $ .</body><body package="SpyLite-Core">isPartiallyCovered	^ self methods anySatisfy: #isCovered</body><body package="SpyLite-Core">isPartiallyExecuted	| isPartiallyExecuted |	isPartiallyExecuted := false.	self allMethods do:[:m | m numberOfInvocations &gt; 0 ifTrue:[isPartiallyExecuted := true]].	^isPartiallyExecuted</body><body package="SpyLite-Core">isSubclassOf: aClassSpy	"True of I am a subclass of aClassSpy"		^ self == aClassSpy		ifTrue: [ true ]		ifFalse: [ 			self superclass ifNil: [ ^ false ].			self superclass isSubclassOf: aClassSpy ]</body><body package="SpyLite-Core">isTestClass		^ self superclass 			ifNil: [ self theClass superclass = SUnit.TestCase or:[self theClass superclass = XProgramming.SUnit.TestCase] ] 			ifNotNil: [ self superclass isTestClass ]</body><body package="SpyLite-Core">understandMethodNamed: aSelector	(self hasMethodNamed: aSelector)		ifTrue: [ ^ true ].		self superclass ifNil: [ ^ false ].		^ self superclass understandMethodNamed: aSelector</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>printing</category><body package="SpyLite-Core">printOn: stream	stream nextPut: $&lt;.	stream nextPutAll: (self className printString).	stream nextPut: $&gt;</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>installing</category><body package="SpyLite-Core">install		self allMethods do:[:m | m install]</body></methods><methods><class-id>Spy1.SLClass</class-id> <category>initialize-release</category><body package="SpyLite-Core">initialize 	super initialize.	 methods := IdentityDictionary new.	packageSpy := SLPackage nullObject</body></methods><methods><class-id>Spy1.SLClass class</class-id> <category>hooks</category><body package="SpyLite-Core">spyClassForMethod	^ SLMethod</body></methods><methods><class-id>Spy1.SLClass class</class-id> <category>accessing</category><body package="SpyLite-Core">nullObject	^ self new</body></methods><methods><class-id>Spy1.SLPackage</class-id> <category>accessing-computed</category><body package="SpyLite-Core">allMethods	| coll |	coll := OrderedCollection new.	self classes do: [:cls | coll addAll: cls methods. coll addAll: cls metaclassSpy methods ].	^ coll</body></methods><methods><class-id>Spy1.SLPackage</class-id> <category>testing</category><body package="SpyLite-Core">hasClassNamed: className	^ self classes includesKey: className asSymbol</body></methods><methods><class-id>Spy1.SLPackage</class-id> <category>accessing</category><body package="SpyLite-Core">&gt;&gt; aSymbol	"we are accessing a method defined in a metaclass"	(aSymbol includes: $ ) ifTrue: [ ^ (self &gt;&gt; aSymbol asString sunitSubStrings first asSymbol) metaclassSpy ].		^ self classAt: aSymbol</body><body package="SpyLite-Core">classAt: aSymbol	^ classes at: aSymbol ifAbsent: [ self error: 'Class ', aSymbol, ' not found']</body><body package="SpyLite-Core">classAt: aSymbol ifNone: aBlock	^ classes at: aSymbol ifAbsent: aBlock</body><body package="SpyLite-Core">classAt: aSymbol put: aClassType"	self assert: [aSymbol isSymbol]."		aClassType className: aSymbol.	aClassType packageSpy: self.	"self class globalTypesAt: aClassType className put: aClassType."	^ classes at: aSymbol put: aClassType</body><body package="SpyLite-Core">classes 	^ classes</body><body package="SpyLite-Core">packageName	^ packageName</body><body package="SpyLite-Core">packageName: nameAsString	packageName  := nameAsString</body><body package="SpyLite-Core">profiler	^ profiler</body><body package="SpyLite-Core">profiler: anObject	profiler := anObject</body></methods><methods><class-id>Spy1.SLPackage</class-id> <category>enumerating</category><body package="SpyLite-Core">allClassesSuchThat: aBlock	^ self classes select: aBlock</body><body package="SpyLite-Core">allMethodsSuchThat: aBlock	^ self allMethods select: aBlock</body><body package="SpyLite-Core">classesDo: aBlockOrSymbol	^ self classes do: aBlockOrSymbol</body></methods><methods><class-id>Spy1.SLPackage</class-id> <category>printing</category><body package="SpyLite-Core">printOn: stream	stream nextPutAll: '&lt;&lt;'.	self packageName ifNotNil:[ stream nextPutAll: (self packageName asString).].	stream nextPutAll: '&gt;&gt;'.</body></methods><methods><class-id>Spy1.SLPackage</class-id> <category>contract</category><body package="SpyLite-Core">checkInvariant	self assert: [ packageName notNil ].	self assert: [ packageName isKindOf: ByteString ].	self assert: [ self profiler notNil ].	self assert: [ self classes notNil ].	self assert: [ self classes allSatisfy: [ :c | c isKindOf: self class spyClassForClass ] ].	self assert: [ self classes allSatisfy: [ :c | c package == self ] ].	self assert: [ self classes allSatisfy: [ :c | c profiler == self profiler ]].		self classes do: [ :p | p checkInvariant ]</body></methods><methods><class-id>Spy1.SLPackage</class-id> <category>initialize-release</category><body package="SpyLite-Core">initialize 	super initialize.	classes := Dictionary new.	profiler := SLProfiler nullObject</body></methods><methods><class-id>Spy1.SLPackage class</class-id> <category>hooks</category><body package="SpyLite-Core">nullObject	^ self new</body><body package="SpyLite-Core">spyClassForClass	^ SLClass</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>accessing</category><body package="SpyLite-Core">classSpy	^ classSpy</body><body package="SpyLite-Core">classSpy: anObject	classSpy := anObject</body><body package="SpyLite-Core">compiledMethod	^ self originalMethod</body><body package="SpyLite-Core">instrumentedMethod	^ instrumentedMethod</body><body package="SpyLite-Core">instrumentedMethod: aTemplateMethod	instrumentedMethod := aTemplateMethod</body><body package="SpyLite-Core">originalMethod	"originalMethod isSpy ifTrue: [ ^ originalMethod originalMethod ]."	^ originalMethod</body><body package="SpyLite-Core">originalMethod: aCompiledMethod	"self assert: [ aCompiledMethod isSpy not ]."	originalMethod := aCompiledMethod</body><body package="SpyLite-Core">selector	^ selector</body><body package="SpyLite-Core">spyWrapper	^spywrapper</body><body package="SpyLite-Core">spyWrapper: aSpyWrapper	spywrapper := aSpyWrapper.</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>hooks</category><body package="SpyLite-Core">afterRun: methodName with: listOfArguments in: receiver</body><body package="SpyLite-Core">beforeRun: methodName with: listOfArguments in: receiver</body><body package="SpyLite-Core">flushCache	"Tell the interpreter to remove all references to this method from its method lookup cache, if it has one.  This primitive must be called whenever a method is defined or removed.	NOTE:  Only one of two selective flush methods needs to be used.	Squeak 2.2 and earlier uses 119 (See Symbol flushCache).	Squeak 2.3 and later uses 116 (See CompiledMethod flushCache).""	&lt;primitive: 116&gt;"</body><body package="SpyLite-Core">returnValue: value</body><body package="SpyLite-Core">run: methodName with: listOfArguments in: receiver	| v |	self classSpy ifNotNil: [		classSpy beforeEachExecution: methodName On: receiver with: listOfArguments ].	self beforeRun: methodName with: listOfArguments in: receiver.	"	v := originalMethod valueWithReceiver: receiver arguments: listOfArguments."	v := self spyWrapper clientMethod valueWithReceiver: receiver arguments: listOfArguments.	self classSpy ifNotNil: [ 		classSpy afterEachExecution: methodName On: receiver with: listOfArguments ].	self afterRun: methodName with: listOfArguments in: receiver.	self returnValue: v.	^ v</body><body package="SpyLite-Core">selector: aSelectorAsSymbol	selector := aSelectorAsSymbol</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>testing</category><body package="SpyLite-Core">hasClassSpy 	^ self classSpy notNil</body><body package="SpyLite-Core">hasIncomingCalls	Smalltalk.incomingCalls ifNil: [ ^ false ].	^ self incomingCalls size &gt; 0</body><body package="SpyLite-Core">hasLiteral: v	^ self originalMethod hasLiteral: v</body><body package="SpyLite-Core">hasNoIncomingCalls	^ self hasIncomingCalls not</body><body package="SpyLite-Core">hasOutgoingCalls	Smalltalk.outgoingCalls ifNil: [ ^ false ].	^ self outgoingCalls size &gt; 0</body><body package="SpyLite-Core">isAbstract	^false</body><body package="SpyLite-Core">isMethodExisting"	self halt."	^ self theClass methodDictionary includesKey: self selector</body><body package="SpyLite-Core">isMethodNotExisting	^ self isMethodExisting not</body><body package="SpyLite-Core">isNotMethodExtension	"True if I am a class extension"	^ self originalMethod isExtension not</body><body package="SpyLite-Core">isRequired	^ self originalMethod isRequired</body><body package="SpyLite-Core">isRequired: marker	^ self originalMethod isRequired: marker</body><body package="SpyLite-Core">isSpy	^ true</body><body package="SpyLite-Core">isTest		^ ('#test*' match: self selector printString ) and: [(self classSpy isTestClass )]</body><body package="SpyLite-Core">notCovered	^ self isCovered not</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>delegation</category><body package="SpyLite-Core">= v	| vp |	(v isKindOf: SLMethod)		ifTrue: [ vp := v originalMethod ]		ifFalse: [ vp := v ].		^ self originalMethod == vp</body><body package="SpyLite-Core">at: v	^ originalMethod at: v</body><body package="SpyLite-Core">endPC	^ originalMethod endPC</body><body package="SpyLite-Core">getSourceFor: sel in: class	^ originalMethod getSourceFor: sel in: class</body><body package="SpyLite-Core">hasLiteralSuchThat: v	^ originalMethod hasLiteralSuchThat: v</body><body package="SpyLite-Core">initialPC	^ originalMethod initialPC</body><body package="SpyLite-Core">isConflict	^ originalMethod isConflict</body><body package="SpyLite-Core">last	^ originalMethod last</body><body package="SpyLite-Core">literalAt: v	^ originalMethod literalAt: v</body><body package="SpyLite-Core">literals	^ originalMethod literals</body><body package="SpyLite-Core">methodClass	^ originalMethod methodClass</body><body package="SpyLite-Core">objectForDataStream: v	^ originalMethod objectForDataStream: v</body><body package="SpyLite-Core">pragmas	^ originalMethod pragmas</body><body package="SpyLite-Core">readDataFrom: v1 size: v2	^ originalMethod readDataFrom: v1 size: v2</body><body package="SpyLite-Core">refersToLiteral: v	^ originalMethod refersToLiteral: v</body><body package="SpyLite-Core">sourcePointer	^ originalMethod sourcePointer</body><body package="SpyLite-Core">storeDataOn: v	^ originalMethod storeDataOn: v</body><body package="SpyLite-Core">storeOn: s	^ originalMethod storeOn: s</body><body package="SpyLite-Core">theClass	^ spywrapper mclass</body><body package="SpyLite-Core">veryDeepCopyWith: v	^ originalMethod veryDeepCopyWith: v</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>accessing-computed</category><body package="SpyLite-Core">numberOfLinesOfCode	^4	"^ originalMethod  numberOfLinesOfCode"</body><body package="SpyLite-Core">package	^ self classSpy packageSpy</body><body package="SpyLite-Core">profiler	self package ifNil: [ ^ nil ].	^ self package profiler</body><body package="SpyLite-Core">sourceCode"	^ originalMethod getSourceFromFile"	^ originalMethod getSource</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>printing</category><body package="SpyLite-Core">printOn: stream	stream nextPut: $&lt;.	self classSpy ifNotNil:[ stream nextPutAll: (self theClass name asString).].	stream nextPutAll: ('&gt;&gt;').	self selector ifNotNil:[stream nextPutAll: (self selector asString).].	stream nextPut: $&gt;</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>contract</category><body package="SpyLite-Core">checkInvariant	self assert: [ selector notNil ].	self assert: [ selector isKindOf: Symbol ].	self assert: [ originalMethod isKindOf: CompiledMethod ].	self assert: [ self profiler notNil ].	self assert: [ self classSpy notNil ].	self assert: [ self classSpy profiler == self profiler ].	self assert: [ self classSpy profiler notNil ].		self assert: [ self classSpy profiler isKindOf: SLProfiler ].</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>installing</category><body package="SpyLite-Core">install	"We do nothing if the method has been supressed"	"(self theClass methodDict includesKey: self selector) ifFalse: [ ^ self ].	self assert: [ (self theClass methodDict at: self selector) isSpy not ].	self assert: [ self originalMethod notNil ].	self assert: [ self instrumentedMethod notNil ].	self flushCache."		"We update the original method, it may have changed since the uninstall"	"originalMethod := self theClass methodDict at: self selector.	self theClass methodDict at: self selector put: self instrumentedMethod."	self spyWrapper install.</body><body package="SpyLite-Core">uninstall	"self theClass methodDict at: self selector put: self originalMethod."	(self spyWrapper) uninstall."	self originalMethod uninstall."	self flushCache</body></methods><methods><class-id>Spy1.SLMethod</class-id> <category>initialize-release</category><body package="SpyLite-Core">initialize	super initialize.		selector := #unamed.	"Set a mock method, the #initialize itself"	"This is to make the class invariant pass"	originalMethod := self class compiledMethodAt: #initialize.	classSpy := SLClass nullObject</body></methods><methods><class-id>Spy1.SLMethod class</class-id> <category>public</category><body package="SpyLite-Core">isInMeta	^ inMeta</body><body package="SpyLite-Core">setInMeta	inMeta := true</body><body package="SpyLite-Core">setInNonMeta	inMeta := false</body></methods><methods><class-id>Spy1.SLMethod class</class-id> <category>hooks</category><body package="SpyLite-Core">spyClassForMethod	^ self</body></methods><methods><class-id>Spy1.SLMethodCoverage</class-id> <category>as yet unclassified</category><body package="SpyLite-Coverage">installGhosts	| rbMethodNode newMethod aClass |	"self selector = #pic ifTrue: [ self halt ]."	self originalMethod sourceCode size &gt; 20000		ifTrue: [ self uninstall ]		ifFalse: [ [ rbMethodNode := RBParser				parseMethod: self originalMethod sourceCode.			blocks := SLInstrumentor new				visitNode: rbMethodNode;				blocks.			aClass := self originalMethod methodClass.			newMethod := aClass				compile: rbMethodNode printString				notifying: nil.			aClass &gt;&gt; newMethod				replaceLiterals: (Array with: #metaObject -&gt; self) ]				on: Error				do: [ :e | self uninstall ] ]</body></methods><methods><class-id>Spy1.SLMethodCoverage</class-id> <category>As yet unclassified</category><body package="SpyLite-Coverage">installGhosts	| rbMethodNode newMethod aClass |	"self selector = #pic ifTrue: [ self halt ]."	self originalMethod sourceCode size &gt; 20000		ifTrue: [ self uninstall ]		ifFalse: [ [ rbMethodNode := RBParser				parseMethod: self originalMethod sourceCode.			blocks := SLInstrumentor new				visitNode: rbMethodNode;				blocks.			aClass := self originalMethod methodClass.			newMethod := aClass				compile: rbMethodNode printString				notifying: nil.			aClass &gt;&gt; newMethod				replaceLiterals: (Array with: #metaObject -&gt; self) ]				on: Error				do: [ :e | self uninstall ] ]</body></methods><methods><class-id>Spy1.SLMethodCoverage</class-id> <category>as yet unclassified</category><body package="SpyLite-Coverage">updateStateFirstBlock	blocks ifNotEmpty: [ blocks first executed ]</body></methods><methods><class-id>Spy1.SLMethodCoverage</class-id> <category>public - metrics</category><body package="SpyLite-Coverage">numberOfAllStatements	^ self blocks		inject: 0		into: [ :sum :block | sum + block numberOfStatements ]</body><body package="SpyLite-Coverage">numberOfExecutedStatements	^ (self blocks select: #wasExecuted)		inject: 0		into: [ :sum :block | sum + block numberOfStatements ]</body></methods><methods><class-id>Spy1.SLMethodCoverage</class-id> <category>enumerating</category><body package="SpyLite-Coverage">count: aNumber	blocks		detect: [ :block | block id = aNumber ]		ifFound: [ :block | 			self updateStateFirstBlock.			block executed ]</body></methods><methods><class-id>Spy1.SLMethodCoverage</class-id> <category>initialize-release</category><body package="SpyLite-Coverage">initialize	super initialize.	blocks := OrderedCollection new</body></methods><methods><class-id>Spy1.SLMethodCoverage</class-id> <category>accessing</category><body package="SpyLite-Coverage">blocks	^ blocks</body></methods><methods><class-id>Spy1.SLCollectorLiteral</class-id> <category>accessing</category><body package="SpyLite-Coverage">literals	^ literals</body></methods><methods><class-id>Spy1.SLCollectorLiteral</class-id> <category>initialization</category><body package="SpyLite-Coverage">initialize	literals := Dictionary new</body></methods><methods><class-id>Spy1.SLProfilerCoverage</class-id> <category>as yet unclassified</category><body package="SpyLite-Coverage">calculateExecutedMethodsOf: aSymbol	| methods |	methods := (self classAt: aSymbol) allMethods.	^ ((methods		select: [ :aMethod | aMethod blocks isNotEmpty ]		thenCollect: [ :aMethod | aMethod blocks first ])		select: [ :aBlock | aBlock wasExecuted ]) size</body><body package="SpyLite-Coverage">calculateExecutedStatementsOf: aSymbol	| methods |	methods := (self classAt: aSymbol) allMethods.	^ methods		inject: 0		into: [ :sum :method | sum + method numberOfExecutedStatements ]</body><body package="SpyLite-Coverage">cleanBlocksOfMethods	self allMethods		do: [ :aMethod | aMethod blocks do: [ :aBlock | aBlock noExecuted ] ]</body><body package="SpyLite-Coverage">methodCoverage	| methods |	methods := self allMethods.	methods isEmpty		ifTrue: [ ^ 0 ].	^ (100 * self numberOfExecutedMethods / methods size) asFloat		round: 3</body><body package="SpyLite-Coverage">methodCoverage1	| numberMethods |	numberMethods := self allMethods size.	^ (self calculateExecutedMethodsByClass associations		collect: [ :assoc | 			| aClassName |			aClassName := assoc key.			numberMethods &gt; 0				ifTrue:					[ aClassName -&gt; ((100 * assoc value / numberMethods) asFloat round: 3)	"(self classAt: aClassName)" ]				ifFalse: [ aClassName -&gt; 0 ] ]) asDictionary</body><body package="SpyLite-Coverage">numberOfAllStatements	^ self allMethods		inject: 0		into: [ :sum :method | sum + method numberOfAllStatements ]</body><body package="SpyLite-Coverage">numberOfExecutedMethods	| methodsWithBlocks |	methodsWithBlocks := self allMethods		select: [ :aMethod | aMethod blocks isNotEmpty ].	^ (methodsWithBlocks		collect: [ :aMethod | aMethod blocks first ]		thenSelect: [ :aBlock | aBlock wasExecuted ]) size</body><body package="SpyLite-Coverage">numberOfExecutedStatements	^ self allMethods		inject: 0		into: [ :sum :method | sum + method numberOfExecutedStatements ]</body><body package="SpyLite-Coverage">statementCoverage	self numberOfAllStatements == 0		ifTrue: [ ^ 0 ].	^ (100 * self numberOfExecutedStatements / self numberOfAllStatements)		asFloat round: 3</body><body package="SpyLite-Coverage">statementCoverage1	| numb |	numb := self numberOfAllStatements.	^ (self calculateExecutedStatementsByClass associations		collect: [ :assoc | 			numb &gt; 0				ifFalse: [ assoc key -&gt; 0 ]				ifTrue: [ assoc key						-&gt;							((100 * assoc value / self numberOfAllStatements) asFloat round: 3)	"(self classAt: assoc key)" ] ])		asDictionary</body></methods><methods><class-id>Spy1.SLProfilerCoverage</class-id> <category>hooks</category><body package="SpyLite-Coverage">beforeProfiling	self allMethods select: #isNotMethodExtension thenDo: #installGhosts</body></methods><methods><class-id>Spy1.SLProfilerCoverage</class-id> <category>As yet unclassified</category><body package="SpyLite-Coverage">unboundMethodwith: t1 	"	***This is decompiled code.*** 	No source was available"	^self allMethods select: #isNotMethodExtension thenDo: #installGhosts</body></methods><methods><class-id>Spy1.SLProfilerCoverage class</class-id> <category>hooks</category><body package="SpyLite-Coverage">spyClassForPackage	^ SLPackageCoverage</body></methods><methods><class-id>Spy1.SLClassCoverage class</class-id> <category>hooks</category><body package="SpyLite-Coverage">spyClassForMethod	^ SLMethodCoverage</body></methods><methods><class-id>Spy1.SLPackageCoverage class</class-id> <category>hooks</category><body package="SpyLite-Coverage">spyClassForClass	^ SLClassCoverage</body></methods><methods><class-id>Spy1.SLBlock</class-id> <category>accessing</category><body package="SpyLite-Coverage">executed	executed := true</body><body package="SpyLite-Coverage">id	^ id</body><body package="SpyLite-Coverage">id: anObject	id := anObject</body><body package="SpyLite-Coverage">numberOfStatements	^ numberOfStatements</body><body package="SpyLite-Coverage">numberOfStatements: anObject	numberOfStatements := anObject</body><body package="SpyLite-Coverage">start	^ start</body><body package="SpyLite-Coverage">start: anObject	start := anObject</body><body package="SpyLite-Coverage">stop	^ stop</body><body package="SpyLite-Coverage">stop: anObject	stop := anObject</body><body package="SpyLite-Coverage">wasExecuted	^ executed</body></methods><methods><class-id>Spy1.SLBlock</class-id> <category>as yet unclassified</category><body package="SpyLite-Coverage">noExecuted	executed := false</body></methods><methods><class-id>Spy1.SLBlock</class-id> <category>initialization</category><body package="SpyLite-Coverage">initialize	super initialize.	executed := false.	numberOfStatements := 0</body></methods><methods><class-id>Spy1.SLBlock class</class-id> <category>instance creation</category><body package="SpyLite-Coverage">new	^ super new initialize</body></methods><methods><class-id>Spy1.SLInstrumentor</class-id> <category>visiting</category><body package="SpyLite-Coverage">addBlock: aBlockNode	blocks add: (self buildSBBlock: aBlockNode)</body><body package="SpyLite-Coverage">buildGhostNode: anInteger	^ RBParser		parseExpression: '#metaObject count: ' , anInteger asString , '.nil.'</body><body package="SpyLite-Coverage">buildSBBlock: aBlockNode	^ SLBlock new		id: self nextId;		numberOfStatements: aBlockNode body statements size;		yourself</body><body package="SpyLite-Coverage">instrumentBlock: aBlockNode	self addBlock: aBlockNode.	aBlockNode body addNodeFirst: (self buildGhostNode: currentId)</body><body package="SpyLite-Coverage">nextId	currentId := blocks size + 1.	^ currentId</body></methods><methods><class-id>Spy1.SLInstrumentor</class-id> <category>initialization</category><body package="SpyLite-Coverage">initialize	super initialize.	blocks := OrderedCollection new</body></methods><methods><class-id>Spy1.SLInstrumentor</class-id> <category>accessing</category><body package="SpyLite-Coverage">blocks	^ blocks</body></methods><methods><class-id>Spy1.SSTypeCollectorClass</class-id> <category>defaults</category><body package="SpyLite-TypeCollector">typeName	^ self className</body></methods><methods><class-id>Spy1.SSTypeCollectorClass class</class-id> <category>hooks</category><body package="SpyLite-TypeCollector">spyClassForMethod	^ SSTypeCollectorMethod</body></methods><methods><class-id>Spy1.SSTypeCollectorMethod</class-id> <category>accessing</category><body package="SpyLite-TypeCollector">argTypes	^ argTypes</body><body package="SpyLite-TypeCollector">dictLiterals	^ literals</body><body package="SpyLite-TypeCollector">receiverType	^ receiverType</body><body package="SpyLite-TypeCollector">returnType	^ returnType</body></methods><methods><class-id>Spy1.SSTypeCollectorMethod</class-id> <category>hooks</category><body package="SpyLite-TypeCollector">beforeRun: methodName with: listOfArguments in: aReceiver	self saveArguments: listOfArguments.	self saveReceiver: aReceiver.	self selectLiteralsOf: self originalMethod sourceCode.	listOfArguments do: [ :arg | self checkIfArgIsScalar: arg ].	executed := true</body><body package="SpyLite-TypeCollector">checkIfArgIsScalar: arg	(self profiler isScalar: arg)		ifTrue: [ self profiler addScalar: arg ]</body><body package="SpyLite-TypeCollector">initialize	super initialize.	returnType := Set new.	receiverType := Set new.	argTypes := OrderedCollection new.	executed := false.	literals := Dictionary new</body><body package="SpyLite-TypeCollector">nameOf: anObject	^ anObject isClass		ifTrue: [ anObject name ]		ifFalse: [ anObject class name ]</body><body package="SpyLite-TypeCollector">returnValue: value	returnType add: value class name.	self checkIfArgIsScalar: value</body><body package="SpyLite-TypeCollector">saveArguments: args	args		doWithIndex: [ :anObject :index | 			[ argTypes at: index ]				on: SubscriptOutOfBounds				do: [ argTypes add: Set new ].			(argTypes at: index) add: anObject class name ]</body><body package="SpyLite-TypeCollector">saveReceiver: anObject	receiverType add: (self nameOf: anObject)</body><body package="SpyLite-TypeCollector">selectLiteralsOf: string	| node visitor |	node := RBParser parseMethod: string.	visitor := SLCollectorLiteral new.	node acceptVisitor: visitor.	literals := visitor literals</body><body package="SpyLite-TypeCollector">wasExecuted	^ executed</body></methods><methods><class-id>Spy1.SSTypeCollectorMethod</class-id> <category>testing</category><body package="SpyLite-TypeCollector">isDeprecated	^ originalMethod isDeprecated</body><body package="SpyLite-TypeCollector">isValidReturnTypeWithReceiver	^ self receiverType = self returnType</body></methods><methods><class-id>Spy1.SSTypeCollectorPackage class</class-id> <category>hooks</category><body package="SpyLite-TypeCollector">spyClassForClass	^ SSTypeCollectorClass</body></methods><methods><class-id>Spy1.SSTypeCollector</class-id> <category>initialization</category><body package="SpyLite-TypeCollector">addScalar: anObject	| value |	value := scalars at: anObject class name ifAbsentPut: [ Set new ].	value add: anObject</body><body package="SpyLite-TypeCollector">initialize	super initialize.	scalars := Dictionary new</body><body package="SpyLite-TypeCollector">isScalar: anObject	(anObject class name includesAll: 'BlockClosure')		ifTrue: [ ^ true ].	self allClassesAsDictionary		at: anObject class name		ifAbsent: [ ^ true ].	^ false</body><body package="SpyLite-TypeCollector">scalars	^ scalars</body></methods><methods><class-id>Spy1.SSTypeCollector class</class-id> <category>hooks</category><body package="SpyLite-TypeCollector">profile: aBlock onPackagesMatching: regex	^ self profile: aBlock inPackagesMatching: regex	"asTypeInfo"</body><body package="SpyLite-TypeCollector">spyClassForPackage	^ SSTypeCollectorPackage</body><body package="SpyLite-TypeCollector">typeNameOf: anObject	^ anObject name</body></methods><methods><class-id>Spy1.SSTypeCollectorMethodTest</class-id> <category>running</category><body package="SpyLite-Tests">setUp	typeCollectorMethod := SSTypeCollectorMethod new</body></methods><methods><class-id>Spy1.SSTypeCollectorMethodTest</class-id> <category>tests</category><body package="SpyLite-Tests">testSelectLiteralsOf	| source dictLiterals |	source := 'test1 	^ 1	'.	typeCollectorMethod selectLiteralsOf: source.	dictLiterals := typeCollectorMethod dictLiterals.	self		assertCollection: dictLiterals keys		hasSameElements: #(#SmallInteger).	self		assertCollection: (dictLiterals values flatCollect: [ :s | s ])		hasSameElements: #(1).	source := 'test2		|number string|		number := 2.		string := ''hello''.		number = 5 ifTrue: [string := ''world''].'.	typeCollectorMethod selectLiteralsOf: source.	dictLiterals := typeCollectorMethod dictLiterals.	self		assertCollection: dictLiterals keys		hasSameElements: #(#SmallInteger #ByteString).	self		assertCollection: (dictLiterals values flatCollect: [ :val | val ])		hasSameElements: #(2 5 'hello' 'world')</body><body package="SpyLite-Tests">testSelectLiteralsOfMethodsWithoutLiterals	| source |	source := 'test1 	^ name	'.	typeCollectorMethod selectLiteralsOf: source.	self assert: typeCollectorMethod dictLiterals associations isEmpty.	source := 'test2		name = nickname ifTrue: [id := age].'.	typeCollectorMethod selectLiteralsOf: source.	self assert: typeCollectorMethod dictLiterals associations isEmpty</body></methods><methods><class-id>Spy1.SLProfilerCoverageTest</class-id> <category>asserting</category><body package="SpyLite-Tests">assert: aObject class: aClass	self assert: aObject class name equals: aClass name</body><body package="SpyLite-Tests">assertNoExecutedMethods: profiler equals: aNumber	self assert: profiler numberOfExecutedMethods equals: aNumber</body><body package="SpyLite-Tests">assertNumExecutedMethodsOf: profiler on: symbol equals: number	| dict |	dict := profiler calculateExecutedMethodsByClass.	self assert: (dict at: symbol) equals: number</body><body package="SpyLite-Tests">assertNumExecutedStatementsOf: profiler on: symbol equals: number	| dict |	dict := profiler calculateExecutedStatementsByClass.	self assert: (dict at: symbol) equals: number</body></methods><methods><class-id>Spy1.SLProfilerCoverageTest</class-id> <category>as yet unclassified</category><body package="SpyLite-Tests">asserMethodCoverage: profiler toNoExecutedMethods: aNumber	self		assert: profiler methodCoverage		closeTo: ((100 * aNumber / profiler allMethods size) asFloat round: 2)</body><body package="SpyLite-Tests">assertStatementCoverageOf: profiler on: symbol equals: number	| dictMethodCoverage |	dictMethodCoverage := profiler statementCoverage1.	self assert: (dictMethodCoverage at: symbol) equals: number</body></methods><methods><class-id>Spy1.SLProfilerCoverageTest</class-id> <category>tests</category><body package="SpyLite-Tests">testMethodCoverage	| profiler |	profiler := SLProfilerCoverage		profile: [ SLCounter new ]		inPackagesMatching: 'SpyLite-Scen*'.	self assertNumExecutedMethodsOf: profiler on: #SLCounter equals: 0.	self assertMethodCoverageOf: profiler on: #SLCounter equals: 0.	self clean: profiler.	profiler := SLProfilerCoverage		profile: [ SLCounter new one ]		inPackagesMatching: 'SpyLite-Scen*'.	self assertNumExecutedMethodsOf: profiler on: #SLCounter equals: 1.	self		assertMethodCoverageOf: profiler		on: #SLCounter		equals: ((1 / 7) asFloat * 100 round: 3).	self clean: profiler.	profiler := SLProfilerCoverage		profile: [ SLCounter new anAssignment ]		inPackagesMatching: 'SpyLite-Scen*'.	self assertNumExecutedMethodsOf: profiler on: #SLCounter equals: 1.	self		assertMethodCoverageOf: profiler		on: #SLCounter		equals: ((1 / 7) asFloat * 100 round: 3).	self clean: profiler.	profiler := SLProfilerCoverage		profile: [ SLCounter new main ]		inPackagesMatching: 'SpyLite-Scen*'.	self assertNumExecutedMethodsOf: profiler on: #SLCounter equals: 2.	self		assertMethodCoverageOf: profiler		on: #SLCounter		equals: ((2 / 7) asFloat * 100 round: 3).	self clean: profiler.	profiler := SLProfilerCoverage		profile: [ SLCounter new methWithCondition ]		inPackagesMatching: 'SpyLite-Scen*'.	self assertNumExecutedMethodsOf: profiler on: #SLCounter equals: 1.	self		assertMethodCoverageOf: profiler		on: #SLCounter		equals: ((1 / 7) asFloat * 100 round: 3).	self clean: profiler.	profiler := SLProfilerCoverage		profile: [ SLCounter new methMix ]		inPackagesMatching: 'SpyLite-Scen*'.	self assertNumExecutedMethodsOf: profiler on: #SLCounter equals: 1.	self		assertMethodCoverageOf: profiler		on: #SLCounter		equals: ((1 / 7) asFloat * 100 round: 3).	self clean: profiler.	profiler := SLProfilerCoverage		profile: [ SLCounter new methWithComposeBlocks ]		inPackagesMatching: 'SpyLite-Scen*'.	self assertNumExecutedMethodsOf: profiler on: #SLCounter equals: 1.	self		assertMethodCoverageOf: profiler		on: #SLCounter		equals: ((1 / 7) asFloat * 100 round: 3).	self clean: profiler.	profiler := SLProfilerCoverage		profile: [ SLCounter new methWithArguments: #(2 6 8 13 5 9 11 13) ]		inPackagesMatching: 'SpyLite-Scen*'.	self assertNumExecutedMethodsOf: profiler on: #SLCounter equals: 1.	self		assertMethodCoverageOf: profiler		on: #SLCounter		equals: ((1 / 7) asFloat * 100 round: 3).	self clean: profiler</body><body package="SpyLite-Tests">testProfileOnPackagesMatching	| profiler |	profiler := SLProfilerCoverage		profile: [ SLCounter new ]		inPackagesMatching: 'SpyLite-Scen*'.	self assert: profiler class: SLProfilerCoverage.	self assertMethodCoverageOf: profiler on: #SLCounter equals: 0.	self assert: profiler statementCoverage1 isEmpty.	self clean: profiler</body><body package="SpyLite-Tests">testStatementCoverage	| profiler |	profiler := SLProfilerCoverage		profile: [ SLCounter new ]		inPackagesMatching: 'SpyLite-Scen*'.	self assert: profiler numberOfAllStatements equals: 27.	self assert: profiler statementCoverage1 isEmpty.	self clean: profiler.	profiler := SLProfilerCoverage		profile: [ SLCounter new one ]		inPackagesMatching: 'SpyLite-Scen*'.	self assertNumExecutedStatementsOf: profiler on: #SLCounter equals: 1.	self		assertStatementCoverageOf: profiler		on: #SLCounter		equals: ((1 / 27) asFloat * 100 round: 3).	self clean: profiler.	profiler := SLProfilerCoverage		profile: [ SLCounter new anAssignment ]		inPackagesMatching: 'SpyLite-Scen*'.	self assertNumExecutedStatementsOf: profiler on: #SLCounter equals: 2.	self		assertStatementCoverageOf: profiler		on: #SLCounter		equals: ((2 / 27) asFloat * 100 round: 3).	self clean: profiler.	profiler := SLProfilerCoverage		profile: [ SLCounter new main ]		inPackagesMatching: 'SpyLite-Scen*'.	self assertNumExecutedStatementsOf: profiler on: #SLCounter equals: 2.	self		assertStatementCoverageOf: profiler		on: #SLCounter		equals: ((2 / 27) asFloat * 100 round: 3).	self clean: profiler.	profiler := SLProfilerCoverage		profile: [ SLCounter new methWithCondition ]		inPackagesMatching: 'SpyLite-Scen*'.	self assertNumExecutedStatementsOf: profiler on: #SLCounter equals: 2.	self		assertStatementCoverageOf: profiler		on: #SLCounter		equals: ((2 / 27) asFloat * 100 round: 3).	self clean: profiler.	profiler := SLProfilerCoverage		profile: [ SLCounter new methMix ]		inPackagesMatching: 'SpyLite-Scen*'.	self assertNumExecutedStatementsOf: profiler on: #SLCounter equals: 5.	self		assertStatementCoverageOf: profiler		on: #SLCounter		equals: ((5 / 27) asFloat * 100 round: 3).	self clean: profiler.	profiler := SLProfilerCoverage		profile: [ SLCounter new methWithComposeBlocks ]		inPackagesMatching: 'SpyLite-Scen*'.	self assert: profiler numberOfExecutedStatements equals: 7.	self		assertStatementCoverageOf: profiler		on: #SLCounter		equals: ((7 / 27) asFloat * 100 round: 3).	self clean: profiler.	profiler := SLProfilerCoverage		profile: [ SLCounter new methWithArguments: #(2 6 8 13 5 9 11 13) ]		inPackagesMatching: 'SpyLite-Scen*'.	self assertNumExecutedStatementsOf: profiler on: #SLCounter equals: 6.	self		assertStatementCoverageOf: profiler		on: #SLCounter		equals: ((6 / 27) asFloat * 100 round: 3).	self clean: profiler.	profiler := SLProfilerCoverage		profile: [ SLCounter new methWithArguments: #(1 4 6 7) ]		inPackagesMatching: 'SpyLite-Scen*'.	self assertNumExecutedStatementsOf: profiler on: #SLCounter equals: 6.	self		assertStatementCoverageOf: profiler		on: #SLCounter		equals: ((6 / 27) asFloat * 100 round: 3).	self clean: profiler.	profiler := SLProfilerCoverage		profile: [ SLCounter new methWithArguments: #(4 6 12) ]		inPackagesMatching: 'SpyLite-Scen*'.	self assertNumExecutedStatementsOf: profiler on: #SLCounter equals: 4.	self		assertStatementCoverageOf: profiler		on: #SLCounter		equals: ((4 / 27) asFloat * 100 round: 3).	self clean: profiler</body></methods><methods><class-id>Spy1.SLProfilerCoverageTest</class-id> <category>running</category><body package="SpyLite-Tests">tearDown	"	S2Lock value: false.	S2Context value: nil.	S2Profiler remove."	super tearDown</body></methods><methods><class-id>Spy1.SLProfilerCoverageTest</class-id> <category>api</category><body package="SpyLite-Tests">clean: aProfiler	aProfiler uninstall	"SLProfilerCoverage resetInstance."</body></methods><methods><class-id>Spy1.SLCounter</class-id> <category>as yet unclassified</category><body package="SpyLite-Scenario">anAssignment	| a |	a := 3.	^ a</body><body package="SpyLite-Scenario">methMix	| aBoolean number |	aBoolean := 2 == 3.	aBoolean		ifTrue: [ number := 3 ]		ifFalse: [ number := 5 ].	number := number + 1.	^ number</body><body package="SpyLite-Scenario">methWithArguments: aList	| selectedNumbers |	selectedNumbers := OrderedCollection new.	aList		detect: [ :aNum | aNum odd ]		ifFound: [ :aNum | 			aNum &gt; 10				ifTrue: [ selectedNumbers add: aNum ]				ifFalse: [ selectedNumbers add: aNum * 3 ] ]		ifNone: [  ].	^ selectedNumbers</body><body package="SpyLite-Scenario">methWithComposeBlocks	| list selectedNumbers |	selectedNumbers := OrderedCollection new.	list := (Array new: 8)		at: 1 put: 1;		at: 2 put: 4;		at: 3 put: 6;		at: 4 put: 7;		at: 5 put: 8;		at: 6 put: 15;		at: 7 put: 17;		at: 8 put: 16;		yourself.	list		select: [ :aNum | aNum odd ]		thenDo: [ :aNum | 			aNum &gt; 10				ifTrue: [ selectedNumbers add: aNum ] ].	^ selectedNumbers</body><body package="SpyLite-Scenario">methWithCondition	^ 2 = 1		ifTrue: [ 3 ]		ifFalse: [ 4 ]</body></methods><methods><class-id>Spy1.SLCounter</class-id> <category>accessing structure variables</category><body package="SpyLite-Scenario">one	^ 1</body></methods><methods><class-id>Spy1.SLCounter</class-id> <category>accessing</category><body package="SpyLite-Scenario">main	^ self one</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>MethodWrapper</name><environment>Refactory.Wrappers</environment><super>Kernel.CompiledMethod</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>clientMethod selector </inst-vars><class-inst-vars>methods </class-inst-vars><imports></imports><category>Refactory-Method Wrappers</category><attributes><package>Method Wrapper Base</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>RBProgramNodeVisitor</name><environment>Refactory.Browser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Browser-Parse Tree Matching</category><attributes><package>Browser-Parser</package></attributes></class></st-source>