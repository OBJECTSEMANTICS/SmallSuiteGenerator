<?xml version="1.0"?><st-source><!-- Name: PNGImageWriterNotice: Copyright © 2012 John Brant, Steven KellyThis utility is made available to use under the MIT license, as detailed below.Permission is hereby granted, free of charge, to any person obtaininga copy of this software and associated documentation files (the"Software"), to deal in the Software without restriction, includingwithout limitation the rights to use, copy, modify, merge, publish,distribute, sublicense, and/or sell copies of the Software, and topermit persons to whom the Software is furnished to do so, subject tothe following conditions:The above copyright notice and this permission notice shall beincluded in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OFMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANYCLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THESOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.Comment: This package contains a PNG image writer. It can convert an Image (or anything that understands #asImage) or an OpaqueImage into a stream of characters that represent a PNG file.UsageTo use this, you will need to load either the Compression-ZLibWrite package, the Compression parcel (from the goodies parcels directory) or the ZLibInterface parcel.To compress an image, use: "PNGImageWriter writeImage: anImage on: aStream".For example, to compress the contents of your screen:	| stream |	stream := 'screen.png' asFilename writeStream.	[stream binary.	Refactory.PNG.PNGImageWriter 		writeImage: (Screen default completeContentsOfArea: Screen default bounds) 		on: stream] 			ensure: [stream close]DbIdentifier: psql_public_cst_2007DbTrace: 87600DbUsername: niallrDbVersion: 1.15DevelopmentPrerequisites: #(#(#any 'Refactory-Namespace' ''))PackageName: PNGImageWriterParcel: #('PNGImageWriter')ParcelName: PNGImageWriterPrerequisiteParcels: #(#('Refactory-Namespace' ''))PrintStringCache: (1.15,niallr)Version: 1.15Date: 9:12:43 AM January 6, 2014 --><time-stamp>From VisualWorks®, Pre-Release 7.10.1 (oct13.1) of October 3, 2013 on January 6, 2014 at 9:12:43 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>PNG</name><environment>Refactory</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>PNGImageWriter</category><attributes><package>PNGImageWriter</package></attributes></name-space><class><name>CRCWriteStreamWrapper</name><environment>Refactory.PNG</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PNGImageWriter</category><attributes><package>PNGImageWriter</package></attributes></class><comment><class-id>Refactory.PNG.CRCWriteStreamWrapper</class-id><body>CRCWriteStreamWrapper is a simple wrapper on a stream that computes the CRC value of the items put on the stream..Instance Variables:	stream	&lt;Stream&gt;	the stream we are writing to	value	&lt;Integer&gt;	the current CRC value</body></comment><class><name>PNGImageWriter</name><environment>Refactory.PNG</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>image stream colorMap previousColor pixelsPerUnitX pixelsPerUnitY resolution </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PNGImageWriter</category><attributes><package>PNGImageWriter</package></attributes></class><comment><class-id>Refactory.PNG.PNGImageWriter</class-id><body>PNGImageWriter creates a PNG image from an Image (or similar that understands #asImage) or OpaqueImage (by redirecting to the PNGOpaqueImageWriter subclass). Instance Variables	colorMap			&lt;Dictionary key: Integer value: Integer&gt;	If we are using a palette this maps the real color number to the palette index	image				&lt;Image&gt;											The image we are saving	resolution		&lt;Point&gt;											Resolution of the image, in dots per inch.	previousColor	&lt;ByteArray&gt;										When saving a true color image, this is the previous RGB value of the pixel to the left	stream			&lt;CRCWriteStreamWrapper&gt;					The stream we write our output on</body></comment><class><name>PNGOpaqueImageWriter</name><environment>Refactory.PNG</environment><super>Refactory.PNG.PNGImageWriter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mask previousAlpha </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PNGImageWriter</category><attributes><package>PNGImageWriter</package></attributes></class><comment><class-id>Refactory.PNG.PNGOpaqueImageWriter</class-id><body>PNGOpaqueImageWriter can write an OpaqueImage as an RGBA PNG; each pixel is either completely opaque or completely transparent. This class need not be called directly: PNGImageWriter will redirect OpaqueImages here.Instance Variables:	mask	&lt;Image&gt;	the mask	previousAlpha	&lt;SmallInteger&gt;	the previous alpha value of the pixel to the left</body></comment><shared-variable><name>CRCTable</name><environment>Refactory.PNG.CRCWriteStreamWrapper</environment><private>false</private><constant>false</constant><category>variables</category><initializer>	| value |	(0 to: 255) collect: 			[:i | 			value := i.			0 to: 7				do: 					[:j | 					(value bitAnd: 1) == 1 						ifTrue: [value := 16rEDB88320 bitXor: (value bitShift: -1)]						ifFalse: [value := value bitShift: -1]].			value]</initializer><attributes><package>PNGImageWriter</package></attributes></shared-variable><methods><class-id>Refactory.PNG.CRCWriteStreamWrapper</class-id> <category>accessing</category><body package="PNGImageWriter">nextPut: anInteger 	value := (CRCTable at: ((value bitXor: anInteger) bitAnd: 255) + 1) 				bitXor: (value bitShift: -8).	stream nextPut: anInteger</body><body package="PNGImageWriter">nextPutInteger: anInteger 	4 to: 1		by: -1		do: [:i | self nextPut: (anInteger digitAt: i)]</body><body package="PNGImageWriter">putCRC	self nextPutInteger: (value bitXor: 16rFFFFFFFF).	self resetCRCValue</body><body package="PNGImageWriter">resetCRCValue	value := 16rFFFFFFFF</body></methods><methods><class-id>Refactory.PNG.CRCWriteStreamWrapper</class-id> <category>initialize-release</category><body package="PNGImageWriter">on: aStream 	stream := aStream.	self resetCRCValue</body></methods><methods><class-id>Refactory.PNG.CRCWriteStreamWrapper class</class-id> <category>instance creation</category><body package="PNGImageWriter">on: aStream 	^(self basicNew)		on: aStream;		yourself</body></methods><methods><class-id>Refactory.PNG.PNGImageWriter</class-id> <category>private</category><body package="PNGImageWriter">calculateColorPalette	| table index |	colorMap := nil.	table := Set new.	0 to: image width - 1		do: 			[:x | 			0 to: image height - 1				do: 					[:y | 					table add: (image atX: x y: y).					table size &gt; 256 ifTrue: [^self	"too many entries for a palette"]]].	index := 0.	colorMap := Dictionary new.	table asSortedCollection do: 			[:each | 			colorMap at: each put: index.			index := index + 1]</body><body package="PNGImageWriter">hasColorPalette	^colorMap notNil</body><body package="PNGImageWriter">hasResolution	^resolution notNil</body><body package="PNGImageWriter">resetPreviousColors	previousColor isNil ifTrue: [previousColor := ByteArray new: 3].	1 to: 3 do: [:i | previousColor at: i put: 0]</body><body package="PNGImageWriter">saveColorDifference: each on: zlibStream 	"Open coding this improves speed by over 100%"	| color |	zlibStream nextPut: 		(((color := each scaledRed bitShift: -5) - (previousColor at: 1)) bitAnd: 16rFF).	previousColor at: 1 put: color.	zlibStream nextPut: 		(((color := each scaledGreen bitShift: -5) - (previousColor at: 2)) bitAnd: 16rFF).	previousColor at: 2 put: color.	zlibStream nextPut: 		(((color := each scaledBlue bitShift: -5) - (previousColor at: 3)) bitAnd: 16rFF).	previousColor at: 3 put: color.</body><body package="PNGImageWriter">writeChunk: aString size: anInteger with: aBlock 	stream nextPutInteger: anInteger.	stream resetCRCValue.	stream nextPutAll: aString asByteArray.	aBlock value.	stream putCRC</body><body package="PNGImageWriter">writeColor: anInteger on: aStream 	| color |	color := image palette at: (anInteger bitAnd: 16rFFFFFF).	^aStream		nextPut: (color red * 255) rounded;		nextPut: (color green * 255) rounded;		nextPut: (color blue * 255) rounded</body><body package="PNGImageWriter">writeEndChunk	self 		writeChunk: 'IEND'		size: 0		with: []</body><body package="PNGImageWriter">writeFileHeader	stream nextPutAll: #[137 80 78 71 13 10 26 10]</body><body package="PNGImageWriter">writeHeaderChunk	self 		writeChunk: 'IHDR'		size: 13		with: 			[stream				nextPutInteger: image width;				nextPutInteger: image height.			stream nextPut: 8.	"Assume that all colors are 24bit"			stream nextPut: (self hasColorPalette ifTrue: [3] ifFalse: [2]).	"Palette?"			stream nextPut: 0.	"Compression"			stream nextPut: 0.	"Filter method"			stream nextPut: 0	"Non-interlaced"]</body><body package="PNGImageWriter">writeImageChunk	| contents pixelBlock scanLineBlock |	self hasColorPalette 		ifTrue: 			[scanLineBlock := [0].			pixelBlock := [:each :zlibStream | zlibStream nextPut: (colorMap at: each)]]		ifFalse: 			[scanLineBlock := 					[self resetPreviousColors.					1].			pixelBlock := [:each :zlibStream | self saveColorDifference: (image palette at: (each bitAnd: 16rFFFFFF)) on: zlibStream]].	contents := self writeImageData: pixelBlock scanLine: scanLineBlock.	self 		writeChunk: 'IDAT'		size: contents size		with: [stream nextPutAll: contents]</body><body package="PNGImageWriter">writeImageData: writeBlock scanLine: scanLineBlock 	| zlibStream dataStream |	dataStream := WriteStream on: ByteArray new.	zlibStream := self zlibWriteStreamOn: dataStream.	0 to: image height - 1		do: 			[:y | 			zlibStream nextPut: scanLineBlock value.			0 to: image width - 1				do: [:x | writeBlock value: (image atX: x y: y) value: zlibStream]].	zlibStream close.	^dataStream contents</body><body package="PNGImageWriter">writePaletteChunk	self 		writeChunk: 'PLTE'		size: 3 * colorMap size		with: 			[| table |			table := Array new: colorMap size.			colorMap keysAndValuesDo: [:key :value | table at: value + 1 put: key].			table do: [:each | self writeColor: each on: stream]]</body><body package="PNGImageWriter">writePhysicalPixelChunk	self 		writeChunk: 'pHYs'		size: 9		with: 			[stream				nextPutInteger: (resolution x * 39.375) rounded;				nextPutInteger: (resolution y * 39.375) rounded;				nextPut: 1]</body><body package="PNGImageWriter">zlibWriteStreamClass	^#{OS.ZLib.ZLibWriteStream} valueOrDo: 		[#{Refactory.ZLib.ZLibWriteStream} valueOrDo: "fast but error on about 1%"			[#{Net.ZLibWriteStream} 				valueOrDo: [self error: 'No ZLibWriteStream found. Load Compression-ZLibWrite, ZLibInterface or Compression parcel']]]</body><body package="PNGImageWriter">zlibWriteStreamOn: dataStream	"Override this to add your own choice of compression settings"	^self zlibWriteStreamClass on: dataStream</body></methods><methods><class-id>Refactory.PNG.PNGImageWriter</class-id> <category>initialize-release</category><body package="PNGImageWriter">image: anImage 	image := anImage.	self calculateColorPalette</body><body package="PNGImageWriter">stream: aBinaryStream 	stream := CRCWriteStreamWrapper on: aBinaryStream</body></methods><methods><class-id>Refactory.PNG.PNGImageWriter</class-id> <category>accessing</category><body package="PNGImageWriter">resolution: aPoint	"Set the resolution (pixels per inch) to the specified &lt;Point&gt;."	resolution := aPoint</body><body package="PNGImageWriter">writeImage	self writeFileHeader.	self writeHeaderChunk.	self hasColorPalette ifTrue: [self writePaletteChunk].	self hasResolution ifTrue: [self writePhysicalPixelChunk].	self writeImageChunk.	self writeEndChunk</body></methods><methods><class-id>Refactory.PNG.PNGImageWriter class</class-id> <category>creating</category><body package="PNGImageWriter">writeImage: anImage on: aBinaryStream 	"| stream |	stream := 'screen.png' asFilename writeStream.	[stream binary.	self writeImage: (Screen default completeContentsOfArea: Screen default bounds) on: stream] ensure: [stream close]"	"Hack to make life easier for callers who like to treat Images and OpaqueImages alike"	(anImage isKindOf: OpaqueImage) ifTrue: [^PNGOpaqueImageWriter writeImage: anImage on: aBinaryStream].	^(self new)		image: anImage asImage;		stream: aBinaryStream;		writeImage;		yourself</body></methods><methods><class-id>Refactory.PNG.PNGOpaqueImageWriter</class-id> <category>accessing</category><body package="PNGImageWriter">mask	^mask</body><body package="PNGImageWriter">mask: anObject	mask := anObject</body></methods><methods><class-id>Refactory.PNG.PNGOpaqueImageWriter</class-id> <category>private</category><body package="PNGImageWriter">calculateColorPalette	"can not have an indexed palette, as we don't want to check that each color always has the same transparency wherever it occurs"	colorMap := nil.</body><body package="PNGImageWriter">resetPreviousColors	super resetPreviousColors.	previousAlpha := 0.</body><body package="PNGImageWriter">saveColorDifference: each maskCoverage: coverageValue on: zlibStream 	| alpha |	self saveColorDifference: each on: zlibStream.	alpha := (coverageValue coverage * 255) rounded. 	zlibStream nextPut: (alpha - previousAlpha) \\ 256.	previousAlpha := alpha.</body><body package="PNGImageWriter">writeHeaderChunk	self 		writeChunk: 'IHDR'		size: 13		with: 			[stream				nextPutInteger: image width;				nextPutInteger: image height.			stream nextPut: 8.	"Assume that all colors are 24bit"			stream nextPut: 6.	"colorType RGBA"			stream nextPut: 0.	"Compression"			stream nextPut: 0.	"Filter method"			stream nextPut: 0	"Non-interlaced"]</body><body package="PNGImageWriter">writeImageChunk	| contents pixelBlock scanLineBlock |	scanLineBlock := 			[self resetPreviousColors.			1].	pixelBlock := [:each :maskEach :zlibStream | self saveColorDifference: (image palette at: (each bitAnd: 16rFFFFFF)) maskCoverage: (mask palette at: maskEach) on: zlibStream].	contents := self writeImageData: pixelBlock scanLine: scanLineBlock.	self 		writeChunk: 'IDAT'		size: contents size		with: [stream nextPutAll: contents]</body><body package="PNGImageWriter">writeImageData: writeBlock scanLine: scanLineBlock 	| zlibStream dataStream |	dataStream := WriteStream on: ByteArray new.	zlibStream := self zlibWriteStreamOn: dataStream.	0 to: image height - 1		do: 			[:y | 			zlibStream nextPut: scanLineBlock value.			0 to: image width - 1				do: [:x | writeBlock value: (image atX: x y: y) value: (mask atX: x y: y) value: zlibStream]].	zlibStream close.	^dataStream contents</body></methods><methods><class-id>Refactory.PNG.PNGOpaqueImageWriter class</class-id> <category>creating</category><body package="PNGImageWriter">writeImage: anOpaqueImage on: aBinaryStream 	"| stream |	stream := 'alert.png' asFilename writeStream.	[stream binary.	self writeImage: UILookPolicy basicNew alertIcon on: stream] ensure: [stream close]"	^(self new)		image: anOpaqueImage figure asImage;		mask: anOpaqueImage shape asImage;		stream: aBinaryStream;		writeImage;		yourself</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class></st-source>