<?xml version="1.0"?><st-source><!-- Name: SmallSuiteGenerator-ExtensionsPackageName: SmallSuiteGenerator-ExtensionsParcel: #('SmallSuiteGenerator-Extensions')ParcelDirectory: SmallSuiteGenerator-ExtensionsDate: 5:15:20 PM November 13, 2019 --><time-stamp>From VisualWorksÂ®, 8.3 of July 28, 2017 on November 13, 2019 at 5:15:20 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><methods><class-id>Core.String</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Extensions">substrings: separators	"Answer an array of non-empty substrings from the receiver separated by	one or more characters from the 'separators' argument collection."	| substrings substringStart |	substrings := (Array new: 10) writeStream.	1 to: self size do: [ :i | 		| nextChar |		nextChar := self at: i.		(separators includes: nextChar)			ifTrue: [				substringStart					ifNotNil: [						substrings nextPut: (self copyFrom: substringStart to: i - 1).						substringStart := nil ] ]			ifFalse: [ substringStart ifNil: [ substringStart := i ] ] ].	substringStart		ifNotNil: [ substrings nextPut: (self copyFrom: substringStart to: self size) ].	^ substrings contents</body></methods><methods><class-id>Core.Dictionary</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions">at: key ifPresent: aPresentBlock ifAbsent: anAbsentBlock	"Lookup the given key in the receiver. If it is present, answer the	value of evaluating the first block optionally with the value associated	with the key.	Otherwise answer the value of the second block."	self at: key ifPresent: [:v | ^ aPresentBlock cull: v].	^ anAbsentBlock value</body><body package="SmallSuiteGenerator-Extensions">at: key ifPresent: aPresentBlock ifAbsentPut: anAbsentBlock	"Lookup the given key in the receiver. If it is present, answer the	value of evaluating the first block optionally with the value associated	with the key.	Otherwise store and return the result of evaluating the second block as the	new value of the key."	^ self		at: key		ifPresent: aPresentBlock		ifAbsent: [self at: key put: anAbsentBlock value]</body><body package="SmallSuiteGenerator-Extensions">flatCollect: aBlock 	"Evaluate aBlock for each of the receiver's values (by opposition to keys) and answer the	list of all resulting values flatten one level. Assumes that aBlock returns some kind	of collection for each element. Equivalent to the lisp's mapcan"	"If you want to have keys use associations collect: or associations flatCollect: "		^ self flatCollect: aBlock as: OrderedCollection</body></methods><methods><class-id>Core.SequenceableCollection class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Extensions">new: newSize streamContents: blockWithArg	| stream |	stream := WriteStream on: (self streamSpecies new: newSize).	blockWithArg value: stream.	^ stream contents</body><body package="SmallSuiteGenerator-Extensions">streamContents: blockWithArg	^ self new: 100 streamContents: blockWithArg</body><body package="SmallSuiteGenerator-Extensions">streamSpecies	"I return the class that is used for streaming. If override consider overriding #new:streamContents:"	^ self</body></methods><methods><class-id>Core.Collection class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Extensions">with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject	"Answer a new instance of a Collection containing the		four arguments as the elements."	| newCollection |	newCollection := self new.	newCollection add: firstObject.	newCollection add: secondObject.	newCollection add: thirdObject.	newCollection add: fourthObject.	newCollection add: fifthObject.	^newCollection</body></methods><methods><class-id>Core.Collection</class-id> <category>testing</category><body package="SmallSuiteGenerator-Extensions">collect: collectBlock thenSelect: selectBlock	"Utility method to improve readability."	^ (self collect: collectBlock) select: selectBlock</body></methods><methods><class-id>Core.Collection</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions">flatCollect: aBlock 	"Evaluate aBlock for each of the receiver's elements and answer the	list of all resulting values flatten one level. Assumes that aBlock returns some kind	of collection for each element. Equivalent to the lisp's mapcan"		"( #((3 4) (1 2)) flatCollect: [:each | each ] )&gt;&gt;&gt; #(3 4 1 2)"	"( #(3 4 1 2) flatCollect: [:each | { each } ] ) &gt;&gt;&gt; #(3 4 1 2)"		^ self flatCollect: aBlock as: self species</body><body package="SmallSuiteGenerator-Extensions">flatCollect: aBlock as: aCollectionClass	"Evaluate aBlock for each of the receiver's elements and answer the	list of all resulting values flatten one level. Assumes that aBlock returns some kind	of collection for each element. Equivalent to the lisp's mapcan"	| col |	col := aCollectionClass new: self size. 		self do: [ :each |		col addAll: (aBlock value: each) ].	^col</body></methods><methods><class-id>Core.Collection</class-id> <category>testing</category><body package="SmallSuiteGenerator-Extensions">ifEmpty: aBlock	"Evaluate the given block, answering its value if the receiver is empty, otherwise answer the receiver."		"Note that the fact that this method returns its receiver in case the receiver is not empty allows one to write expressions like the following ones: self classifyMethodAs: (myProtocol ifEmpty: ['As yet unclassified'])"	^ self isEmpty 		ifTrue: [ aBlock value ]		ifFalse: [ self ]</body><body package="SmallSuiteGenerator-Extensions">ifEmpty: emptyBlock ifNotEmpty: notEmptyBlock	"Evaluate emptyBlock if I'm empty, notEmptyBlock otherwise"	" If the notEmptyBlock has an argument, eval with the receiver as its argument"	self isEmpty ifTrue: [ ^emptyBlock value ].	^notEmptyBlock cull: self</body><body package="SmallSuiteGenerator-Extensions">ifNotEmpty: aBlock	"Evaluate the given block with the receiver as argument, answering its value    unless the receiver is empty, in which case answer the receiver."    ^self isEmpty          ifTrue: [self]          ifFalse: [aBlock cull: self] </body></methods><methods><class-id>SUnit.TestCase</class-id> <category>accessing</category><body package="SmallSuiteGenerator-Extensions">assertCollection: actual hasSameElements: expected	"Assert that a collection contains the same elements as the given collection. Order is not checked, only the presence/absence of elements."	| missingElements additionalElements |	additionalElements := actual difference: expected.	missingElements := expected difference: (actual intersection: expected).	self		assert: (additionalElements isEmpty and: [ missingElements isEmpty ])		description:			(String				streamContents: [ :stream | 					stream						nextPutAll: 'Given Collections do not match!';						lf;						tab;						nextPutAll: 'additions : ';						print: additionalElements asArray;						lf;						tab;						nextPutAll: 'missing: ';						print: missingElements asArray;						lf ])</body></methods><methods><class-id>SUnit.TestCase</class-id> <category>backwards compatibility</category><body package="SmallSuiteGenerator-Extensions">deny: anObject equals: anotherObject	(anObject = anotherObject) ifTrue: [self signalFailure: anObject printString, ' is not equal to ', anotherObject printString.]</body></methods><methods><class-id>Core.Class</class-id> <category>testing</category><body package="SmallSuiteGenerator-Extensions">isClass	^ true</body></methods><methods><class-id>Core.ArrayedCollection class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Extensions">with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject	"Answer a new instance of ArrayedCollection, containing the four 	arguments as the elements."	| newCollection |	newCollection := self new: 5.	newCollection at: 1 put: firstObject.	newCollection at: 2 put: secondObject.	newCollection at: 3 put: thirdObject.	newCollection at: 4 put: fourthObject.	newCollection at: 5 put: fifthObject.	^newCollection</body></methods><methods><class-id>SmallSuiteGenerator.SRandom class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Extensions">new	^ self basicNewInstance</body></methods><methods><class-id>SmallSuiteGenerator.SError class</class-id> <category>As yet unclassified</category><body package="SmallSuiteGenerator-Extensions">signal: anObject	^ self new signal: anObject</body></methods><methods><class-id>Core.Metaclass</class-id> <category>testing</category><body package="SmallSuiteGenerator-Extensions">isClass	^ true</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="SmallSuiteGenerator-Extensions">isClass	^ false</body><body package="SmallSuiteGenerator-Extensions">isDeprecated	^false</body><body package="SmallSuiteGenerator-Extensions">value	^self</body></methods><methods><class-id>Core.Random class</class-id> <category>instance creation</category><body package="SmallSuiteGenerator-Extensions">seed: anInteger 	^self new seed: anInteger</body></methods><methods><class-id>Core.Random</class-id> <category>private</category><body package="SmallSuiteGenerator-Extensions">nextInt: anInteger	"Answer a random integer in the interval [1, anInteger].	Handle large numbers too (for cryptography)."	anInteger strictlyPositive ifFalse: [ self error: 'Range must be positive' ].	anInteger asFloat isInfinity		ifTrue: [^(self nextValue asFraction * anInteger) truncated + 1].	^ (self nextValue * anInteger) truncated + 1</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Random</name><environment>Core</environment><super>Core.Stream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>seed </inst-vars><class-inst-vars>defaultGeneratorClass </class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class></st-source>